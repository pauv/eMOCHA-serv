/*
 * Copyright (c) 2008-10 Mark Birbeck
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var A=arguments,E=null,C,B,D;for(C=0;C<A.length;C=C+1){D=(""+A[C]).split(".");E=YAHOO;for(B=(D[0]=="YAHOO")?1:0;B<D.length;B=B+1){E[D[B]]=E[D[B]]||{};E=E[D[B]];}}return E;};YAHOO.log=function(D,A,C){var B=YAHOO.widget.Logger;if(B&&B.log){return B.log(D,A,C);}else{return false;}};YAHOO.register=function(A,E,D){var I=YAHOO.env.modules,B,H,G,F,C;if(!I[A]){I[A]={versions:[],builds:[]};}B=I[A];H=D.version;G=D.build;F=YAHOO.env.listeners;B.name=A;B.version=H;B.build=G;B.versions.push(H);B.builds.push(G);B.mainClass=E;for(C=0;C<F.length;C=C+1){F[C](B);}if(E){E.VERSION=H;E.BUILD=G;}else{YAHOO.log("mainClass is undefined for module "+A,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(A){return YAHOO.env.modules[A]||null;};YAHOO.env.ua=function(){var D=function(H){var I=0;return parseFloat(H.replace(/\./g,function(){return(I++==1)?"":".";}));},G=navigator,F={ie:0,opera:0,gecko:0,webkit:0,mobile:null,air:0,caja:G.cajaVersion,secure:false,os:null},C=navigator&&navigator.userAgent,E=window&&window.location,B=E&&E.href,A;F.secure=B&&(B.toLowerCase().indexOf("https")===0);if(C){if((/windows|win32/i).test(C)){F.os="windows";}else{if((/macintosh/i).test(C)){F.os="macintosh";}}if((/KHTML/).test(C)){F.webkit=1;}A=C.match(/AppleWebKit\/([^\s]*)/);if(A&&A[1]){F.webkit=D(A[1]);if(/ Mobile\//.test(C)){F.mobile="Apple";}else{A=C.match(/NokiaN[^\/]*/);if(A){F.mobile=A[0];}}A=C.match(/AdobeAIR\/([^\s]*)/);if(A){F.air=A[0];}}if(!F.webkit){A=C.match(/Opera[\s\/]([^\s]*)/);if(A&&A[1]){F.opera=D(A[1]);A=C.match(/Opera Mini[^;]*/);if(A){F.mobile=A[0];}}else{A=C.match(/MSIE\s([^;]*)/);if(A&&A[1]){F.ie=D(A[1]);}else{A=C.match(/Gecko\/([^\s]*)/);if(A){F.gecko=1;A=C.match(/rv:([^\s\)]*)/);if(A&&A[1]){F.gecko=D(A[1]);}}}}}}return F;}();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var B=YAHOO_config.listener,A=YAHOO.env.listeners,D=true,C;if(B){for(C=0;C<A.length;C++){if(A[C]==B){D=false;break;}}if(D){A.push(B);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var B=YAHOO.lang,A=Object.prototype,H="[object Array]",C="[object Function]",G="[object Object]",E=[],F=["toString","valueOf"],D={isArray:function(I){return A.toString.apply(I)===H;},isBoolean:function(I){return typeof I==="boolean";},isFunction:function(I){return(typeof I==="function")||A.toString.apply(I)===C;},isNull:function(I){return I===null;},isNumber:function(I){return typeof I==="number"&&isFinite(I);},isObject:function(I){return(I&&(typeof I==="object"||B.isFunction(I)))||false;},isString:function(I){return typeof I==="string";},isUndefined:function(I){return typeof I==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(K,J){var I,M,L;for(I=0;I<F.length;I=I+1){M=F[I];L=J[M];if(B.isFunction(L)&&L!=A[M]){K[M]=L;}}}:function(){},extend:function(L,M,K){if(!M||!L){throw new Error("extend failed, please check that "+"all dependencies are included.");}var J=function(){},I;J.prototype=M.prototype;L.prototype=new J();L.prototype.constructor=L;L.superclass=M.prototype;if(M.prototype.constructor==A.constructor){M.prototype.constructor=M;}if(K){for(I in K){if(B.hasOwnProperty(K,I)){L.prototype[I]=K[I];}}B._IEEnumFix(L.prototype,K);}},augmentObject:function(M,L){if(!L||!M){throw new Error("Absorb failed, verify dependencies.");}var I=arguments,K,N,J=I[2];if(J&&J!==true){for(K=2;K<I.length;K=K+1){M[I[K]]=L[I[K]];}}else{for(N in L){if(J||!(N in M)){M[N]=L[N];}}B._IEEnumFix(M,L);}},augmentProto:function(L,K){if(!K||!L){throw new Error("Augment failed, verify dependencies.");}var I=[L.prototype,K.prototype],J;for(J=2;J<arguments.length;J=J+1){I.push(arguments[J]);}B.augmentObject.apply(this,I);},dump:function(I,N){var K,M,P=[],Q="{...}",J="f(){...}",O=", ",L=" => ";if(!B.isObject(I)){return I+"";}else{if(I instanceof Date||("nodeType" in I&&"tagName" in I)){return I;}else{if(B.isFunction(I)){return J;}}}N=(B.isNumber(N))?N:3;if(B.isArray(I)){P.push("[");for(K=0,M=I.length;K<M;K=K+1){if(B.isObject(I[K])){P.push((N>0)?B.dump(I[K],N-1):Q);}else{P.push(I[K]);}P.push(O);}if(P.length>1){P.pop();}P.push("]");}else{P.push("{");for(K in I){if(B.hasOwnProperty(I,K)){P.push(K+L);if(B.isObject(I[K])){P.push((N>0)?B.dump(I[K],N-1):Q);}else{P.push(I[K]);}P.push(O);}}if(P.length>1){P.pop();}P.push("}");}return P.join("");},substitute:function(Y,J,R){var N,M,L,U,V,X,T=[],K,O="dump",S=" ",I="{",W="}",Q,P;for(;;){N=Y.lastIndexOf(I);if(N<0){break;}M=Y.indexOf(W,N);if(N+1>=M){break;}K=Y.substring(N+1,M);U=K;X=null;L=U.indexOf(S);if(L>-1){X=U.substring(L+1);U=U.substring(0,L);}V=J[U];if(R){V=R(U,V,X);}if(B.isObject(V)){if(B.isArray(V)){V=B.dump(V,parseInt(X,10));}else{X=X||"";Q=X.indexOf(O);if(Q>-1){X=X.substring(4);}P=V.toString();if(P===G||Q>-1){V=B.dump(V,parseInt(X,10));}else{V=P;}}}else{if(!B.isString(V)&&!B.isNumber(V)){V="~-"+T.length+"-~";T[T.length]=K;}}Y=Y.substring(0,N)+V+Y.substring(M+1);}for(N=T.length-1;N>=0;N=N-1){Y=Y.replace(new RegExp("~-"+N+"-~"),"{"+T[N]+"}","g");}return Y;},trim:function(I){try{return I.replace(/^\s+|\s+$/g,"");}catch(J){return I;}},merge:function(){var L={},J=arguments,I=J.length,K;for(K=0;K<I;K=K+1){B.augmentObject(L,J[K],true);}return L;},later:function(P,J,Q,L,M){P=P||0;J=J||{};var K=Q,O=L,N,I;if(B.isString(Q)){K=J[Q];}if(!K){throw new TypeError("method undefined");}if(O&&!B.isArray(O)){O=[L];}N=function(){K.apply(J,O||E);};I=(M)?setInterval(N,P):setTimeout(N,P);return{interval:M,cancel:function(){if(this.interval){clearInterval(I);}else{clearTimeout(I);}}};},isValue:function(I){return(B.isObject(I)||B.isString(I)||B.isNumber(I)||B.isBoolean(I));}};B.hasOwnProperty=(A.hasOwnProperty)?function(I,J){return I&&I.hasOwnProperty(J);}:function(I,J){return !B.isUndefined(I[J])&&I.constructor.prototype[J]!==I[J];};D.augmentObject(B,D,true);YAHOO.util.Lang=B;B.augment=B.augmentProto;YAHOO.augment=B.augmentProto;YAHOO.extend=B.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.8.2r1",build:"7"});
YAHOO.util.Get=function(){var M={},L=0,R=0,E=false,N=YAHOO.env.ua,S=YAHOO.lang;var J=function(W,T,X){var U=X||window,Y=U.document,Z=Y.createElement(W);for(var V in T){if(T[V]&&YAHOO.lang.hasOwnProperty(T,V)){Z.setAttribute(V,T[V]);}}return Z;};var I=function(U,V,T){var W={id:"yui__dyn_"+(R++),type:"text/css",rel:"stylesheet",href:U};if(T){S.augmentObject(W,T);}return J("link",W,V);};var P=function(U,V,T){var W={id:"yui__dyn_"+(R++),type:"text/javascript",src:U};if(T){S.augmentObject(W,T);}return J("script",W,V);};var A=function(T,U){return{tId:T.tId,win:T.win,data:T.data,nodes:T.nodes,msg:U,purge:function(){D(this.tId);}};};var B=function(T,W){var U=M[W],V=(S.isString(T))?U.win.document.getElementById(T):T;if(!V){Q(W,"target node not found: "+T);}return V;};var Q=function(W,V){var T=M[W];if(T.onFailure){var U=T.scope||T.win;T.onFailure.call(U,A(T,V));}};var C=function(W){var T=M[W];T.finished=true;if(T.aborted){var V="transaction "+W+" was aborted";Q(W,V);return;}if(T.onSuccess){var U=T.scope||T.win;T.onSuccess.call(U,A(T));}};var O=function(V){var T=M[V];if(T.onTimeout){var U=T.scope||T;T.onTimeout.call(U,A(T));}};var G=function(V,Z){var U=M[V];if(U.timer){U.timer.cancel();}if(U.aborted){var X="transaction "+V+" was aborted";Q(V,X);return;}if(Z){U.url.shift();if(U.varName){U.varName.shift();}}else{U.url=(S.isString(U.url))?[U.url]:U.url;if(U.varName){U.varName=(S.isString(U.varName))?[U.varName]:U.varName;}}var c=U.win,b=c.document,a=b.getElementsByTagName("head")[0],W;if(U.url.length===0){if(U.type==="script"&&N.webkit&&N.webkit<420&&!U.finalpass&&!U.varName){var Y=P(null,U.win,U.attributes);Y.innerHTML='YAHOO.util.Get._finalize("'+V+'");';U.nodes.push(Y);a.appendChild(Y);}else{C(V);}return;}var T=U.url[0];if(!T){U.url.shift();return G(V);}if(U.timeout){U.timer=S.later(U.timeout,U,O,V);}if(U.type==="script"){W=P(T,c,U.attributes);}else{W=I(T,c,U.attributes);}F(U.type,W,V,T,c,U.url.length);U.nodes.push(W);if(U.insertBefore){var e=B(U.insertBefore,V);if(e){e.parentNode.insertBefore(W,e);}}else{a.appendChild(W);}if((N.webkit||N.gecko)&&U.type==="css"){G(V,T);}};var K=function(){if(E){return;}E=true;for(var T in M){var U=M[T];if(U.autopurge&&U.finished){D(U.tId);delete M[T];}}E=false;};var D=function(Z){if(M[Z]){var T=M[Z],U=T.nodes,X=U.length,c=T.win.document,a=c.getElementsByTagName("head")[0],V,Y,W,b;if(T.insertBefore){V=B(T.insertBefore,Z);if(V){a=V.parentNode;}}for(Y=0;Y<X;Y=Y+1){W=U[Y];if(W.clearAttributes){W.clearAttributes();}else{for(b in W){delete W[b];}}a.removeChild(W);}T.nodes=[];}};var H=function(U,T,V){var X="q"+(L++);V=V||{};if(L%YAHOO.util.Get.PURGE_THRESH===0){K();}M[X]=S.merge(V,{tId:X,type:U,url:T,finished:false,aborted:false,nodes:[]});var W=M[X];W.win=W.win||window;W.scope=W.scope||W.win;W.autopurge=("autopurge" in W)?W.autopurge:(U==="script")?true:false;if(V.charset){W.attributes=W.attributes||{};W.attributes.charset=V.charset;}S.later(0,W,G,X);return{tId:X};};var F=function(c,X,W,U,Y,Z,b){var a=b||G;if(N.ie){X.onreadystatechange=function(){var d=this.readyState;if("loaded"===d||"complete"===d){X.onreadystatechange=null;a(W,U);}};}else{if(N.webkit){if(c==="script"){if(N.webkit>=420){X.addEventListener("load",function(){a(W,U);});}else{var T=M[W];if(T.varName){var V=YAHOO.util.Get.POLL_FREQ;T.maxattempts=YAHOO.util.Get.TIMEOUT/V;T.attempts=0;T._cache=T.varName[0].split(".");T.timer=S.later(V,T,function(j){var f=this._cache,e=f.length,d=this.win,g;for(g=0;g<e;g=g+1){d=d[f[g]];if(!d){this.attempts++;if(this.attempts++>this.maxattempts){var h="Over retry limit, giving up";T.timer.cancel();Q(W,h);}else{}return;}}T.timer.cancel();a(W,U);},null,true);}else{S.later(YAHOO.util.Get.POLL_FREQ,null,a,[W,U]);}}}}else{X.onload=function(){a(W,U);};}}};return{POLL_FREQ:10,PURGE_THRESH:20,TIMEOUT:2000,_finalize:function(T){S.later(0,null,C,T);},abort:function(U){var V=(S.isString(U))?U:U.tId;var T=M[V];if(T){T.aborted=true;}},script:function(T,U){return H("script",T,U);},css:function(T,U){return H("css",T,U);}};}();YAHOO.register("get",YAHOO.util.Get,{version:"2.8.2r1",build:"7"});(function(){var Y=YAHOO,util=Y.util,lang=Y.lang,env=Y.env,PROV="_provides",SUPER="_supersedes",REQ="expanded",AFTER="_after";var YUI={dupsAllowed:{"yahoo":true,"get":true},info:{"root":"2.8.2r1/build/","base":"http://yui.yahooapis.com/2.8.2r1/build/","comboBase":"http://yui.yahooapis.com/combo?","skin":{"defaultSkin":"sam","base":"assets/skins/","path":"skin.css","after":["reset","fonts","grids","base"],"rollup":3},dupsAllowed:["yahoo","get"],"moduleInfo":{"animation":{"type":"js","path":"animation/animation-min.js","requires":["dom","event"]},"autocomplete":{"type":"js","path":"autocomplete/autocomplete-min.js","requires":["dom","event","datasource"],"optional":["connection","animation"],"skinnable":true},"base":{"type":"css","path":"base/base-min.css","after":["reset","fonts","grids"]},"button":{"type":"js","path":"button/button-min.js","requires":["element"],"optional":["menu"],"skinnable":true},"calendar":{"type":"js","path":"calendar/calendar-min.js","requires":["event","dom"],supersedes:["datemeth"],"skinnable":true},"carousel":{"type":"js","path":"carousel/carousel-min.js","requires":["element"],"optional":["animation"],"skinnable":true},"charts":{"type":"js","path":"charts/charts-min.js","requires":["element","json","datasource","swf"]},"colorpicker":{"type":"js","path":"colorpicker/colorpicker-min.js","requires":["slider","element"],"optional":["animation"],"skinnable":true},"connection":{"type":"js","path":"connection/connection-min.js","requires":["event"],"supersedes":["connectioncore"]},"connectioncore":{"type":"js","path":"connection/connection_core-min.js","requires":["event"],"pkg":"connection"},"container":{"type":"js","path":"container/container-min.js","requires":["dom","event"],"optional":["dragdrop","animation","connection"],"supersedes":["containercore"],"skinnable":true},"containercore":{"type":"js","path":"container/container_core-min.js","requires":["dom","event"],"pkg":"container"},"cookie":{"type":"js","path":"cookie/cookie-min.js","requires":["yahoo"]},"datasource":{"type":"js","path":"datasource/datasource-min.js","requires":["event"],"optional":["connection"]},"datatable":{"type":"js","path":"datatable/datatable-min.js","requires":["element","datasource"],"optional":["calendar","dragdrop","paginator"],"skinnable":true},datemath:{"type":"js","path":"datemath/datemath-min.js","requires":["yahoo"]},"dom":{"type":"js","path":"dom/dom-min.js","requires":["yahoo"]},"dragdrop":{"type":"js","path":"dragdrop/dragdrop-min.js","requires":["dom","event"]},"editor":{"type":"js","path":"editor/editor-min.js","requires":["menu","element","button"],"optional":["animation","dragdrop"],"supersedes":["simpleeditor"],"skinnable":true},"element":{"type":"js","path":"element/element-min.js","requires":["dom","event"],"optional":["event-mouseenter","event-delegate"]},"element-delegate":{"type":"js","path":"element-delegate/element-delegate-min.js","requires":["element"]},"event":{"type":"js","path":"event/event-min.js","requires":["yahoo"]},"event-simulate":{"type":"js","path":"event-simulate/event-simulate-min.js","requires":["event"]},"event-delegate":{"type":"js","path":"event-delegate/event-delegate-min.js","requires":["event"],"optional":["selector"]},"event-mouseenter":{"type":"js","path":"event-mouseenter/event-mouseenter-min.js","requires":["dom","event"]},"fonts":{"type":"css","path":"fonts/fonts-min.css"},"get":{"type":"js","path":"get/get-min.js","requires":["yahoo"]},"grids":{"type":"css","path":"grids/grids-min.css","requires":["fonts"],"optional":["reset"]},"history":{"type":"js","path":"history/history-min.js","requires":["event"]},"imagecropper":{"type":"js","path":"imagecropper/imagecropper-min.js","requires":["dragdrop","element","resize"],"skinnable":true},"imageloader":{"type":"js","path":"imageloader/imageloader-min.js","requires":["event","dom"]},"json":{"type":"js","path":"json/json-min.js","requires":["yahoo"]},"layout":{"type":"js","path":"layout/layout-min.js","requires":["element"],"optional":["animation","dragdrop","resize","selector"],"skinnable":true},"logger":{"type":"js","path":"logger/logger-min.js","requires":["event","dom"],"optional":["dragdrop"],"skinnable":true},"menu":{"type":"js","path":"menu/menu-min.js","requires":["containercore"],"skinnable":true},"paginator":{"type":"js","path":"paginator/paginator-min.js","requires":["element"],"skinnable":true},"profiler":{"type":"js","path":"profiler/profiler-min.js","requires":["yahoo"]},"profilerviewer":{"type":"js","path":"profilerviewer/profilerviewer-min.js","requires":["profiler","yuiloader","element"],"skinnable":true},"progressbar":{"type":"js","path":"progressbar/progressbar-min.js","requires":["element"],"optional":["animation"],"skinnable":true},"reset":{"type":"css","path":"reset/reset-min.css"},"reset-fonts-grids":{"type":"css","path":"reset-fonts-grids/reset-fonts-grids.css","supersedes":["reset","fonts","grids","reset-fonts"],"rollup":4},"reset-fonts":{"type":"css","path":"reset-fonts/reset-fonts.css","supersedes":["reset","fonts"],"rollup":2},"resize":{"type":"js","path":"resize/resize-min.js","requires":["dragdrop","element"],"optional":["animation"],"skinnable":true},"selector":{"type":"js","path":"selector/selector-min.js","requires":["yahoo","dom"]},"simpleeditor":{"type":"js","path":"editor/simpleeditor-min.js","requires":["element"],"optional":["containercore","menu","button","animation","dragdrop"],"skinnable":true,"pkg":"editor"},"slider":{"type":"js","path":"slider/slider-min.js","requires":["dragdrop"],"optional":["animation"],"skinnable":true},"storage":{"type":"js","path":"storage/storage-min.js","requires":["yahoo","event","cookie"],"optional":["swfstore"]},"stylesheet":{"type":"js","path":"stylesheet/stylesheet-min.js","requires":["yahoo"]},"swf":{"type":"js","path":"swf/swf-min.js","requires":["element"],"supersedes":["swfdetect"]},"swfdetect":{"type":"js","path":"swfdetect/swfdetect-min.js","requires":["yahoo"]},"swfstore":{"type":"js","path":"swfstore/swfstore-min.js","requires":["element","cookie","swf"]},"tabview":{"type":"js","path":"tabview/tabview-min.js","requires":["element"],"optional":["connection"],"skinnable":true},"treeview":{"type":"js","path":"treeview/treeview-min.js","requires":["event","dom"],"optional":["json","animation","calendar"],"skinnable":true},"uploader":{"type":"js","path":"uploader/uploader-min.js","requires":["element"]},"utilities":{"type":"js","path":"utilities/utilities.js","supersedes":["yahoo","event","dragdrop","animation","dom","connection","element","yahoo-dom-event","get","yuiloader","yuiloader-dom-event"],"rollup":8},"yahoo":{"type":"js","path":"yahoo/yahoo-min.js"},"yahoo-dom-event":{"type":"js","path":"yahoo-dom-event/yahoo-dom-event.js","supersedes":["yahoo","event","dom"],"rollup":3},"yuiloader":{"type":"js","path":"yuiloader/yuiloader-min.js","supersedes":["yahoo","get"]},"yuiloader-dom-event":{"type":"js","path":"yuiloader-dom-event/yuiloader-dom-event.js","supersedes":["yahoo","dom","event","get","yuiloader","yahoo-dom-event"],"rollup":5},"yuitest":{"type":"js","path":"yuitest/yuitest-min.js","requires":["logger"],"optional":["event-simulate"],"skinnable":true}}},ObjectUtil:{appendArray:function(o,a){if(a){for(var i=0;
i<a.length;i=i+1){o[a[i]]=true;}}},keys:function(o,ordered){var a=[],i;for(i in o){if(lang.hasOwnProperty(o,i)){a.push(i);}}return a;}},ArrayUtil:{appendArray:function(a1,a2){Array.prototype.push.apply(a1,a2);},indexOf:function(a,val){for(var i=0;i<a.length;i=i+1){if(a[i]===val){return i;}}return -1;},toObject:function(a){var o={};for(var i=0;i<a.length;i=i+1){o[a[i]]=true;}return o;},uniq:function(a){return YUI.ObjectUtil.keys(YUI.ArrayUtil.toObject(a));}}};YAHOO.util.YUILoader=function(o){this._internalCallback=null;this._useYahooListener=false;this.onSuccess=null;this.onFailure=Y.log;this.onProgress=null;this.onTimeout=null;this.scope=this;this.data=null;this.insertBefore=null;this.charset=null;this.varName=null;this.base=YUI.info.base;this.comboBase=YUI.info.comboBase;this.combine=false;this.root=YUI.info.root;this.timeout=0;this.ignore=null;this.force=null;this.allowRollup=true;this.filter=null;this.required={};this.moduleInfo=lang.merge(YUI.info.moduleInfo);this.rollups=null;this.loadOptional=false;this.sorted=[];this.loaded={};this.dirty=true;this.inserted={};var self=this;env.listeners.push(function(m){if(self._useYahooListener){self.loadNext(m.name);}});this.skin=lang.merge(YUI.info.skin);this._config(o);};Y.util.YUILoader.prototype={FILTERS:{RAW:{"searchExp":"-min\\.js","replaceStr":".js"},DEBUG:{"searchExp":"-min\\.js","replaceStr":"-debug.js"}},SKIN_PREFIX:"skin-",_config:function(o){if(o){for(var i in o){if(lang.hasOwnProperty(o,i)){if(i=="require"){this.require(o[i]);}else{this[i]=o[i];}}}}var f=this.filter;if(lang.isString(f)){f=f.toUpperCase();if(f==="DEBUG"){this.require("logger");}if(!Y.widget.LogWriter){Y.widget.LogWriter=function(){return Y;};}this.filter=this.FILTERS[f];}},addModule:function(o){if(!o||!o.name||!o.type||(!o.path&&!o.fullpath)){return false;}o.ext=("ext" in o)?o.ext:true;o.requires=o.requires||[];this.moduleInfo[o.name]=o;this.dirty=true;return true;},require:function(what){var a=(typeof what==="string")?arguments:what;this.dirty=true;YUI.ObjectUtil.appendArray(this.required,a);},_addSkin:function(skin,mod){var name=this.formatSkin(skin),info=this.moduleInfo,sinf=this.skin,ext=info[mod]&&info[mod].ext;if(!info[name]){this.addModule({"name":name,"type":"css","path":sinf.base+skin+"/"+sinf.path,"after":sinf.after,"rollup":sinf.rollup,"ext":ext});}if(mod){name=this.formatSkin(skin,mod);if(!info[name]){var mdef=info[mod],pkg=mdef.pkg||mod;this.addModule({"name":name,"type":"css","after":sinf.after,"path":pkg+"/"+sinf.base+skin+"/"+mod+".css","ext":ext});}}return name;},getRequires:function(mod){if(!mod){return[];}if(!this.dirty&&mod.expanded){return mod.expanded;}mod.requires=mod.requires||[];var i,d=[],r=mod.requires,o=mod.optional,info=this.moduleInfo,m;for(i=0;i<r.length;i=i+1){d.push(r[i]);m=info[r[i]];YUI.ArrayUtil.appendArray(d,this.getRequires(m));}if(o&&this.loadOptional){for(i=0;i<o.length;i=i+1){d.push(o[i]);YUI.ArrayUtil.appendArray(d,this.getRequires(info[o[i]]));}}mod.expanded=YUI.ArrayUtil.uniq(d);return mod.expanded;},getProvides:function(name,notMe){var addMe=!(notMe),ckey=(addMe)?PROV:SUPER,m=this.moduleInfo[name],o={};if(!m){return o;}if(m[ckey]){return m[ckey];}var s=m.supersedes,done={},me=this;var add=function(mm){if(!done[mm]){done[mm]=true;lang.augmentObject(o,me.getProvides(mm));}};if(s){for(var i=0;i<s.length;i=i+1){add(s[i]);}}m[SUPER]=o;m[PROV]=lang.merge(o);m[PROV][name]=true;return m[ckey];},calculate:function(o){if(o||this.dirty){this._config(o);this._setup();this._explode();if(this.allowRollup){this._rollup();}this._reduce();this._sort();this.dirty=false;}},_setup:function(){var info=this.moduleInfo,name,i,j;for(name in info){if(lang.hasOwnProperty(info,name)){var m=info[name];if(m&&m.skinnable){var o=this.skin.overrides,smod;if(o&&o[name]){for(i=0;i<o[name].length;i=i+1){smod=this._addSkin(o[name][i],name);}}else{smod=this._addSkin(this.skin.defaultSkin,name);}m.requires.push(smod);}}}var l=lang.merge(this.inserted);if(!this._sandbox){l=lang.merge(l,env.modules);}if(this.ignore){YUI.ObjectUtil.appendArray(l,this.ignore);}if(this.force){for(i=0;i<this.force.length;i=i+1){if(this.force[i] in l){delete l[this.force[i]];}}}for(j in l){if(lang.hasOwnProperty(l,j)){lang.augmentObject(l,this.getProvides(j));}}this.loaded=l;},_explode:function(){var r=this.required,i,mod;for(i in r){if(lang.hasOwnProperty(r,i)){mod=this.moduleInfo[i];if(mod){var req=this.getRequires(mod);if(req){YUI.ObjectUtil.appendArray(r,req);}}}}},_skin:function(){},formatSkin:function(skin,mod){var s=this.SKIN_PREFIX+skin;if(mod){s=s+"-"+mod;}return s;},parseSkin:function(mod){if(mod.indexOf(this.SKIN_PREFIX)===0){var a=mod.split("-");return{skin:a[1],module:a[2]};}return null;},_rollup:function(){var i,j,m,s,rollups={},r=this.required,roll,info=this.moduleInfo;if(this.dirty||!this.rollups){for(i in info){if(lang.hasOwnProperty(info,i)){m=info[i];if(m&&m.rollup){rollups[i]=m;}}}this.rollups=rollups;}for(;;){var rolled=false;for(i in rollups){if(!r[i]&&!this.loaded[i]){m=info[i];s=m.supersedes;roll=false;if(!m.rollup){continue;}var skin=(m.ext)?false:this.parseSkin(i),c=0;if(skin){for(j in r){if(lang.hasOwnProperty(r,j)){if(i!==j&&this.parseSkin(j)){c++;roll=(c>=m.rollup);if(roll){break;}}}}}else{for(j=0;j<s.length;j=j+1){if(this.loaded[s[j]]&&(!YUI.dupsAllowed[s[j]])){roll=false;break;}else{if(r[s[j]]){c++;roll=(c>=m.rollup);if(roll){break;}}}}}if(roll){r[i]=true;rolled=true;this.getRequires(m);}}}if(!rolled){break;}}},_reduce:function(){var i,j,s,m,r=this.required;for(i in r){if(i in this.loaded){delete r[i];}else{var skinDef=this.parseSkin(i);if(skinDef){if(!skinDef.module){var skin_pre=this.SKIN_PREFIX+skinDef.skin;for(j in r){if(lang.hasOwnProperty(r,j)){m=this.moduleInfo[j];var ext=m&&m.ext;if(!ext&&j!==i&&j.indexOf(skin_pre)>-1){delete r[j];}}}}}else{m=this.moduleInfo[i];s=m&&m.supersedes;if(s){for(j=0;j<s.length;j=j+1){if(s[j] in r){delete r[s[j]];}}}}}}},_onFailure:function(msg){YAHOO.log("Failure","info","loader");var f=this.onFailure;if(f){f.call(this.scope,{msg:"failure: "+msg,data:this.data,success:false});
}},_onTimeout:function(){YAHOO.log("Timeout","info","loader");var f=this.onTimeout;if(f){f.call(this.scope,{msg:"timeout",data:this.data,success:false});}},_sort:function(){var s=[],info=this.moduleInfo,loaded=this.loaded,checkOptional=!this.loadOptional,me=this;var requires=function(aa,bb){var mm=info[aa];if(loaded[bb]||!mm){return false;}var ii,rr=mm.expanded,after=mm.after,other=info[bb],optional=mm.optional;if(rr&&YUI.ArrayUtil.indexOf(rr,bb)>-1){return true;}if(after&&YUI.ArrayUtil.indexOf(after,bb)>-1){return true;}if(checkOptional&&optional&&YUI.ArrayUtil.indexOf(optional,bb)>-1){return true;}var ss=info[bb]&&info[bb].supersedes;if(ss){for(ii=0;ii<ss.length;ii=ii+1){if(requires(aa,ss[ii])){return true;}}}if(mm.ext&&mm.type=="css"&&!other.ext&&other.type=="css"){return true;}return false;};for(var i in this.required){if(lang.hasOwnProperty(this.required,i)){s.push(i);}}var p=0;for(;;){var l=s.length,a,b,j,k,moved=false;for(j=p;j<l;j=j+1){a=s[j];for(k=j+1;k<l;k=k+1){if(requires(a,s[k])){b=s.splice(k,1);s.splice(j,0,b[0]);moved=true;break;}}if(moved){break;}else{p=p+1;}}if(!moved){break;}}this.sorted=s;},toString:function(){var o={type:"YUILoader",base:this.base,filter:this.filter,required:this.required,loaded:this.loaded,inserted:this.inserted};lang.dump(o,1);},_combine:function(){this._combining=[];var self=this,s=this.sorted,len=s.length,js=this.comboBase,css=this.comboBase,target,startLen=js.length,i,m,type=this.loadType;YAHOO.log("type "+type);for(i=0;i<len;i=i+1){m=this.moduleInfo[s[i]];if(m&&!m.ext&&(!type||type===m.type)){target=this.root+m.path;target+="&";if(m.type=="js"){js+=target;}else{css+=target;}this._combining.push(s[i]);}}if(this._combining.length){YAHOO.log("Attempting to combine: "+this._combining,"info","loader");var callback=function(o){var c=this._combining,len=c.length,i,m;for(i=0;i<len;i=i+1){this.inserted[c[i]]=true;}this.loadNext(o.data);},loadScript=function(){if(js.length>startLen){YAHOO.util.Get.script(self._filter(js),{data:self._loading,onSuccess:callback,onFailure:self._onFailure,onTimeout:self._onTimeout,insertBefore:self.insertBefore,charset:self.charset,timeout:self.timeout,scope:self});}};if(css.length>startLen){YAHOO.util.Get.css(this._filter(css),{data:this._loading,onSuccess:loadScript,onFailure:this._onFailure,onTimeout:this._onTimeout,insertBefore:this.insertBefore,charset:this.charset,timeout:this.timeout,scope:self});}else{loadScript();}return;}else{this.loadNext(this._loading);}},insert:function(o,type){this.calculate(o);this._loading=true;this.loadType=type;if(this.combine){return this._combine();}if(!type){var self=this;this._internalCallback=function(){self._internalCallback=null;self.insert(null,"js");};this.insert(null,"css");return;}this.loadNext();},sandbox:function(o,type){this._config(o);if(!this.onSuccess){throw new Error("You must supply an onSuccess handler for your sandbox");}this._sandbox=true;var self=this;if(!type||type!=="js"){this._internalCallback=function(){self._internalCallback=null;self.sandbox(null,"js");};this.insert(null,"css");return;}if(!util.Connect){var ld=new YAHOO.util.YUILoader();ld.insert({base:this.base,filter:this.filter,require:"connection",insertBefore:this.insertBefore,charset:this.charset,onSuccess:function(){this.sandbox(null,"js");},scope:this},"js");return;}this._scriptText=[];this._loadCount=0;this._stopCount=this.sorted.length;this._xhr=[];this.calculate();var s=this.sorted,l=s.length,i,m,url;for(i=0;i<l;i=i+1){m=this.moduleInfo[s[i]];if(!m){this._onFailure("undefined module "+m);for(var j=0;j<this._xhr.length;j=j+1){this._xhr[j].abort();}return;}if(m.type!=="js"){this._loadCount++;continue;}url=m.fullpath;url=(url)?this._filter(url):this._url(m.path);var xhrData={success:function(o){var idx=o.argument[0],name=o.argument[2];this._scriptText[idx]=o.responseText;if(this.onProgress){this.onProgress.call(this.scope,{name:name,scriptText:o.responseText,xhrResponse:o,data:this.data});}this._loadCount++;if(this._loadCount>=this._stopCount){var v=this.varName||"YAHOO";var t="(function() {\n";var b="\nreturn "+v+";\n})();";var ref=eval(t+this._scriptText.join("\n")+b);this._pushEvents(ref);if(ref){this.onSuccess.call(this.scope,{reference:ref,data:this.data});}else{this._onFailure.call(this.varName+" reference failure");}}},failure:function(o){this.onFailure.call(this.scope,{msg:"XHR failure",xhrResponse:o,data:this.data});},scope:this,argument:[i,url,s[i]]};this._xhr.push(util.Connect.asyncRequest("GET",url,xhrData));}},loadNext:function(mname){if(!this._loading){return;}if(mname){if(mname!==this._loading){return;}this.inserted[mname]=true;if(this.onProgress){this.onProgress.call(this.scope,{name:mname,data:this.data});}}var s=this.sorted,len=s.length,i,m;for(i=0;i<len;i=i+1){if(s[i] in this.inserted){continue;}if(s[i]===this._loading){return;}m=this.moduleInfo[s[i]];if(!m){this.onFailure.call(this.scope,{msg:"undefined module "+m,data:this.data});return;}if(!this.loadType||this.loadType===m.type){this._loading=s[i];var fn=(m.type==="css")?util.Get.css:util.Get.script,url=m.fullpath,self=this,c=function(o){self.loadNext(o.data);};url=(url)?this._filter(url):this._url(m.path);if(env.ua.webkit&&env.ua.webkit<420&&m.type==="js"&&!m.varName){c=null;this._useYahooListener=true;}fn(url,{data:s[i],onSuccess:c,onFailure:this._onFailure,onTimeout:this._onTimeout,insertBefore:this.insertBefore,charset:this.charset,timeout:this.timeout,varName:m.varName,scope:self});return;}}this._loading=null;if(this._internalCallback){var f=this._internalCallback;this._internalCallback=null;f.call(this);}else{if(this.onSuccess){this._pushEvents();this.onSuccess.call(this.scope,{data:this.data});}}},_pushEvents:function(ref){var r=ref||YAHOO;if(r.util&&r.util.Event){r.util.Event._load();}},_filter:function(str){var f=this.filter;return(f)?str.replace(new RegExp(f.searchExp,"g"),f.replaceStr):str;},_url:function(path){return this._filter((this.base||"")+path);}};})();YAHOO.register("yuiloader",YAHOO.util.YUILoader,{version:"2.8.2r1",build:"7"});
(function(){YAHOO.env._id_counter=YAHOO.env._id_counter||0;var E=YAHOO.util,L=YAHOO.lang,m=YAHOO.env.ua,A=YAHOO.lang.trim,d={},h={},N=/^t(?:able|d|h)$/i,X=/color$/i,K=window.document,W=K.documentElement,e="ownerDocument",n="defaultView",v="documentElement",t="compatMode",b="offsetLeft",P="offsetTop",u="offsetParent",Z="parentNode",l="nodeType",C="tagName",O="scrollLeft",i="scrollTop",Q="getBoundingClientRect",w="getComputedStyle",a="currentStyle",M="CSS1Compat",c="BackCompat",g="class",F="className",J="",B=" ",s="(?:^|\\s)",k="(?= |$)",U="g",p="position",f="fixed",V="relative",j="left",o="top",r="medium",q="borderLeftWidth",R="borderTopWidth",D=m.opera,I=m.webkit,H=m.gecko,T=m.ie;E.Dom={CUSTOM_ATTRIBUTES:(!W.hasAttribute)?{"for":"htmlFor","class":F}:{"htmlFor":"for","className":g},DOT_ATTRIBUTES:{},get:function(z){var AB,x,AA,y,Y,G;if(z){if(z[l]||z.item){return z;}if(typeof z==="string"){AB=z;z=K.getElementById(z);G=(z)?z.attributes:null;if(z&&G&&G.id&&G.id.value===AB){return z;}else{if(z&&K.all){z=null;x=K.all[AB];for(y=0,Y=x.length;y<Y;++y){if(x[y].id===AB){return x[y];}}}}return z;}if(YAHOO.util.Element&&z instanceof YAHOO.util.Element){z=z.get("element");}if("length" in z){AA=[];for(y=0,Y=z.length;y<Y;++y){AA[AA.length]=E.Dom.get(z[y]);}return AA;}return z;}return null;},getComputedStyle:function(G,Y){if(window[w]){return G[e][n][w](G,null)[Y];}else{if(G[a]){return E.Dom.IE_ComputedStyle.get(G,Y);}}},getStyle:function(G,Y){return E.Dom.batch(G,E.Dom._getStyle,Y);},_getStyle:function(){if(window[w]){return function(G,y){y=(y==="float")?y="cssFloat":E.Dom._toCamel(y);var x=G.style[y],Y;if(!x){Y=G[e][n][w](G,null);if(Y){x=Y[y];}}return x;};}else{if(W[a]){return function(G,y){var x;switch(y){case"opacity":x=100;try{x=G.filters["DXImageTransform.Microsoft.Alpha"].opacity;}catch(z){try{x=G.filters("alpha").opacity;}catch(Y){}}return x/100;case"float":y="styleFloat";default:y=E.Dom._toCamel(y);x=G[a]?G[a][y]:null;return(G.style[y]||x);}};}}}(),setStyle:function(G,Y,x){E.Dom.batch(G,E.Dom._setStyle,{prop:Y,val:x});},_setStyle:function(){if(T){return function(Y,G){var x=E.Dom._toCamel(G.prop),y=G.val;if(Y){switch(x){case"opacity":if(L.isString(Y.style.filter)){Y.style.filter="alpha(opacity="+y*100+")";if(!Y[a]||!Y[a].hasLayout){Y.style.zoom=1;}}break;case"float":x="styleFloat";default:Y.style[x]=y;}}else{}};}else{return function(Y,G){var x=E.Dom._toCamel(G.prop),y=G.val;if(Y){if(x=="float"){x="cssFloat";}Y.style[x]=y;}else{}};}}(),getXY:function(G){return E.Dom.batch(G,E.Dom._getXY);},_canPosition:function(G){return(E.Dom._getStyle(G,"display")!=="none"&&E.Dom._inDoc(G));},_getXY:function(){if(K[v][Q]){return function(y){var z,Y,AA,AF,AE,AD,AC,G,x,AB=Math.floor,AG=false;if(E.Dom._canPosition(y)){AA=y[Q]();AF=y[e];z=E.Dom.getDocumentScrollLeft(AF);Y=E.Dom.getDocumentScrollTop(AF);AG=[AB(AA[j]),AB(AA[o])];if(T&&m.ie<8){AE=2;AD=2;AC=AF[t];if(m.ie===6){if(AC!==c){AE=0;AD=0;}}if((AC===c)){G=S(AF[v],q);x=S(AF[v],R);if(G!==r){AE=parseInt(G,10);}if(x!==r){AD=parseInt(x,10);}}AG[0]-=AE;AG[1]-=AD;}if((Y||z)){AG[0]+=z;AG[1]+=Y;}AG[0]=AB(AG[0]);AG[1]=AB(AG[1]);}else{}return AG;};}else{return function(y){var x,Y,AA,AB,AC,z=false,G=y;if(E.Dom._canPosition(y)){z=[y[b],y[P]];x=E.Dom.getDocumentScrollLeft(y[e]);Y=E.Dom.getDocumentScrollTop(y[e]);AC=((H||m.webkit>519)?true:false);while((G=G[u])){z[0]+=G[b];z[1]+=G[P];if(AC){z=E.Dom._calcBorders(G,z);}}if(E.Dom._getStyle(y,p)!==f){G=y;while((G=G[Z])&&G[C]){AA=G[i];AB=G[O];if(H&&(E.Dom._getStyle(G,"overflow")!=="visible")){z=E.Dom._calcBorders(G,z);}if(AA||AB){z[0]-=AB;z[1]-=AA;}}z[0]+=x;z[1]+=Y;}else{if(D){z[0]-=x;z[1]-=Y;}else{if(I||H){z[0]+=x;z[1]+=Y;}}}z[0]=Math.floor(z[0]);z[1]=Math.floor(z[1]);}else{}return z;};}}(),getX:function(G){var Y=function(x){return E.Dom.getXY(x)[0];};return E.Dom.batch(G,Y,E.Dom,true);},getY:function(G){var Y=function(x){return E.Dom.getXY(x)[1];};return E.Dom.batch(G,Y,E.Dom,true);},setXY:function(G,x,Y){E.Dom.batch(G,E.Dom._setXY,{pos:x,noRetry:Y});},_setXY:function(G,z){var AA=E.Dom._getStyle(G,p),y=E.Dom.setStyle,AD=z.pos,Y=z.noRetry,AB=[parseInt(E.Dom.getComputedStyle(G,j),10),parseInt(E.Dom.getComputedStyle(G,o),10)],AC,x;if(AA=="static"){AA=V;y(G,p,AA);}AC=E.Dom._getXY(G);if(!AD||AC===false){return false;}if(isNaN(AB[0])){AB[0]=(AA==V)?0:G[b];}if(isNaN(AB[1])){AB[1]=(AA==V)?0:G[P];}if(AD[0]!==null){y(G,j,AD[0]-AC[0]+AB[0]+"px");}if(AD[1]!==null){y(G,o,AD[1]-AC[1]+AB[1]+"px");}if(!Y){x=E.Dom._getXY(G);if((AD[0]!==null&&x[0]!=AD[0])||(AD[1]!==null&&x[1]!=AD[1])){E.Dom._setXY(G,{pos:AD,noRetry:true});}}},setX:function(Y,G){E.Dom.setXY(Y,[G,null]);},setY:function(G,Y){E.Dom.setXY(G,[null,Y]);},getRegion:function(G){var Y=function(x){var y=false;if(E.Dom._canPosition(x)){y=E.Region.getRegion(x);}else{}return y;};return E.Dom.batch(G,Y,E.Dom,true);},getClientWidth:function(){return E.Dom.getViewportWidth();},getClientHeight:function(){return E.Dom.getViewportHeight();},getElementsByClassName:function(AB,AF,AC,AE,x,AD){AF=AF||"*";AC=(AC)?E.Dom.get(AC):null||K;if(!AC){return[];}var Y=[],G=AC.getElementsByTagName(AF),z=E.Dom.hasClass;for(var y=0,AA=G.length;y<AA;++y){if(z(G[y],AB)){Y[Y.length]=G[y];}}if(AE){E.Dom.batch(Y,AE,x,AD);}return Y;},hasClass:function(Y,G){return E.Dom.batch(Y,E.Dom._hasClass,G);},_hasClass:function(x,Y){var G=false,y;if(x&&Y){y=E.Dom._getAttribute(x,F)||J;if(Y.exec){G=Y.test(y);}else{G=Y&&(B+y+B).indexOf(B+Y+B)>-1;}}else{}return G;},addClass:function(Y,G){return E.Dom.batch(Y,E.Dom._addClass,G);},_addClass:function(x,Y){var G=false,y;if(x&&Y){y=E.Dom._getAttribute(x,F)||J;if(!E.Dom._hasClass(x,Y)){E.Dom.setAttribute(x,F,A(y+B+Y));G=true;}}else{}return G;},removeClass:function(Y,G){return E.Dom.batch(Y,E.Dom._removeClass,G);},_removeClass:function(y,x){var Y=false,AA,z,G;if(y&&x){AA=E.Dom._getAttribute(y,F)||J;E.Dom.setAttribute(y,F,AA.replace(E.Dom._getClassRegex(x),J));z=E.Dom._getAttribute(y,F);if(AA!==z){E.Dom.setAttribute(y,F,A(z));Y=true;if(E.Dom._getAttribute(y,F)===""){G=(y.hasAttribute&&y.hasAttribute(g))?g:F;
y.removeAttribute(G);}}}else{}return Y;},replaceClass:function(x,Y,G){return E.Dom.batch(x,E.Dom._replaceClass,{from:Y,to:G});},_replaceClass:function(y,x){var Y,AB,AA,G=false,z;if(y&&x){AB=x.from;AA=x.to;if(!AA){G=false;}else{if(!AB){G=E.Dom._addClass(y,x.to);}else{if(AB!==AA){z=E.Dom._getAttribute(y,F)||J;Y=(B+z.replace(E.Dom._getClassRegex(AB),B+AA)).split(E.Dom._getClassRegex(AA));Y.splice(1,0,B+AA);E.Dom.setAttribute(y,F,A(Y.join(J)));G=true;}}}}else{}return G;},generateId:function(G,x){x=x||"yui-gen";var Y=function(y){if(y&&y.id){return y.id;}var z=x+YAHOO.env._id_counter++;if(y){if(y[e]&&y[e].getElementById(z)){return E.Dom.generateId(y,z+x);}y.id=z;}return z;};return E.Dom.batch(G,Y,E.Dom,true)||Y.apply(E.Dom,arguments);},isAncestor:function(Y,x){Y=E.Dom.get(Y);x=E.Dom.get(x);var G=false;if((Y&&x)&&(Y[l]&&x[l])){if(Y.contains&&Y!==x){G=Y.contains(x);}else{if(Y.compareDocumentPosition){G=!!(Y.compareDocumentPosition(x)&16);}}}else{}return G;},inDocument:function(G,Y){return E.Dom._inDoc(E.Dom.get(G),Y);},_inDoc:function(Y,x){var G=false;if(Y&&Y[C]){x=x||Y[e];G=E.Dom.isAncestor(x[v],Y);}else{}return G;},getElementsBy:function(Y,AF,AB,AD,y,AC,AE){AF=AF||"*";AB=(AB)?E.Dom.get(AB):null||K;if(!AB){return[];}var x=[],G=AB.getElementsByTagName(AF);for(var z=0,AA=G.length;z<AA;++z){if(Y(G[z])){if(AE){x=G[z];break;}else{x[x.length]=G[z];}}}if(AD){E.Dom.batch(x,AD,y,AC);}return x;},getElementBy:function(x,G,Y){return E.Dom.getElementsBy(x,G,Y,null,null,null,true);},batch:function(x,AB,AA,z){var y=[],Y=(z)?AA:window;x=(x&&(x[C]||x.item))?x:E.Dom.get(x);if(x&&AB){if(x[C]||x.length===undefined){return AB.call(Y,x,AA);}for(var G=0;G<x.length;++G){y[y.length]=AB.call(Y,x[G],AA);}}else{return false;}return y;},getDocumentHeight:function(){var Y=(K[t]!=M||I)?K.body.scrollHeight:W.scrollHeight,G=Math.max(Y,E.Dom.getViewportHeight());return G;},getDocumentWidth:function(){var Y=(K[t]!=M||I)?K.body.scrollWidth:W.scrollWidth,G=Math.max(Y,E.Dom.getViewportWidth());return G;},getViewportHeight:function(){var G=self.innerHeight,Y=K[t];if((Y||T)&&!D){G=(Y==M)?W.clientHeight:K.body.clientHeight;}return G;},getViewportWidth:function(){var G=self.innerWidth,Y=K[t];if(Y||T){G=(Y==M)?W.clientWidth:K.body.clientWidth;}return G;},getAncestorBy:function(G,Y){while((G=G[Z])){if(E.Dom._testElement(G,Y)){return G;}}return null;},getAncestorByClassName:function(Y,G){Y=E.Dom.get(Y);if(!Y){return null;}var x=function(y){return E.Dom.hasClass(y,G);};return E.Dom.getAncestorBy(Y,x);},getAncestorByTagName:function(Y,G){Y=E.Dom.get(Y);if(!Y){return null;}var x=function(y){return y[C]&&y[C].toUpperCase()==G.toUpperCase();};return E.Dom.getAncestorBy(Y,x);},getPreviousSiblingBy:function(G,Y){while(G){G=G.previousSibling;if(E.Dom._testElement(G,Y)){return G;}}return null;},getPreviousSibling:function(G){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getPreviousSiblingBy(G);},getNextSiblingBy:function(G,Y){while(G){G=G.nextSibling;if(E.Dom._testElement(G,Y)){return G;}}return null;},getNextSibling:function(G){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getNextSiblingBy(G);},getFirstChildBy:function(G,x){var Y=(E.Dom._testElement(G.firstChild,x))?G.firstChild:null;return Y||E.Dom.getNextSiblingBy(G.firstChild,x);},getFirstChild:function(G,Y){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getFirstChildBy(G);},getLastChildBy:function(G,x){if(!G){return null;}var Y=(E.Dom._testElement(G.lastChild,x))?G.lastChild:null;return Y||E.Dom.getPreviousSiblingBy(G.lastChild,x);},getLastChild:function(G){G=E.Dom.get(G);return E.Dom.getLastChildBy(G);},getChildrenBy:function(Y,y){var x=E.Dom.getFirstChildBy(Y,y),G=x?[x]:[];E.Dom.getNextSiblingBy(x,function(z){if(!y||y(z)){G[G.length]=z;}return false;});return G;},getChildren:function(G){G=E.Dom.get(G);if(!G){}return E.Dom.getChildrenBy(G);},getDocumentScrollLeft:function(G){G=G||K;return Math.max(G[v].scrollLeft,G.body.scrollLeft);},getDocumentScrollTop:function(G){G=G||K;return Math.max(G[v].scrollTop,G.body.scrollTop);},insertBefore:function(Y,G){Y=E.Dom.get(Y);G=E.Dom.get(G);if(!Y||!G||!G[Z]){return null;}return G[Z].insertBefore(Y,G);},insertAfter:function(Y,G){Y=E.Dom.get(Y);G=E.Dom.get(G);if(!Y||!G||!G[Z]){return null;}if(G.nextSibling){return G[Z].insertBefore(Y,G.nextSibling);}else{return G[Z].appendChild(Y);}},getClientRegion:function(){var x=E.Dom.getDocumentScrollTop(),Y=E.Dom.getDocumentScrollLeft(),y=E.Dom.getViewportWidth()+Y,G=E.Dom.getViewportHeight()+x;return new E.Region(x,y,G,Y);},setAttribute:function(Y,G,x){E.Dom.batch(Y,E.Dom._setAttribute,{attr:G,val:x});},_setAttribute:function(x,Y){var G=E.Dom._toCamel(Y.attr),y=Y.val;if(x&&x.setAttribute){if(E.Dom.DOT_ATTRIBUTES[G]){x[G]=y;}else{G=E.Dom.CUSTOM_ATTRIBUTES[G]||G;x.setAttribute(G,y);}}else{}},getAttribute:function(Y,G){return E.Dom.batch(Y,E.Dom._getAttribute,G);},_getAttribute:function(Y,G){var x;G=E.Dom.CUSTOM_ATTRIBUTES[G]||G;if(Y&&Y.getAttribute){x=Y.getAttribute(G,2);}else{}return x;},_toCamel:function(Y){var x=d;function G(y,z){return z.toUpperCase();}return x[Y]||(x[Y]=Y.indexOf("-")===-1?Y:Y.replace(/-([a-z])/gi,G));},_getClassRegex:function(Y){var G;if(Y!==undefined){if(Y.exec){G=Y;}else{G=h[Y];if(!G){Y=Y.replace(E.Dom._patterns.CLASS_RE_TOKENS,"\\$1");G=h[Y]=new RegExp(s+Y+k,U);}}}return G;},_patterns:{ROOT_TAG:/^body|html$/i,CLASS_RE_TOKENS:/([\.\(\)\^\$\*\+\?\|\[\]\{\}\\])/g},_testElement:function(G,Y){return G&&G[l]==1&&(!Y||Y(G));},_calcBorders:function(x,y){var Y=parseInt(E.Dom[w](x,R),10)||0,G=parseInt(E.Dom[w](x,q),10)||0;if(H){if(N.test(x[C])){Y=0;G=0;}}y[0]+=G;y[1]+=Y;return y;}};var S=E.Dom[w];if(m.opera){E.Dom[w]=function(Y,G){var x=S(Y,G);if(X.test(G)){x=E.Dom.Color.toRGB(x);}return x;};}if(m.webkit){E.Dom[w]=function(Y,G){var x=S(Y,G);if(x==="rgba(0, 0, 0, 0)"){x="transparent";}return x;};}if(m.ie&&m.ie>=8&&K.documentElement.hasAttribute){E.Dom.DOT_ATTRIBUTES.type=true;}})();YAHOO.util.Region=function(C,D,A,B){this.top=C;this.y=C;this[1]=C;this.right=D;this.bottom=A;this.left=B;this.x=B;this[0]=B;
this.width=this.right-this.left;this.height=this.bottom-this.top;};YAHOO.util.Region.prototype.contains=function(A){return(A.left>=this.left&&A.right<=this.right&&A.top>=this.top&&A.bottom<=this.bottom);};YAHOO.util.Region.prototype.getArea=function(){return((this.bottom-this.top)*(this.right-this.left));};YAHOO.util.Region.prototype.intersect=function(E){var C=Math.max(this.top,E.top),D=Math.min(this.right,E.right),A=Math.min(this.bottom,E.bottom),B=Math.max(this.left,E.left);if(A>=C&&D>=B){return new YAHOO.util.Region(C,D,A,B);}else{return null;}};YAHOO.util.Region.prototype.union=function(E){var C=Math.min(this.top,E.top),D=Math.max(this.right,E.right),A=Math.max(this.bottom,E.bottom),B=Math.min(this.left,E.left);return new YAHOO.util.Region(C,D,A,B);};YAHOO.util.Region.prototype.toString=function(){return("Region {"+"top: "+this.top+", right: "+this.right+", bottom: "+this.bottom+", left: "+this.left+", height: "+this.height+", width: "+this.width+"}");};YAHOO.util.Region.getRegion=function(D){var F=YAHOO.util.Dom.getXY(D),C=F[1],E=F[0]+D.offsetWidth,A=F[1]+D.offsetHeight,B=F[0];return new YAHOO.util.Region(C,E,A,B);};YAHOO.util.Point=function(A,B){if(YAHOO.lang.isArray(A)){B=A[1];A=A[0];}YAHOO.util.Point.superclass.constructor.call(this,B,A,B,A);};YAHOO.extend(YAHOO.util.Point,YAHOO.util.Region);(function(){var B=YAHOO.util,A="clientTop",F="clientLeft",J="parentNode",K="right",W="hasLayout",I="px",U="opacity",L="auto",D="borderLeftWidth",G="borderTopWidth",P="borderRightWidth",V="borderBottomWidth",S="visible",Q="transparent",N="height",E="width",H="style",T="currentStyle",R=/^width|height$/,O=/^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,M={get:function(X,Z){var Y="",a=X[T][Z];if(Z===U){Y=B.Dom.getStyle(X,U);}else{if(!a||(a.indexOf&&a.indexOf(I)>-1)){Y=a;}else{if(B.Dom.IE_COMPUTED[Z]){Y=B.Dom.IE_COMPUTED[Z](X,Z);}else{if(O.test(a)){Y=B.Dom.IE.ComputedStyle.getPixel(X,Z);}else{Y=a;}}}}return Y;},getOffset:function(Z,e){var b=Z[T][e],X=e.charAt(0).toUpperCase()+e.substr(1),c="offset"+X,Y="pixel"+X,a="",d;if(b==L){d=Z[c];if(d===undefined){a=0;}a=d;if(R.test(e)){Z[H][e]=d;if(Z[c]>d){a=d-(Z[c]-d);}Z[H][e]=L;}}else{if(!Z[H][Y]&&!Z[H][e]){Z[H][e]=b;}a=Z[H][Y];}return a+I;},getBorderWidth:function(X,Z){var Y=null;if(!X[T][W]){X[H].zoom=1;}switch(Z){case G:Y=X[A];break;case V:Y=X.offsetHeight-X.clientHeight-X[A];break;case D:Y=X[F];break;case P:Y=X.offsetWidth-X.clientWidth-X[F];break;}return Y+I;},getPixel:function(Y,X){var a=null,b=Y[T][K],Z=Y[T][X];Y[H][K]=Z;a=Y[H].pixelRight;Y[H][K]=b;return a+I;},getMargin:function(Y,X){var Z;if(Y[T][X]==L){Z=0+I;}else{Z=B.Dom.IE.ComputedStyle.getPixel(Y,X);}return Z;},getVisibility:function(Y,X){var Z;while((Z=Y[T])&&Z[X]=="inherit"){Y=Y[J];}return(Z)?Z[X]:S;},getColor:function(Y,X){return B.Dom.Color.toRGB(Y[T][X])||Q;},getBorderColor:function(Y,X){var Z=Y[T],a=Z[X]||Z.color;return B.Dom.Color.toRGB(B.Dom.Color.toHex(a));}},C={};C.top=C.right=C.bottom=C.left=C[E]=C[N]=M.getOffset;C.color=M.getColor;C[G]=C[P]=C[V]=C[D]=M.getBorderWidth;C.marginTop=C.marginRight=C.marginBottom=C.marginLeft=M.getMargin;C.visibility=M.getVisibility;C.borderColor=C.borderTopColor=C.borderRightColor=C.borderBottomColor=C.borderLeftColor=M.getBorderColor;B.Dom.IE_COMPUTED=C;B.Dom.IE_ComputedStyle=M;})();(function(){var C="toString",A=parseInt,B=RegExp,D=YAHOO.util;D.Dom.Color={KEYWORDS:{black:"000",silver:"c0c0c0",gray:"808080",white:"fff",maroon:"800000",red:"f00",purple:"800080",fuchsia:"f0f",green:"008000",lime:"0f0",olive:"808000",yellow:"ff0",navy:"000080",blue:"00f",teal:"008080",aqua:"0ff"},re_RGB:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,re_hex:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,re_hex3:/([0-9A-F])/gi,toRGB:function(E){if(!D.Dom.Color.re_RGB.test(E)){E=D.Dom.Color.toHex(E);}if(D.Dom.Color.re_hex.exec(E)){E="rgb("+[A(B.$1,16),A(B.$2,16),A(B.$3,16)].join(", ")+")";}return E;},toHex:function(H){H=D.Dom.Color.KEYWORDS[H]||H;if(D.Dom.Color.re_RGB.exec(H)){var G=(B.$1.length===1)?"0"+B.$1:Number(B.$1),F=(B.$2.length===1)?"0"+B.$2:Number(B.$2),E=(B.$3.length===1)?"0"+B.$3:Number(B.$3);H=[G[C](16),F[C](16),E[C](16)].join("");}if(H.length<6){H=H.replace(D.Dom.Color.re_hex3,"$1$1");}if(H!=="transparent"&&H.indexOf("#")<0){H="#"+H;}return H.toLowerCase();}};}());YAHOO.register("dom",YAHOO.util.Dom,{version:"2.8.2r1",build:"7"});YAHOO.util.CustomEvent=function(D,C,B,A,E){this.type=D;this.scope=C||window;this.silent=B;this.fireOnce=E;this.fired=false;this.firedWith=null;this.signature=A||YAHOO.util.CustomEvent.LIST;this.subscribers=[];if(!this.silent){}var F="_YUICEOnSubscribe";if(D!==F){this.subscribeEvent=new YAHOO.util.CustomEvent(F,this,true);}this.lastError=null;};YAHOO.util.CustomEvent.LIST=0;YAHOO.util.CustomEvent.FLAT=1;YAHOO.util.CustomEvent.prototype={subscribe:function(B,C,D){if(!B){throw new Error("Invalid callback for subscriber to '"+this.type+"'");}if(this.subscribeEvent){this.subscribeEvent.fire(B,C,D);}var A=new YAHOO.util.Subscriber(B,C,D);if(this.fireOnce&&this.fired){this.notify(A,this.firedWith);}else{this.subscribers.push(A);}},unsubscribe:function(D,F){if(!D){return this.unsubscribeAll();}var E=false;for(var B=0,A=this.subscribers.length;B<A;++B){var C=this.subscribers[B];if(C&&C.contains(D,F)){this._delete(B);E=true;}}return E;},fire:function(){this.lastError=null;var H=[],A=this.subscribers.length;var D=[].slice.call(arguments,0),C=true,F,B=false;if(this.fireOnce){if(this.fired){return true;}else{this.firedWith=D;}}this.fired=true;if(!A&&this.silent){return true;}if(!this.silent){}var E=this.subscribers.slice();for(F=0;F<A;++F){var G=E[F];if(!G){B=true;}else{C=this.notify(G,D);if(false===C){if(!this.silent){}break;}}}return(C!==false);},notify:function(F,C){var B,H=null,E=F.getScope(this.scope),A=YAHOO.util.Event.throwErrors;if(!this.silent){}if(this.signature==YAHOO.util.CustomEvent.FLAT){if(C.length>0){H=C[0];}try{B=F.fn.call(E,H,F.obj);}catch(G){this.lastError=G;if(A){throw G;}}}else{try{B=F.fn.call(E,this.type,C,F.obj);}catch(D){this.lastError=D;if(A){throw D;}}}return B;},unsubscribeAll:function(){var A=this.subscribers.length,B;for(B=A-1;B>-1;B--){this._delete(B);}this.subscribers=[];return A;},_delete:function(A){var B=this.subscribers[A];if(B){delete B.fn;delete B.obj;}this.subscribers.splice(A,1);},toString:function(){return"CustomEvent: "+"'"+this.type+"', "+"context: "+this.scope;}};YAHOO.util.Subscriber=function(A,B,C){this.fn=A;this.obj=YAHOO.lang.isUndefined(B)?null:B;this.overrideContext=C;};YAHOO.util.Subscriber.prototype.getScope=function(A){if(this.overrideContext){if(this.overrideContext===true){return this.obj;}else{return this.overrideContext;}}return A;};YAHOO.util.Subscriber.prototype.contains=function(A,B){if(B){return(this.fn==A&&this.obj==B);}else{return(this.fn==A);}};YAHOO.util.Subscriber.prototype.toString=function(){return"Subscriber { obj: "+this.obj+", overrideContext: "+(this.overrideContext||"no")+" }";};if(!YAHOO.util.Event){YAHOO.util.Event=function(){var G=false,H=[],J=[],A=0,E=[],B=0,C={63232:38,63233:40,63234:37,63235:39,63276:33,63277:34,25:9},D=YAHOO.env.ua.ie,F="focusin",I="focusout";return{POLL_RETRYS:500,POLL_INTERVAL:40,EL:0,TYPE:1,FN:2,WFN:3,UNLOAD_OBJ:3,ADJ_SCOPE:4,OBJ:5,OVERRIDE:6,CAPTURE:7,lastError:null,isSafari:YAHOO.env.ua.webkit,webkit:YAHOO.env.ua.webkit,isIE:D,_interval:null,_dri:null,_specialTypes:{focusin:(D?"focusin":"focus"),focusout:(D?"focusout":"blur")},DOMReady:false,throwErrors:false,startInterval:function(){if(!this._interval){this._interval=YAHOO.lang.later(this.POLL_INTERVAL,this,this._tryPreloadAttach,null,true);}},onAvailable:function(Q,M,O,P,N){var K=(YAHOO.lang.isString(Q))?[Q]:Q;for(var L=0;L<K.length;L=L+1){E.push({id:K[L],fn:M,obj:O,overrideContext:P,checkReady:N});}A=this.POLL_RETRYS;this.startInterval();},onContentReady:function(N,K,L,M){this.onAvailable(N,K,L,M,true);},onDOMReady:function(){this.DOMReadyEvent.subscribe.apply(this.DOMReadyEvent,arguments);},_addListener:function(M,K,V,P,T,Y){if(!V||!V.call){return false;}if(this._isValidCollection(M)){var W=true;for(var Q=0,S=M.length;Q<S;++Q){W=this.on(M[Q],K,V,P,T)&&W;}return W;}else{if(YAHOO.lang.isString(M)){var O=this.getEl(M);if(O){M=O;}else{this.onAvailable(M,function(){YAHOO.util.Event._addListener(M,K,V,P,T,Y);});return true;}}}if(!M){return false;}if("unload"==K&&P!==this){J[J.length]=[M,K,V,P,T];return true;}var L=M;if(T){if(T===true){L=P;}else{L=T;}}var N=function(Z){return V.call(L,YAHOO.util.Event.getEvent(Z,M),P);};var X=[M,K,V,N,L,P,T,Y];var R=H.length;H[R]=X;try{this._simpleAdd(M,K,N,Y);}catch(U){this.lastError=U;this.removeListener(M,K,V);return false;}return true;},_getType:function(K){return this._specialTypes[K]||K;},addListener:function(M,P,L,N,O){var K=((P==F||P==I)&&!YAHOO.env.ua.ie)?true:false;return this._addListener(M,this._getType(P),L,N,O,K);},addFocusListener:function(L,K,M,N){return this.on(L,F,K,M,N);},removeFocusListener:function(L,K){return this.removeListener(L,F,K);},addBlurListener:function(L,K,M,N){return this.on(L,I,K,M,N);},removeBlurListener:function(L,K){return this.removeListener(L,I,K);},removeListener:function(L,K,R){var M,P,U;K=this._getType(K);if(typeof L=="string"){L=this.getEl(L);}else{if(this._isValidCollection(L)){var S=true;for(M=L.length-1;M>-1;M--){S=(this.removeListener(L[M],K,R)&&S);}return S;}}if(!R||!R.call){return this.purgeElement(L,false,K);}if("unload"==K){for(M=J.length-1;M>-1;M--){U=J[M];if(U&&U[0]==L&&U[1]==K&&U[2]==R){J.splice(M,1);return true;}}return false;}var N=null;var O=arguments[3];if("undefined"===typeof O){O=this._getCacheIndex(H,L,K,R);}if(O>=0){N=H[O];}if(!L||!N){return false;}var T=N[this.CAPTURE]===true?true:false;try{this._simpleRemove(L,K,N[this.WFN],T);}catch(Q){this.lastError=Q;return false;}delete H[O][this.WFN];delete H[O][this.FN];H.splice(O,1);return true;},getTarget:function(M,L){var K=M.target||M.srcElement;return this.resolveTextNode(K);},resolveTextNode:function(L){try{if(L&&3==L.nodeType){return L.parentNode;}}catch(K){}return L;},getPageX:function(L){var K=L.pageX;if(!K&&0!==K){K=L.clientX||0;if(this.isIE){K+=this._getScrollLeft();}}return K;},getPageY:function(K){var L=K.pageY;if(!L&&0!==L){L=K.clientY||0;if(this.isIE){L+=this._getScrollTop();}}return L;},getXY:function(K){return[this.getPageX(K),this.getPageY(K)];},getRelatedTarget:function(L){var K=L.relatedTarget;if(!K){if(L.type=="mouseout"){K=L.toElement;
}else{if(L.type=="mouseover"){K=L.fromElement;}}}return this.resolveTextNode(K);},getTime:function(M){if(!M.time){var L=new Date().getTime();try{M.time=L;}catch(K){this.lastError=K;return L;}}return M.time;},stopEvent:function(K){this.stopPropagation(K);this.preventDefault(K);},stopPropagation:function(K){if(K.stopPropagation){K.stopPropagation();}else{K.cancelBubble=true;}},preventDefault:function(K){if(K.preventDefault){K.preventDefault();}else{K.returnValue=false;}},getEvent:function(M,K){var L=M||window.event;if(!L){var N=this.getEvent.caller;while(N){L=N.arguments[0];if(L&&Event==L.constructor){break;}N=N.caller;}}return L;},getCharCode:function(L){var K=L.keyCode||L.charCode||0;if(YAHOO.env.ua.webkit&&(K in C)){K=C[K];}return K;},_getCacheIndex:function(M,P,Q,O){for(var N=0,L=M.length;N<L;N=N+1){var K=M[N];if(K&&K[this.FN]==O&&K[this.EL]==P&&K[this.TYPE]==Q){return N;}}return -1;},generateId:function(K){var L=K.id;if(!L){L="yuievtautoid-"+B;++B;K.id=L;}return L;},_isValidCollection:function(L){try{return(L&&typeof L!=="string"&&L.length&&!L.tagName&&!L.alert&&typeof L[0]!=="undefined");}catch(K){return false;}},elCache:{},getEl:function(K){return(typeof K==="string")?document.getElementById(K):K;},clearCache:function(){},DOMReadyEvent:new YAHOO.util.CustomEvent("DOMReady",YAHOO,0,0,1),_load:function(L){if(!G){G=true;var K=YAHOO.util.Event;K._ready();K._tryPreloadAttach();}},_ready:function(L){var K=YAHOO.util.Event;if(!K.DOMReady){K.DOMReady=true;K.DOMReadyEvent.fire();K._simpleRemove(document,"DOMContentLoaded",K._ready);}},_tryPreloadAttach:function(){if(E.length===0){A=0;if(this._interval){this._interval.cancel();this._interval=null;}return;}if(this.locked){return;}if(this.isIE){if(!this.DOMReady){this.startInterval();return;}}this.locked=true;var Q=!G;if(!Q){Q=(A>0&&E.length>0);}var P=[];var R=function(T,U){var S=T;if(U.overrideContext){if(U.overrideContext===true){S=U.obj;}else{S=U.overrideContext;}}U.fn.call(S,U.obj);};var L,K,O,N,M=[];for(L=0,K=E.length;L<K;L=L+1){O=E[L];if(O){N=this.getEl(O.id);if(N){if(O.checkReady){if(G||N.nextSibling||!Q){M.push(O);E[L]=null;}}else{R(N,O);E[L]=null;}}else{P.push(O);}}}for(L=0,K=M.length;L<K;L=L+1){O=M[L];R(this.getEl(O.id),O);}A--;if(Q){for(L=E.length-1;L>-1;L--){O=E[L];if(!O||!O.id){E.splice(L,1);}}this.startInterval();}else{if(this._interval){this._interval.cancel();this._interval=null;}}this.locked=false;},purgeElement:function(O,P,R){var M=(YAHOO.lang.isString(O))?this.getEl(O):O;var Q=this.getListeners(M,R),N,K;if(Q){for(N=Q.length-1;N>-1;N--){var L=Q[N];this.removeListener(M,L.type,L.fn);}}if(P&&M&&M.childNodes){for(N=0,K=M.childNodes.length;N<K;++N){this.purgeElement(M.childNodes[N],P,R);}}},getListeners:function(M,K){var P=[],L;if(!K){L=[H,J];}else{if(K==="unload"){L=[J];}else{K=this._getType(K);L=[H];}}var R=(YAHOO.lang.isString(M))?this.getEl(M):M;for(var O=0;O<L.length;O=O+1){var T=L[O];if(T){for(var Q=0,S=T.length;Q<S;++Q){var N=T[Q];if(N&&N[this.EL]===R&&(!K||K===N[this.TYPE])){P.push({type:N[this.TYPE],fn:N[this.FN],obj:N[this.OBJ],adjust:N[this.OVERRIDE],scope:N[this.ADJ_SCOPE],index:Q});}}}}return(P.length)?P:null;},_unload:function(R){var L=YAHOO.util.Event,O,N,M,Q,P,S=J.slice(),K;for(O=0,Q=J.length;O<Q;++O){M=S[O];if(M){K=window;if(M[L.ADJ_SCOPE]){if(M[L.ADJ_SCOPE]===true){K=M[L.UNLOAD_OBJ];}else{K=M[L.ADJ_SCOPE];}}M[L.FN].call(K,L.getEvent(R,M[L.EL]),M[L.UNLOAD_OBJ]);S[O]=null;}}M=null;K=null;J=null;if(H){for(N=H.length-1;N>-1;N--){M=H[N];if(M){L.removeListener(M[L.EL],M[L.TYPE],M[L.FN],N);}}M=null;}L._simpleRemove(window,"unload",L._unload);},_getScrollLeft:function(){return this._getScroll()[1];},_getScrollTop:function(){return this._getScroll()[0];},_getScroll:function(){var K=document.documentElement,L=document.body;if(K&&(K.scrollTop||K.scrollLeft)){return[K.scrollTop,K.scrollLeft];}else{if(L){return[L.scrollTop,L.scrollLeft];}else{return[0,0];}}},regCE:function(){},_simpleAdd:function(){if(window.addEventListener){return function(M,N,L,K){M.addEventListener(N,L,(K));};}else{if(window.attachEvent){return function(M,N,L,K){M.attachEvent("on"+N,L);};}else{return function(){};}}}(),_simpleRemove:function(){if(window.removeEventListener){return function(M,N,L,K){M.removeEventListener(N,L,(K));};}else{if(window.detachEvent){return function(L,M,K){L.detachEvent("on"+M,K);};}else{return function(){};}}}()};}();(function(){var EU=YAHOO.util.Event;EU.on=EU.addListener;EU.onFocus=EU.addFocusListener;EU.onBlur=EU.addBlurListener;
/* DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller/Diego Perini */
if(EU.isIE){if(self!==self.top){document.onreadystatechange=function(){if(document.readyState=="complete"){document.onreadystatechange=null;EU._ready();}};}else{YAHOO.util.Event.onDOMReady(YAHOO.util.Event._tryPreloadAttach,YAHOO.util.Event,true);var n=document.createElement("p");EU._dri=setInterval(function(){try{n.doScroll("left");clearInterval(EU._dri);EU._dri=null;EU._ready();n=null;}catch(ex){}},EU.POLL_INTERVAL);}}else{if(EU.webkit&&EU.webkit<525){EU._dri=setInterval(function(){var rs=document.readyState;if("loaded"==rs||"complete"==rs){clearInterval(EU._dri);EU._dri=null;EU._ready();}},EU.POLL_INTERVAL);}else{EU._simpleAdd(document,"DOMContentLoaded",EU._ready);}}EU._simpleAdd(window,"load",EU._load);EU._simpleAdd(window,"unload",EU._unload);EU._tryPreloadAttach();})();}YAHOO.util.EventProvider=function(){};YAHOO.util.EventProvider.prototype={__yui_events:null,__yui_subscribers:null,subscribe:function(A,C,F,E){this.__yui_events=this.__yui_events||{};var D=this.__yui_events[A];if(D){D.subscribe(C,F,E);}else{this.__yui_subscribers=this.__yui_subscribers||{};var B=this.__yui_subscribers;if(!B[A]){B[A]=[];}B[A].push({fn:C,obj:F,overrideContext:E});}},unsubscribe:function(C,E,G){this.__yui_events=this.__yui_events||{};var A=this.__yui_events;if(C){var F=A[C];if(F){return F.unsubscribe(E,G);}}else{var B=true;for(var D in A){if(YAHOO.lang.hasOwnProperty(A,D)){B=B&&A[D].unsubscribe(E,G);}}return B;}return false;},unsubscribeAll:function(A){return this.unsubscribe(A);
},createEvent:function(B,G){this.__yui_events=this.__yui_events||{};var E=G||{},D=this.__yui_events,F;if(D[B]){}else{F=new YAHOO.util.CustomEvent(B,E.scope||this,E.silent,YAHOO.util.CustomEvent.FLAT,E.fireOnce);D[B]=F;if(E.onSubscribeCallback){F.subscribeEvent.subscribe(E.onSubscribeCallback);}this.__yui_subscribers=this.__yui_subscribers||{};var A=this.__yui_subscribers[B];if(A){for(var C=0;C<A.length;++C){F.subscribe(A[C].fn,A[C].obj,A[C].overrideContext);}}}return D[B];},fireEvent:function(B){this.__yui_events=this.__yui_events||{};var D=this.__yui_events[B];if(!D){return null;}var A=[];for(var C=1;C<arguments.length;++C){A.push(arguments[C]);}return D.fire.apply(D,A);},hasEvent:function(A){if(this.__yui_events){if(this.__yui_events[A]){return true;}}return false;}};(function(){var A=YAHOO.util.Event,C=YAHOO.lang;YAHOO.util.KeyListener=function(D,I,E,F){if(!D){}else{if(!I){}else{if(!E){}}}if(!F){F=YAHOO.util.KeyListener.KEYDOWN;}var G=new YAHOO.util.CustomEvent("keyPressed");this.enabledEvent=new YAHOO.util.CustomEvent("enabled");this.disabledEvent=new YAHOO.util.CustomEvent("disabled");if(C.isString(D)){D=document.getElementById(D);}if(C.isFunction(E)){G.subscribe(E);}else{G.subscribe(E.fn,E.scope,E.correctScope);}function H(O,N){if(!I.shift){I.shift=false;}if(!I.alt){I.alt=false;}if(!I.ctrl){I.ctrl=false;}if(O.shiftKey==I.shift&&O.altKey==I.alt&&O.ctrlKey==I.ctrl){var J,M=I.keys,L;if(YAHOO.lang.isArray(M)){for(var K=0;K<M.length;K++){J=M[K];L=A.getCharCode(O);if(J==L){G.fire(L,O);break;}}}else{L=A.getCharCode(O);if(M==L){G.fire(L,O);}}}}this.enable=function(){if(!this.enabled){A.on(D,F,H);this.enabledEvent.fire(I);}this.enabled=true;};this.disable=function(){if(this.enabled){A.removeListener(D,F,H);this.disabledEvent.fire(I);}this.enabled=false;};this.toString=function(){return"KeyListener ["+I.keys+"] "+D.tagName+(D.id?"["+D.id+"]":"");};};var B=YAHOO.util.KeyListener;B.KEYDOWN="keydown";B.KEYUP="keyup";B.KEY={ALT:18,BACK_SPACE:8,CAPS_LOCK:20,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,META:224,NUM_LOCK:144,PAGE_DOWN:34,PAGE_UP:33,PAUSE:19,PRINTSCREEN:44,RIGHT:39,SCROLL_LOCK:145,SHIFT:16,SPACE:32,TAB:9,UP:38};})();YAHOO.register("event",YAHOO.util.Event,{version:"2.8.2r1",build:"7"});YAHOO.register("yuiloader-dom-event", YAHOO, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
(function() {

var Y = YAHOO.util;

/*
Copyright (c) 2006, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/

/**
 * The animation module provides allows effects to be added to HTMLElements.
 * @module animation
 * @requires yahoo, event, dom
 */

/**
 *
 * Base animation class that provides the interface for building animated effects.
 * <p>Usage: var myAnim = new YAHOO.util.Anim(el, { width: { from: 10, to: 100 } }, 1, YAHOO.util.Easing.easeOut);</p>
 * @class Anim
 * @namespace YAHOO.util
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @constructor
 * @param {String | HTMLElement} el Reference to the element that will be animated
 * @param {Object} attributes The attribute(s) to be animated.
 * Each attribute is an object with at minimum a "to" or "by" member defined.
 * Additional optional members are "from" (defaults to current value), "units" (defaults to "px").
 * All attribute names use camelCase.
 * @param {Number} duration (optional, defaults to 1 second) Length of animation (frames or seconds), defaults to time-based
 * @param {Function} method (optional, defaults to YAHOO.util.Easing.easeNone) Computes the values that are applied to the attributes per frame (generally a YAHOO.util.Easing method)
 */

var Anim = function(el, attributes, duration, method) {
    if (!el) {
    }
    this.init(el, attributes, duration, method);
};

Anim.NAME = 'Anim';

Anim.prototype = {
    /**
     * Provides a readable name for the Anim instance.
     * @method toString
     * @return {String}
     */
    toString: function() {
        var el = this.getEl() || {};
        var id = el.id || el.tagName;
        return (this.constructor.NAME + ': ' + id);
    },

    patterns: { // cached for performance
        noNegatives:        /width|height|opacity|padding/i, // keep at zero or above
        offsetAttribute:  /^((width|height)|(top|left))$/, // use offsetValue as default
        defaultUnit:        /width|height|top$|bottom$|left$|right$/i, // use 'px' by default
        offsetUnit:         /\d+(em|%|en|ex|pt|in|cm|mm|pc)$/i // IE may return these, so convert these to offset
    },

    /**
     * Returns the value computed by the animation's "method".
     * @method doMethod
     * @param {String} attr The name of the attribute.
     * @param {Number} start The value this attribute should start from for this animation.
     * @param {Number} end  The value this attribute should end at for this animation.
     * @return {Number} The Value to be applied to the attribute.
     */
    doMethod: function(attr, start, end) {
        return this.method(this.currentFrame, start, end - start, this.totalFrames);
    },

    /**
     * Applies a value to an attribute.
     * @method setAttribute
     * @param {String} attr The name of the attribute.
     * @param {Number} val The value to be applied to the attribute.
     * @param {String} unit The unit ('px', '%', etc.) of the value.
     */
    setAttribute: function(attr, val, unit) {
        var el = this.getEl();
        if ( this.patterns.noNegatives.test(attr) ) {
            val = (val > 0) ? val : 0;
        }

        if (attr in el && !('style' in el && attr in el.style)) {
            el[attr] = val;
        } else {
            Y.Dom.setStyle(el, attr, val + unit);
        }
    },

    /**
     * Returns current value of the attribute.
     * @method getAttribute
     * @param {String} attr The name of the attribute.
     * @return {Number} val The current value of the attribute.
     */
    getAttribute: function(attr) {
        var el = this.getEl();
        var val = Y.Dom.getStyle(el, attr);

        if (val !== 'auto' && !this.patterns.offsetUnit.test(val)) {
            return parseFloat(val);
        }

        var a = this.patterns.offsetAttribute.exec(attr) || [];
        var pos = !!( a[3] ); // top or left
        var box = !!( a[2] ); // width or height

        if ('style' in el) {
            if ( box || (Y.Dom.getStyle(el, 'position') == 'absolute' && pos) ) {
                val = el['offset' + a[0].charAt(0).toUpperCase() + a[0].substr(1)];
            } else { // default to zero for other 'auto'
                val = 0;
            }
        } else if (attr in el) {
            val = el[attr];
        }

        return val;
    },

    /**
     * Returns the unit to use when none is supplied.
     * @method getDefaultUnit
     * @param {attr} attr The name of the attribute.
     * @return {String} The default unit to be used.
     */
    getDefaultUnit: function(attr) {
         if ( this.patterns.defaultUnit.test(attr) ) {
            return 'px';
         }

         return '';
    },

    /**
     * Sets the actual values to be used during the animation.  Should only be needed for subclass use.
     * @method setRuntimeAttribute
     * @param {Object} attr The attribute object
     * @private
     */
    setRuntimeAttribute: function(attr) {
        var start;
        var end;
        var attributes = this.attributes;

        this.runtimeAttributes[attr] = {};

        var isset = function(prop) {
            return (typeof prop !== 'undefined');
        };

        if ( !isset(attributes[attr]['to']) && !isset(attributes[attr]['by']) ) {
            return false; // note return; nothing to animate to
        }

        start = ( isset(attributes[attr]['from']) ) ? attributes[attr]['from'] : this.getAttribute(attr);

        if ( isset(attributes[attr]['to']) ) {
            end = attributes[attr]['to'];
        } else if ( isset(attributes[attr]['by']) ) {
            if (start.constructor == Array) {
                end = [];
                for (var i = 0, len = start.length; i < len; ++i) {
                    end[i] = start[i] + attributes[attr]['by'][i] * 1; // times 1 to cast "by"
                }
            } else {
                end = start + attributes[attr]['by'] * 1;
            }
        }

        this.runtimeAttributes[attr].start = start;
        this.runtimeAttributes[attr].end = end;

        this.runtimeAttributes[attr].unit = ( isset(attributes[attr].unit) ) ?
                attributes[attr]['unit'] : this.getDefaultUnit(attr);
        return true;
    },

    /**
     * Constructor for Anim instance.
     * @method init
     * @param {String | HTMLElement} el Reference to the element that will be animated
     * @param {Object} attributes The attribute(s) to be animated.
     * Each attribute is an object with at minimum a "to" or "by" member defined.
     * Additional optional members are "from" (defaults to current value), "units" (defaults to "px").
     * All attribute names use camelCase.
     * @param {Number} duration (optional, defaults to 1 second) Length of animation (frames or seconds), defaults to time-based
     * @param {Function} method (optional, defaults to YAHOO.util.Easing.easeNone) Computes the values that are applied to the attributes per frame (generally a YAHOO.util.Easing method)
     */
    init: function(el, attributes, duration, method) {
        /**
         * Whether or not the animation is running.
         * @property isAnimated
         * @private
         * @type Boolean
         */
        var isAnimated = false;

        /**
         * A Date object that is created when the animation begins.
         * @property startTime
         * @private
         * @type Date
         */
        var startTime = null;

        /**
         * The number of frames this animation was able to execute.
         * @property actualFrames
         * @private
         * @type Int
         */
        var actualFrames = 0;

        /**
         * The element to be animated.
         * @property el
         * @private
         * @type HTMLElement
         */
        el = Y.Dom.get(el);

        /**
         * The collection of attributes to be animated.
         * Each attribute must have at least a "to" or "by" defined in order to animate.
         * If "to" is supplied, the animation will end with the attribute at that value.
         * If "by" is supplied, the animation will end at that value plus its starting value.
         * If both are supplied, "to" is used, and "by" is ignored.
         * Optional additional member include "from" (the value the attribute should start animating from, defaults to current value), and "unit" (the units to apply to the values).
         * @property attributes
         * @type Object
         */
        this.attributes = attributes || {};

        /**
         * The length of the animation.  Defaults to "1" (second).
         * @property duration
         * @type Number
         */
        this.duration = !YAHOO.lang.isUndefined(duration) ? duration : 1;

        /**
         * The method that will provide values to the attribute(s) during the animation.
         * Defaults to "YAHOO.util.Easing.easeNone".
         * @property method
         * @type Function
         */
        this.method = method || Y.Easing.easeNone;

        /**
         * Whether or not the duration should be treated as seconds.
         * Defaults to true.
         * @property useSeconds
         * @type Boolean
         */
        this.useSeconds = true; // default to seconds

        /**
         * The location of the current animation on the timeline.
         * In time-based animations, this is used by AnimMgr to ensure the animation finishes on time.
         * @property currentFrame
         * @type Int
         */
        this.currentFrame = 0;

        /**
         * The total number of frames to be executed.
         * In time-based animations, this is used by AnimMgr to ensure the animation finishes on time.
         * @property totalFrames
         * @type Int
         */
        this.totalFrames = Y.AnimMgr.fps;

        /**
         * Changes the animated element
         * @method setEl
         */
        this.setEl = function(element) {
            el = Y.Dom.get(element);
        };

        /**
         * Returns a reference to the animated element.
         * @method getEl
         * @return {HTMLElement}
         */
        this.getEl = function() { return el; };

        /**
         * Checks whether the element is currently animated.
         * @method isAnimated
         * @return {Boolean} current value of isAnimated.
         */
        this.isAnimated = function() {
            return isAnimated;
        };

        /**
         * Returns the animation start time.
         * @method getStartTime
         * @return {Date} current value of startTime.
         */
        this.getStartTime = function() {
            return startTime;
        };

        this.runtimeAttributes = {};



        /**
         * Starts the animation by registering it with the animation manager.
         * @method animate
         */
        this.animate = function() {
            if ( this.isAnimated() ) {
                return false;
            }

            this.currentFrame = 0;

            this.totalFrames = ( this.useSeconds ) ? Math.ceil(Y.AnimMgr.fps * this.duration) : this.duration;

            if (this.duration === 0 && this.useSeconds) { // jump to last frame if zero second duration
                this.totalFrames = 1;
            }
            Y.AnimMgr.registerElement(this);
            return true;
        };

        /**
         * Stops the animation.  Normally called by AnimMgr when animation completes.
         * @method stop
         * @param {Boolean} finish (optional) If true, animation will jump to final frame.
         */
        this.stop = function(finish) {
            if (!this.isAnimated()) { // nothing to stop
                return false;
            }

            if (finish) {
                 this.currentFrame = this.totalFrames;
                 this._onTween.fire();
            }
            Y.AnimMgr.stop(this);
        };

        var onStart = function() {
            this.onStart.fire();

            this.runtimeAttributes = {};
            for (var attr in this.attributes) {
                this.setRuntimeAttribute(attr);
            }

            isAnimated = true;
            actualFrames = 0;
            startTime = new Date();
        };

        /**
         * Feeds the starting and ending values for each animated attribute to doMethod once per frame, then applies the resulting value to the attribute(s).
         * @private
         */

        var onTween = function() {
            var data = {
                duration: new Date() - this.getStartTime(),
                currentFrame: this.currentFrame
            };

            data.toString = function() {
                return (
                    'duration: ' + data.duration +
                    ', currentFrame: ' + data.currentFrame
                );
            };

            this.onTween.fire(data);

            var runtimeAttributes = this.runtimeAttributes;

            for (var attr in runtimeAttributes) {
                this.setAttribute(attr, this.doMethod(attr, runtimeAttributes[attr].start, runtimeAttributes[attr].end), runtimeAttributes[attr].unit);
            }

            actualFrames += 1;
        };

        var onComplete = function() {
            var actual_duration = (new Date() - startTime) / 1000 ;

            var data = {
                duration: actual_duration,
                frames: actualFrames,
                fps: actualFrames / actual_duration
            };

            data.toString = function() {
                return (
                    'duration: ' + data.duration +
                    ', frames: ' + data.frames +
                    ', fps: ' + data.fps
                );
            };

            isAnimated = false;
            actualFrames = 0;
            this.onComplete.fire(data);
        };

        /**
         * Custom event that fires after onStart, useful in subclassing
         * @private
         */
        this._onStart = new Y.CustomEvent('_start', this, true);

        /**
         * Custom event that fires when animation begins
         * Listen via subscribe method (e.g. myAnim.onStart.subscribe(someFunction)
         * @event onStart
         */
        this.onStart = new Y.CustomEvent('start', this);

        /**
         * Custom event that fires between each frame
         * Listen via subscribe method (e.g. myAnim.onTween.subscribe(someFunction)
         * @event onTween
         */
        this.onTween = new Y.CustomEvent('tween', this);

        /**
         * Custom event that fires after onTween
         * @private
         */
        this._onTween = new Y.CustomEvent('_tween', this, true);

        /**
         * Custom event that fires when animation ends
         * Listen via subscribe method (e.g. myAnim.onComplete.subscribe(someFunction)
         * @event onComplete
         */
        this.onComplete = new Y.CustomEvent('complete', this);
        /**
         * Custom event that fires after onComplete
         * @private
         */
        this._onComplete = new Y.CustomEvent('_complete', this, true);

        this._onStart.subscribe(onStart);
        this._onTween.subscribe(onTween);
        this._onComplete.subscribe(onComplete);
    }
};

    Y.Anim = Anim;
})();
/**
 * Handles animation queueing and threading.
 * Used by Anim and subclasses.
 * @class AnimMgr
 * @namespace YAHOO.util
 */
YAHOO.util.AnimMgr = new function() {
    /**
     * Reference to the animation Interval.
     * @property thread
     * @private
     * @type Int
     */
    var thread = null;

    /**
     * The current queue of registered animation objects.
     * @property queue
     * @private
     * @type Array
     */
    var queue = [];

    /**
     * The number of active animations.
     * @property tweenCount
     * @private
     * @type Int
     */
    var tweenCount = 0;

    /**
     * Base frame rate (frames per second).
     * Arbitrarily high for better x-browser calibration (slower browsers drop more frames).
     * @property fps
     * @type Int
     *
     */
    this.fps = 1000;

    /**
     * Interval delay in milliseconds, defaults to fastest possible.
     * @property delay
     * @type Int
     *
     */
    this.delay = 1;

    /**
     * Adds an animation instance to the animation queue.
     * All animation instances must be registered in order to animate.
     * @method registerElement
     * @param {object} tween The Anim instance to be be registered
     */
    this.registerElement = function(tween) {
        queue[queue.length] = tween;
        tweenCount += 1;
        tween._onStart.fire();
        this.start();
    };

    /**
     * removes an animation instance from the animation queue.
     * All animation instances must be registered in order to animate.
     * @method unRegister
     * @param {object} tween The Anim instance to be be registered
     * @param {Int} index The index of the Anim instance
     * @private
     */
    this.unRegister = function(tween, index) {
        index = index || getIndex(tween);
        if (!tween.isAnimated() || index === -1) {
            return false;
        }

        tween._onComplete.fire();
        queue.splice(index, 1);

        tweenCount -= 1;
        if (tweenCount <= 0) {
            this.stop();
        }

        return true;
    };

    /**
     * Starts the animation thread.
	* Only one thread can run at a time.
     * @method start
     */
    this.start = function() {
        if (thread === null) {
            thread = setInterval(this.run, this.delay);
        }
    };

    /**
     * Stops the animation thread or a specific animation instance.
     * @method stop
     * @param {object} tween A specific Anim instance to stop (optional)
     * If no instance given, Manager stops thread and all animations.
     */
    this.stop = function(tween) {
        if (!tween) {
            clearInterval(thread);

            for (var i = 0, len = queue.length; i < len; ++i) {
                this.unRegister(queue[0], 0);
            }

            queue = [];
            thread = null;
            tweenCount = 0;
        }
        else {
            this.unRegister(tween);
        }
    };

    /**
     * Called per Interval to handle each animation frame.
     * @method run
     */
    this.run = function() {
        for (var i = 0, len = queue.length; i < len; ++i) {
            var tween = queue[i];
            if ( !tween || !tween.isAnimated() ) { continue; }

            if (tween.currentFrame < tween.totalFrames || tween.totalFrames === null)
            {
                tween.currentFrame += 1;

                if (tween.useSeconds) {
                    correctFrame(tween);
                }
                tween._onTween.fire();
            }
            else { YAHOO.util.AnimMgr.stop(tween, i); }
        }
    };

    var getIndex = function(anim) {
        for (var i = 0, len = queue.length; i < len; ++i) {
            if (queue[i] === anim) {
                return i; // note return;
            }
        }
        return -1;
    };

    /**
     * On the fly frame correction to keep animation on time.
     * @method correctFrame
     * @private
     * @param {Object} tween The Anim instance being corrected.
     */
    var correctFrame = function(tween) {
        var frames = tween.totalFrames;
        var frame = tween.currentFrame;
        var expected = (tween.currentFrame * tween.duration * 1000 / tween.totalFrames);
        var elapsed = (new Date() - tween.getStartTime());
        var tweak = 0;

        if (elapsed < tween.duration * 1000) { // check if falling behind
            tweak = Math.round((elapsed / expected - 1) * tween.currentFrame);
        } else { // went over duration, so jump to end
            tweak = frames - (frame + 1);
        }
        if (tweak > 0 && isFinite(tweak)) { // adjust if needed
            if (tween.currentFrame + tweak >= frames) {// dont go past last frame
                tweak = frames - (frame + 1);
            }

            tween.currentFrame += tweak;
        }
    };
    this._queue = queue;
    this._getIndex = getIndex;
};
/**
 * Used to calculate Bezier splines for any number of control points.
 * @class Bezier
 * @namespace YAHOO.util
 *
 */
YAHOO.util.Bezier = new function() {
    /**
     * Get the current position of the animated element based on t.
     * Each point is an array of "x" and "y" values (0 = x, 1 = y)
     * At least 2 points are required (start and end).
     * First point is start. Last point is end.
     * Additional control points are optional.
     * @method getPosition
     * @param {Array} points An array containing Bezier points
     * @param {Number} t A number between 0 and 1 which is the basis for determining current position
     * @return {Array} An array containing int x and y member data
     */
    this.getPosition = function(points, t) {
        var n = points.length;
        var tmp = [];

        for (var i = 0; i < n; ++i){
            tmp[i] = [points[i][0], points[i][1]]; // save input
        }

        for (var j = 1; j < n; ++j) {
            for (i = 0; i < n - j; ++i) {
                tmp[i][0] = (1 - t) * tmp[i][0] + t * tmp[parseInt(i + 1, 10)][0];
                tmp[i][1] = (1 - t) * tmp[i][1] + t * tmp[parseInt(i + 1, 10)][1];
            }
        }

        return [ tmp[0][0], tmp[0][1] ];

    };
};
(function() {
/**
 * Anim subclass for color transitions.
 * <p>Usage: <code>var myAnim = new Y.ColorAnim(el, { backgroundColor: { from: '#FF0000', to: '#FFFFFF' } }, 1, Y.Easing.easeOut);</code> Color values can be specified with either 112233, #112233,
 * [255,255,255], or rgb(255,255,255)</p>
 * @class ColorAnim
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @constructor
 * @extends YAHOO.util.Anim
 * @param {HTMLElement | String} el Reference to the element that will be animated
 * @param {Object} attributes The attribute(s) to be animated.
 * Each attribute is an object with at minimum a "to" or "by" member defined.
 * Additional optional members are "from" (defaults to current value), "units" (defaults to "px").
 * All attribute names use camelCase.
 * @param {Number} duration (optional, defaults to 1 second) Length of animation (frames or seconds), defaults to time-based
 * @param {Function} method (optional, defaults to YAHOO.util.Easing.easeNone) Computes the values that are applied to the attributes per frame (generally a YAHOO.util.Easing method)
 */
    var ColorAnim = function(el, attributes, duration,  method) {
        ColorAnim.superclass.constructor.call(this, el, attributes, duration, method);
    };

    ColorAnim.NAME = 'ColorAnim';

    ColorAnim.DEFAULT_BGCOLOR = '#fff';
    var Y = YAHOO.util;
    YAHOO.extend(ColorAnim, Y.Anim);

    var superclass = ColorAnim.superclass;
    var proto = ColorAnim.prototype;

    proto.patterns.color = /color$/i;
    proto.patterns.rgb            = /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i;
    proto.patterns.hex            = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i;
    proto.patterns.hex3          = /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;
    proto.patterns.transparent = /^transparent|rgba\(0, 0, 0, 0\)$/; // need rgba for safari

    /**
     * Attempts to parse the given string and return a 3-tuple.
     * @method parseColor
     * @param {String} s The string to parse.
     * @return {Array} The 3-tuple of rgb values.
     */
    proto.parseColor = function(s) {
        if (s.length == 3) { return s; }

        var c = this.patterns.hex.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16) ];
        }

        c = this.patterns.rgb.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10) ];
        }

        c = this.patterns.hex3.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16) ];
        }

        return null;
    };

    proto.getAttribute = function(attr) {
        var el = this.getEl();
        if (this.patterns.color.test(attr) ) {
            var val = YAHOO.util.Dom.getStyle(el, attr);

            var that = this;
            if (this.patterns.transparent.test(val)) { // bgcolor default
                var parent = YAHOO.util.Dom.getAncestorBy(el, function(node) {
                    return !that.patterns.transparent.test(val);
                });

                if (parent) {
                    val = Y.Dom.getStyle(parent, attr);
                } else {
                    val = ColorAnim.DEFAULT_BGCOLOR;
                }
            }
        } else {
            val = superclass.getAttribute.call(this, attr);
        }

        return val;
    };

    proto.doMethod = function(attr, start, end) {
        var val;

        if ( this.patterns.color.test(attr) ) {
            val = [];
            for (var i = 0, len = start.length; i < len; ++i) {
                val[i] = superclass.doMethod.call(this, attr, start[i], end[i]);
            }

            val = 'rgb('+Math.floor(val[0])+','+Math.floor(val[1])+','+Math.floor(val[2])+')';
        }
        else {
            val = superclass.doMethod.call(this, attr, start, end);
        }

        return val;
    };

    proto.setRuntimeAttribute = function(attr) {
        superclass.setRuntimeAttribute.call(this, attr);

        if ( this.patterns.color.test(attr) ) {
            var attributes = this.attributes;
            var start = this.parseColor(this.runtimeAttributes[attr].start);
            var end = this.parseColor(this.runtimeAttributes[attr].end);
            if ( typeof attributes[attr]['to'] === 'undefined' && typeof attributes[attr]['by'] !== 'undefined' ) {
                end = this.parseColor(attributes[attr].by);

                for (var i = 0, len = start.length; i < len; ++i) {
                    end[i] = start[i] + end[i];
                }
            }

            this.runtimeAttributes[attr].start = start;
            this.runtimeAttributes[attr].end = end;
        }
    };

    Y.ColorAnim = ColorAnim;
})();
/*!
TERMS OF USE - EASING EQUATIONS
Open source under the BSD License.
Copyright 2001 Robert Penner All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * Singleton that determines how an animation proceeds from start to end.
 * @class Easing
 * @namespace YAHOO.util
*/

YAHOO.util.Easing = {

    /**
     * Uniform speed between points.
     * @method easeNone
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeNone: function (t, b, c, d) {
    	return c*t/d + b;
    },

    /**
     * Begins slowly and accelerates towards end.
     * @method easeIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeIn: function (t, b, c, d) {
    	return c*(t/=d)*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.
     * @method easeOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOut: function (t, b, c, d) {
    	return -c *(t/=d)*(t-2) + b;
    },

    /**
     * Begins slowly and decelerates towards end.
     * @method easeBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBoth: function (t, b, c, d) {
    	if ((t/=d/2) < 1) {
            return c/2*t*t + b;
        }

    	return -c/2 * ((--t)*(t-2) - 1) + b;
    },

    /**
     * Begins slowly and accelerates towards end.
     * @method easeInStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeInStrong: function (t, b, c, d) {
    	return c*(t/=d)*t*t*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.
     * @method easeOutStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOutStrong: function (t, b, c, d) {
    	return -c * ((t=t/d-1)*t*t*t - 1) + b;
    },

    /**
     * Begins slowly and decelerates towards end.
     * @method easeBothStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBothStrong: function (t, b, c, d) {
    	if ((t/=d/2) < 1) {
            return c/2*t*t*t*t + b;
        }

    	return -c/2 * ((t-=2)*t*t*t - 2) + b;
    },

    /**
     * Snap in elastic effect.
     * @method elasticIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */

    elasticIn: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }
        if ( (t /= d) == 1 ) {
            return b+c;
        }
        if (!p) {
            p=d*.3;
        }

    	if (!a || a < Math.abs(c)) {
            a = c;
            var s = p/4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }

    	return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    },

    /**
     * Snap out elastic effect.
     * @method elasticOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticOut: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }
        if ( (t /= d) == 1 ) {
            return b+c;
        }
        if (!p) {
            p=d*.3;
        }

    	if (!a || a < Math.abs(c)) {
            a = c;
            var s = p / 4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }

    	return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
    },

    /**
     * Snap both elastic effect.
     * @method elasticBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticBoth: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }

        if ( (t /= d/2) == 2 ) {
            return b+c;
        }

        if (!p) {
            p = d*(.3*1.5);
        }

    	if ( !a || a < Math.abs(c) ) {
            a = c;
            var s = p/4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }

    	if (t < 1) {
            return -.5*(a*Math.pow(2,10*(t-=1)) *
                    Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
        }
    	return a*Math.pow(2,-10*(t-=1)) *
                Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
    },


    /**
     * Backtracks slightly, then reverses direction and moves to end.
     * @method backIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backIn: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158;
        }
    	return c*(t/=d)*t*((s+1)*t - s) + b;
    },

    /**
     * Overshoots end, then reverses and comes back to end.
     * @method backOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backOut: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158;
        }
    	return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
    },

    /**
     * Backtracks slightly, then reverses direction, overshoots end,
     * then reverses and comes back to end.
     * @method backBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backBoth: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158;
        }

    	if ((t /= d/2 ) < 1) {
            return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
        }
    	return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
    },

    /**
     * Bounce off of start.
     * @method bounceIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceIn: function (t, b, c, d) {
    	return c - YAHOO.util.Easing.bounceOut(d-t, 0, c, d) + b;
    },

    /**
     * Bounces off end.
     * @method bounceOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceOut: function (t, b, c, d) {
    	if ((t/=d) < (1/2.75)) {
    		return c*(7.5625*t*t) + b;
    	} else if (t < (2/2.75)) {
    		return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
    	} else if (t < (2.5/2.75)) {
    		return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
    	}
        return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
    },

    /**
     * Bounces off start and end.
     * @method bounceBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceBoth: function (t, b, c, d) {
    	if (t < d/2) {
            return YAHOO.util.Easing.bounceIn(t*2, 0, c, d) * .5 + b;
        }
    	return YAHOO.util.Easing.bounceOut(t*2-d, 0, c, d) * .5 + c*.5 + b;
    }
};

(function() {
/**
 * Anim subclass for moving elements along a path defined by the "points"
 * member of "attributes".  All "points" are arrays with x, y coordinates.
 * <p>Usage: <code>var myAnim = new YAHOO.util.Motion(el, { points: { to: [800, 800] } }, 1, YAHOO.util.Easing.easeOut);</code></p>
 * @class Motion
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @constructor
 * @extends YAHOO.util.ColorAnim
 * @param {String | HTMLElement} el Reference to the element that will be animated
 * @param {Object} attributes The attribute(s) to be animated.
 * Each attribute is an object with at minimum a "to" or "by" member defined.
 * Additional optional members are "from" (defaults to current value), "units" (defaults to "px").
 * All attribute names use camelCase.
 * @param {Number} duration (optional, defaults to 1 second) Length of animation (frames or seconds), defaults to time-based
 * @param {Function} method (optional, defaults to YAHOO.util.Easing.easeNone) Computes the values that are applied to the attributes per frame (generally a YAHOO.util.Easing method)
 */
    var Motion = function(el, attributes, duration,  method) {
        if (el) { // dont break existing subclasses not using YAHOO.extend
            Motion.superclass.constructor.call(this, el, attributes, duration, method);
        }
    };


    Motion.NAME = 'Motion';

    var Y = YAHOO.util;
    YAHOO.extend(Motion, Y.ColorAnim);

    var superclass = Motion.superclass;
    var proto = Motion.prototype;

    proto.patterns.points = /^points$/i;

    proto.setAttribute = function(attr, val, unit) {
        if (  this.patterns.points.test(attr) ) {
            unit = unit || 'px';
            superclass.setAttribute.call(this, 'left', val[0], unit);
            superclass.setAttribute.call(this, 'top', val[1], unit);
        } else {
            superclass.setAttribute.call(this, attr, val, unit);
        }
    };

    proto.getAttribute = function(attr) {
        if (  this.patterns.points.test(attr) ) {
            var val = [
                superclass.getAttribute.call(this, 'left'),
                superclass.getAttribute.call(this, 'top')
            ];
        } else {
            val = superclass.getAttribute.call(this, attr);
        }

        return val;
    };

    proto.doMethod = function(attr, start, end) {
        var val = null;

        if ( this.patterns.points.test(attr) ) {
            var t = this.method(this.currentFrame, 0, 100, this.totalFrames) / 100;
            val = Y.Bezier.getPosition(this.runtimeAttributes[attr], t);
        } else {
            val = superclass.doMethod.call(this, attr, start, end);
        }
        return val;
    };

    proto.setRuntimeAttribute = function(attr) {
        if ( this.patterns.points.test(attr) ) {
            var el = this.getEl();
            var attributes = this.attributes;
            var start;
            var control = attributes['points']['control'] || [];
            var end;
            var i, len;

            if (control.length > 0 && !(control[0] instanceof Array) ) { // could be single point or array of points
                control = [control];
            } else { // break reference to attributes.points.control
                var tmp = [];
                for (i = 0, len = control.length; i< len; ++i) {
                    tmp[i] = control[i];
                }
                control = tmp;
            }

            if (Y.Dom.getStyle(el, 'position') == 'static') { // default to relative
                Y.Dom.setStyle(el, 'position', 'relative');
            }

            if ( isset(attributes['points']['from']) ) {
                Y.Dom.setXY(el, attributes['points']['from']); // set position to from point
            }
            else { Y.Dom.setXY( el, Y.Dom.getXY(el) ); } // set it to current position

            start = this.getAttribute('points'); // get actual top & left

            if ( isset(attributes['points']['to']) ) {
                end = translateValues.call(this, attributes['points']['to'], start);

                var pageXY = Y.Dom.getXY(this.getEl());
                for (i = 0, len = control.length; i < len; ++i) {
                    control[i] = translateValues.call(this, control[i], start);
                }


            } else if ( isset(attributes['points']['by']) ) {
                end = [ start[0] + attributes['points']['by'][0], start[1] + attributes['points']['by'][1] ];

                for (i = 0, len = control.length; i < len; ++i) {
                    control[i] = [ start[0] + control[i][0], start[1] + control[i][1] ];
                }
            }

            this.runtimeAttributes[attr] = [start];

            if (control.length > 0) {
                this.runtimeAttributes[attr] = this.runtimeAttributes[attr].concat(control);
            }

            this.runtimeAttributes[attr][this.runtimeAttributes[attr].length] = end;
        }
        else {
            superclass.setRuntimeAttribute.call(this, attr);
        }
    };

    var translateValues = function(val, start) {
        var pageXY = Y.Dom.getXY(this.getEl());
        val = [ val[0] - pageXY[0] + start[0], val[1] - pageXY[1] + start[1] ];

        return val;
    };

    var isset = function(prop) {
        return (typeof prop !== 'undefined');
    };

    Y.Motion = Motion;
})();
(function() {
/**
 * Anim subclass for scrolling elements to a position defined by the "scroll"
 * member of "attributes".  All "scroll" members are arrays with x, y scroll positions.
 * <p>Usage: <code>var myAnim = new YAHOO.util.Scroll(el, { scroll: { to: [0, 800] } }, 1, YAHOO.util.Easing.easeOut);</code></p>
 * @class Scroll
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @extends YAHOO.util.ColorAnim
 * @constructor
 * @param {String or HTMLElement} el Reference to the element that will be animated
 * @param {Object} attributes The attribute(s) to be animated.
 * Each attribute is an object with at minimum a "to" or "by" member defined.
 * Additional optional members are "from" (defaults to current value), "units" (defaults to "px").
 * All attribute names use camelCase.
 * @param {Number} duration (optional, defaults to 1 second) Length of animation (frames or seconds), defaults to time-based
 * @param {Function} method (optional, defaults to YAHOO.util.Easing.easeNone) Computes the values that are applied to the attributes per frame (generally a YAHOO.util.Easing method)
 */
    var Scroll = function(el, attributes, duration,  method) {
        if (el) { // dont break existing subclasses not using YAHOO.extend
            Scroll.superclass.constructor.call(this, el, attributes, duration, method);
        }
    };

    Scroll.NAME = 'Scroll';

    var Y = YAHOO.util;
    YAHOO.extend(Scroll, Y.ColorAnim);

    var superclass = Scroll.superclass;
    var proto = Scroll.prototype;

    proto.doMethod = function(attr, start, end) {
        var val = null;

        if (attr == 'scroll') {
            val = [
                this.method(this.currentFrame, start[0], end[0] - start[0], this.totalFrames),
                this.method(this.currentFrame, start[1], end[1] - start[1], this.totalFrames)
            ];

        } else {
            val = superclass.doMethod.call(this, attr, start, end);
        }
        return val;
    };

    proto.getAttribute = function(attr) {
        var val = null;
        var el = this.getEl();

        if (attr == 'scroll') {
            val = [ el.scrollLeft, el.scrollTop ];
        } else {
            val = superclass.getAttribute.call(this, attr);
        }

        return val;
    };

    proto.setAttribute = function(attr, val, unit) {
        var el = this.getEl();

        if (attr == 'scroll') {
            el.scrollLeft = val[0];
            el.scrollTop = val[1];
        } else {
            superclass.setAttribute.call(this, attr, val, unit);
        }
    };

    Y.Scroll = Scroll;
})();
YAHOO.register("animation", YAHOO.util.Anim, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
(function () {

    /**
    * Config is a utility used within an Object to allow the implementer to
    * maintain a list of local configuration properties and listen for changes
    * to those properties dynamically using CustomEvent. The initial values are
    * also maintained so that the configuration can be reset at any given point
    * to its initial state.
    * @namespace YAHOO.util
    * @class Config
    * @constructor
    * @param {Object} owner The owner Object to which this Config Object belongs
    */
    YAHOO.util.Config = function (owner) {

        if (owner) {
            this.init(owner);
        }


    };


    var Lang = YAHOO.lang,
        CustomEvent = YAHOO.util.CustomEvent,
        Config = YAHOO.util.Config;


    /**
     * Constant representing the CustomEvent type for the config changed event.
     * @property YAHOO.util.Config.CONFIG_CHANGED_EVENT
     * @private
     * @static
     * @final
     */
    Config.CONFIG_CHANGED_EVENT = "configChanged";

    /**
     * Constant representing the boolean type string
     * @property YAHOO.util.Config.BOOLEAN_TYPE
     * @private
     * @static
     * @final
     */
    Config.BOOLEAN_TYPE = "boolean";

    Config.prototype = {

        /**
        * Object reference to the owner of this Config Object
        * @property owner
        * @type Object
        */
        owner: null,

        /**
        * Boolean flag that specifies whether a queue is currently
        * being executed
        * @property queueInProgress
        * @type Boolean
        */
        queueInProgress: false,

        /**
        * Maintains the local collection of configuration property objects and
        * their specified values
        * @property config
        * @private
        * @type Object
        */
        config: null,

        /**
        * Maintains the local collection of configuration property objects as
        * they were initially applied.
        * This object is used when resetting a property.
        * @property initialConfig
        * @private
        * @type Object
        */
        initialConfig: null,

        /**
        * Maintains the local, normalized CustomEvent queue
        * @property eventQueue
        * @private
        * @type Object
        */
        eventQueue: null,

        /**
        * Custom Event, notifying subscribers when Config properties are set
        * (setProperty is called without the silent flag
        * @event configChangedEvent
        */
        configChangedEvent: null,

        /**
        * Initializes the configuration Object and all of its local members.
        * @method init
        * @param {Object} owner The owner Object to which this Config
        * Object belongs
        */
        init: function (owner) {

            this.owner = owner;

            this.configChangedEvent =
                this.createEvent(Config.CONFIG_CHANGED_EVENT);

            this.configChangedEvent.signature = CustomEvent.LIST;
            this.queueInProgress = false;
            this.config = {};
            this.initialConfig = {};
            this.eventQueue = [];

        },

        /**
        * Validates that the value passed in is a Boolean.
        * @method checkBoolean
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */
        checkBoolean: function (val) {
            return (typeof val == Config.BOOLEAN_TYPE);
        },

        /**
        * Validates that the value passed in is a number.
        * @method checkNumber
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */
        checkNumber: function (val) {
            return (!isNaN(val));
        },

        /**
        * Fires a configuration property event using the specified value.
        * @method fireEvent
        * @private
        * @param {String} key The configuration property's name
        * @param {value} Object The value of the correct type for the property
        */
        fireEvent: function ( key, value ) {
            var property = this.config[key];

            if (property && property.event) {
                property.event.fire(value);
            }
        },

        /**
        * Adds a property to the Config Object's private config hash.
        * @method addProperty
        * @param {String} key The configuration property's name
        * @param {Object} propertyObject The Object containing all of this
        * property's arguments
        */
        addProperty: function ( key, propertyObject ) {
            key = key.toLowerCase();

            this.config[key] = propertyObject;

            propertyObject.event = this.createEvent(key, { scope: this.owner });
            propertyObject.event.signature = CustomEvent.LIST;


            propertyObject.key = key;

            if (propertyObject.handler) {
                propertyObject.event.subscribe(propertyObject.handler,
                    this.owner);
            }

            this.setProperty(key, propertyObject.value, true);

            if (! propertyObject.suppressEvent) {
                this.queueProperty(key, propertyObject.value);
            }

        },

        /**
        * Returns a key-value configuration map of the values currently set in
        * the Config Object.
        * @method getConfig
        * @return {Object} The current config, represented in a key-value map
        */
        getConfig: function () {

            var cfg = {},
                currCfg = this.config,
                prop,
                property;

            for (prop in currCfg) {
                if (Lang.hasOwnProperty(currCfg, prop)) {
                    property = currCfg[prop];
                    if (property && property.event) {
                        cfg[prop] = property.value;
                    }
                }
            }

            return cfg;
        },

        /**
        * Returns the value of specified property.
        * @method getProperty
        * @param {String} key The name of the property
        * @return {Object}  The value of the specified property
        */
        getProperty: function (key) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.value;
            } else {
                return undefined;
            }
        },

        /**
        * Resets the specified property's value to its initial value.
        * @method resetProperty
        * @param {String} key The name of the property
        * @return {Boolean} True is the property was reset, false if not
        */
        resetProperty: function (key) {

            key = key.toLowerCase();

            var property = this.config[key];

            if (property && property.event) {

                if (this.initialConfig[key] &&
                    !Lang.isUndefined(this.initialConfig[key])) {

                    this.setProperty(key, this.initialConfig[key]);

                    return true;

                }

            } else {

                return false;
            }

        },

        /**
        * Sets the value of a property. If the silent property is passed as
        * true, the property's event will not be fired.
        * @method setProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @param {Boolean} silent Whether the value should be set silently,
        * without firing the property event.
        * @return {Boolean} True, if the set was successful, false if it failed.
        */
        setProperty: function (key, value, silent) {

            var property;

            key = key.toLowerCase();

            if (this.queueInProgress && ! silent) {
                this.queueProperty(key,value);
                return true;

            } else {
                property = this.config[key];
                if (property && property.event) {
                    if (property.validator && !property.validator(value)) {
                        return false;
                    } else {
                        property.value = value;
                        if (! silent) {
                            this.fireEvent(key, value);
                            this.configChangedEvent.fire([key, value]);
                        }
                        return true;
                    }
                } else {
                    return false;
                }
            }
        },

        /**
        * Sets the value of a property and queues its event to execute. If the
        * event is already scheduled to execute, it is
        * moved from its current position to the end of the queue.
        * @method queueProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @return {Boolean}  true, if the set was successful, false if
        * it failed.
        */
        queueProperty: function (key, value) {

            key = key.toLowerCase();

            var property = this.config[key],
                foundDuplicate = false,
                iLen,
                queueItem,
                queueItemKey,
                queueItemValue,
                sLen,
                supercedesCheck,
                qLen,
                queueItemCheck,
                queueItemCheckKey,
                queueItemCheckValue,
                i,
                s,
                q;

            if (property && property.event) {

                if (!Lang.isUndefined(value) && property.validator &&
                    !property.validator(value)) { // validator
                    return false;
                } else {

                    if (!Lang.isUndefined(value)) {
                        property.value = value;
                    } else {
                        value = property.value;
                    }

                    foundDuplicate = false;
                    iLen = this.eventQueue.length;

                    for (i = 0; i < iLen; i++) {
                        queueItem = this.eventQueue[i];

                        if (queueItem) {
                            queueItemKey = queueItem[0];
                            queueItemValue = queueItem[1];

                            if (queueItemKey == key) {

                                /*
                                    found a dupe... push to end of queue, null
                                    current item, and break
                                */

                                this.eventQueue[i] = null;

                                this.eventQueue.push(
                                    [key, (!Lang.isUndefined(value) ?
                                    value : queueItemValue)]);

                                foundDuplicate = true;
                                break;
                            }
                        }
                    }


                    if (! foundDuplicate && !Lang.isUndefined(value)) {
                        this.eventQueue.push([key, value]);
                    }
                }

                if (property.supercedes) {

                    sLen = property.supercedes.length;

                    for (s = 0; s < sLen; s++) {

                        supercedesCheck = property.supercedes[s];
                        qLen = this.eventQueue.length;

                        for (q = 0; q < qLen; q++) {
                            queueItemCheck = this.eventQueue[q];

                            if (queueItemCheck) {
                                queueItemCheckKey = queueItemCheck[0];
                                queueItemCheckValue = queueItemCheck[1];

                                if (queueItemCheckKey ==
                                    supercedesCheck.toLowerCase() ) {

                                    this.eventQueue.push([queueItemCheckKey,
                                        queueItemCheckValue]);

                                    this.eventQueue[q] = null;
                                    break;

                                }
                            }
                        }
                    }
                }


                return true;
            } else {
                return false;
            }
        },

        /**
        * Fires the event for a property using the property's current value.
        * @method refireEvent
        * @param {String} key The name of the property
        */
        refireEvent: function (key) {

            key = key.toLowerCase();

            var property = this.config[key];

            if (property && property.event &&

                !Lang.isUndefined(property.value)) {

                if (this.queueInProgress) {

                    this.queueProperty(key);

                } else {

                    this.fireEvent(key, property.value);

                }

            }
        },

        /**
        * Applies a key-value Object literal to the configuration, replacing
        * any existing values, and queueing the property events.
        * Although the values will be set, fireQueue() must be called for their
        * associated events to execute.
        * @method applyConfig
        * @param {Object} userConfig The configuration Object literal
        * @param {Boolean} init  When set to true, the initialConfig will
        * be set to the userConfig passed in, so that calling a reset will
        * reset the properties to the passed values.
        */
        applyConfig: function (userConfig, init) {

            var sKey,
                oConfig;

            if (init) {
                oConfig = {};
                for (sKey in userConfig) {
                    if (Lang.hasOwnProperty(userConfig, sKey)) {
                        oConfig[sKey.toLowerCase()] = userConfig[sKey];
                    }
                }
                this.initialConfig = oConfig;
            }

            for (sKey in userConfig) {
                if (Lang.hasOwnProperty(userConfig, sKey)) {
                    this.queueProperty(sKey, userConfig[sKey]);
                }
            }
        },

        /**
        * Refires the events for all configuration properties using their
        * current values.
        * @method refresh
        */
        refresh: function () {

            var prop;

            for (prop in this.config) {
                if (Lang.hasOwnProperty(this.config, prop)) {
                    this.refireEvent(prop);
                }
            }
        },

        /**
        * Fires the normalized list of queued property change events
        * @method fireQueue
        */
        fireQueue: function () {

            var i,
                queueItem,
                key,
                value,
                property;

            this.queueInProgress = true;
            for (i = 0;i < this.eventQueue.length; i++) {
                queueItem = this.eventQueue[i];
                if (queueItem) {

                    key = queueItem[0];
                    value = queueItem[1];
                    property = this.config[key];

                    property.value = value;

                    this.eventQueue[i] = null;

                    this.fireEvent(key,value);
                }
            }

            this.queueInProgress = false;
            this.eventQueue = [];
        },

        /**
        * Subscribes an external handler to the change event for any
        * given property.
        * @method subscribeToConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to
        * the property's event
        * @param {Object} obj The Object to use for scoping the event handler
        * (see CustomEvent documentation)
        * @param {Boolean} overrideContext Optional. If true, will override
        * "this" within the handler to map to the scope Object passed into the
        * method.
        * @return {Boolean} True, if the subscription was successful,
        * otherwise false.
        */
        subscribeToConfigEvent: function (key, handler, obj, overrideContext) {

            var property = this.config[key.toLowerCase()];

            if (property && property.event) {
                if (!Config.alreadySubscribed(property.event, handler, obj)) {
                    property.event.subscribe(handler, obj, overrideContext);
                }
                return true;
            } else {
                return false;
            }

        },

        /**
        * Unsubscribes an external handler from the change event for any
        * given property.
        * @method unsubscribeFromConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to
        * the property's event
        * @param {Object} obj The Object to use for scoping the event
        * handler (see CustomEvent documentation)
        * @return {Boolean} True, if the unsubscription was successful,
        * otherwise false.
        */
        unsubscribeFromConfigEvent: function (key, handler, obj) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.event.unsubscribe(handler, obj);
            } else {
                return false;
            }
        },

        /**
        * Returns a string representation of the Config object
        * @method toString
        * @return {String} The Config object in string format.
        */
        toString: function () {
            var output = "Config";
            if (this.owner) {
                output += " [" + this.owner.toString() + "]";
            }
            return output;
        },

        /**
        * Returns a string representation of the Config object's current
        * CustomEvent queue
        * @method outputEventQueue
        * @return {String} The string list of CustomEvents currently queued
        * for execution
        */
        outputEventQueue: function () {

            var output = "",
                queueItem,
                q,
                nQueue = this.eventQueue.length;

            for (q = 0; q < nQueue; q++) {
                queueItem = this.eventQueue[q];
                if (queueItem) {
                    output += queueItem[0] + "=" + queueItem[1] + ", ";
                }
            }
            return output;
        },

        /**
        * Sets all properties to null, unsubscribes all listeners from each
        * property's change event and all listeners from the configChangedEvent.
        * @method destroy
        */
        destroy: function () {

            var oConfig = this.config,
                sProperty,
                oProperty;


            for (sProperty in oConfig) {

                if (Lang.hasOwnProperty(oConfig, sProperty)) {

                    oProperty = oConfig[sProperty];

                    oProperty.event.unsubscribeAll();
                    oProperty.event = null;

                }

            }

            this.configChangedEvent.unsubscribeAll();

            this.configChangedEvent = null;
            this.owner = null;
            this.config = null;
            this.initialConfig = null;
            this.eventQueue = null;

        }

    };



    /**
    * Checks to determine if a particular function/Object pair are already
    * subscribed to the specified CustomEvent
    * @method YAHOO.util.Config.alreadySubscribed
    * @static
    * @param {YAHOO.util.CustomEvent} evt The CustomEvent for which to check
    * the subscriptions
    * @param {Function} fn The function to look for in the subscribers list
    * @param {Object} obj The execution scope Object for the subscription
    * @return {Boolean} true, if the function/Object pair is already subscribed
    * to the CustomEvent passed in
    */
    Config.alreadySubscribed = function (evt, fn, obj) {

        var nSubscribers = evt.subscribers.length,
            subsc,
            i;

        if (nSubscribers > 0) {
            i = nSubscribers - 1;
            do {
                subsc = evt.subscribers[i];
                if (subsc && subsc.obj == obj && subsc.fn == fn) {
                    return true;
                }
            }
            while (i--);
        }

        return false;

    };

    YAHOO.lang.augmentProto(Config, YAHOO.util.EventProvider);

}());
(function () {

    /**
    * The Container family of components is designed to enable developers to
    * create different kinds of content-containing modules on the web. Module
    * and Overlay are the most basic containers, and they can be used directly
    * or extended to build custom containers. Also part of the Container family
    * are four UI controls that extend Module and Overlay: Tooltip, Panel,
    * Dialog, and SimpleDialog.
    * @module container
    * @title Container
    * @requires yahoo, dom, event
    * @optional dragdrop, animation, button
    */

    /**
    * Module is a JavaScript representation of the Standard Module Format.
    * Standard Module Format is a simple standard for markup containers where
    * child nodes representing the header, body, and footer of the content are
    * denoted using the CSS classes "hd", "bd", and "ft" respectively.
    * Module is the base class for all other classes in the YUI
    * Container package.
    * @namespace YAHOO.widget
    * @class Module
    * @constructor
    * @param {String} el The element ID representing the Module <em>OR</em>
    * @param {HTMLElement} el The element representing the Module
    * @param {Object} userConfig The configuration Object literal containing
    * the configuration that should be set for this module. See configuration
    * documentation for more details.
    */
    YAHOO.widget.Module = function (el, userConfig) {
        if (el) {
            this.init(el, userConfig);
        } else {
        }
    };

    var Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Module = YAHOO.widget.Module,
        UA = YAHOO.env.ua,

        m_oModuleTemplate,
        m_oHeaderTemplate,
        m_oBodyTemplate,
        m_oFooterTemplate,

        /**
        * Constant representing the name of the Module's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "BEFORE_INIT": "beforeInit",
            "INIT": "init",
            "APPEND": "append",
            "BEFORE_RENDER": "beforeRender",
            "RENDER": "render",
            "CHANGE_HEADER": "changeHeader",
            "CHANGE_BODY": "changeBody",
            "CHANGE_FOOTER": "changeFooter",
            "CHANGE_CONTENT": "changeContent",
            "DESTROY": "destroy",
            "BEFORE_SHOW": "beforeShow",
            "SHOW": "show",
            "BEFORE_HIDE": "beforeHide",
            "HIDE": "hide"
        },

        /**
        * Constant representing the Module's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "VISIBLE": {
                key: "visible",
                value: true,
                validator: YAHOO.lang.isBoolean
            },

            "EFFECT": {
                key: "effect",
                suppressEvent: true,
                supercedes: ["visible"]
            },

            "MONITOR_RESIZE": {
                key: "monitorresize",
                value: true
            },

            "APPEND_TO_DOCUMENT_BODY": {
                key: "appendtodocumentbody",
                value: false
            }
        };

    /**
    * Constant representing the prefix path to use for non-secure images
    * @property YAHOO.widget.Module.IMG_ROOT
    * @static
    * @final
    * @type String
    */
    Module.IMG_ROOT = null;

    /**
    * Constant representing the prefix path to use for securely served images
    * @property YAHOO.widget.Module.IMG_ROOT_SSL
    * @static
    * @final
    * @type String
    */
    Module.IMG_ROOT_SSL = null;

    /**
    * Constant for the default CSS class name that represents a Module
    * @property YAHOO.widget.Module.CSS_MODULE
    * @static
    * @final
    * @type String
    */
    Module.CSS_MODULE = "yui-module";

    /**
    * Constant representing the module header
    * @property YAHOO.widget.Module.CSS_HEADER
    * @static
    * @final
    * @type String
    */
    Module.CSS_HEADER = "hd";

    /**
    * Constant representing the module body
    * @property YAHOO.widget.Module.CSS_BODY
    * @static
    * @final
    * @type String
    */
    Module.CSS_BODY = "bd";

    /**
    * Constant representing the module footer
    * @property YAHOO.widget.Module.CSS_FOOTER
    * @static
    * @final
    * @type String
    */
    Module.CSS_FOOTER = "ft";

    /**
    * Constant representing the url for the "src" attribute of the iframe
    * used to monitor changes to the browser's base font size
    * @property YAHOO.widget.Module.RESIZE_MONITOR_SECURE_URL
    * @static
    * @final
    * @type String
    */
    Module.RESIZE_MONITOR_SECURE_URL = "javascript:false;";

    /**
    * Constant representing the buffer amount (in pixels) to use when positioning
    * the text resize monitor offscreen. The resize monitor is positioned
    * offscreen by an amount eqaul to its offsetHeight + the buffer value.
    *
    * @property YAHOO.widget.Module.RESIZE_MONITOR_BUFFER
    * @static
    * @type Number
    */
    Module.RESIZE_MONITOR_BUFFER = 1;

    /**
    * Singleton CustomEvent fired when the font size is changed in the browser.
    * Opera's "zoom" functionality currently does not support text
    * size detection.
    * @event YAHOO.widget.Module.textResizeEvent
    */
    Module.textResizeEvent = new CustomEvent("textResize");

    /**
     * Helper utility method, which forces a document level
     * redraw for Opera, which can help remove repaint
     * irregularities after applying DOM changes.
     *
     * @method YAHOO.widget.Module.forceDocumentRedraw
     * @static
     */
    Module.forceDocumentRedraw = function() {
        var docEl = document.documentElement;
        if (docEl) {
            docEl.className += " ";
            docEl.className = YAHOO.lang.trim(docEl.className);
        }
    };

    function createModuleTemplate() {

        if (!m_oModuleTemplate) {
            m_oModuleTemplate = document.createElement("div");

            m_oModuleTemplate.innerHTML = ("<div class=\"" +
                Module.CSS_HEADER + "\"></div>" + "<div class=\"" +
                Module.CSS_BODY + "\"></div><div class=\"" +
                Module.CSS_FOOTER + "\"></div>");

            m_oHeaderTemplate = m_oModuleTemplate.firstChild;
            m_oBodyTemplate = m_oHeaderTemplate.nextSibling;
            m_oFooterTemplate = m_oBodyTemplate.nextSibling;
        }

        return m_oModuleTemplate;
    }

    function createHeader() {
        if (!m_oHeaderTemplate) {
            createModuleTemplate();
        }
        return (m_oHeaderTemplate.cloneNode(false));
    }

    function createBody() {
        if (!m_oBodyTemplate) {
            createModuleTemplate();
        }
        return (m_oBodyTemplate.cloneNode(false));
    }

    function createFooter() {
        if (!m_oFooterTemplate) {
            createModuleTemplate();
        }
        return (m_oFooterTemplate.cloneNode(false));
    }

    Module.prototype = {

        /**
        * The class's constructor function
        * @property contructor
        * @type Function
        */
        constructor: Module,

        /**
        * The main module element that contains the header, body, and footer
        * @property element
        * @type HTMLElement
        */
        element: null,

        /**
        * The header element, denoted with CSS class "hd"
        * @property header
        * @type HTMLElement
        */
        header: null,

        /**
        * The body element, denoted with CSS class "bd"
        * @property body
        * @type HTMLElement
        */
        body: null,

        /**
        * The footer element, denoted with CSS class "ft"
        * @property footer
        * @type HTMLElement
        */
        footer: null,

        /**
        * The id of the element
        * @property id
        * @type String
        */
        id: null,

        /**
        * A string representing the root path for all images created by
        * a Module instance.
        * @deprecated It is recommend that any images for a Module be applied
        * via CSS using the "background-image" property.
        * @property imageRoot
        * @type String
        */
        imageRoot: Module.IMG_ROOT,

        /**
        * Initializes the custom events for Module which are fired
        * automatically at appropriate times by the Module class.
        * @method initEvents
        */
        initEvents: function () {

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired prior to class initalization.
            * @event beforeInitEvent
            * @param {class} classRef class reference of the initializing
            * class, such as this.beforeInitEvent.fire(Module)
            */
            this.beforeInitEvent = this.createEvent(EVENT_TYPES.BEFORE_INIT);
            this.beforeInitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after class initalization.
            * @event initEvent
            * @param {class} classRef class reference of the initializing
            * class, such as this.beforeInitEvent.fire(Module)
            */
            this.initEvent = this.createEvent(EVENT_TYPES.INIT);
            this.initEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the Module is appended to the DOM
            * @event appendEvent
            */
            this.appendEvent = this.createEvent(EVENT_TYPES.APPEND);
            this.appendEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is rendered
            * @event beforeRenderEvent
            */
            this.beforeRenderEvent = this.createEvent(EVENT_TYPES.BEFORE_RENDER);
            this.beforeRenderEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Module is rendered
            * @event renderEvent
            */
            this.renderEvent = this.createEvent(EVENT_TYPES.RENDER);
            this.renderEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the header content of the Module
            * is modified
            * @event changeHeaderEvent
            * @param {String/HTMLElement} content String/element representing
            * the new header content
            */
            this.changeHeaderEvent = this.createEvent(EVENT_TYPES.CHANGE_HEADER);
            this.changeHeaderEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the body content of the Module is modified
            * @event changeBodyEvent
            * @param {String/HTMLElement} content String/element representing
            * the new body content
            */
            this.changeBodyEvent = this.createEvent(EVENT_TYPES.CHANGE_BODY);
            this.changeBodyEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the footer content of the Module
            * is modified
            * @event changeFooterEvent
            * @param {String/HTMLElement} content String/element representing
            * the new footer content
            */
            this.changeFooterEvent = this.createEvent(EVENT_TYPES.CHANGE_FOOTER);
            this.changeFooterEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the content of the Module is modified
            * @event changeContentEvent
            */
            this.changeContentEvent = this.createEvent(EVENT_TYPES.CHANGE_CONTENT);
            this.changeContentEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the Module is destroyed
            * @event destroyEvent
            */
            this.destroyEvent = this.createEvent(EVENT_TYPES.DESTROY);
            this.destroyEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is shown
            * @event beforeShowEvent
            */
            this.beforeShowEvent = this.createEvent(EVENT_TYPES.BEFORE_SHOW);
            this.beforeShowEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Module is shown
            * @event showEvent
            */
            this.showEvent = this.createEvent(EVENT_TYPES.SHOW);
            this.showEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired before the Module is hidden
            * @event beforeHideEvent
            */
            this.beforeHideEvent = this.createEvent(EVENT_TYPES.BEFORE_HIDE);
            this.beforeHideEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Module is hidden
            * @event hideEvent
            */
            this.hideEvent = this.createEvent(EVENT_TYPES.HIDE);
            this.hideEvent.signature = SIGNATURE;
        },

        /**
        * String representing the current user-agent platform
        * @property platform
        * @type String
        */
        platform: function () {
            var ua = navigator.userAgent.toLowerCase();

            if (ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1) {
                return "windows";
            } else if (ua.indexOf("macintosh") != -1) {
                return "mac";
            } else {
                return false;
            }
        }(),

        /**
        * String representing the user-agent of the browser
        * @deprecated Use YAHOO.env.ua
        * @property browser
        * @type String
        */
        browser: function () {
            var ua = navigator.userAgent.toLowerCase();
            /*
                 Check Opera first in case of spoof and check Safari before
                 Gecko since Safari's user agent string includes "like Gecko"
            */
            if (ua.indexOf('opera') != -1) {
                return 'opera';
            } else if (ua.indexOf('msie 7') != -1) {
                return 'ie7';
            } else if (ua.indexOf('msie') != -1) {
                return 'ie';
            } else if (ua.indexOf('safari') != -1) {
                return 'safari';
            } else if (ua.indexOf('gecko') != -1) {
                return 'gecko';
            } else {
                return false;
            }
        }(),

        /**
        * Boolean representing whether or not the current browsing context is
        * secure (https)
        * @property isSecure
        * @type Boolean
        */
        isSecure: function () {
            if (window.location.href.toLowerCase().indexOf("https") === 0) {
                return true;
            } else {
                return false;
            }
        }(),

        /**
        * Initializes the custom events for Module which are fired
        * automatically at appropriate times by the Module class.
        */
        initDefaultConfig: function () {
            /**
            * Specifies whether the Module is visible on the page.
            * @config visible
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.VISIBLE.key, {
                handler: this.configVisible,
                value: DEFAULT_CONFIG.VISIBLE.value,
                validator: DEFAULT_CONFIG.VISIBLE.validator
            });

            /**
            * <p>
            * Object or array of objects representing the ContainerEffect
            * classes that are active for animating the container.
            * </p>
            * <p>
            * <strong>NOTE:</strong> Although this configuration
            * property is introduced at the Module level, an out of the box
            * implementation is not shipped for the Module class so setting
            * the proroperty on the Module class has no effect. The Overlay
            * class is the first class to provide out of the box ContainerEffect
            * support.
            * </p>
            * @config effect
            * @type Object
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.EFFECT.key, {
                suppressEvent: DEFAULT_CONFIG.EFFECT.suppressEvent,
                supercedes: DEFAULT_CONFIG.EFFECT.supercedes
            });

            /**
            * Specifies whether to create a special proxy iframe to monitor
            * for user font resizing in the document
            * @config monitorresize
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.MONITOR_RESIZE.key, {
                handler: this.configMonitorResize,
                value: DEFAULT_CONFIG.MONITOR_RESIZE.value
            });

            /**
            * Specifies if the module should be rendered as the first child
            * of document.body or appended as the last child when render is called
            * with document.body as the "appendToNode".
            * <p>
            * Appending to the body while the DOM is still being constructed can
            * lead to Operation Aborted errors in IE hence this flag is set to
            * false by default.
            * </p>
            *
            * @config appendtodocumentbody
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.key, {
                value: DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.value
            });
        },

        /**
        * The Module class's initialization method, which is executed for
        * Module and all of its subclasses. This method is automatically
        * called by the constructor, and  sets up all DOM references for
        * pre-existing markup, and creates required markup if it is not
        * already present.
        * <p>
        * If the element passed in does not have an id, one will be generated
        * for it.
        * </p>
        * @method init
        * @param {String} el The element ID representing the Module <em>OR</em>
        * @param {HTMLElement} el The element representing the Module
        * @param {Object} userConfig The configuration Object literal
        * containing the configuration that should be set for this module.
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            var elId, child;

            this.initEvents();
            this.beforeInitEvent.fire(Module);

            /**
            * The Module's Config object used for monitoring
            * configuration properties.
            * @property cfg
            * @type YAHOO.util.Config
            */
            this.cfg = new Config(this);

            if (this.isSecure) {
                this.imageRoot = Module.IMG_ROOT_SSL;
            }

            if (typeof el == "string") {
                elId = el;
                el = document.getElementById(el);
                if (! el) {
                    el = (createModuleTemplate()).cloneNode(false);
                    el.id = elId;
                }
            }

            this.id = Dom.generateId(el);
            this.element = el;

            child = this.element.firstChild;

            if (child) {
                var fndHd = false, fndBd = false, fndFt = false;
                do {
                    if (1 == child.nodeType) {
                        if (!fndHd && Dom.hasClass(child, Module.CSS_HEADER)) {
                            this.header = child;
                            fndHd = true;
                        } else if (!fndBd && Dom.hasClass(child, Module.CSS_BODY)) {
                            this.body = child;
                            fndBd = true;
                        } else if (!fndFt && Dom.hasClass(child, Module.CSS_FOOTER)){
                            this.footer = child;
                            fndFt = true;
                        }
                    }
                } while ((child = child.nextSibling));
            }

            this.initDefaultConfig();

            Dom.addClass(this.element, Module.CSS_MODULE);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            /*
                Subscribe to the fireQueue() method of Config so that any
                queued configuration changes are excecuted upon render of
                the Module
            */

            if (!Config.alreadySubscribed(this.renderEvent, this.cfg.fireQueue, this.cfg)) {
                this.renderEvent.subscribe(this.cfg.fireQueue, this.cfg, true);
            }

            this.initEvent.fire(Module);
        },

        /**
        * Initialize an empty IFRAME that is placed out of the visible area
        * that can be used to detect text resize.
        * @method initResizeMonitor
        */
        initResizeMonitor: function () {

            var isGeckoWin = (UA.gecko && this.platform == "windows");
            if (isGeckoWin) {
                var self = this;
                setTimeout(function(){self._initResizeMonitor();}, 0);
            } else {
                this._initResizeMonitor();
            }
        },

        /**
         * Create and initialize the text resize monitoring iframe.
         *
         * @protected
         * @method _initResizeMonitor
         */
        _initResizeMonitor : function() {

            var oDoc,
                oIFrame,
                sHTML;

            function fireTextResize() {
                Module.textResizeEvent.fire();
            }

            if (!UA.opera) {
                oIFrame = Dom.get("_yuiResizeMonitor");

                var supportsCWResize = this._supportsCWResize();

                if (!oIFrame) {
                    oIFrame = document.createElement("iframe");

                    if (this.isSecure && Module.RESIZE_MONITOR_SECURE_URL && UA.ie) {
                        oIFrame.src = Module.RESIZE_MONITOR_SECURE_URL;
                    }

                    if (!supportsCWResize) {
                        sHTML = ["<html><head><script ",
                                 "type=\"text/javascript\">",
                                 "window.onresize=function(){window.parent.",
                                 "YAHOO.widget.Module.textResizeEvent.",
                                 "fire();};<",
                                 "\/script></head>",
                                 "<body></body></html>"].join('');

                        oIFrame.src = "data:text/html;charset=utf-8," + encodeURIComponent(sHTML);
                    }

                    oIFrame.id = "_yuiResizeMonitor";
                    oIFrame.title = "Text Resize Monitor";
                    /*
                        Need to set "position" property before inserting the
                        iframe into the document or Safari's status bar will
                        forever indicate the iframe is loading
                        (See YUILibrary bug #1723064)
                    */
                    oIFrame.style.position = "absolute";
                    oIFrame.style.visibility = "hidden";

                    var db = document.body,
                        fc = db.firstChild;
                    if (fc) {
                        db.insertBefore(oIFrame, fc);
                    } else {
                        db.appendChild(oIFrame);
                    }

                    oIFrame.style.backgroundColor = "transparent";

                    oIFrame.style.borderWidth = "0";
                    oIFrame.style.width = "2em";
                    oIFrame.style.height = "2em";
                    oIFrame.style.left = "0";
                    oIFrame.style.top = (-1 * (oIFrame.offsetHeight + Module.RESIZE_MONITOR_BUFFER)) + "px";
                    oIFrame.style.visibility = "visible";

                    /*
                       Don't open/close the document for Gecko like we used to, since it
                       leads to duplicate cookies. (See YUILibrary bug #1721755)
                    */
                    if (UA.webkit) {
                        oDoc = oIFrame.contentWindow.document;
                        oDoc.open();
                        oDoc.close();
                    }
                }

                if (oIFrame && oIFrame.contentWindow) {
                    Module.textResizeEvent.subscribe(this.onDomResize, this, true);

                    if (!Module.textResizeInitialized) {
                        if (supportsCWResize) {
                            if (!Event.on(oIFrame.contentWindow, "resize", fireTextResize)) {
                                /*
                                     This will fail in IE if document.domain has
                                     changed, so we must change the listener to
                                     use the oIFrame element instead
                                */
                                Event.on(oIFrame, "resize", fireTextResize);
                            }
                        }
                        Module.textResizeInitialized = true;
                    }
                    this.resizeMonitor = oIFrame;
                }
            }
        },

        /**
         * Text resize monitor helper method.
         * Determines if the browser supports resize events on iframe content windows.
         *
         * @private
         * @method _supportsCWResize
         */
        _supportsCWResize : function() {
            /*
                Gecko 1.8.0 (FF1.5), 1.8.1.0-5 (FF2) won't fire resize on contentWindow.
                Gecko 1.8.1.6+ (FF2.0.0.6+) and all other browsers will fire resize on contentWindow.

                We don't want to start sniffing for patch versions, so fire textResize the same
                way on all FF2 flavors
             */
            var bSupported = true;
            if (UA.gecko && UA.gecko <= 1.8) {
                bSupported = false;
            }
            return bSupported;
        },

        /**
        * Event handler fired when the resize monitor element is resized.
        * @method onDomResize
        * @param {DOMEvent} e The DOM resize event
        * @param {Object} obj The scope object passed to the handler
        */
        onDomResize: function (e, obj) {

            var nTop = -1 * (this.resizeMonitor.offsetHeight + Module.RESIZE_MONITOR_BUFFER);

            this.resizeMonitor.style.top = nTop + "px";
            this.resizeMonitor.style.left = "0";
        },

        /**
        * Sets the Module's header content to the string specified, or appends
        * the passed element to the header. If no header is present, one will
        * be automatically created. An empty string can be passed to the method
        * to clear the contents of the header.
        *
        * @method setHeader
        * @param {String} headerContent The string used to set the header.
        * As a convenience, non HTMLElement objects can also be passed into
        * the method, and will be treated as strings, with the header innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} headerContent The HTMLElement to append to
        * <em>OR</em>
        * @param {DocumentFragment} headerContent The document fragment
        * containing elements which are to be added to the header
        */
        setHeader: function (headerContent) {
            var oHeader = this.header || (this.header = createHeader());

            if (headerContent.nodeName) {
                oHeader.innerHTML = "";
                oHeader.appendChild(headerContent);
            } else {
                oHeader.innerHTML = headerContent;
            }

            if (this._rendered) {
                this._renderHeader();
            }

            this.changeHeaderEvent.fire(headerContent);
            this.changeContentEvent.fire();

        },

        /**
        * Appends the passed element to the header. If no header is present,
        * one will be automatically created.
        * @method appendToHeader
        * @param {HTMLElement | DocumentFragment} element The element to
        * append to the header. In the case of a document fragment, the
        * children of the fragment will be appended to the header.
        */
        appendToHeader: function (element) {
            var oHeader = this.header || (this.header = createHeader());

            oHeader.appendChild(element);

            this.changeHeaderEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
        * Sets the Module's body content to the HTML specified.
        *
        * If no body is present, one will be automatically created.
        *
        * An empty string can be passed to the method to clear the contents of the body.
        * @method setBody
        * @param {String} bodyContent The HTML used to set the body.
        * As a convenience, non HTMLElement objects can also be passed into
        * the method, and will be treated as strings, with the body innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} bodyContent The HTMLElement to add as the first and only
        * child of the body element.
        * <em>OR</em>
        * @param {DocumentFragment} bodyContent The document fragment
        * containing elements which are to be added to the body
        */
        setBody: function (bodyContent) {
            var oBody = this.body || (this.body = createBody());

            if (bodyContent.nodeName) {
                oBody.innerHTML = "";
                oBody.appendChild(bodyContent);
            } else {
                oBody.innerHTML = bodyContent;
            }

            if (this._rendered) {
                this._renderBody();
            }

            this.changeBodyEvent.fire(bodyContent);
            this.changeContentEvent.fire();
        },

        /**
        * Appends the passed element to the body. If no body is present, one
        * will be automatically created.
        * @method appendToBody
        * @param {HTMLElement | DocumentFragment} element The element to
        * append to the body. In the case of a document fragment, the
        * children of the fragment will be appended to the body.
        *
        */
        appendToBody: function (element) {
            var oBody = this.body || (this.body = createBody());

            oBody.appendChild(element);

            this.changeBodyEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
        * Sets the Module's footer content to the HTML specified, or appends
        * the passed element to the footer. If no footer is present, one will
        * be automatically created. An empty string can be passed to the method
        * to clear the contents of the footer.
        * @method setFooter
        * @param {String} footerContent The HTML used to set the footer
        * As a convenience, non HTMLElement objects can also be passed into
        * the method, and will be treated as strings, with the footer innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} footerContent The HTMLElement to append to
        * the footer
        * <em>OR</em>
        * @param {DocumentFragment} footerContent The document fragment containing
        * elements which are to be added to the footer
        */
        setFooter: function (footerContent) {

            var oFooter = this.footer || (this.footer = createFooter());

            if (footerContent.nodeName) {
                oFooter.innerHTML = "";
                oFooter.appendChild(footerContent);
            } else {
                oFooter.innerHTML = footerContent;
            }

            if (this._rendered) {
                this._renderFooter();
            }

            this.changeFooterEvent.fire(footerContent);
            this.changeContentEvent.fire();
        },

        /**
        * Appends the passed element to the footer. If no footer is present,
        * one will be automatically created.
        * @method appendToFooter
        * @param {HTMLElement | DocumentFragment} element The element to
        * append to the footer. In the case of a document fragment, the
        * children of the fragment will be appended to the footer
        */
        appendToFooter: function (element) {

            var oFooter = this.footer || (this.footer = createFooter());

            oFooter.appendChild(element);

            this.changeFooterEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
        * Renders the Module by inserting the elements that are not already
        * in the main Module into their correct places. Optionally appends
        * the Module to the specified node prior to the render's execution.
        * <p>
        * For Modules without existing markup, the appendToNode argument
        * is REQUIRED. If this argument is ommitted and the current element is
        * not present in the document, the function will return false,
        * indicating that the render was a failure.
        * </p>
        * <p>
        * NOTE: As of 2.3.1, if the appendToNode is the document's body element
        * then the module is rendered as the first child of the body element,
        * and not appended to it, to avoid Operation Aborted errors in IE when
        * rendering the module before window's load event is fired. You can
        * use the appendtodocumentbody configuration property to change this
        * to append to document.body if required.
        * </p>
        * @method render
        * @param {String} appendToNode The element id to which the Module
        * should be appended to prior to rendering <em>OR</em>
        * @param {HTMLElement} appendToNode The element to which the Module
        * should be appended to prior to rendering
        * @param {HTMLElement} moduleElement OPTIONAL. The element that
        * represents the actual Standard Module container.
        * @return {Boolean} Success or failure of the render
        */
        render: function (appendToNode, moduleElement) {

            var me = this;

            function appendTo(parentNode) {
                if (typeof parentNode == "string") {
                    parentNode = document.getElementById(parentNode);
                }

                if (parentNode) {
                    me._addToParent(parentNode, me.element);
                    me.appendEvent.fire();
                }
            }

            this.beforeRenderEvent.fire();

            if (! moduleElement) {
                moduleElement = this.element;
            }

            if (appendToNode) {
                appendTo(appendToNode);
            } else {
                if (! Dom.inDocument(this.element)) {
                    return false;
                }
            }

            this._renderHeader(moduleElement);
            this._renderBody(moduleElement);
            this._renderFooter(moduleElement);

            this._rendered = true;

            this.renderEvent.fire();
            return true;
        },

        /**
         * Renders the currently set header into it's proper position under the
         * module element. If the module element is not provided, "this.element"
         * is used.
         *
         * @method _renderHeader
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element
         */
        _renderHeader: function(moduleElement){
            moduleElement = moduleElement || this.element;

            if (this.header && !Dom.inDocument(this.header)) {
                var firstChild = moduleElement.firstChild;
                if (firstChild) {
                    moduleElement.insertBefore(this.header, firstChild);
                } else {
                    moduleElement.appendChild(this.header);
                }
            }
        },

        /**
         * Renders the currently set body into it's proper position under the
         * module element. If the module element is not provided, "this.element"
         * is used.
         *
         * @method _renderBody
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element.
         */
        _renderBody: function(moduleElement){
            moduleElement = moduleElement || this.element;

            if (this.body && !Dom.inDocument(this.body)) {
                if (this.footer && Dom.isAncestor(moduleElement, this.footer)) {
                    moduleElement.insertBefore(this.body, this.footer);
                } else {
                    moduleElement.appendChild(this.body);
                }
            }
        },

        /**
         * Renders the currently set footer into it's proper position under the
         * module element. If the module element is not provided, "this.element"
         * is used.
         *
         * @method _renderFooter
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element
         */
        _renderFooter: function(moduleElement){
            moduleElement = moduleElement || this.element;

            if (this.footer && !Dom.inDocument(this.footer)) {
                moduleElement.appendChild(this.footer);
            }
        },

        /**
        * Removes the Module element from the DOM and sets all child elements
        * to null.
        * @method destroy
        */
        destroy: function () {

            var parent;

            if (this.element) {
                Event.purgeElement(this.element, true);
                parent = this.element.parentNode;
            }

            if (parent) {
                parent.removeChild(this.element);
            }

            this.element = null;
            this.header = null;
            this.body = null;
            this.footer = null;

            Module.textResizeEvent.unsubscribe(this.onDomResize, this);

            this.cfg.destroy();
            this.cfg = null;

            this.destroyEvent.fire();
        },

        /**
        * Shows the Module element by setting the visible configuration
        * property to true. Also fires two events: beforeShowEvent prior to
        * the visibility change, and showEvent after.
        * @method show
        */
        show: function () {
            this.cfg.setProperty("visible", true);
        },

        /**
        * Hides the Module element by setting the visible configuration
        * property to false. Also fires two events: beforeHideEvent prior to
        * the visibility change, and hideEvent after.
        * @method hide
        */
        hide: function () {
            this.cfg.setProperty("visible", false);
        },

        /**
        * Default event handler for changing the visibility property of a
        * Module. By default, this is achieved by switching the "display" style
        * between "block" and "none".
        * This method is responsible for firing showEvent and hideEvent.
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        * @method configVisible
        */
        configVisible: function (type, args, obj) {
            var visible = args[0];
            if (visible) {
                this.beforeShowEvent.fire();
                Dom.setStyle(this.element, "display", "block");
                this.showEvent.fire();
            } else {
                this.beforeHideEvent.fire();
                Dom.setStyle(this.element, "display", "none");
                this.hideEvent.fire();
            }
        },

        /**
        * Default event handler for the "monitorresize" configuration property
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        * @method configMonitorResize
        */
        configMonitorResize: function (type, args, obj) {
            var monitor = args[0];
            if (monitor) {
                this.initResizeMonitor();
            } else {
                Module.textResizeEvent.unsubscribe(this.onDomResize, this, true);
                this.resizeMonitor = null;
            }
        },

        /**
         * This method is a protected helper, used when constructing the DOM structure for the module
         * to account for situations which may cause Operation Aborted errors in IE. It should not
         * be used for general DOM construction.
         * <p>
         * If the parentNode is not document.body, the element is appended as the last element.
         * </p>
         * <p>
         * If the parentNode is document.body the element is added as the first child to help
         * prevent Operation Aborted errors in IE.
         * </p>
         *
         * @param {parentNode} The HTML element to which the element will be added
         * @param {element} The HTML element to be added to parentNode's children
         * @method _addToParent
         * @protected
         */
        _addToParent: function(parentNode, element) {
            if (!this.cfg.getProperty("appendtodocumentbody") && parentNode === document.body && parentNode.firstChild) {
                parentNode.insertBefore(element, parentNode.firstChild);
            } else {
                parentNode.appendChild(element);
            }
        },

        /**
        * Returns a String representation of the Object.
        * @method toString
        * @return {String} The string representation of the Module
        */
        toString: function () {
            return "Module " + this.id;
        }
    };

    YAHOO.lang.augmentProto(Module, YAHOO.util.EventProvider);

}());
(function () {

    /**
    * Overlay is a Module that is absolutely positioned above the page flow. It
    * has convenience methods for positioning and sizing, as well as options for
    * controlling zIndex and constraining the Overlay's position to the current
    * visible viewport. Overlay also contains a dynamicly generated IFRAME which
    * is placed beneath it for Internet Explorer 6 and 5.x so that it will be
    * properly rendered above SELECT elements.
    * @namespace YAHOO.widget
    * @class Overlay
    * @extends YAHOO.widget.Module
    * @param {String} el The element ID representing the Overlay <em>OR</em>
    * @param {HTMLElement} el The element representing the Overlay
    * @param {Object} userConfig The configuration object literal containing
    * the configuration that should be set for this Overlay. See configuration
    * documentation for more details.
    * @constructor
    */
    YAHOO.widget.Overlay = function (el, userConfig) {
        YAHOO.widget.Overlay.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = YAHOO.lang,
        CustomEvent = YAHOO.util.CustomEvent,
        Module = YAHOO.widget.Module,
        Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        UA = YAHOO.env.ua,
        Overlay = YAHOO.widget.Overlay,

        _SUBSCRIBE = "subscribe",
        _UNSUBSCRIBE = "unsubscribe",
        _CONTAINED = "contained",

        m_oIFrameTemplate,

        /**
        * Constant representing the name of the Overlay's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "BEFORE_MOVE": "beforeMove",
            "MOVE": "move"
        },

        /**
        * Constant representing the Overlay's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "X": {
                key: "x",
                validator: Lang.isNumber,
                suppressEvent: true,
                supercedes: ["iframe"]
            },

            "Y": {
                key: "y",
                validator: Lang.isNumber,
                suppressEvent: true,
                supercedes: ["iframe"]
            },

            "XY": {
                key: "xy",
                suppressEvent: true,
                supercedes: ["iframe"]
            },

            "CONTEXT": {
                key: "context",
                suppressEvent: true,
                supercedes: ["iframe"]
            },

            "FIXED_CENTER": {
                key: "fixedcenter",
                value: false,
                supercedes: ["iframe", "visible"]
            },

            "WIDTH": {
                key: "width",
                suppressEvent: true,
                supercedes: ["context", "fixedcenter", "iframe"]
            },

            "HEIGHT": {
                key: "height",
                suppressEvent: true,
                supercedes: ["context", "fixedcenter", "iframe"]
            },

            "AUTO_FILL_HEIGHT" : {
                key: "autofillheight",
                supercedes: ["height"],
                value:"body"
            },

            "ZINDEX": {
                key: "zindex",
                value: null
            },

            "CONSTRAIN_TO_VIEWPORT": {
                key: "constraintoviewport",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["iframe", "x", "y", "xy"]
            },

            "IFRAME": {
                key: "iframe",
                value: (UA.ie == 6 ? true : false),
                validator: Lang.isBoolean,
                supercedes: ["zindex"]
            },

            "PREVENT_CONTEXT_OVERLAP": {
                key: "preventcontextoverlap",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["constraintoviewport"]
            }

        };

    /**
    * The URL that will be placed in the iframe
    * @property YAHOO.widget.Overlay.IFRAME_SRC
    * @static
    * @final
    * @type String
    */
    Overlay.IFRAME_SRC = "javascript:false;";

    /**
    * Number representing how much the iframe shim should be offset from each
    * side of an Overlay instance, in pixels.
    * @property YAHOO.widget.Overlay.IFRAME_SRC
    * @default 3
    * @static
    * @final
    * @type Number
    */
    Overlay.IFRAME_OFFSET = 3;

    /**
    * Number representing the minimum distance an Overlay instance should be
    * positioned relative to the boundaries of the browser's viewport, in pixels.
    * @property YAHOO.widget.Overlay.VIEWPORT_OFFSET
    * @default 10
    * @static
    * @final
    * @type Number
    */
    Overlay.VIEWPORT_OFFSET = 10;

    /**
    * Constant representing the top left corner of an element, used for
    * configuring the context element alignment
    * @property YAHOO.widget.Overlay.TOP_LEFT
    * @static
    * @final
    * @type String
    */
    Overlay.TOP_LEFT = "tl";

    /**
    * Constant representing the top right corner of an element, used for
    * configuring the context element alignment
    * @property YAHOO.widget.Overlay.TOP_RIGHT
    * @static
    * @final
    * @type String
    */
    Overlay.TOP_RIGHT = "tr";

    /**
    * Constant representing the top bottom left corner of an element, used for
    * configuring the context element alignment
    * @property YAHOO.widget.Overlay.BOTTOM_LEFT
    * @static
    * @final
    * @type String
    */
    Overlay.BOTTOM_LEFT = "bl";

    /**
    * Constant representing the bottom right corner of an element, used for
    * configuring the context element alignment
    * @property YAHOO.widget.Overlay.BOTTOM_RIGHT
    * @static
    * @final
    * @type String
    */
    Overlay.BOTTOM_RIGHT = "br";

    Overlay.PREVENT_OVERLAP_X = {
        "tltr": true,
        "blbr": true,
        "brbl": true,
        "trtl": true
    };

    Overlay.PREVENT_OVERLAP_Y = {
        "trbr": true,
        "tlbl": true,
        "bltl": true,
        "brtr": true
    };

    /**
    * Constant representing the default CSS class used for an Overlay
    * @property YAHOO.widget.Overlay.CSS_OVERLAY
    * @static
    * @final
    * @type String
    */
    Overlay.CSS_OVERLAY = "yui-overlay";

    /**
    * Constant representing the default hidden CSS class used for an Overlay. This class is
    * applied to the overlay's outer DIV whenever it's hidden.
    *
    * @property YAHOO.widget.Overlay.CSS_HIDDEN
    * @static
    * @final
    * @type String
    */
    Overlay.CSS_HIDDEN = "yui-overlay-hidden";

    /**
    * Constant representing the default CSS class used for an Overlay iframe shim.
    *
    * @property YAHOO.widget.Overlay.CSS_IFRAME
    * @static
    * @final
    * @type String
    */
    Overlay.CSS_IFRAME = "yui-overlay-iframe";

    /**
     * Constant representing the names of the standard module elements
     * used in the overlay.
     * @property YAHOO.widget.Overlay.STD_MOD_RE
     * @static
     * @final
     * @type RegExp
     */
    Overlay.STD_MOD_RE = /^\s*?(body|footer|header)\s*?$/i;

    /**
    * A singleton CustomEvent used for reacting to the DOM event for
    * window scroll
    * @event YAHOO.widget.Overlay.windowScrollEvent
    */
    Overlay.windowScrollEvent = new CustomEvent("windowScroll");

    /**
    * A singleton CustomEvent used for reacting to the DOM event for
    * window resize
    * @event YAHOO.widget.Overlay.windowResizeEvent
    */
    Overlay.windowResizeEvent = new CustomEvent("windowResize");

    /**
    * The DOM event handler used to fire the CustomEvent for window scroll
    * @method YAHOO.widget.Overlay.windowScrollHandler
    * @static
    * @param {DOMEvent} e The DOM scroll event
    */
    Overlay.windowScrollHandler = function (e) {
        var t = Event.getTarget(e);

        if (!t || t === window || t === window.document) {
            if (UA.ie) {

                if (! window.scrollEnd) {
                    window.scrollEnd = -1;
                }

                clearTimeout(window.scrollEnd);

                window.scrollEnd = setTimeout(function () {
                    Overlay.windowScrollEvent.fire();
                }, 1);

            } else {
                Overlay.windowScrollEvent.fire();
            }
        }
    };

    /**
    * The DOM event handler used to fire the CustomEvent for window resize
    * @method YAHOO.widget.Overlay.windowResizeHandler
    * @static
    * @param {DOMEvent} e The DOM resize event
    */
    Overlay.windowResizeHandler = function (e) {

        if (UA.ie) {
            if (! window.resizeEnd) {
                window.resizeEnd = -1;
            }

            clearTimeout(window.resizeEnd);

            window.resizeEnd = setTimeout(function () {
                Overlay.windowResizeEvent.fire();
            }, 100);
        } else {
            Overlay.windowResizeEvent.fire();
        }
    };

    /**
    * A boolean that indicated whether the window resize and scroll events have
    * already been subscribed to.
    * @property YAHOO.widget.Overlay._initialized
    * @private
    * @type Boolean
    */
    Overlay._initialized = null;

    if (Overlay._initialized === null) {
        Event.on(window, "scroll", Overlay.windowScrollHandler);
        Event.on(window, "resize", Overlay.windowResizeHandler);
        Overlay._initialized = true;
    }

    /**
     * Internal map of special event types, which are provided
     * by the instance. It maps the event type to the custom event
     * instance. Contains entries for the "windowScroll", "windowResize" and
     * "textResize" static container events.
     *
     * @property YAHOO.widget.Overlay._TRIGGER_MAP
     * @type Object
     * @static
     * @private
     */
    Overlay._TRIGGER_MAP = {
        "windowScroll" : Overlay.windowScrollEvent,
        "windowResize" : Overlay.windowResizeEvent,
        "textResize"   : Module.textResizeEvent
    };

    YAHOO.extend(Overlay, Module, {

        /**
         * <p>
         * Array of default event types which will trigger
         * context alignment for the Overlay class.
         * </p>
         * <p>The array is empty by default for Overlay,
         * but maybe populated in future releases, so classes extending
         * Overlay which need to define their own set of CONTEXT_TRIGGERS
         * should concatenate their super class's prototype.CONTEXT_TRIGGERS
         * value with their own array of values.
         * </p>
         * <p>
         * E.g.:
         * <code>CustomOverlay.prototype.CONTEXT_TRIGGERS = YAHOO.widget.Overlay.prototype.CONTEXT_TRIGGERS.concat(["windowScroll"]);</code>
         * </p>
         *
         * @property CONTEXT_TRIGGERS
         * @type Array
         * @final
         */
        CONTEXT_TRIGGERS : [],

        /**
        * The Overlay initialization method, which is executed for Overlay and
        * all of its subclasses. This method is automatically called by the
        * constructor, and  sets up all DOM references for pre-existing markup,
        * and creates required markup if it is not already present.
        * @method init
        * @param {String} el The element ID representing the Overlay <em>OR</em>
        * @param {HTMLElement} el The element representing the Overlay
        * @param {Object} userConfig The configuration object literal
        * containing the configuration that should be set for this Overlay.
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            /*
                 Note that we don't pass the user config in here yet because we
                 only want it executed once, at the lowest subclass level
            */

            Overlay.superclass.init.call(this, el/*, userConfig*/);

            this.beforeInitEvent.fire(Overlay);

            Dom.addClass(this.element, Overlay.CSS_OVERLAY);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            if (this.platform == "mac" && UA.gecko) {

                if (! Config.alreadySubscribed(this.showEvent,
                    this.showMacGeckoScrollbars, this)) {

                    this.showEvent.subscribe(this.showMacGeckoScrollbars,
                        this, true);

                }

                if (! Config.alreadySubscribed(this.hideEvent,
                    this.hideMacGeckoScrollbars, this)) {

                    this.hideEvent.subscribe(this.hideMacGeckoScrollbars,
                        this, true);

                }
            }

            this.initEvent.fire(Overlay);
        },

        /**
        * Initializes the custom events for Overlay which are fired
        * automatically at appropriate times by the Overlay class.
        * @method initEvents
        */
        initEvents: function () {

            Overlay.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired before the Overlay is moved.
            * @event beforeMoveEvent
            * @param {Number} x x coordinate
            * @param {Number} y y coordinate
            */
            this.beforeMoveEvent = this.createEvent(EVENT_TYPES.BEFORE_MOVE);
            this.beforeMoveEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the Overlay is moved.
            * @event moveEvent
            * @param {Number} x x coordinate
            * @param {Number} y y coordinate
            */
            this.moveEvent = this.createEvent(EVENT_TYPES.MOVE);
            this.moveEvent.signature = SIGNATURE;

        },

        /**
        * Initializes the class's configurable properties which can be changed
        * using the Overlay's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {

            Overlay.superclass.initDefaultConfig.call(this);

            var cfg = this.cfg;


            /**
            * The absolute x-coordinate position of the Overlay
            * @config x
            * @type Number
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.X.key, {

                handler: this.configX,
                validator: DEFAULT_CONFIG.X.validator,
                suppressEvent: DEFAULT_CONFIG.X.suppressEvent,
                supercedes: DEFAULT_CONFIG.X.supercedes

            });

            /**
            * The absolute y-coordinate position of the Overlay
            * @config y
            * @type Number
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.Y.key, {

                handler: this.configY,
                validator: DEFAULT_CONFIG.Y.validator,
                suppressEvent: DEFAULT_CONFIG.Y.suppressEvent,
                supercedes: DEFAULT_CONFIG.Y.supercedes

            });

            /**
            * An array with the absolute x and y positions of the Overlay
            * @config xy
            * @type Number[]
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.XY.key, {
                handler: this.configXY,
                suppressEvent: DEFAULT_CONFIG.XY.suppressEvent,
                supercedes: DEFAULT_CONFIG.XY.supercedes
            });

            /**
            * <p>
            * The array of context arguments for context-sensitive positioning.
            * </p>
            *
            * <p>
            * The format of the array is: <code>[contextElementOrId, overlayCorner, contextCorner, arrayOfTriggerEvents (optional), xyOffset (optional)]</code>, the
            * the 5 array elements described in detail below:
            * </p>
            *
            * <dl>
            * <dt>contextElementOrId &#60;String|HTMLElement&#62;</dt>
            * <dd>A reference to the context element to which the overlay should be aligned (or it's id).</dd>
            * <dt>overlayCorner &#60;String&#62;</dt>
            * <dd>The corner of the overlay which is to be used for alignment. This corner will be aligned to the
            * corner of the context element defined by the "contextCorner" entry which follows. Supported string values are:
            * "tr" (top right), "tl" (top left), "br" (bottom right), or "bl" (bottom left).</dd>
            * <dt>contextCorner &#60;String&#62;</dt>
            * <dd>The corner of the context element which is to be used for alignment. Supported string values are the same ones listed for the "overlayCorner" entry above.</dd>
            * <dt>arrayOfTriggerEvents (optional) &#60;Array[String|CustomEvent]&#62;</dt>
            * <dd>
            * <p>
            * By default, context alignment is a one time operation, aligning the Overlay to the context element when context configuration property is set, or when the <a href="#method_align">align</a>
            * method is invoked. However, you can use the optional "arrayOfTriggerEvents" entry to define the list of events which should force the overlay to re-align itself with the context element.
            * This is useful in situations where the layout of the document may change, resulting in the context element's position being modified.
            * </p>
            * <p>
            * The array can contain either event type strings for events the instance publishes (e.g. "beforeShow") or CustomEvent instances. Additionally the following
            * 3 static container event types are also currently supported : <code>"windowResize", "windowScroll", "textResize"</code> (defined in <a href="#property__TRIGGER_MAP">_TRIGGER_MAP</a> private property).
            * </p>
            * </dd>
            * <dt>xyOffset &#60;Number[]&#62;</dt>
            * <dd>
            * A 2 element Array specifying the X and Y pixel amounts by which the Overlay should be offset from the aligned corner. e.g. [5,0] offsets the Overlay 5 pixels to the left, <em>after</em> aligning the given context corners.
            * NOTE: If using this property and no triggers need to be defined, the arrayOfTriggerEvents property should be set to null to maintain correct array positions for the arguments.
            * </dd>
            * </dl>
            *
            * <p>
            * For example, setting this property to <code>["img1", "tl", "bl"]</code> will
            * align the Overlay's top left corner to the bottom left corner of the
            * context element with id "img1".
            * </p>
            * <p>
            * Setting this property to <code>["img1", "tl", "bl", null, [0,5]</code> will
            * align the Overlay's top left corner to the bottom left corner of the
            * context element with id "img1", and then offset it by 5 pixels on the Y axis (providing a 5 pixel gap between the bottom of the context element and top of the overlay).
            * </p>
            * <p>
            * Adding the optional trigger values: <code>["img1", "tl", "bl", ["beforeShow", "windowResize"], [0,5]]</code>,
            * will re-align the overlay position, whenever the "beforeShow" or "windowResize" events are fired.
            * </p>
            *
            * @config context
            * @type Array
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.CONTEXT.key, {
                handler: this.configContext,
                suppressEvent: DEFAULT_CONFIG.CONTEXT.suppressEvent,
                supercedes: DEFAULT_CONFIG.CONTEXT.supercedes
            });

            /**
            * Determines whether or not the Overlay should be anchored
            * to the center of the viewport.
            *
            * <p>This property can be set to:</p>
            *
            * <dl>
            * <dt>true</dt>
            * <dd>
            * To enable fixed center positioning
            * <p>
            * When enabled, the overlay will
            * be positioned in the center of viewport when initially displayed, and
            * will remain in the center of the viewport whenever the window is
            * scrolled or resized.
            * </p>
            * <p>
            * If the overlay is too big for the viewport,
            * it's top left corner will be aligned with the top left corner of the viewport.
            * </p>
            * </dd>
            * <dt>false</dt>
            * <dd>
            * To disable fixed center positioning.
            * <p>In this case the overlay can still be
            * centered as a one-off operation, by invoking the <code>center()</code> method,
            * however it will not remain centered when the window is scrolled/resized.
            * </dd>
            * <dt>"contained"<dt>
            * <dd>To enable fixed center positioning, as with the <code>true</code> option.
            * <p>However, unlike setting the property to <code>true</code>,
            * when the property is set to <code>"contained"</code>, if the overlay is
            * too big for the viewport, it will not get automatically centered when the
            * user scrolls or resizes the window (until the window is large enough to contain the
            * overlay). This is useful in cases where the Overlay has both header and footer
            * UI controls which the user may need to access.
            * </p>
            * </dd>
            * </dl>
            *
            * @config fixedcenter
            * @type Boolean | String
            * @default false
            */
            cfg.addProperty(DEFAULT_CONFIG.FIXED_CENTER.key, {
                handler: this.configFixedCenter,
                value: DEFAULT_CONFIG.FIXED_CENTER.value,
                validator: DEFAULT_CONFIG.FIXED_CENTER.validator,
                supercedes: DEFAULT_CONFIG.FIXED_CENTER.supercedes
            });

            /**
            * CSS width of the Overlay.
            * @config width
            * @type String
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.WIDTH.key, {
                handler: this.configWidth,
                suppressEvent: DEFAULT_CONFIG.WIDTH.suppressEvent,
                supercedes: DEFAULT_CONFIG.WIDTH.supercedes
            });

            /**
            * CSS height of the Overlay.
            * @config height
            * @type String
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.HEIGHT.key, {
                handler: this.configHeight,
                suppressEvent: DEFAULT_CONFIG.HEIGHT.suppressEvent,
                supercedes: DEFAULT_CONFIG.HEIGHT.supercedes
            });

            /**
            * Standard module element which should auto fill out the height of the Overlay if the height config property is set.
            * Supported values are "header", "body", "footer".
            *
            * @config autofillheight
            * @type String
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.AUTO_FILL_HEIGHT.key, {
                handler: this.configAutoFillHeight,
                value : DEFAULT_CONFIG.AUTO_FILL_HEIGHT.value,
                validator : this._validateAutoFill,
                supercedes: DEFAULT_CONFIG.AUTO_FILL_HEIGHT.supercedes
            });

            /**
            * CSS z-index of the Overlay.
            * @config zIndex
            * @type Number
            * @default null
            */
            cfg.addProperty(DEFAULT_CONFIG.ZINDEX.key, {
                handler: this.configzIndex,
                value: DEFAULT_CONFIG.ZINDEX.value
            });

            /**
            * True if the Overlay should be prevented from being positioned
            * out of the viewport.
            * @config constraintoviewport
            * @type Boolean
            * @default false
            */
            cfg.addProperty(DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.key, {

                handler: this.configConstrainToViewport,
                value: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.value,
                validator: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.validator,
                supercedes: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.supercedes

            });

            /**
            * @config iframe
            * @description Boolean indicating whether or not the Overlay should
            * have an IFRAME shim; used to prevent SELECT elements from
            * poking through an Overlay instance in IE6.  When set to "true",
            * the iframe shim is created when the Overlay instance is intially
            * made visible.
            * @type Boolean
            * @default true for IE6 and below, false for all other browsers.
            */
            cfg.addProperty(DEFAULT_CONFIG.IFRAME.key, {

                handler: this.configIframe,
                value: DEFAULT_CONFIG.IFRAME.value,
                validator: DEFAULT_CONFIG.IFRAME.validator,
                supercedes: DEFAULT_CONFIG.IFRAME.supercedes

            });

            /**
            * @config preventcontextoverlap
            * @description Boolean indicating whether or not the Overlay should overlap its
            * context element (defined using the "context" configuration property) when the
            * "constraintoviewport" configuration property is set to "true".
            * @type Boolean
            * @default false
            */
            cfg.addProperty(DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.key, {
                value: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.value,
                validator: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.validator,
                supercedes: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.supercedes
            });
        },

        /**
        * Moves the Overlay to the specified position. This function is
        * identical to calling this.cfg.setProperty("xy", [x,y]);
        * @method moveTo
        * @param {Number} x The Overlay's new x position
        * @param {Number} y The Overlay's new y position
        */
        moveTo: function (x, y) {
            this.cfg.setProperty("xy", [x, y]);
        },

        /**
        * Adds a CSS class ("hide-scrollbars") and removes a CSS class
        * ("show-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X
        * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
        * @method hideMacGeckoScrollbars
        */
        hideMacGeckoScrollbars: function () {
            Dom.replaceClass(this.element, "show-scrollbars", "hide-scrollbars");
        },

        /**
        * Adds a CSS class ("show-scrollbars") and removes a CSS class
        * ("hide-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X
        * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
        * @method showMacGeckoScrollbars
        */
        showMacGeckoScrollbars: function () {
            Dom.replaceClass(this.element, "hide-scrollbars", "show-scrollbars");
        },

        /**
         * Internal implementation to set the visibility of the overlay in the DOM.
         *
         * @method _setDomVisibility
         * @param {boolean} visible Whether to show or hide the Overlay's outer element
         * @protected
         */
        _setDomVisibility : function(show) {
            Dom.setStyle(this.element, "visibility", (show) ? "visible" : "hidden");
            var hiddenClass = Overlay.CSS_HIDDEN;

            if (show) {
                Dom.removeClass(this.element, hiddenClass);
            } else {
                Dom.addClass(this.element, hiddenClass);
            }
        },

        /**
        * The default event handler fired when the "visible" property is
        * changed.  This method is responsible for firing showEvent
        * and hideEvent.
        * @method configVisible
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configVisible: function (type, args, obj) {

            var visible = args[0],
                currentVis = Dom.getStyle(this.element, "visibility"),
                effect = this.cfg.getProperty("effect"),
                effectInstances = [],
                isMacGecko = (this.platform == "mac" && UA.gecko),
                alreadySubscribed = Config.alreadySubscribed,
                eff, ei, e, i, j, k, h,
                nEffects,
                nEffectInstances;

            if (currentVis == "inherit") {
                e = this.element.parentNode;

                while (e.nodeType != 9 && e.nodeType != 11) {
                    currentVis = Dom.getStyle(e, "visibility");

                    if (currentVis != "inherit") {
                        break;
                    }

                    e = e.parentNode;
                }

                if (currentVis == "inherit") {
                    currentVis = "visible";
                }
            }

            if (effect) {
                if (effect instanceof Array) {
                    nEffects = effect.length;

                    for (i = 0; i < nEffects; i++) {
                        eff = effect[i];
                        effectInstances[effectInstances.length] =
                            eff.effect(this, eff.duration);

                    }
                } else {
                    effectInstances[effectInstances.length] =
                        effect.effect(this, effect.duration);
                }
            }

            if (visible) { // Show
                if (isMacGecko) {
                    this.showMacGeckoScrollbars();
                }

                if (effect) { // Animate in
                    if (visible) { // Animate in if not showing
                        if (currentVis != "visible" || currentVis === "") {
                            this.beforeShowEvent.fire();
                            nEffectInstances = effectInstances.length;

                            for (j = 0; j < nEffectInstances; j++) {
                                ei = effectInstances[j];
                                if (j === 0 && !alreadySubscribed(
                                        ei.animateInCompleteEvent,
                                        this.showEvent.fire, this.showEvent)) {

                                    /*
                                         Delegate showEvent until end
                                         of animateInComplete
                                    */

                                    ei.animateInCompleteEvent.subscribe(
                                     this.showEvent.fire, this.showEvent, true);
                                }
                                ei.animateIn();
                            }
                        }
                    }
                } else { // Show
                    if (currentVis != "visible" || currentVis === "") {
                        this.beforeShowEvent.fire();

                        this._setDomVisibility(true);

                        this.cfg.refireEvent("iframe");
                        this.showEvent.fire();
                    } else {
                        this._setDomVisibility(true);
                    }
                }
            } else { // Hide

                if (isMacGecko) {
                    this.hideMacGeckoScrollbars();
                }

                if (effect) { // Animate out if showing
                    if (currentVis == "visible") {
                        this.beforeHideEvent.fire();

                        nEffectInstances = effectInstances.length;
                        for (k = 0; k < nEffectInstances; k++) {
                            h = effectInstances[k];

                            if (k === 0 && !alreadySubscribed(
                                h.animateOutCompleteEvent, this.hideEvent.fire,
                                this.hideEvent)) {

                                /*
                                     Delegate hideEvent until end
                                     of animateOutComplete
                                */

                                h.animateOutCompleteEvent.subscribe(
                                    this.hideEvent.fire, this.hideEvent, true);

                            }
                            h.animateOut();
                        }

                    } else if (currentVis === "") {
                        this._setDomVisibility(false);
                    }

                } else { // Simple hide

                    if (currentVis == "visible" || currentVis === "") {
                        this.beforeHideEvent.fire();
                        this._setDomVisibility(false);
                        this.hideEvent.fire();
                    } else {
                        this._setDomVisibility(false);
                    }
                }
            }
        },

        /**
        * Fixed center event handler used for centering on scroll/resize, but only if
        * the overlay is visible and, if "fixedcenter" is set to "contained", only if
        * the overlay fits within the viewport.
        *
        * @method doCenterOnDOMEvent
        */
        doCenterOnDOMEvent: function () {
            var cfg = this.cfg,
                fc = cfg.getProperty("fixedcenter");

            if (cfg.getProperty("visible")) {
                if (fc && (fc !== _CONTAINED || this.fitsInViewport())) {
                    this.center();
                }
            }
        },

        /**
         * Determines if the Overlay (including the offset value defined by Overlay.VIEWPORT_OFFSET)
         * will fit entirely inside the viewport, in both dimensions - width and height.
         *
         * @method fitsInViewport
         * @return boolean true if the Overlay will fit, false if not
         */
        fitsInViewport : function() {
            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                element = this.element,
                elementWidth = element.offsetWidth,
                elementHeight = element.offsetHeight,
                viewportWidth = Dom.getViewportWidth(),
                viewportHeight = Dom.getViewportHeight();

            return ((elementWidth + nViewportOffset < viewportWidth) && (elementHeight + nViewportOffset < viewportHeight));
        },

        /**
        * The default event handler fired when the "fixedcenter" property
        * is changed.
        * @method configFixedCenter
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configFixedCenter: function (type, args, obj) {

            var val = args[0],
                alreadySubscribed = Config.alreadySubscribed,
                windowResizeEvent = Overlay.windowResizeEvent,
                windowScrollEvent = Overlay.windowScrollEvent;

            if (val) {
                this.center();

                if (!alreadySubscribed(this.beforeShowEvent, this.center)) {
                    this.beforeShowEvent.subscribe(this.center);
                }

                if (!alreadySubscribed(windowResizeEvent, this.doCenterOnDOMEvent, this)) {
                    windowResizeEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

                if (!alreadySubscribed(windowScrollEvent, this.doCenterOnDOMEvent, this)) {
                    windowScrollEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

            } else {
                this.beforeShowEvent.unsubscribe(this.center);

                windowResizeEvent.unsubscribe(this.doCenterOnDOMEvent, this);
                windowScrollEvent.unsubscribe(this.doCenterOnDOMEvent, this);
            }
        },

        /**
        * The default event handler fired when the "height" property is changed.
        * @method configHeight
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configHeight: function (type, args, obj) {

            var height = args[0],
                el = this.element;

            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
        },

        /**
         * The default event handler fired when the "autofillheight" property is changed.
         * @method configAutoFillHeight
         *
         * @param {String} type The CustomEvent type (usually the property name)
         * @param {Object[]} args The CustomEvent arguments. For configuration
         * handlers, args[0] will equal the newly applied value for the property.
         * @param {Object} obj The scope object. For configuration handlers,
         * this will usually equal the owner.
         */
        configAutoFillHeight: function (type, args, obj) {
            var fillEl = args[0],
                cfg = this.cfg,
                autoFillHeight = "autofillheight",
                height = "height",
                currEl = cfg.getProperty(autoFillHeight),
                autoFill = this._autoFillOnHeightChange;

            cfg.unsubscribeFromConfigEvent(height, autoFill);
            Module.textResizeEvent.unsubscribe(autoFill);
            this.changeContentEvent.unsubscribe(autoFill);

            if (currEl && fillEl !== currEl && this[currEl]) {
                Dom.setStyle(this[currEl], height, "");
            }

            if (fillEl) {
                fillEl = Lang.trim(fillEl.toLowerCase());

                cfg.subscribeToConfigEvent(height, autoFill, this[fillEl], this);
                Module.textResizeEvent.subscribe(autoFill, this[fillEl], this);
                this.changeContentEvent.subscribe(autoFill, this[fillEl], this);

                cfg.setProperty(autoFillHeight, fillEl, true);
            }
        },

        /**
        * The default event handler fired when the "width" property is changed.
        * @method configWidth
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configWidth: function (type, args, obj) {

            var width = args[0],
                el = this.element;

            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");
        },

        /**
        * The default event handler fired when the "zIndex" property is changed.
        * @method configzIndex
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configzIndex: function (type, args, obj) {

            var zIndex = args[0],
                el = this.element;

            if (! zIndex) {
                zIndex = Dom.getStyle(el, "zIndex");
                if (! zIndex || isNaN(zIndex)) {
                    zIndex = 0;
                }
            }

            if (this.iframe || this.cfg.getProperty("iframe") === true) {
                if (zIndex <= 0) {
                    zIndex = 1;
                }
            }

            Dom.setStyle(el, "zIndex", zIndex);
            this.cfg.setProperty("zIndex", zIndex, true);

            if (this.iframe) {
                this.stackIframe();
            }
        },

        /**
        * The default event handler fired when the "xy" property is changed.
        * @method configXY
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configXY: function (type, args, obj) {

            var pos = args[0],
                x = pos[0],
                y = pos[1];

            this.cfg.setProperty("x", x);
            this.cfg.setProperty("y", y);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");


            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
        * The default event handler fired when the "x" property is changed.
        * @method configX
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configX: function (type, args, obj) {

            var x = args[0],
                y = this.cfg.getProperty("y");

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");

            Dom.setX(this.element, x, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
        * The default event handler fired when the "y" property is changed.
        * @method configY
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configY: function (type, args, obj) {

            var x = this.cfg.getProperty("x"),
                y = args[0];

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");

            Dom.setY(this.element, y, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
        * Shows the iframe shim, if it has been enabled.
        * @method showIframe
        */
        showIframe: function () {

            var oIFrame = this.iframe,
                oParentNode;

            if (oIFrame) {
                oParentNode = this.element.parentNode;

                if (oParentNode != oIFrame.parentNode) {
                    this._addToParent(oParentNode, oIFrame);
                }
                oIFrame.style.display = "block";
            }
        },

        /**
        * Hides the iframe shim, if it has been enabled.
        * @method hideIframe
        */
        hideIframe: function () {
            if (this.iframe) {
                this.iframe.style.display = "none";
            }
        },

        /**
        * Syncronizes the size and position of iframe shim to that of its
        * corresponding Overlay instance.
        * @method syncIframe
        */
        syncIframe: function () {

            var oIFrame = this.iframe,
                oElement = this.element,
                nOffset = Overlay.IFRAME_OFFSET,
                nDimensionOffset = (nOffset * 2),
                aXY;

            if (oIFrame) {
                oIFrame.style.width = (oElement.offsetWidth + nDimensionOffset + "px");
                oIFrame.style.height = (oElement.offsetHeight + nDimensionOffset + "px");

                aXY = this.cfg.getProperty("xy");

                if (!Lang.isArray(aXY) || (isNaN(aXY[0]) || isNaN(aXY[1]))) {
                    this.syncPosition();
                    aXY = this.cfg.getProperty("xy");
                }
                Dom.setXY(oIFrame, [(aXY[0] - nOffset), (aXY[1] - nOffset)]);
            }
        },

        /**
         * Sets the zindex of the iframe shim, if it exists, based on the zindex of
         * the Overlay element. The zindex of the iframe is set to be one less
         * than the Overlay element's zindex.
         *
         * <p>NOTE: This method will not bump up the zindex of the Overlay element
         * to ensure that the iframe shim has a non-negative zindex.
         * If you require the iframe zindex to be 0 or higher, the zindex of
         * the Overlay element should be set to a value greater than 0, before
         * this method is called.
         * </p>
         * @method stackIframe
         */
        stackIframe: function () {
            if (this.iframe) {
                var overlayZ = Dom.getStyle(this.element, "zIndex");
                if (!YAHOO.lang.isUndefined(overlayZ) && !isNaN(overlayZ)) {
                    Dom.setStyle(this.iframe, "zIndex", (overlayZ - 1));
                }
            }
        },

        /**
        * The default event handler fired when the "iframe" property is changed.
        * @method configIframe
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configIframe: function (type, args, obj) {

            var bIFrame = args[0];

            function createIFrame() {

                var oIFrame = this.iframe,
                    oElement = this.element,
                    oParent;

                if (!oIFrame) {
                    if (!m_oIFrameTemplate) {
                        m_oIFrameTemplate = document.createElement("iframe");

                        if (this.isSecure) {
                            m_oIFrameTemplate.src = Overlay.IFRAME_SRC;
                        }

                        /*
                            Set the opacity of the <iframe> to 0 so that it
                            doesn't modify the opacity of any transparent
                            elements that may be on top of it (like a shadow).
                        */
                        if (UA.ie) {
                            m_oIFrameTemplate.style.filter = "alpha(opacity=0)";
                            /*
                                 Need to set the "frameBorder" property to 0
                                 supress the default <iframe> border in IE.
                                 Setting the CSS "border" property alone
                                 doesn't supress it.
                            */
                            m_oIFrameTemplate.frameBorder = 0;
                        }
                        else {
                            m_oIFrameTemplate.style.opacity = "0";
                        }

                        m_oIFrameTemplate.style.position = "absolute";
                        m_oIFrameTemplate.style.border = "none";
                        m_oIFrameTemplate.style.margin = "0";
                        m_oIFrameTemplate.style.padding = "0";
                        m_oIFrameTemplate.style.display = "none";
                        m_oIFrameTemplate.tabIndex = -1;
                        m_oIFrameTemplate.className = Overlay.CSS_IFRAME;
                    }

                    oIFrame = m_oIFrameTemplate.cloneNode(false);
                    oIFrame.id = this.id + "_f";
                    oParent = oElement.parentNode;

                    var parentNode = oParent || document.body;

                    this._addToParent(parentNode, oIFrame);
                    this.iframe = oIFrame;
                }

                /*
                     Show the <iframe> before positioning it since the "setXY"
                     method of DOM requires the element be in the document
                     and visible.
                */
                this.showIframe();

                /*
                     Syncronize the size and position of the <iframe> to that
                     of the Overlay.
                */
                this.syncIframe();
                this.stackIframe();

                if (!this._hasIframeEventListeners) {
                    this.showEvent.subscribe(this.showIframe);
                    this.hideEvent.subscribe(this.hideIframe);
                    this.changeContentEvent.subscribe(this.syncIframe);

                    this._hasIframeEventListeners = true;
                }
            }

            function onBeforeShow() {
                createIFrame.call(this);
                this.beforeShowEvent.unsubscribe(onBeforeShow);
                this._iframeDeferred = false;
            }

            if (bIFrame) { // <iframe> shim is enabled

                if (this.cfg.getProperty("visible")) {
                    createIFrame.call(this);
                } else {
                    if (!this._iframeDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._iframeDeferred = true;
                    }
                }

            } else {    // <iframe> shim is disabled
                this.hideIframe();

                if (this._hasIframeEventListeners) {
                    this.showEvent.unsubscribe(this.showIframe);
                    this.hideEvent.unsubscribe(this.hideIframe);
                    this.changeContentEvent.unsubscribe(this.syncIframe);

                    this._hasIframeEventListeners = false;
                }
            }
        },

        /**
         * Set's the container's XY value from DOM if not already set.
         *
         * Differs from syncPosition, in that the XY value is only sync'd with DOM if
         * not already set. The method also refire's the XY config property event, so any
         * beforeMove, Move event listeners are invoked.
         *
         * @method _primeXYFromDOM
         * @protected
         */
        _primeXYFromDOM : function() {
            if (YAHOO.lang.isUndefined(this.cfg.getProperty("xy"))) {
                this.syncPosition();
                this.cfg.refireEvent("xy");
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
            }
        },

        /**
        * The default event handler fired when the "constraintoviewport"
        * property is changed.
        * @method configConstrainToViewport
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for
        * the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configConstrainToViewport: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (! Config.alreadySubscribed(this.beforeMoveEvent, this.enforceConstraints, this)) {
                    this.beforeMoveEvent.subscribe(this.enforceConstraints, this, true);
                }
                if (! Config.alreadySubscribed(this.beforeShowEvent, this._primeXYFromDOM)) {
                    this.beforeShowEvent.subscribe(this._primeXYFromDOM);
                }
            } else {
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
                this.beforeMoveEvent.unsubscribe(this.enforceConstraints, this);
            }
        },

         /**
        * The default event handler fired when the "context" property
        * is changed.
        *
        * @method configContext
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configContext: function (type, args, obj) {

            var contextArgs = args[0],
                contextEl,
                elementMagnetCorner,
                contextMagnetCorner,
                triggers,
                offset,
                defTriggers = this.CONTEXT_TRIGGERS;

            if (contextArgs) {

                contextEl = contextArgs[0];
                elementMagnetCorner = contextArgs[1];
                contextMagnetCorner = contextArgs[2];
                triggers = contextArgs[3];
                offset = contextArgs[4];

                if (defTriggers && defTriggers.length > 0) {
                    triggers = (triggers || []).concat(defTriggers);
                }

                if (contextEl) {
                    if (typeof contextEl == "string") {
                        this.cfg.setProperty("context", [
                                document.getElementById(contextEl),
                                elementMagnetCorner,
                                contextMagnetCorner,
                                triggers,
                                offset],
                                true);
                    }

                    if (elementMagnetCorner && contextMagnetCorner) {
                        this.align(elementMagnetCorner, contextMagnetCorner, offset);
                    }

                    if (this._contextTriggers) {
                        this._processTriggers(this._contextTriggers, _UNSUBSCRIBE, this._alignOnTrigger);
                    }

                    if (triggers) {
                        this._processTriggers(triggers, _SUBSCRIBE, this._alignOnTrigger);
                        this._contextTriggers = triggers;
                    }
                }
            }
        },

        /**
         * Custom Event handler for context alignment triggers. Invokes the align method
         *
         * @method _alignOnTrigger
         * @protected
         *
         * @param {String} type The event type (not used by the default implementation)
         * @param {Any[]} args The array of arguments for the trigger event (not used by the default implementation)
         */
        _alignOnTrigger: function(type, args) {
            this.align();
        },

        /**
         * Helper method to locate the custom event instance for the event name string
         * passed in. As a convenience measure, any custom events passed in are returned.
         *
         * @method _findTriggerCE
         * @private
         *
         * @param {String|CustomEvent} t Either a CustomEvent, or event type (e.g. "windowScroll") for which a
         * custom event instance needs to be looked up from the Overlay._TRIGGER_MAP.
         */
        _findTriggerCE : function(t) {
            var tce = null;
            if (t instanceof CustomEvent) {
                tce = t;
            } else if (Overlay._TRIGGER_MAP[t]) {
                tce = Overlay._TRIGGER_MAP[t];
            }
            return tce;
        },

        /**
         * Utility method that subscribes or unsubscribes the given
         * function from the list of trigger events provided.
         *
         * @method _processTriggers
         * @protected
         *
         * @param {Array[String|CustomEvent]} triggers An array of either CustomEvents, event type strings
         * (e.g. "beforeShow", "windowScroll") to/from which the provided function should be
         * subscribed/unsubscribed respectively.
         *
         * @param {String} mode Either "subscribe" or "unsubscribe", specifying whether or not
         * we are subscribing or unsubscribing trigger listeners
         *
         * @param {Function} fn The function to be subscribed/unsubscribed to/from the trigger event.
         * Context is always set to the overlay instance, and no additional object argument
         * get passed to the subscribed function.
         */
        _processTriggers : function(triggers, mode, fn) {
            var t, tce;

            for (var i = 0, l = triggers.length; i < l; ++i) {
                t = triggers[i];
                tce = this._findTriggerCE(t);
                if (tce) {
                    tce[mode](fn, this, true);
                } else {
                    this[mode](t, fn);
                }
            }
        },

        /**
        * Aligns the Overlay to its context element using the specified corner
        * points (represented by the constants TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT,
        * and BOTTOM_RIGHT.
        * @method align
        * @param {String} elementAlign  The String representing the corner of
        * the Overlay that should be aligned to the context element
        * @param {String} contextAlign  The corner of the context element
        * that the elementAlign corner should stick to.
        * @param {Number[]} xyOffset Optional. A 2 element array specifying the x and y pixel offsets which should be applied
        * after aligning the element and context corners. For example, passing in [5, -10] for this value, would offset the
        * Overlay by 5 pixels along the X axis (horizontally) and -10 pixels along the Y axis (vertically) after aligning the specified corners.
        */
        align: function (elementAlign, contextAlign, xyOffset) {

            var contextArgs = this.cfg.getProperty("context"),
                me = this,
                context,
                element,
                contextRegion;

            function doAlign(v, h) {

                var alignX = null, alignY = null;

                switch (elementAlign) {

                    case Overlay.TOP_LEFT:
                        alignX = h;
                        alignY = v;
                        break;

                    case Overlay.TOP_RIGHT:
                        alignX = h - element.offsetWidth;
                        alignY = v;
                        break;

                    case Overlay.BOTTOM_LEFT:
                        alignX = h;
                        alignY = v - element.offsetHeight;
                        break;

                    case Overlay.BOTTOM_RIGHT:
                        alignX = h - element.offsetWidth;
                        alignY = v - element.offsetHeight;
                        break;
                }

                if (alignX !== null && alignY !== null) {
                    if (xyOffset) {
                        alignX += xyOffset[0];
                        alignY += xyOffset[1];
                    }
                    me.moveTo(alignX, alignY);
                }
            }

            if (contextArgs) {
                context = contextArgs[0];
                element = this.element;
                me = this;

                if (! elementAlign) {
                    elementAlign = contextArgs[1];
                }

                if (! contextAlign) {
                    contextAlign = contextArgs[2];
                }

                if (!xyOffset && contextArgs[4]) {
                    xyOffset = contextArgs[4];
                }

                if (element && context) {
                    contextRegion = Dom.getRegion(context);

                    switch (contextAlign) {

                        case Overlay.TOP_LEFT:
                            doAlign(contextRegion.top, contextRegion.left);
                            break;

                        case Overlay.TOP_RIGHT:
                            doAlign(contextRegion.top, contextRegion.right);
                            break;

                        case Overlay.BOTTOM_LEFT:
                            doAlign(contextRegion.bottom, contextRegion.left);
                            break;

                        case Overlay.BOTTOM_RIGHT:
                            doAlign(contextRegion.bottom, contextRegion.right);
                            break;
                    }
                }
            }
        },

        /**
        * The default event handler executed when the moveEvent is fired, if the
        * "constraintoviewport" is set to true.
        * @method enforceConstraints
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        enforceConstraints: function (type, args, obj) {
            var pos = args[0];

            var cXY = this.getConstrainedXY(pos[0], pos[1]);
            this.cfg.setProperty("x", cXY[0], true);
            this.cfg.setProperty("y", cXY[1], true);
            this.cfg.setProperty("xy", cXY, true);
        },

        /**
         * Shared implementation method for getConstrainedX and getConstrainedY.
         *
         * <p>
         * Given a coordinate value, returns the calculated coordinate required to
         * position the Overlay if it is to be constrained to the viewport, based on the
         * current element size, viewport dimensions, scroll values and preventoverlap
         * settings
         * </p>
         *
         * @method _getConstrainedPos
         * @protected
         * @param {String} pos The coordinate which needs to be constrained, either "x" or "y"
         * @param {Number} The coordinate value which needs to be constrained
         * @return {Number} The constrained coordinate value
         */
        _getConstrainedPos: function(pos, val) {

            var overlayEl = this.element,

                buffer = Overlay.VIEWPORT_OFFSET,

                x = (pos == "x"),

                overlaySize      = (x) ? overlayEl.offsetWidth : overlayEl.offsetHeight,
                viewportSize     = (x) ? Dom.getViewportWidth() : Dom.getViewportHeight(),
                docScroll        = (x) ? Dom.getDocumentScrollLeft() : Dom.getDocumentScrollTop(),
                overlapPositions = (x) ? Overlay.PREVENT_OVERLAP_X : Overlay.PREVENT_OVERLAP_Y,

                context = this.cfg.getProperty("context"),

                bOverlayFitsInViewport = (overlaySize + buffer < viewportSize),
                bPreventContextOverlap = this.cfg.getProperty("preventcontextoverlap") && context && overlapPositions[(context[1] + context[2])],

                minConstraint = docScroll + buffer,
                maxConstraint = docScroll + viewportSize - overlaySize - buffer,

                constrainedVal = val;

            if (val < minConstraint || val > maxConstraint) {
                if (bPreventContextOverlap) {
                    constrainedVal = this._preventOverlap(pos, context[0], overlaySize, viewportSize, docScroll);
                } else {
                    if (bOverlayFitsInViewport) {
                        if (val < minConstraint) {
                            constrainedVal = minConstraint;
                        } else if (val > maxConstraint) {
                            constrainedVal = maxConstraint;
                        }
                    } else {
                        constrainedVal = minConstraint;
                    }
                }
            }

            return constrainedVal;
        },

        /**
         * Helper method, used to position the Overlap to prevent overlap with the
         * context element (used when preventcontextoverlap is enabled)
         *
         * @method _preventOverlap
         * @protected
         * @param {String} pos The coordinate to prevent overlap for, either "x" or "y".
         * @param {HTMLElement} contextEl The context element
         * @param {Number} overlaySize The related overlay dimension value (for "x", the width, for "y", the height)
         * @param {Number} viewportSize The related viewport dimension value (for "x", the width, for "y", the height)
         * @param {Object} docScroll  The related document scroll value (for "x", the scrollLeft, for "y", the scrollTop)
         *
         * @return {Number} The new coordinate value which was set to prevent overlap
         */
        _preventOverlap : function(pos, contextEl, overlaySize, viewportSize, docScroll) {

            var x = (pos == "x"),

                buffer = Overlay.VIEWPORT_OFFSET,

                overlay = this,

                contextElPos   = ((x) ? Dom.getX(contextEl) : Dom.getY(contextEl)) - docScroll,
                contextElSize  = (x) ? contextEl.offsetWidth : contextEl.offsetHeight,

                minRegionSize = contextElPos - buffer,
                maxRegionSize = (viewportSize - (contextElPos + contextElSize)) - buffer,

                bFlipped = false,

                flip = function () {
                    var flippedVal;

                    if ((overlay.cfg.getProperty(pos) - docScroll) > contextElPos) {
                        flippedVal = (contextElPos - overlaySize);
                    } else {
                        flippedVal = (contextElPos + contextElSize);
                    }

                    overlay.cfg.setProperty(pos, (flippedVal + docScroll), true);

                    return flippedVal;
                },

                setPosition = function () {

                    var displayRegionSize = ((overlay.cfg.getProperty(pos) - docScroll) > contextElPos) ? maxRegionSize : minRegionSize,
                        position;

                    if (overlaySize > displayRegionSize) {
                        if (bFlipped) {
                            /*
                                 All possible positions and values have been
                                 tried, but none were successful, so fall back
                                 to the original size and position.
                            */
                            flip();
                        } else {
                            flip();
                            bFlipped = true;
                            position = setPosition();
                        }
                    }

                    return position;
                };

            setPosition();

            return this.cfg.getProperty(pos);
        },

        /**
         * Given x coordinate value, returns the calculated x coordinate required to
         * position the Overlay if it is to be constrained to the viewport, based on the
         * current element size, viewport dimensions and scroll values.
         *
         * @param {Number} x The X coordinate value to be constrained
         * @return {Number} The constrained x coordinate
         */
        getConstrainedX: function (x) {
            return this._getConstrainedPos("x", x);
        },

        /**
         * Given y coordinate value, returns the calculated y coordinate required to
         * position the Overlay if it is to be constrained to the viewport, based on the
         * current element size, viewport dimensions and scroll values.
         *
         * @param {Number} y The Y coordinate value to be constrained
         * @return {Number} The constrained y coordinate
         */
        getConstrainedY : function (y) {
            return this._getConstrainedPos("y", y);
        },

        /**
         * Given x, y coordinate values, returns the calculated coordinates required to
         * position the Overlay if it is to be constrained to the viewport, based on the
         * current element size, viewport dimensions and scroll values.
         *
         * @param {Number} x The X coordinate value to be constrained
         * @param {Number} y The Y coordinate value to be constrained
         * @return {Array} The constrained x and y coordinates at index 0 and 1 respectively;
         */
        getConstrainedXY: function(x, y) {
            return [this.getConstrainedX(x), this.getConstrainedY(y)];
        },

        /**
        * Centers the container in the viewport.
        * @method center
        */
        center: function () {

            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                elementWidth = this.element.offsetWidth,
                elementHeight = this.element.offsetHeight,
                viewPortWidth = Dom.getViewportWidth(),
                viewPortHeight = Dom.getViewportHeight(),
                x,
                y;

            if (elementWidth < viewPortWidth) {
                x = (viewPortWidth / 2) - (elementWidth / 2) + Dom.getDocumentScrollLeft();
            } else {
                x = nViewportOffset + Dom.getDocumentScrollLeft();
            }

            if (elementHeight < viewPortHeight) {
                y = (viewPortHeight / 2) - (elementHeight / 2) + Dom.getDocumentScrollTop();
            } else {
                y = nViewportOffset + Dom.getDocumentScrollTop();
            }

            this.cfg.setProperty("xy", [parseInt(x, 10), parseInt(y, 10)]);
            this.cfg.refireEvent("iframe");

            if (UA.webkit) {
                this.forceContainerRedraw();
            }
        },

        /**
        * Synchronizes the Panel's "xy", "x", and "y" properties with the
        * Panel's position in the DOM. This is primarily used to update
        * position information during drag & drop.
        * @method syncPosition
        */
        syncPosition: function () {

            var pos = Dom.getXY(this.element);

            this.cfg.setProperty("x", pos[0], true);
            this.cfg.setProperty("y", pos[1], true);
            this.cfg.setProperty("xy", pos, true);

        },

        /**
        * Event handler fired when the resize monitor element is resized.
        * @method onDomResize
        * @param {DOMEvent} e The resize DOM event
        * @param {Object} obj The scope object
        */
        onDomResize: function (e, obj) {

            var me = this;

            Overlay.superclass.onDomResize.call(this, e, obj);

            setTimeout(function () {
                me.syncPosition();
                me.cfg.refireEvent("iframe");
                me.cfg.refireEvent("context");
            }, 0);
        },

        /**
         * Determines the content box height of the given element (height of the element, without padding or borders) in pixels.
         *
         * @method _getComputedHeight
         * @private
         * @param {HTMLElement} el The element for which the content height needs to be determined
         * @return {Number} The content box height of the given element, or null if it could not be determined.
         */
        _getComputedHeight : (function() {

            if (document.defaultView && document.defaultView.getComputedStyle) {
                return function(el) {
                    var height = null;
                    if (el.ownerDocument && el.ownerDocument.defaultView) {
                        var computed = el.ownerDocument.defaultView.getComputedStyle(el, '');
                        if (computed) {
                            height = parseInt(computed.height, 10);
                        }
                    }
                    return (Lang.isNumber(height)) ? height : null;
                };
            } else {
                return function(el) {
                    var height = null;
                    if (el.style.pixelHeight) {
                        height = el.style.pixelHeight;
                    }
                    return (Lang.isNumber(height)) ? height : null;
                };
            }
        })(),

        /**
         * autofillheight validator. Verifies that the autofill value is either null
         * or one of the strings : "body", "header" or "footer".
         *
         * @method _validateAutoFillHeight
         * @protected
         * @param {String} val
         * @return true, if valid, false otherwise
         */
        _validateAutoFillHeight : function(val) {
            return (!val) || (Lang.isString(val) && Overlay.STD_MOD_RE.test(val));
        },

        /**
         * The default custom event handler executed when the overlay's height is changed,
         * if the autofillheight property has been set.
         *
         * @method _autoFillOnHeightChange
         * @protected
         * @param {String} type The event type
         * @param {Array} args The array of arguments passed to event subscribers
         * @param {HTMLElement} el The header, body or footer element which is to be resized to fill
         * out the containers height
         */
        _autoFillOnHeightChange : function(type, args, el) {
            var height = this.cfg.getProperty("height");
            if ((height && height !== "auto") || (height === 0)) {
                this.fillHeight(el);
            }
        },

        /**
         * Returns the sub-pixel height of the el, using getBoundingClientRect, if available,
         * otherwise returns the offsetHeight
         * @method _getPreciseHeight
         * @private
         * @param {HTMLElement} el
         * @return {Float} The sub-pixel height if supported by the browser, else the rounded height.
         */
        _getPreciseHeight : function(el) {
            var height = el.offsetHeight;

            if (el.getBoundingClientRect) {
                var rect = el.getBoundingClientRect();
                height = rect.bottom - rect.top;
            }

            return height;
        },

        /**
         * <p>
         * Sets the height on the provided header, body or footer element to
         * fill out the height of the container. It determines the height of the
         * containers content box, based on it's configured height value, and
         * sets the height of the autofillheight element to fill out any
         * space remaining after the other standard module element heights
         * have been accounted for.
         * </p>
         * <p><strong>NOTE:</strong> This method is not designed to work if an explicit
         * height has not been set on the container, since for an "auto" height container,
         * the heights of the header/body/footer will drive the height of the container.</p>
         *
         * @method fillHeight
         * @param {HTMLElement} el The element which should be resized to fill out the height
         * of the container element.
         */
        fillHeight : function(el) {
            if (el) {
                var container = this.innerElement || this.element,
                    containerEls = [this.header, this.body, this.footer],
                    containerEl,
                    total = 0,
                    filled = 0,
                    remaining = 0,
                    validEl = false;

                for (var i = 0, l = containerEls.length; i < l; i++) {
                    containerEl = containerEls[i];
                    if (containerEl) {
                        if (el !== containerEl) {
                            filled += this._getPreciseHeight(containerEl);
                        } else {
                            validEl = true;
                        }
                    }
                }

                if (validEl) {

                    if (UA.ie || UA.opera) {
                        Dom.setStyle(el, 'height', 0 + 'px');
                    }

                    total = this._getComputedHeight(container);

                    if (total === null) {
                        Dom.addClass(container, "yui-override-padding");
                        total = container.clientHeight; // Content, No Border, 0 Padding (set by yui-override-padding)
                        Dom.removeClass(container, "yui-override-padding");
                    }

                    remaining = Math.max(total - filled, 0);

                    Dom.setStyle(el, "height", remaining + "px");

                    if (el.offsetHeight != remaining) {
                        remaining = Math.max(remaining - (el.offsetHeight - remaining), 0);
                    }
                    Dom.setStyle(el, "height", remaining + "px");
                }
            }
        },

        /**
        * Places the Overlay on top of all other instances of
        * YAHOO.widget.Overlay.
        * @method bringToTop
        */
        bringToTop: function () {

            var aOverlays = [],
                oElement = this.element;

            function compareZIndexDesc(p_oOverlay1, p_oOverlay2) {

                var sZIndex1 = Dom.getStyle(p_oOverlay1, "zIndex"),
                    sZIndex2 = Dom.getStyle(p_oOverlay2, "zIndex"),

                    nZIndex1 = (!sZIndex1 || isNaN(sZIndex1)) ? 0 : parseInt(sZIndex1, 10),
                    nZIndex2 = (!sZIndex2 || isNaN(sZIndex2)) ? 0 : parseInt(sZIndex2, 10);

                if (nZIndex1 > nZIndex2) {
                    return -1;
                } else if (nZIndex1 < nZIndex2) {
                    return 1;
                } else {
                    return 0;
                }
            }

            function isOverlayElement(p_oElement) {

                var isOverlay = Dom.hasClass(p_oElement, Overlay.CSS_OVERLAY),
                    Panel = YAHOO.widget.Panel;

                if (isOverlay && !Dom.isAncestor(oElement, p_oElement)) {
                    if (Panel && Dom.hasClass(p_oElement, Panel.CSS_PANEL)) {
                        aOverlays[aOverlays.length] = p_oElement.parentNode;
                    } else {
                        aOverlays[aOverlays.length] = p_oElement;
                    }
                }
            }

            Dom.getElementsBy(isOverlayElement, "DIV", document.body);

            aOverlays.sort(compareZIndexDesc);

            var oTopOverlay = aOverlays[0],
                nTopZIndex;

            if (oTopOverlay) {
                nTopZIndex = Dom.getStyle(oTopOverlay, "zIndex");

                if (!isNaN(nTopZIndex)) {
                    var bRequiresBump = false;

                    if (oTopOverlay != oElement) {
                        bRequiresBump = true;
                    } else if (aOverlays.length > 1) {
                        var nNextZIndex = Dom.getStyle(aOverlays[1], "zIndex");
                        if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                            bRequiresBump = true;
                        }
                    }
                    if (bRequiresBump) {
                        this.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                    }
                }
            }
        },

        /**
        * Removes the Overlay element from the DOM and sets all child
        * elements to null.
        * @method destroy
        */
        destroy: function () {

            if (this.iframe) {
                this.iframe.parentNode.removeChild(this.iframe);
            }

            this.iframe = null;

            Overlay.windowResizeEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);

            Overlay.windowScrollEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);

            Module.textResizeEvent.unsubscribe(this._autoFillOnHeightChange);

            if (this._contextTriggers) {
                this._processTriggers(this._contextTriggers, _UNSUBSCRIBE, this._alignOnTrigger);
            }

            Overlay.superclass.destroy.call(this);
        },

        /**
         * Can be used to force the container to repaint/redraw it's contents.
         * <p>
         * By default applies and then removes a 1px bottom margin through the
         * application/removal of a "yui-force-redraw" class.
         * </p>
         * <p>
         * It is currently used by Overlay to force a repaint for webkit
         * browsers, when centering.
         * </p>
         * @method forceContainerRedraw
         */
        forceContainerRedraw : function() {
            var c = this;
            Dom.addClass(c.element, "yui-force-redraw");
            setTimeout(function() {
                Dom.removeClass(c.element, "yui-force-redraw");
            }, 0);
        },

        /**
        * Returns a String representation of the object.
        * @method toString
        * @return {String} The string representation of the Overlay.
        */
        toString: function () {
            return "Overlay " + this.id;
        }

    });
}());
(function () {

    /**
    * OverlayManager is used for maintaining the focus status of
    * multiple Overlays.
    * @namespace YAHOO.widget
    * @namespace YAHOO.widget
    * @class OverlayManager
    * @constructor
    * @param {Array} overlays Optional. A collection of Overlays to register
    * with the manager.
    * @param {Object} userConfig  The object literal representing the user
    * configuration of the OverlayManager
    */
    YAHOO.widget.OverlayManager = function (userConfig) {
        this.init(userConfig);
    };

    var Overlay = YAHOO.widget.Overlay,
        Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        CustomEvent = YAHOO.util.CustomEvent,
        OverlayManager = YAHOO.widget.OverlayManager;

    /**
    * The CSS class representing a focused Overlay
    * @property OverlayManager.CSS_FOCUSED
    * @static
    * @final
    * @type String
    */
    OverlayManager.CSS_FOCUSED = "focused";

    OverlayManager.prototype = {

        /**
        * The class's constructor function
        * @property contructor
        * @type Function
        */
        constructor: OverlayManager,

        /**
        * The array of Overlays that are currently registered
        * @property overlays
        * @type YAHOO.widget.Overlay[]
        */
        overlays: null,

        /**
        * Initializes the default configuration of the OverlayManager
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
            /**
            * The collection of registered Overlays in use by
            * the OverlayManager
            * @config overlays
            * @type YAHOO.widget.Overlay[]
            * @default null
            */
            this.cfg.addProperty("overlays", { suppressEvent: true } );

            /**
            * The default DOM event that should be used to focus an Overlay
            * @config focusevent
            * @type String
            * @default "mousedown"
            */
            this.cfg.addProperty("focusevent", { value: "mousedown" } );
        },

        /**
        * Initializes the OverlayManager
        * @method init
        * @param {Overlay[]} overlays Optional. A collection of Overlays to
        * register with the manager.
        * @param {Object} userConfig  The object literal representing the user
        * configuration of the OverlayManager
        */
        init: function (userConfig) {

            /**
            * The OverlayManager's Config object used for monitoring
            * configuration properties.
            * @property cfg
            * @type Config
            */
            this.cfg = new Config(this);

            this.initDefaultConfig();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
            this.cfg.fireQueue();

            /**
            * The currently activated Overlay
            * @property activeOverlay
            * @private
            * @type YAHOO.widget.Overlay
            */
            var activeOverlay = null;

            /**
            * Returns the currently focused Overlay
            * @method getActive
            * @return {Overlay} The currently focused Overlay
            */
            this.getActive = function () {
                return activeOverlay;
            };

            /**
            * Focuses the specified Overlay
            * @method focus
            * @param {Overlay} overlay The Overlay to focus
            * @param {String} overlay The id of the Overlay to focus
            */
            this.focus = function (overlay) {
                var o = this.find(overlay);
                if (o) {
                    o.focus();
                }
            };

            /**
            * Removes the specified Overlay from the manager
            * @method remove
            * @param {Overlay} overlay The Overlay to remove
            * @param {String} overlay The id of the Overlay to remove
            */
            this.remove = function (overlay) {

                var o = this.find(overlay),
                        originalZ;

                if (o) {
                    if (activeOverlay == o) {
                        activeOverlay = null;
                    }

                    var bDestroyed = (o.element === null && o.cfg === null) ? true : false;

                    if (!bDestroyed) {
                        originalZ = Dom.getStyle(o.element, "zIndex");
                        o.cfg.setProperty("zIndex", -1000, true);
                    }

                    this.overlays.sort(this.compareZIndexDesc);
                    this.overlays = this.overlays.slice(0, (this.overlays.length - 1));

                    o.hideEvent.unsubscribe(o.blur);
                    o.destroyEvent.unsubscribe(this._onOverlayDestroy, o);
                    o.focusEvent.unsubscribe(this._onOverlayFocusHandler, o);
                    o.blurEvent.unsubscribe(this._onOverlayBlurHandler, o);

                    if (!bDestroyed) {
                        Event.removeListener(o.element, this.cfg.getProperty("focusevent"), this._onOverlayElementFocus);
                        o.cfg.setProperty("zIndex", originalZ, true);
                        o.cfg.setProperty("manager", null);
                    }

                    /* _managed Flag for custom or existing. Don't want to remove existing */
                    if (o.focusEvent._managed) { o.focusEvent = null; }
                    if (o.blurEvent._managed) { o.blurEvent = null; }

                    if (o.focus._managed) { o.focus = null; }
                    if (o.blur._managed) { o.blur = null; }
                }
            };

            /**
            * Removes focus from all registered Overlays in the manager
            * @method blurAll
            */
            this.blurAll = function () {

                var nOverlays = this.overlays.length,
                    i;

                if (nOverlays > 0) {
                    i = nOverlays - 1;
                    do {
                        this.overlays[i].blur();
                    }
                    while(i--);
                }
            };

            /**
             * Updates the state of the OverlayManager and overlay, as a result of the overlay
             * being blurred.
             *
             * @method _manageBlur
             * @param {Overlay} overlay The overlay instance which got blurred.
             * @protected
             */
            this._manageBlur = function (overlay) {
                var changed = false;
                if (activeOverlay == overlay) {
                    Dom.removeClass(activeOverlay.element, OverlayManager.CSS_FOCUSED);
                    activeOverlay = null;
                    changed = true;
                }
                return changed;
            };

            /**
             * Updates the state of the OverlayManager and overlay, as a result of the overlay
             * receiving focus.
             *
             * @method _manageFocus
             * @param {Overlay} overlay The overlay instance which got focus.
             * @protected
             */
            this._manageFocus = function(overlay) {
                var changed = false;
                if (activeOverlay != overlay) {
                    if (activeOverlay) {
                        activeOverlay.blur();
                    }
                    activeOverlay = overlay;
                    this.bringToTop(activeOverlay);
                    Dom.addClass(activeOverlay.element, OverlayManager.CSS_FOCUSED);
                    changed = true;
                }
                return changed;
            };

            var overlays = this.cfg.getProperty("overlays");

            if (! this.overlays) {
                this.overlays = [];
            }

            if (overlays) {
                this.register(overlays);
                this.overlays.sort(this.compareZIndexDesc);
            }
        },

        /**
        * @method _onOverlayElementFocus
        * @description Event handler for the DOM event that is used to focus
        * the Overlay instance as specified by the "focusevent"
        * configuration property.
        * @private
        * @param {Event} p_oEvent Object representing the DOM event
        * object passed back by the event utility (Event).
        */
        _onOverlayElementFocus: function (p_oEvent) {

            var oTarget = Event.getTarget(p_oEvent),
                oClose = this.close;

            if (oClose && (oTarget == oClose || Dom.isAncestor(oClose, oTarget))) {
                this.blur();
            } else {
                this.focus();
            }
        },

        /**
        * @method _onOverlayDestroy
        * @description "destroy" event handler for the Overlay.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        * @param {Overlay} p_oOverlay Object representing the overlay that
        * fired the event.
        */
        _onOverlayDestroy: function (p_sType, p_aArgs, p_oOverlay) {
            this.remove(p_oOverlay);
        },

        /**
        * @method _onOverlayFocusHandler
        *
        * @description focusEvent Handler, used to delegate to _manageFocus with the correct arguments.
        *
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        * @param {Overlay} p_oOverlay Object representing the overlay that
        * fired the event.
        */
        _onOverlayFocusHandler: function(p_sType, p_aArgs, p_oOverlay) {
            this._manageFocus(p_oOverlay);
        },

        /**
        * @method _onOverlayBlurHandler
        * @description blurEvent Handler, used to delegate to _manageBlur with the correct arguments.
        *
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        * @param {Overlay} p_oOverlay Object representing the overlay that
        * fired the event.
        */
        _onOverlayBlurHandler: function(p_sType, p_aArgs, p_oOverlay) {
            this._manageBlur(p_oOverlay);
        },

        /**
         * Subscribes to the Overlay based instance focusEvent, to allow the OverlayManager to
         * monitor focus state.
         *
         * If the instance already has a focusEvent (e.g. Menu), OverlayManager will subscribe
         * to the existing focusEvent, however if a focusEvent or focus method does not exist
         * on the instance, the _bindFocus method will add them, and the focus method will
         * update the OverlayManager's state directly.
         *
         * @method _bindFocus
         * @param {Overlay} overlay The overlay for which focus needs to be managed
         * @protected
         */
        _bindFocus : function(overlay) {
            var mgr = this;

            if (!overlay.focusEvent) {
                overlay.focusEvent = overlay.createEvent("focus");
                overlay.focusEvent.signature = CustomEvent.LIST;
                overlay.focusEvent._managed = true;
            } else {
                overlay.focusEvent.subscribe(mgr._onOverlayFocusHandler, overlay, mgr);
            }

            if (!overlay.focus) {
                Event.on(overlay.element, mgr.cfg.getProperty("focusevent"), mgr._onOverlayElementFocus, null, overlay);
                overlay.focus = function () {
                    if (mgr._manageFocus(this)) {
                        if (this.cfg.getProperty("visible") && this.focusFirst) {
                            this.focusFirst();
                        }
                        this.focusEvent.fire();
                    }
                };
                overlay.focus._managed = true;
            }
        },

        /**
         * Subscribes to the Overlay based instance's blurEvent to allow the OverlayManager to
         * monitor blur state.
         *
         * If the instance already has a blurEvent (e.g. Menu), OverlayManager will subscribe
         * to the existing blurEvent, however if a blurEvent or blur method does not exist
         * on the instance, the _bindBlur method will add them, and the blur method
         * update the OverlayManager's state directly.
         *
         * @method _bindBlur
         * @param {Overlay} overlay The overlay for which blur needs to be managed
         * @protected
         */
        _bindBlur : function(overlay) {
            var mgr = this;

            if (!overlay.blurEvent) {
                overlay.blurEvent = overlay.createEvent("blur");
                overlay.blurEvent.signature = CustomEvent.LIST;
                overlay.focusEvent._managed = true;
            } else {
                overlay.blurEvent.subscribe(mgr._onOverlayBlurHandler, overlay, mgr);
            }

            if (!overlay.blur) {
                overlay.blur = function () {
                    if (mgr._manageBlur(this)) {
                        this.blurEvent.fire();
                    }
                };
                overlay.blur._managed = true;
            }

            overlay.hideEvent.subscribe(overlay.blur);
        },

        /**
         * Subscribes to the Overlay based instance's destroyEvent, to allow the Overlay
         * to be removed for the OverlayManager when destroyed.
         *
         * @method _bindDestroy
         * @param {Overlay} overlay The overlay instance being managed
         * @protected
         */
        _bindDestroy : function(overlay) {
            var mgr = this;
            overlay.destroyEvent.subscribe(mgr._onOverlayDestroy, overlay, mgr);
        },

        /**
         * Ensures the zIndex configuration property on the managed overlay based instance
         * is set to the computed zIndex value from the DOM (with "auto" translating to 0).
         *
         * @method _syncZIndex
         * @param {Overlay} overlay The overlay instance being managed
         * @protected
         */
        _syncZIndex : function(overlay) {
            var zIndex = Dom.getStyle(overlay.element, "zIndex");
            if (!isNaN(zIndex)) {
                overlay.cfg.setProperty("zIndex", parseInt(zIndex, 10));
            } else {
                overlay.cfg.setProperty("zIndex", 0);
            }
        },

        /**
        * Registers an Overlay or an array of Overlays with the manager. Upon
        * registration, the Overlay receives functions for focus and blur,
        * along with CustomEvents for each.
        *
        * @method register
        * @param {Overlay} overlay  An Overlay to register with the manager.
        * @param {Overlay[]} overlay  An array of Overlays to register with
        * the manager.
        * @return {boolean} true if any Overlays are registered.
        */
        register: function (overlay) {

            var registered = false,
                i,
                n;

            if (overlay instanceof Overlay) {

                overlay.cfg.addProperty("manager", { value: this } );

                this._bindFocus(overlay);
                this._bindBlur(overlay);
                this._bindDestroy(overlay);
                this._syncZIndex(overlay);

                this.overlays.push(overlay);
                this.bringToTop(overlay);

                registered = true;

            } else if (overlay instanceof Array) {

                for (i = 0, n = overlay.length; i < n; i++) {
                    registered = this.register(overlay[i]) || registered;
                }

            }

            return registered;
        },

        /**
        * Places the specified Overlay instance on top of all other
        * Overlay instances.
        * @method bringToTop
        * @param {YAHOO.widget.Overlay} p_oOverlay Object representing an
        * Overlay instance.
        * @param {String} p_oOverlay String representing the id of an
        * Overlay instance.
        */
        bringToTop: function (p_oOverlay) {

            var oOverlay = this.find(p_oOverlay),
                nTopZIndex,
                oTopOverlay,
                aOverlays;

            if (oOverlay) {

                aOverlays = this.overlays;
                aOverlays.sort(this.compareZIndexDesc);

                oTopOverlay = aOverlays[0];

                if (oTopOverlay) {
                    nTopZIndex = Dom.getStyle(oTopOverlay.element, "zIndex");

                    if (!isNaN(nTopZIndex)) {

                        var bRequiresBump = false;

                        if (oTopOverlay !== oOverlay) {
                            bRequiresBump = true;
                        } else if (aOverlays.length > 1) {
                            var nNextZIndex = Dom.getStyle(aOverlays[1].element, "zIndex");
                            if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                                bRequiresBump = true;
                            }
                        }

                        if (bRequiresBump) {
                            oOverlay.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                        }
                    }
                    aOverlays.sort(this.compareZIndexDesc);
                }
            }
        },

        /**
        * Attempts to locate an Overlay by instance or ID.
        * @method find
        * @param {Overlay} overlay  An Overlay to locate within the manager
        * @param {String} overlay  An Overlay id to locate within the manager
        * @return {Overlay} The requested Overlay, if found, or null if it
        * cannot be located.
        */
        find: function (overlay) {

            var isInstance = overlay instanceof Overlay,
                overlays = this.overlays,
                n = overlays.length,
                found = null,
                o,
                i;

            if (isInstance || typeof overlay == "string") {
                for (i = n-1; i >= 0; i--) {
                    o = overlays[i];
                    if ((isInstance && (o === overlay)) || (o.id == overlay)) {
                        found = o;
                        break;
                    }
                }
            }

            return found;
        },

        /**
        * Used for sorting the manager's Overlays by z-index.
        * @method compareZIndexDesc
        * @private
        * @return {Number} 0, 1, or -1, depending on where the Overlay should
        * fall in the stacking order.
        */
        compareZIndexDesc: function (o1, o2) {

            var zIndex1 = (o1.cfg) ? o1.cfg.getProperty("zIndex") : null, // Sort invalid (destroyed)
                zIndex2 = (o2.cfg) ? o2.cfg.getProperty("zIndex") : null; // objects at bottom.

            if (zIndex1 === null && zIndex2 === null) {
                return 0;
            } else if (zIndex1 === null){
                return 1;
            } else if (zIndex2 === null) {
                return -1;
            } else if (zIndex1 > zIndex2) {
                return -1;
            } else if (zIndex1 < zIndex2) {
                return 1;
            } else {
                return 0;
            }
        },

        /**
        * Shows all Overlays in the manager.
        * @method showAll
        */
        showAll: function () {
            var overlays = this.overlays,
                n = overlays.length,
                i;

            for (i = n - 1; i >= 0; i--) {
                overlays[i].show();
            }
        },

        /**
        * Hides all Overlays in the manager.
        * @method hideAll
        */
        hideAll: function () {
            var overlays = this.overlays,
                n = overlays.length,
                i;

            for (i = n - 1; i >= 0; i--) {
                overlays[i].hide();
            }
        },

        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the OverlayManager
        */
        toString: function () {
            return "OverlayManager";
        }
    };
}());
(function () {

    /**
    * Tooltip is an implementation of Overlay that behaves like an OS tooltip,
    * displaying when the user mouses over a particular element, and
    * disappearing on mouse out.
    * @namespace YAHOO.widget
    * @class Tooltip
    * @extends YAHOO.widget.Overlay
    * @constructor
    * @param {String} el The element ID representing the Tooltip <em>OR</em>
    * @param {HTMLElement} el The element representing the Tooltip
    * @param {Object} userConfig The configuration object literal containing
    * the configuration that should be set for this Overlay. See configuration
    * documentation for more details.
    */
    YAHOO.widget.Tooltip = function (el, userConfig) {
        YAHOO.widget.Tooltip.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Dom = YAHOO.util.Dom,
        Tooltip = YAHOO.widget.Tooltip,
        UA = YAHOO.env.ua,
        bIEQuirks = (UA.ie && (UA.ie <= 6 || document.compatMode == "BackCompat")),

        m_oShadowTemplate,

        /**
        * Constant representing the Tooltip's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "PREVENT_OVERLAP": {
                key: "preventoverlap",
                value: true,
                validator: Lang.isBoolean,
                supercedes: ["x", "y", "xy"]
            },

            "SHOW_DELAY": {
                key: "showdelay",
                value: 200,
                validator: Lang.isNumber
            },

            "AUTO_DISMISS_DELAY": {
                key: "autodismissdelay",
                value: 5000,
                validator: Lang.isNumber
            },

            "HIDE_DELAY": {
                key: "hidedelay",
                value: 250,
                validator: Lang.isNumber
            },

            "TEXT": {
                key: "text",
                suppressEvent: true
            },

            "CONTAINER": {
                key: "container"
            },

            "DISABLED": {
                key: "disabled",
                value: false,
                suppressEvent: true
            },

            "XY_OFFSET": {
                key: "xyoffset",
                value: [0, 25],
                suppressEvent: true
            }
        },

        /**
        * Constant representing the name of the Tooltip's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "CONTEXT_MOUSE_OVER": "contextMouseOver",
            "CONTEXT_MOUSE_OUT": "contextMouseOut",
            "CONTEXT_TRIGGER": "contextTrigger"
        };

    /**
    * Constant representing the Tooltip CSS class
    * @property YAHOO.widget.Tooltip.CSS_TOOLTIP
    * @static
    * @final
    * @type String
    */
    Tooltip.CSS_TOOLTIP = "yui-tt";

    function restoreOriginalWidth(sOriginalWidth, sForcedWidth) {

        var oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sForcedWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }
    }

    /*
        changeContent event handler that sets a Tooltip instance's "width"
        configuration property to the value of its root HTML
        elements's offsetWidth if a specific width has not been set.
    */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        if ("_originalWidth" in this) {
            restoreOriginalWidth.call(this, this._originalWidth, this._forcedWidth);
        }

        var oBody = document.body,
            oConfig = this.cfg,
            sOriginalWidth = oConfig.getProperty("width"),
            sNewWidth,
            oClone;

        if ((!sOriginalWidth || sOriginalWidth == "auto") &&
            (oConfig.getProperty("container") != oBody ||
            oConfig.getProperty("x") >= Dom.getViewportWidth() ||
            oConfig.getProperty("y") >= Dom.getViewportHeight())) {

            oClone = this.element.cloneNode(true);
            oClone.style.visibility = "hidden";
            oClone.style.top = "0px";
            oClone.style.left = "0px";

            oBody.appendChild(oClone);

            sNewWidth = (oClone.offsetWidth + "px");

            oBody.removeChild(oClone);
            oClone = null;

            oConfig.setProperty("width", sNewWidth);
            oConfig.refireEvent("xy");

            this._originalWidth = sOriginalWidth || "";
            this._forcedWidth = sNewWidth;
        }
    }


    function onDOMReady(p_sType, p_aArgs, p_oObject) {
        this.render(p_oObject);
    }


    function onInit() {
        Event.onDOMReady(onDOMReady, this.cfg.getProperty("container"), this);
    }

    YAHOO.extend(Tooltip, YAHOO.widget.Overlay, {

        /**
        * The Tooltip initialization method. This method is automatically
        * called by the constructor. A Tooltip is automatically rendered by
        * the init method, and it also is set to be invisible by default,
        * and constrained to viewport by default as well.
        * @method init
        * @param {String} el The element ID representing the Tooltip <em>OR</em>
        * @param {HTMLElement} el The element representing the Tooltip
        * @param {Object} userConfig The configuration object literal
        * containing the configuration that should be set for this Tooltip.
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {


            Tooltip.superclass.init.call(this, el);

            this.beforeInitEvent.fire(Tooltip);

            Dom.addClass(this.element, Tooltip.CSS_TOOLTIP);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.cfg.queueProperty("visible", false);
            this.cfg.queueProperty("constraintoviewport", true);

            this.setBody("");

            this.subscribe("changeContent", setWidthToOffsetWidth);
            this.subscribe("init", onInit);
            this.subscribe("render", this.onRender);

            this.initEvent.fire(Tooltip);
        },

        /**
        * Initializes the custom events for Tooltip
        * @method initEvents
        */
        initEvents: function () {

            Tooltip.superclass.initEvents.call(this);
            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired when user mouses over a context element. Returning false from
            * a subscriber to this event will prevent the tooltip from being displayed for
            * the current context element.
            *
            * @event contextMouseOverEvent
            * @param {HTMLElement} context The context element which the user just moused over
            * @param {DOMEvent} e The DOM event object, associated with the mouse over
            */
            this.contextMouseOverEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OVER);
            this.contextMouseOverEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired when the user mouses out of a context element.
            *
            * @event contextMouseOutEvent
            * @param {HTMLElement} context The context element which the user just moused out of
            * @param {DOMEvent} e The DOM event object, associated with the mouse out
            */
            this.contextMouseOutEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OUT);
            this.contextMouseOutEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired just before the tooltip is displayed for the current context.
            * <p>
            *  You can subscribe to this event if you need to set up the text for the
            *  tooltip based on the context element for which it is about to be displayed.
            * </p>
            * <p>This event differs from the beforeShow event in following respects:</p>
            * <ol>
            *   <li>
            *    When moving from one context element to another, if the tooltip is not
            *    hidden (the <code>hidedelay</code> is not reached), the beforeShow and Show events will not
            *    be fired when the tooltip is displayed for the new context since it is already visible.
            *    However the contextTrigger event is always fired before displaying the tooltip for
            *    a new context.
            *   </li>
            *   <li>
            *    The trigger event provides access to the context element, allowing you to
            *    set the text of the tooltip based on context element for which the tooltip is
            *    triggered.
            *   </li>
            * </ol>
            * <p>
            *  It is not possible to prevent the tooltip from being displayed
            *  using this event. You can use the contextMouseOverEvent if you need to prevent
            *  the tooltip from being displayed.
            * </p>
            * @event contextTriggerEvent
            * @param {HTMLElement} context The context element for which the tooltip is triggered
            */
            this.contextTriggerEvent = this.createEvent(EVENT_TYPES.CONTEXT_TRIGGER);
            this.contextTriggerEvent.signature = SIGNATURE;
        },

        /**
        * Initializes the class's configurable properties which can be
        * changed using the Overlay's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {

            Tooltip.superclass.initDefaultConfig.call(this);

            /**
            * Specifies whether the Tooltip should be kept from overlapping
            * its context element.
            * @config preventoverlap
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.PREVENT_OVERLAP.key, {
                value: DEFAULT_CONFIG.PREVENT_OVERLAP.value,
                validator: DEFAULT_CONFIG.PREVENT_OVERLAP.validator,
                supercedes: DEFAULT_CONFIG.PREVENT_OVERLAP.supercedes
            });

            /**
            * The number of milliseconds to wait before showing a Tooltip
            * on mouseover.
            * @config showdelay
            * @type Number
            * @default 200
            */
            this.cfg.addProperty(DEFAULT_CONFIG.SHOW_DELAY.key, {
                handler: this.configShowDelay,
                value: 200,
                validator: DEFAULT_CONFIG.SHOW_DELAY.validator
            });

            /**
            * The number of milliseconds to wait before automatically
            * dismissing a Tooltip after the mouse has been resting on the
            * context element.
            * @config autodismissdelay
            * @type Number
            * @default 5000
            */
            this.cfg.addProperty(DEFAULT_CONFIG.AUTO_DISMISS_DELAY.key, {
                handler: this.configAutoDismissDelay,
                value: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.value,
                validator: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.validator
            });

            /**
            * The number of milliseconds to wait before hiding a Tooltip
            * after mouseout.
            * @config hidedelay
            * @type Number
            * @default 250
            */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDE_DELAY.key, {
                handler: this.configHideDelay,
                value: DEFAULT_CONFIG.HIDE_DELAY.value,
                validator: DEFAULT_CONFIG.HIDE_DELAY.validator
            });

            /**
            * Specifies the Tooltip's text.
            * @config text
            * @type String
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, {
                handler: this.configText,
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent
            });

            /**
            * Specifies the container element that the Tooltip's markup
            * should be rendered into.
            * @config container
            * @type HTMLElement/String
            * @default document.body
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CONTAINER.key, {
                handler: this.configContainer,
                value: document.body
            });

            /**
            * Specifies whether or not the tooltip is disabled. Disabled tooltips
            * will not be displayed. If the tooltip is driven by the title attribute
            * of the context element, the title attribute will still be removed for
            * disabled tooltips, to prevent default tooltip behavior.
            *
            * @config disabled
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DISABLED.key, {
                handler: this.configContainer,
                value: DEFAULT_CONFIG.DISABLED.value,
                supressEvent: DEFAULT_CONFIG.DISABLED.suppressEvent
            });

            /**
            * Specifies the XY offset from the mouse position, where the tooltip should be displayed, specified
            * as a 2 element array (e.g. [10, 20]);
            *
            * @config xyoffset
            * @type Array
            * @default [0, 25]
            */
            this.cfg.addProperty(DEFAULT_CONFIG.XY_OFFSET.key, {
                value: DEFAULT_CONFIG.XY_OFFSET.value.concat(),
                supressEvent: DEFAULT_CONFIG.XY_OFFSET.suppressEvent
            });

            /**
            * Specifies the element or elements that the Tooltip should be
            * anchored to on mouseover.
            * @config context
            * @type HTMLElement[]/String[]
            * @default null
            */

            /**
            * String representing the width of the Tooltip.  <em>Please note:
            * </em> As of version 2.3 if either no value or a value of "auto"
            * is specified, and the Toolip's "container" configuration property
            * is set to something other than <code>document.body</code> or
            * its "context" element resides outside the immediately visible
            * portion of the document, the width of the Tooltip will be
            * calculated based on the offsetWidth of its root HTML and set just
            * before it is made visible.  The original value will be
            * restored when the Tooltip is hidden. This ensures the Tooltip is
            * rendered at a usable width.  For more information see
            * YUILibrary bug #1685496 and YUILibrary
            * bug #1735423.
            * @config width
            * @type String
            * @default null
            */

        },


        /**
        * The default event handler fired when the "text" property is changed.
        * @method configText
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configText: function (type, args, obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
            }
        },

        /**
        * The default event handler fired when the "container" property
        * is changed.
        * @method configContainer
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For
        * configuration handlers, args[0] will equal the newly applied value
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configContainer: function (type, args, obj) {
            var container = args[0];

            if (typeof container == 'string') {
                this.cfg.setProperty("container", document.getElementById(container), true);
            }
        },

        /**
        * @method _removeEventListeners
        * @description Removes all of the DOM event handlers from the HTML
        *  element(s) that trigger the display of the tooltip.
        * @protected
        */
        _removeEventListeners: function () {

            var aElements = this._context,
                nElements,
                oElement,
                i;

            if (aElements) {
                nElements = aElements.length;
                if (nElements > 0) {
                    i = nElements - 1;
                    do {
                        oElement = aElements[i];
                        Event.removeListener(oElement, "mouseover", this.onContextMouseOver);
                        Event.removeListener(oElement, "mousemove", this.onContextMouseMove);
                        Event.removeListener(oElement, "mouseout", this.onContextMouseOut);
                    }
                    while (i--);
                }
            }
        },

        /**
        * The default event handler fired when the "context" property
        * is changed.
        * @method configContext
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configContext: function (type, args, obj) {

            var context = args[0],
                aElements,
                nElements,
                oElement,
                i;

            if (context) {

                if (! (context instanceof Array)) {
                    if (typeof context == "string") {
                        this.cfg.setProperty("context", [document.getElementById(context)], true);
                    } else { // Assuming this is an element
                        this.cfg.setProperty("context", [context], true);
                    }
                    context = this.cfg.getProperty("context");
                }

                this._removeEventListeners();

                this._context = context;

                aElements = this._context;

                if (aElements) {
                    nElements = aElements.length;
                    if (nElements > 0) {
                        i = nElements - 1;
                        do {
                            oElement = aElements[i];
                            Event.on(oElement, "mouseover", this.onContextMouseOver, this);
                            Event.on(oElement, "mousemove", this.onContextMouseMove, this);
                            Event.on(oElement, "mouseout", this.onContextMouseOut, this);
                        }
                        while (i--);
                    }
                }
            }
        },



        /**
        * The default event handler fired when the user moves the mouse while
        * over the context element.
        * @method onContextMouseMove
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseMove: function (e, obj) {
            obj.pageX = Event.getPageX(e);
            obj.pageY = Event.getPageY(e);
        },

        /**
        * The default event handler fired when the user mouses over the
        * context element.
        * @method onContextMouseOver
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseOver: function (e, obj) {
            var context = this;

            if (context.title) {
                obj._tempTitle = context.title;
                context.title = "";
            }

            if (obj.fireEvent("contextMouseOver", context, e) !== false
                    && !obj.cfg.getProperty("disabled")) {

                if (obj.hideProcId) {
                    clearTimeout(obj.hideProcId);
                    obj.hideProcId = null;
                }

                Event.on(context, "mousemove", obj.onContextMouseMove, obj);

                /**
                * The unique process ID associated with the thread responsible
                * for showing the Tooltip.
                * @type int
                */
                obj.showProcId = obj.doShow(e, context);
            }
        },

        /**
        * The default event handler fired when the user mouses out of
        * the context element.
        * @method onContextMouseOut
        * @param {DOMEvent} e The current DOM event
        * @param {Object} obj The object argument
        */
        onContextMouseOut: function (e, obj) {
            var el = this;

            if (obj._tempTitle) {
                el.title = obj._tempTitle;
                obj._tempTitle = null;
            }

            if (obj.showProcId) {
                clearTimeout(obj.showProcId);
                obj.showProcId = null;
            }

            if (obj.hideProcId) {
                clearTimeout(obj.hideProcId);
                obj.hideProcId = null;
            }

            obj.fireEvent("contextMouseOut", el, e);

            obj.hideProcId = setTimeout(function () {
                obj.hide();
            }, obj.cfg.getProperty("hidedelay"));
        },


        /**
        * Processes the showing of the Tooltip by setting the timeout delay
        * and offset of the Tooltip.
        * @method doShow
        * @param {DOMEvent} e The current DOM event
        * @param {HTMLElement} context The current context element
        * @return {Number} The process ID of the timeout function associated
        * with doShow
        */
        doShow: function (e, context) {

            var offset = this.cfg.getProperty("xyoffset"),
                xOffset = offset[0],
                yOffset = offset[1],
                me = this;

            if (UA.opera && context.tagName &&
                context.tagName.toUpperCase() == "A") {
                yOffset += 12;
            }

            return setTimeout(function () {

                var txt = me.cfg.getProperty("text");

                if (me._tempTitle && (txt === "" || YAHOO.lang.isUndefined(txt) || YAHOO.lang.isNull(txt))) {
                    me.setBody(me._tempTitle);
                } else {
                    me.cfg.refireEvent("text");
                }

                me.moveTo(me.pageX + xOffset, me.pageY + yOffset);

                if (me.cfg.getProperty("preventoverlap")) {
                    me.preventOverlap(me.pageX, me.pageY);
                }

                Event.removeListener(context, "mousemove", me.onContextMouseMove);

                me.contextTriggerEvent.fire(context);

                me.show();

                me.hideProcId = me.doHide();

            }, this.cfg.getProperty("showdelay"));
        },

        /**
        * Sets the timeout for the auto-dismiss delay, which by default is 5
        * seconds, meaning that a tooltip will automatically dismiss itself
        * after 5 seconds of being displayed.
        * @method doHide
        */
        doHide: function () {

            var me = this;


            return setTimeout(function () {

                me.hide();

            }, this.cfg.getProperty("autodismissdelay"));

        },

        /**
        * Fired when the Tooltip is moved, this event handler is used to
        * prevent the Tooltip from overlapping with its context element.
        * @method preventOverlay
        * @param {Number} pageX The x coordinate position of the mouse pointer
        * @param {Number} pageY The y coordinate position of the mouse pointer
        */
        preventOverlap: function (pageX, pageY) {

            var height = this.element.offsetHeight,
                mousePoint = new YAHOO.util.Point(pageX, pageY),
                elementRegion = Dom.getRegion(this.element);

            elementRegion.top -= 5;
            elementRegion.left -= 5;
            elementRegion.right += 5;
            elementRegion.bottom += 5;


            if (elementRegion.contains(mousePoint)) {
                this.cfg.setProperty("y", (pageY - height - 5));
            }
        },


        /**
        * @method onRender
        * @description "render" event handler for the Tooltip.
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        onRender: function (p_sType, p_aArgs) {

            function sizeShadow() {

                var oElement = this.element,
                    oShadow = this.underlay;

                if (oShadow) {
                    oShadow.style.width = (oElement.offsetWidth + 6) + "px";
                    oShadow.style.height = (oElement.offsetHeight + 1) + "px";
                }

            }

            function addShadowVisibleClass() {
                Dom.addClass(this.underlay, "yui-tt-shadow-visible");

                if (UA.ie) {
                    this.forceUnderlayRedraw();
                }
            }

            function removeShadowVisibleClass() {
                Dom.removeClass(this.underlay, "yui-tt-shadow-visible");
            }

            function createShadow() {

                var oShadow = this.underlay,
                    oElement,
                    Module,
                    nIE,
                    me;

                if (!oShadow) {

                    oElement = this.element;
                    Module = YAHOO.widget.Module;
                    nIE = UA.ie;
                    me = this;

                    if (!m_oShadowTemplate) {
                        m_oShadowTemplate = document.createElement("div");
                        m_oShadowTemplate.className = "yui-tt-shadow";
                    }

                    oShadow = m_oShadowTemplate.cloneNode(false);

                    oElement.appendChild(oShadow);

                    this.underlay = oShadow;

                    this._shadow = this.underlay;

                    addShadowVisibleClass.call(this);

                    this.subscribe("beforeShow", addShadowVisibleClass);
                    this.subscribe("hide", removeShadowVisibleClass);

                    if (bIEQuirks) {
                        window.setTimeout(function () {
                            sizeShadow.call(me);
                        }, 0);

                        this.cfg.subscribeToConfigEvent("width", sizeShadow);
                        this.cfg.subscribeToConfigEvent("height", sizeShadow);
                        this.subscribe("changeContent", sizeShadow);

                        Module.textResizeEvent.subscribe(sizeShadow, this, true);
                        this.subscribe("destroy", function () {
                            Module.textResizeEvent.unsubscribe(sizeShadow, this);
                        });
                    }
                }
            }

            function onBeforeShow() {
                createShadow.call(this);
                this.unsubscribe("beforeShow", onBeforeShow);
            }

            if (this.cfg.getProperty("visible")) {
                createShadow.call(this);
            } else {
                this.subscribe("beforeShow", onBeforeShow);
            }

        },

        /**
         * Forces the underlay element to be repainted, through the application/removal
         * of a yui-force-redraw class to the underlay element.
         *
         * @method forceUnderlayRedraw
         */
        forceUnderlayRedraw : function() {
            var tt = this;
            Dom.addClass(tt.underlay, "yui-force-redraw");
            setTimeout(function() {Dom.removeClass(tt.underlay, "yui-force-redraw");}, 0);
        },

        /**
        * Removes the Tooltip element from the DOM and sets all child
        * elements to null.
        * @method destroy
        */
        destroy: function () {

            this._removeEventListeners();

            Tooltip.superclass.destroy.call(this);

        },

        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the Tooltip
        */
        toString: function () {
            return "Tooltip " + this.id;
        }

    });

}());
(function () {

    /**
    * Panel is an implementation of Overlay that behaves like an OS window,
    * with a draggable header and an optional close icon at the top right.
    * @namespace YAHOO.widget
    * @class Panel
    * @extends YAHOO.widget.Overlay
    * @constructor
    * @param {String} el The element ID representing the Panel <em>OR</em>
    * @param {HTMLElement} el The element representing the Panel
    * @param {Object} userConfig The configuration object literal containing
    * the configuration that should be set for this Panel. See configuration
    * documentation for more details.
    */
    YAHOO.widget.Panel = function (el, userConfig) {
        YAHOO.widget.Panel.superclass.constructor.call(this, el, userConfig);
    };

    var _currentModal = null;

    var Lang = YAHOO.lang,
        Util = YAHOO.util,
        Dom = Util.Dom,
        Event = Util.Event,
        CustomEvent = Util.CustomEvent,
        KeyListener = YAHOO.util.KeyListener,
        Config = Util.Config,
        Overlay = YAHOO.widget.Overlay,
        Panel = YAHOO.widget.Panel,
        UA = YAHOO.env.ua,

        bIEQuirks = (UA.ie && (UA.ie <= 6 || document.compatMode == "BackCompat")),

        m_oMaskTemplate,
        m_oUnderlayTemplate,
        m_oCloseIconTemplate,

        /**
        * Constant representing the name of the Panel's events
        * @property EVENT_TYPES
        * @private
        * @final
        * @type Object
        */
        EVENT_TYPES = {
            "SHOW_MASK": "showMask",
            "HIDE_MASK": "hideMask",
            "DRAG": "drag"
        },

        /**
        * Constant representing the Panel's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "CLOSE": {
                key: "close",
                value: true,
                validator: Lang.isBoolean,
                supercedes: ["visible"]
            },

            "DRAGGABLE": {
                key: "draggable",
                value: (Util.DD ? true : false),
                validator: Lang.isBoolean,
                supercedes: ["visible"]
            },

            "DRAG_ONLY" : {
                key: "dragonly",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["draggable"]
            },

            "UNDERLAY": {
                key: "underlay",
                value: "shadow",
                supercedes: ["visible"]
            },

            "MODAL": {
                key: "modal",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["visible", "zindex"]
            },

            "KEY_LISTENERS": {
                key: "keylisteners",
                suppressEvent: true,
                supercedes: ["visible"]
            },

            "STRINGS" : {
                key: "strings",
                supercedes: ["close"],
                validator: Lang.isObject,
                value: {
                    close: "Close"
                }
            }
        };

    /**
    * Constant representing the default CSS class used for a Panel
    * @property YAHOO.widget.Panel.CSS_PANEL
    * @static
    * @final
    * @type String
    */
    Panel.CSS_PANEL = "yui-panel";

    /**
    * Constant representing the default CSS class used for a Panel's
    * wrapping container
    * @property YAHOO.widget.Panel.CSS_PANEL_CONTAINER
    * @static
    * @final
    * @type String
    */
    Panel.CSS_PANEL_CONTAINER = "yui-panel-container";

    /**
     * Constant representing the default set of focusable elements
     * on the pagewhich Modal Panels will prevent access to, when
     * the modal mask is displayed
     *
     * @property YAHOO.widget.Panel.FOCUSABLE
     * @static
     * @type Array
     */
    Panel.FOCUSABLE = [
        "a",
        "button",
        "select",
        "textarea",
        "input",
        "iframe"
    ];


    /*
        "beforeRender" event handler that creates an empty header for a Panel
        instance if its "draggable" configuration property is set to "true"
        and no header has been created.
    */

    function createHeader(p_sType, p_aArgs) {
        if (!this.header && this.cfg.getProperty("draggable")) {
            this.setHeader("&#160;");
        }
    }

    /*
        "hide" event handler that sets a Panel instance's "width"
        configuration property back to its original value before
        "setWidthToOffsetWidth" was called.
    */

    function restoreOriginalWidth(p_sType, p_aArgs, p_oObject) {

        var sOriginalWidth = p_oObject[0],
            sNewWidth = p_oObject[1],
            oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sNewWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }

        this.unsubscribe("hide", restoreOriginalWidth, p_oObject);
    }

    /*
        "beforeShow" event handler that sets a Panel instance's "width"
        configuration property to the value of its root HTML
        elements's offsetWidth
    */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        var oConfig,
            sOriginalWidth,
            sNewWidth;

        if (bIEQuirks) {

            oConfig = this.cfg;
            sOriginalWidth = oConfig.getProperty("width");

            if (!sOriginalWidth || sOriginalWidth == "auto") {

                sNewWidth = (this.element.offsetWidth + "px");

                oConfig.setProperty("width", sNewWidth);

                this.subscribe("hide", restoreOriginalWidth,
                    [(sOriginalWidth || ""), sNewWidth]);

            }
        }
    }

    YAHOO.extend(Panel, Overlay, {

        /**
        * The Overlay initialization method, which is executed for Overlay and
        * all of its subclasses. This method is automatically called by the
        * constructor, and  sets up all DOM references for pre-existing markup,
        * and creates required markup if it is not already present.
        * @method init
        * @param {String} el The element ID representing the Overlay <em>OR</em>
        * @param {HTMLElement} el The element representing the Overlay
        * @param {Object} userConfig The configuration object literal
        * containing the configuration that should be set for this Overlay.
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {
            /*
                 Note that we don't pass the user config in here yet because
                 we only want it executed once, at the lowest subclass level
            */

            Panel.superclass.init.call(this, el/*, userConfig*/);

            this.beforeInitEvent.fire(Panel);

            Dom.addClass(this.element, Panel.CSS_PANEL);

            this.buildWrapper();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.subscribe("showMask", this._addFocusHandlers);
            this.subscribe("hideMask", this._removeFocusHandlers);
            this.subscribe("beforeRender", createHeader);

            this.subscribe("render", function() {
                this.setFirstLastFocusable();
                this.subscribe("changeContent", this.setFirstLastFocusable);
            });

            this.subscribe("show", this.focusFirst);

            this.initEvent.fire(Panel);
        },

        /**
         * @method _onElementFocus
         * @private
         *
         * "focus" event handler for a focuable element. Used to automatically
         * blur the element when it receives focus to ensure that a Panel
         * instance's modality is not compromised.
         *
         * @param {Event} e The DOM event object
         */
        _onElementFocus : function(e){

            if(_currentModal === this) {

                var target = Event.getTarget(e),
                    doc = document.documentElement,
                    insideDoc = (target !== doc && target !== window);

                if (insideDoc && target !== this.element && target !== this.mask && !Dom.isAncestor(this.element, target)) {
                    try {
                        if (this.firstElement) {
                            this.firstElement.focus();
                        } else {
                            if (this._modalFocus) {
                                this._modalFocus.focus();
                            } else {
                                this.innerElement.focus();
                            }
                        }
                    } catch(err){
                        try {
                            if (insideDoc && target !== document.body) {
                                target.blur();
                            }
                        } catch(err2) { }
                    }
                }
            }
        },

        /**
         *  @method _addFocusHandlers
         *  @protected
         *
         *  "showMask" event handler that adds a "focus" event handler to all
         *  focusable elements in the document to enforce a Panel instance's
         *  modality from being compromised.
         *
         *  @param p_sType {String} Custom event type
         *  @param p_aArgs {Array} Custom event arguments
         */
        _addFocusHandlers: function(p_sType, p_aArgs) {
            if (!this.firstElement) {
                if (UA.webkit || UA.opera) {
                    if (!this._modalFocus) {
                        this._createHiddenFocusElement();
                    }
                } else {
                    this.innerElement.tabIndex = 0;
                }
            }
            this.setTabLoop(this.firstElement, this.lastElement);
            Event.onFocus(document.documentElement, this._onElementFocus, this, true);
            _currentModal = this;
        },

        /**
         * Creates a hidden focusable element, used to focus on,
         * to enforce modality for browsers in which focus cannot
         * be applied to the container box.
         *
         * @method _createHiddenFocusElement
         * @private
         */
        _createHiddenFocusElement : function() {
            var e = document.createElement("button");
            e.style.height = "1px";
            e.style.width = "1px";
            e.style.position = "absolute";
            e.style.left = "-10000em";
            e.style.opacity = 0;
            e.tabIndex = -1;
            this.innerElement.appendChild(e);
            this._modalFocus = e;
        },

        /**
         *  @method _removeFocusHandlers
         *  @protected
         *
         *  "hideMask" event handler that removes all "focus" event handlers added
         *  by the "addFocusEventHandlers" method.
         *
         *  @param p_sType {String} Event type
         *  @param p_aArgs {Array} Event Arguments
         */
        _removeFocusHandlers: function(p_sType, p_aArgs) {
            Event.removeFocusListener(document.documentElement, this._onElementFocus, this);

            if (_currentModal == this) {
                _currentModal = null;
            }
        },

        /**
         * Sets focus to the first element in the Panel.
         *
         * @method focusFirst
         */
        focusFirst: function (type, args, obj) {
            var el = this.firstElement;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (el) {
                try {
                    el.focus();
                } catch(err) {
                }
            }
        },

        /**
         * Sets focus to the last element in the Panel.
         *
         * @method focusLast
         */
        focusLast: function (type, args, obj) {
            var el = this.lastElement;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (el) {
                try {
                    el.focus();
                } catch(err) {
                }
            }
        },

        /**
         * Sets up a tab, shift-tab loop between the first and last elements
         * provided. NOTE: Sets up the preventBackTab and preventTabOut KeyListener
         * instance properties, which are reset everytime this method is invoked.
         *
         * @method setTabLoop
         * @param {HTMLElement} firstElement
         * @param {HTMLElement} lastElement
         *
         */
        setTabLoop : function(firstElement, lastElement) {

            var backTab = this.preventBackTab, tab = this.preventTabOut,
                showEvent = this.showEvent, hideEvent = this.hideEvent;

            if (backTab) {
                backTab.disable();
                showEvent.unsubscribe(backTab.enable, backTab);
                hideEvent.unsubscribe(backTab.disable, backTab);
                backTab = this.preventBackTab = null;
            }

            if (tab) {
                tab.disable();
                showEvent.unsubscribe(tab.enable, tab);
                hideEvent.unsubscribe(tab.disable,tab);
                tab = this.preventTabOut = null;
            }

            if (firstElement) {
                this.preventBackTab = new KeyListener(firstElement,
                    {shift:true, keys:9},
                    {fn:this.focusLast, scope:this, correctScope:true}
                );
                backTab = this.preventBackTab;

                showEvent.subscribe(backTab.enable, backTab, true);
                hideEvent.subscribe(backTab.disable,backTab, true);
            }

            if (lastElement) {
                this.preventTabOut = new KeyListener(lastElement,
                    {shift:false, keys:9},
                    {fn:this.focusFirst, scope:this, correctScope:true}
                );
                tab = this.preventTabOut;

                showEvent.subscribe(tab.enable, tab, true);
                hideEvent.subscribe(tab.disable,tab, true);
            }
        },

        /**
         * Returns an array of the currently focusable items which reside within
         * Panel. The set of focusable elements the method looks for are defined
         * in the Panel.FOCUSABLE static property
         *
         * @method getFocusableElements
         * @param {HTMLElement} root element to start from.
         */
        getFocusableElements : function(root) {

            root = root || this.innerElement;

            var focusable = {};
            for (var i = 0; i < Panel.FOCUSABLE.length; i++) {
                focusable[Panel.FOCUSABLE[i]] = true;
            }

            function isFocusable(el) {
                if (el.focus && el.type !== "hidden" && !el.disabled && focusable[el.tagName.toLowerCase()]) {
                    return true;
                }
                return false;
            }

            return Dom.getElementsBy(isFocusable, null, root);
        },

        /**
         * Sets the firstElement and lastElement instance properties
         * to the first and last focusable elements in the Panel.
         *
         * @method setFirstLastFocusable
         */
        setFirstLastFocusable : function() {

            this.firstElement = null;
            this.lastElement = null;

            var elements = this.getFocusableElements();
            this.focusableElements = elements;

            if (elements.length > 0) {
                this.firstElement = elements[0];
                this.lastElement = elements[elements.length - 1];
            }

            if (this.cfg.getProperty("modal")) {
                this.setTabLoop(this.firstElement, this.lastElement);
            }
        },

        /**
         * Initializes the custom events for Module which are fired
         * automatically at appropriate times by the Module class.
         */
        initEvents: function () {
            Panel.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired after the modality mask is shown
            * @event showMaskEvent
            */
            this.showMaskEvent = this.createEvent(EVENT_TYPES.SHOW_MASK);
            this.showMaskEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after the modality mask is hidden
            * @event hideMaskEvent
            */
            this.hideMaskEvent = this.createEvent(EVENT_TYPES.HIDE_MASK);
            this.hideMaskEvent.signature = SIGNATURE;

            /**
            * CustomEvent when the Panel is dragged
            * @event dragEvent
            */
            this.dragEvent = this.createEvent(EVENT_TYPES.DRAG);
            this.dragEvent.signature = SIGNATURE;
        },

        /**
         * Initializes the class's configurable properties which can be changed
         * using the Panel's Config object (cfg).
         * @method initDefaultConfig
         */
        initDefaultConfig: function () {
            Panel.superclass.initDefaultConfig.call(this);


            /**
            * True if the Panel should display a "close" button
            * @config close
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.CLOSE.key, {
                handler: this.configClose,
                value: DEFAULT_CONFIG.CLOSE.value,
                validator: DEFAULT_CONFIG.CLOSE.validator,
                supercedes: DEFAULT_CONFIG.CLOSE.supercedes
            });

            /**
            * Boolean specifying if the Panel should be draggable.  The default
            * value is "true" if the Drag and Drop utility is included,
            * otherwise it is "false." <strong>PLEASE NOTE:</strong> There is a
            * known issue in IE 6 (Strict Mode and Quirks Mode) and IE 7
            * (Quirks Mode) where Panels that either don't have a value set for
            * their "width" configuration property, or their "width"
            * configuration property is set to "auto" will only be draggable by
            * placing the mouse on the text of the Panel's header element.
            * To fix this bug, draggable Panels missing a value for their
            * "width" configuration property, or whose "width" configuration
            * property is set to "auto" will have it set to the value of
            * their root HTML element's offsetWidth before they are made
            * visible.  The calculated width is then removed when the Panel is
            * hidden. <em>This fix is only applied to draggable Panels in IE 6
            * (Strict Mode and Quirks Mode) and IE 7 (Quirks Mode)</em>. For
            * more information on this issue see:
            * YUILibrary bugs #1726972 and #1589210.
            * @config draggable
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAGGABLE.key, {
                handler: this.configDraggable,
                value: (Util.DD) ? true : false,
                validator: DEFAULT_CONFIG.DRAGGABLE.validator,
                supercedes: DEFAULT_CONFIG.DRAGGABLE.supercedes
            });

            /**
            * Boolean specifying if the draggable Panel should be drag only, not interacting with drop
            * targets on the page.
            * <p>
            * When set to true, draggable Panels will not check to see if they are over drop targets,
            * or fire the DragDrop events required to support drop target interaction (onDragEnter,
            * onDragOver, onDragOut, onDragDrop etc.).
            * If the Panel is not designed to be dropped on any target elements on the page, then this
            * flag can be set to true to improve performance.
            * </p>
            * <p>
            * When set to false, all drop target related events will be fired.
            * </p>
            * <p>
            * The property is set to false by default to maintain backwards compatibility but should be
            * set to true if drop target interaction is not required for the Panel, to improve performance.</p>
            *
            * @config dragOnly
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAG_ONLY.key, {
                value: DEFAULT_CONFIG.DRAG_ONLY.value,
                validator: DEFAULT_CONFIG.DRAG_ONLY.validator,
                supercedes: DEFAULT_CONFIG.DRAG_ONLY.supercedes
            });

            /**
            * Sets the type of underlay to display for the Panel. Valid values
            * are "shadow," "matte," and "none".  <strong>PLEASE NOTE:</strong>
            * The creation of the underlay element is deferred until the Panel
            * is initially made visible.  For Gecko-based browsers on Mac
            * OS X the underlay elment is always created as it is used as a
            * shim to prevent Aqua scrollbars below a Panel instance from poking
            * through it (See YUILibrary bug #1723530).
            * @config underlay
            * @type String
            * @default shadow
            */
            this.cfg.addProperty(DEFAULT_CONFIG.UNDERLAY.key, {
                handler: this.configUnderlay,
                value: DEFAULT_CONFIG.UNDERLAY.value,
                supercedes: DEFAULT_CONFIG.UNDERLAY.supercedes
            });

            /**
            * True if the Panel should be displayed in a modal fashion,
            * automatically creating a transparent mask over the document that
            * will not be removed until the Panel is dismissed.
            * @config modal
            * @type Boolean
            * @default false
            */
            this.cfg.addProperty(DEFAULT_CONFIG.MODAL.key, {
                handler: this.configModal,
                value: DEFAULT_CONFIG.MODAL.value,
                validator: DEFAULT_CONFIG.MODAL.validator,
                supercedes: DEFAULT_CONFIG.MODAL.supercedes
            });

            /**
            * A KeyListener (or array of KeyListeners) that will be enabled
            * when the Panel is shown, and disabled when the Panel is hidden.
            * @config keylisteners
            * @type YAHOO.util.KeyListener[]
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.KEY_LISTENERS.key, {
                handler: this.configKeyListeners,
                suppressEvent: DEFAULT_CONFIG.KEY_LISTENERS.suppressEvent,
                supercedes: DEFAULT_CONFIG.KEY_LISTENERS.supercedes
            });

            /**
            * UI Strings used by the Panel
            *
            * @config strings
            * @type Object
            * @default An object literal with the properties shown below:
            *     <dl>
            *         <dt>close</dt><dd><em>String</em> : The string to use for the close icon. Defaults to "Close".</dd>
            *     </dl>
            */
            this.cfg.addProperty(DEFAULT_CONFIG.STRINGS.key, {
                value:DEFAULT_CONFIG.STRINGS.value,
                handler:this.configStrings,
                validator:DEFAULT_CONFIG.STRINGS.validator,
                supercedes:DEFAULT_CONFIG.STRINGS.supercedes
            });
        },


        /**
        * The default event handler fired when the "close" property is changed.
        * The method controls the appending or hiding of the close icon at the
        * top right of the Panel.
        * @method configClose
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configClose: function (type, args, obj) {

            var val = args[0],
                oClose = this.close,
                strings = this.cfg.getProperty("strings");

            if (val) {
                if (!oClose) {

                    if (!m_oCloseIconTemplate) {
                        m_oCloseIconTemplate = document.createElement("a");
                        m_oCloseIconTemplate.className = "container-close";
                        m_oCloseIconTemplate.href = "#";
                    }

                    oClose = m_oCloseIconTemplate.cloneNode(true);
                    this.innerElement.appendChild(oClose);

                    oClose.innerHTML = (strings && strings.close) ? strings.close : "&#160;";

                    Event.on(oClose, "click", this._doClose, this, true);

                    this.close = oClose;

                } else {
                    oClose.style.display = "block";
                }

            } else {
                if (oClose) {
                    oClose.style.display = "none";
                }
            }

        },

        /**
         * Event handler for the close icon
         *
         * @method _doClose
         * @protected
         *
         * @param {DOMEvent} e
         */
        _doClose : function (e) {
            Event.preventDefault(e);
            this.hide();
        },

        /**
        * The default event handler fired when the "draggable" property
        * is changed.
        * @method configDraggable
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configDraggable: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (!Util.DD) {
                    this.cfg.setProperty("draggable", false);
                    return;
                }

                if (this.header) {
                    Dom.setStyle(this.header, "cursor", "move");
                    this.registerDragDrop();
                }

                this.subscribe("beforeShow", setWidthToOffsetWidth);

            } else {

                if (this.dd) {
                    this.dd.unreg();
                }

                if (this.header) {
                    Dom.setStyle(this.header,"cursor","auto");
                }

                this.unsubscribe("beforeShow", setWidthToOffsetWidth);
            }
        },

        /**
        * The default event handler fired when the "underlay" property
        * is changed.
        * @method configUnderlay
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configUnderlay: function (type, args, obj) {

            var bMacGecko = (this.platform == "mac" && UA.gecko),
                sUnderlay = args[0].toLowerCase(),
                oUnderlay = this.underlay,
                oElement = this.element;

            function createUnderlay() {
                var bNew = false;
                if (!oUnderlay) { // create if not already in DOM

                    if (!m_oUnderlayTemplate) {
                        m_oUnderlayTemplate = document.createElement("div");
                        m_oUnderlayTemplate.className = "underlay";
                    }

                    oUnderlay = m_oUnderlayTemplate.cloneNode(false);
                    this.element.appendChild(oUnderlay);

                    this.underlay = oUnderlay;

                    if (bIEQuirks) {
                        this.sizeUnderlay();
                        this.cfg.subscribeToConfigEvent("width", this.sizeUnderlay);
                        this.cfg.subscribeToConfigEvent("height", this.sizeUnderlay);

                        this.changeContentEvent.subscribe(this.sizeUnderlay);
                        YAHOO.widget.Module.textResizeEvent.subscribe(this.sizeUnderlay, this, true);
                    }

                    if (UA.webkit && UA.webkit < 420) {
                        this.changeContentEvent.subscribe(this.forceUnderlayRedraw);
                    }

                    bNew = true;
                }
            }

            function onBeforeShow() {
                var bNew = createUnderlay.call(this);
                if (!bNew && bIEQuirks) {
                    this.sizeUnderlay();
                }
                this._underlayDeferred = false;
                this.beforeShowEvent.unsubscribe(onBeforeShow);
            }

            function destroyUnderlay() {
                if (this._underlayDeferred) {
                    this.beforeShowEvent.unsubscribe(onBeforeShow);
                    this._underlayDeferred = false;
                }

                if (oUnderlay) {
                    this.cfg.unsubscribeFromConfigEvent("width", this.sizeUnderlay);
                    this.cfg.unsubscribeFromConfigEvent("height",this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(this.forceUnderlayRedraw);
                    YAHOO.widget.Module.textResizeEvent.unsubscribe(this.sizeUnderlay, this, true);

                    this.element.removeChild(oUnderlay);

                    this.underlay = null;
                }
            }

            switch (sUnderlay) {
                case "shadow":
                    Dom.removeClass(oElement, "matte");
                    Dom.addClass(oElement, "shadow");
                    break;
                case "matte":
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.addClass(oElement, "matte");
                    break;
                default:
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.removeClass(oElement, "matte");
                    break;
            }

            if ((sUnderlay == "shadow") || (bMacGecko && !oUnderlay)) {
                if (this.cfg.getProperty("visible")) {
                    var bNew = createUnderlay.call(this);
                    if (!bNew && bIEQuirks) {
                        this.sizeUnderlay();
                    }
                } else {
                    if (!this._underlayDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._underlayDeferred = true;
                    }
                }
            }
        },

        /**
        * The default event handler fired when the "modal" property is
        * changed. This handler subscribes or unsubscribes to the show and hide
        * events to handle the display or hide of the modality mask.
        * @method configModal
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configModal: function (type, args, obj) {

            var modal = args[0];
            if (modal) {
                if (!this._hasModalityEventListeners) {

                    this.subscribe("beforeShow", this.buildMask);
                    this.subscribe("beforeShow", this.bringToTop);
                    this.subscribe("beforeShow", this.showMask);
                    this.subscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.subscribe(this.sizeMask,
                        this, true);

                    this._hasModalityEventListeners = true;
                }
            } else {
                if (this._hasModalityEventListeners) {

                    if (this.cfg.getProperty("visible")) {
                        this.hideMask();
                        this.removeMask();
                    }

                    this.unsubscribe("beforeShow", this.buildMask);
                    this.unsubscribe("beforeShow", this.bringToTop);
                    this.unsubscribe("beforeShow", this.showMask);
                    this.unsubscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);

                    this._hasModalityEventListeners = false;
                }
            }
        },

        /**
        * Removes the modality mask.
        * @method removeMask
        */
        removeMask: function () {

            var oMask = this.mask,
                oParentNode;

            if (oMask) {
                /*
                    Hide the mask before destroying it to ensure that DOM
                    event handlers on focusable elements get removed.
                */
                this.hideMask();

                oParentNode = oMask.parentNode;
                if (oParentNode) {
                    oParentNode.removeChild(oMask);
                }

                this.mask = null;
            }
        },

        /**
        * The default event handler fired when the "keylisteners" property
        * is changed.
        * @method configKeyListeners
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configKeyListeners: function (type, args, obj) {

            var listeners = args[0],
                listener,
                nListeners,
                i;

            if (listeners) {

                if (listeners instanceof Array) {

                    nListeners = listeners.length;

                    for (i = 0; i < nListeners; i++) {

                        listener = listeners[i];

                        if (!Config.alreadySubscribed(this.showEvent,
                            listener.enable, listener)) {

                            this.showEvent.subscribe(listener.enable,
                                listener, true);

                        }

                        if (!Config.alreadySubscribed(this.hideEvent,
                            listener.disable, listener)) {

                            this.hideEvent.subscribe(listener.disable,
                                listener, true);

                            this.destroyEvent.subscribe(listener.disable,
                                listener, true);
                        }
                    }

                } else {

                    if (!Config.alreadySubscribed(this.showEvent,
                        listeners.enable, listeners)) {

                        this.showEvent.subscribe(listeners.enable,
                            listeners, true);
                    }

                    if (!Config.alreadySubscribed(this.hideEvent,
                        listeners.disable, listeners)) {

                        this.hideEvent.subscribe(listeners.disable,
                            listeners, true);

                        this.destroyEvent.subscribe(listeners.disable,
                            listeners, true);

                    }

                }

            }

        },

        /**
        * The default handler for the "strings" property
        * @method configStrings
        */
        configStrings : function(type, args, obj) {
            var val = Lang.merge(DEFAULT_CONFIG.STRINGS.value, args[0]);
            this.cfg.setProperty(DEFAULT_CONFIG.STRINGS.key, val, true);
        },

        /**
        * The default event handler fired when the "height" property is changed.
        * @method configHeight
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configHeight: function (type, args, obj) {
            var height = args[0],
                el = this.innerElement;

            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
        },

        /**
         * The default custom event handler executed when the Panel's height is changed,
         * if the autofillheight property has been set.
         *
         * @method _autoFillOnHeightChange
         * @protected
         * @param {String} type The event type
         * @param {Array} args The array of arguments passed to event subscribers
         * @param {HTMLElement} el The header, body or footer element which is to be resized to fill
         * out the containers height
         */
        _autoFillOnHeightChange : function(type, args, el) {
            Panel.superclass._autoFillOnHeightChange.apply(this, arguments);
            if (bIEQuirks) {
                var panel = this;
                setTimeout(function() {
                    panel.sizeUnderlay();
                },0);
            }
        },

        /**
        * The default event handler fired when the "width" property is changed.
        * @method configWidth
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configWidth: function (type, args, obj) {

            var width = args[0],
                el = this.innerElement;

            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");

        },

        /**
        * The default event handler fired when the "zIndex" property is changed.
        * @method configzIndex
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configzIndex: function (type, args, obj) {
            Panel.superclass.configzIndex.call(this, type, args, obj);

            if (this.mask || this.cfg.getProperty("modal") === true) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!panelZ || isNaN(panelZ)) {
                    panelZ = 0;
                }

                if (panelZ === 0) {
                    this.cfg.setProperty("zIndex", 1);
                } else {
                    this.stackMask();
                }
            }
        },

        /**
        * Builds the wrapping container around the Panel that is used for
        * positioning the shadow and matte underlays. The container element is
        * assigned to a  local instance variable called container, and the
        * element is reinserted inside of it.
        * @method buildWrapper
        */
        buildWrapper: function () {

            var elementParent = this.element.parentNode,
                originalElement = this.element,
                wrapper = document.createElement("div");

            wrapper.className = Panel.CSS_PANEL_CONTAINER;
            wrapper.id = originalElement.id + "_c";

            if (elementParent) {
                elementParent.insertBefore(wrapper, originalElement);
            }

            wrapper.appendChild(originalElement);

            this.element = wrapper;
            this.innerElement = originalElement;

            Dom.setStyle(this.innerElement, "visibility", "inherit");
        },

        /**
        * Adjusts the size of the shadow based on the size of the element.
        * @method sizeUnderlay
        */
        sizeUnderlay: function () {
            var oUnderlay = this.underlay,
                oElement;

            if (oUnderlay) {
                oElement = this.element;
                oUnderlay.style.width = oElement.offsetWidth + "px";
                oUnderlay.style.height = oElement.offsetHeight + "px";
            }
        },

        /**
        * Registers the Panel's header for drag & drop capability.
        * @method registerDragDrop
        */
        registerDragDrop: function () {

            var me = this;

            if (this.header) {

                if (!Util.DD) {
                    return;
                }

                var bDragOnly = (this.cfg.getProperty("dragonly") === true);

                /**
                 * The YAHOO.util.DD instance, used to implement the draggable header for the panel if draggable is enabled
                 *
                 * @property dd
                 * @type YAHOO.util.DD
                 */
                this.dd = new Util.DD(this.element.id, this.id, {dragOnly: bDragOnly});

                if (!this.header.id) {
                    this.header.id = this.id + "_h";
                }

                this.dd.startDrag = function () {

                    var offsetHeight,
                        offsetWidth,
                        viewPortWidth,
                        viewPortHeight,
                        scrollX,
                        scrollY;

                    if (YAHOO.env.ua.ie == 6) {
                        Dom.addClass(me.element,"drag");
                    }

                    if (me.cfg.getProperty("constraintoviewport")) {

                        var nViewportOffset = Overlay.VIEWPORT_OFFSET;

                        offsetHeight = me.element.offsetHeight;
                        offsetWidth = me.element.offsetWidth;

                        viewPortWidth = Dom.getViewportWidth();
                        viewPortHeight = Dom.getViewportHeight();

                        scrollX = Dom.getDocumentScrollLeft();
                        scrollY = Dom.getDocumentScrollTop();

                        if (offsetHeight + nViewportOffset < viewPortHeight) {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + viewPortHeight - offsetHeight - nViewportOffset;
                        } else {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + nViewportOffset;
                        }

                        if (offsetWidth + nViewportOffset < viewPortWidth) {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + viewPortWidth - offsetWidth - nViewportOffset;
                        } else {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + nViewportOffset;
                        }

                        this.constrainX = true;
                        this.constrainY = true;
                    } else {
                        this.constrainX = false;
                        this.constrainY = false;
                    }

                    me.dragEvent.fire("startDrag", arguments);
                };

                this.dd.onDrag = function () {
                    me.syncPosition();
                    me.cfg.refireEvent("iframe");
                    if (this.platform == "mac" && YAHOO.env.ua.gecko) {
                        this.showMacGeckoScrollbars();
                    }

                    me.dragEvent.fire("onDrag", arguments);
                };

                this.dd.endDrag = function () {

                    if (YAHOO.env.ua.ie == 6) {
                        Dom.removeClass(me.element,"drag");
                    }

                    me.dragEvent.fire("endDrag", arguments);
                    me.moveEvent.fire(me.cfg.getProperty("xy"));

                };

                this.dd.setHandleElId(this.header.id);
                this.dd.addInvalidHandleType("INPUT");
                this.dd.addInvalidHandleType("SELECT");
                this.dd.addInvalidHandleType("TEXTAREA");
            }
        },

        /**
        * Builds the mask that is laid over the document when the Panel is
        * configured to be modal.
        * @method buildMask
        */
        buildMask: function () {
            var oMask = this.mask;
            if (!oMask) {
                if (!m_oMaskTemplate) {
                    m_oMaskTemplate = document.createElement("div");
                    m_oMaskTemplate.className = "mask";
                    m_oMaskTemplate.innerHTML = "&#160;";
                }
                oMask = m_oMaskTemplate.cloneNode(true);
                oMask.id = this.id + "_mask";

                document.body.insertBefore(oMask, document.body.firstChild);

                this.mask = oMask;

                if (YAHOO.env.ua.gecko && this.platform == "mac") {
                    Dom.addClass(this.mask, "block-scrollbars");
                }

                this.stackMask();
            }
        },

        /**
        * Hides the modality mask.
        * @method hideMask
        */
        hideMask: function () {
            if (this.cfg.getProperty("modal") && this.mask) {
                this.mask.style.display = "none";
                Dom.removeClass(document.body, "masked");
                this.hideMaskEvent.fire();
            }
        },

        /**
        * Shows the modality mask.
        * @method showMask
        */
        showMask: function () {
            if (this.cfg.getProperty("modal") && this.mask) {
                Dom.addClass(document.body, "masked");
                this.sizeMask();
                this.mask.style.display = "block";
                this.showMaskEvent.fire();
            }
        },

        /**
        * Sets the size of the modality mask to cover the entire scrollable
        * area of the document
        * @method sizeMask
        */
        sizeMask: function () {
            if (this.mask) {

                var mask = this.mask,
                    viewWidth = Dom.getViewportWidth(),
                    viewHeight = Dom.getViewportHeight();

                if (mask.offsetHeight > viewHeight) {
                    mask.style.height = viewHeight + "px";
                }

                if (mask.offsetWidth > viewWidth) {
                    mask.style.width = viewWidth + "px";
                }

                mask.style.height = Dom.getDocumentHeight() + "px";
                mask.style.width = Dom.getDocumentWidth() + "px";
            }
        },

        /**
         * Sets the zindex of the mask, if it exists, based on the zindex of
         * the Panel element. The zindex of the mask is set to be one less
         * than the Panel element's zindex.
         *
         * <p>NOTE: This method will not bump up the zindex of the Panel
         * to ensure that the mask has a non-negative zindex. If you require the
         * mask zindex to be 0 or higher, the zindex of the Panel
         * should be set to a value higher than 0, before this method is called.
         * </p>
         * @method stackMask
         */
        stackMask: function() {
            if (this.mask) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!YAHOO.lang.isUndefined(panelZ) && !isNaN(panelZ)) {
                    Dom.setStyle(this.mask, "zIndex", panelZ - 1);
                }
            }
        },

        /**
        * Renders the Panel by inserting the elements that are not already in
        * the main Panel into their correct places. Optionally appends the
        * Panel to the specified node prior to the render's execution. NOTE:
        * For Panels without existing markup, the appendToNode argument is
        * REQUIRED. If this argument is ommitted and the current element is
        * not present in the document, the function will return false,
        * indicating that the render was a failure.
        * @method render
        * @param {String} appendToNode The element id to which the Module
        * should be appended to prior to rendering <em>OR</em>
        * @param {HTMLElement} appendToNode The element to which the Module
        * should be appended to prior to rendering
        * @return {boolean} Success or failure of the render
        */
        render: function (appendToNode) {
            return Panel.superclass.render.call(this, appendToNode, this.innerElement);
        },

        /**
         * Renders the currently set header into it's proper position under the
         * module element. If the module element is not provided, "this.innerElement"
         * is used.
         *
         * @method _renderHeader
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element
         */
        _renderHeader: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
			Panel.superclass._renderHeader.call(this, moduleElement);
        },

        /**
         * Renders the currently set body into it's proper position under the
         * module element. If the module element is not provided, "this.innerElement"
         * is used.
         *
         * @method _renderBody
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element.
         */
        _renderBody: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
            Panel.superclass._renderBody.call(this, moduleElement);
        },

        /**
         * Renders the currently set footer into it's proper position under the
         * module element. If the module element is not provided, "this.innerElement"
         * is used.
         *
         * @method _renderFooter
         * @protected
         * @param {HTMLElement} moduleElement Optional. A reference to the module element
         */
        _renderFooter: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
            Panel.superclass._renderFooter.call(this, moduleElement);
        },

        /**
        * Removes the Panel element from the DOM and sets all child elements
        * to null.
        * @method destroy
        */
        destroy: function () {
            Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);
            this.removeMask();
            if (this.close) {
                Event.purgeElement(this.close);
            }
            Panel.superclass.destroy.call(this);
        },

        /**
         * Forces the underlay element to be repainted through the application/removal
         * of a yui-force-redraw class to the underlay element.
         *
         * @method forceUnderlayRedraw
         */
        forceUnderlayRedraw : function () {
            var u = this.underlay;
            Dom.addClass(u, "yui-force-redraw");
            setTimeout(function(){Dom.removeClass(u, "yui-force-redraw");}, 0);
        },

        /**
        * Returns a String representation of the object.
        * @method toString
        * @return {String} The string representation of the Panel.
        */
        toString: function () {
            return "Panel " + this.id;
        }

    });

}());
(function () {

    /**
    * <p>
    * Dialog is an implementation of Panel that can be used to submit form
    * data.
    * </p>
    * <p>
    * Built-in functionality for buttons with event handlers is included.
    * If the optional YUI Button dependancy is included on the page, the buttons
    * created will be instances of YAHOO.widget.Button, otherwise regular HTML buttons
    * will be created.
    * </p>
    * <p>
    * Forms can be processed in 3 ways -- via an asynchronous Connection utility call,
    * a simple form POST or GET, or manually. The YUI Connection utility should be
    * included if you're using the default "async" postmethod, but is not required if
    * you're using any of the other postmethod values.
    * </p>
    * @namespace YAHOO.widget
    * @class Dialog
    * @extends YAHOO.widget.Panel
    * @constructor
    * @param {String} el The element ID representing the Dialog <em>OR</em>
    * @param {HTMLElement} el The element representing the Dialog
    * @param {Object} userConfig The configuration object literal containing
    * the configuration that should be set for this Dialog. See configuration
    * documentation for more details.
    */
    YAHOO.widget.Dialog = function (el, userConfig) {
        YAHOO.widget.Dialog.superclass.constructor.call(this, el, userConfig);
    };

    var Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Dom = YAHOO.util.Dom,
        Dialog = YAHOO.widget.Dialog,
        Lang = YAHOO.lang,

        /**
         * Constant representing the name of the Dialog's events
         * @property EVENT_TYPES
         * @private
         * @final
         * @type Object
         */
        EVENT_TYPES = {
            "BEFORE_SUBMIT": "beforeSubmit",
            "SUBMIT": "submit",
            "MANUAL_SUBMIT": "manualSubmit",
            "ASYNC_SUBMIT": "asyncSubmit",
            "FORM_SUBMIT": "formSubmit",
            "CANCEL": "cancel"
        },

        /**
        * Constant representing the Dialog's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "POST_METHOD": {
                key: "postmethod",
                value: "async"
            },

            "POST_DATA" : {
                key: "postdata",
                value: null
            },

            "BUTTONS": {
                key: "buttons",
                value: "none",
                supercedes: ["visible"]
            },

            "HIDEAFTERSUBMIT" : {
                key: "hideaftersubmit",
                value: true
            }

        };

    /**
    * Constant representing the default CSS class used for a Dialog
    * @property YAHOO.widget.Dialog.CSS_DIALOG
    * @static
    * @final
    * @type String
    */
    Dialog.CSS_DIALOG = "yui-dialog";

    function removeButtonEventHandlers() {

        var aButtons = this._aButtons,
            nButtons,
            oButton,
            i;

        if (Lang.isArray(aButtons)) {
            nButtons = aButtons.length;

            if (nButtons > 0) {
                i = nButtons - 1;
                do {
                    oButton = aButtons[i];

                    if (YAHOO.widget.Button && oButton instanceof YAHOO.widget.Button) {
                        oButton.destroy();
                    }
                    else if (oButton.tagName.toUpperCase() == "BUTTON") {
                        Event.purgeElement(oButton);
                        Event.purgeElement(oButton, false);
                    }
                }
                while (i--);
            }
        }
    }

    YAHOO.extend(Dialog, YAHOO.widget.Panel, {

        /**
        * @property form
        * @description Object reference to the Dialog's
        * <code>&#60;form&#62;</code> element.
        * @default null
        * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-40002357">HTMLFormElement</a>
        */
        form: null,

        /**
        * Initializes the class's configurable properties which can be changed
        * using the Dialog's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {
            Dialog.superclass.initDefaultConfig.call(this);

            /**
            * The internally maintained callback object for use with the
            * Connection utility. The format of the callback object is
            * similar to Connection Manager's callback object and is
            * simply passed through to Connection Manager when the async
            * request is made.
            * @property callback
            * @type Object
            */
            this.callback = {

                /**
                * The function to execute upon success of the
                * Connection submission (when the form does not
                * contain a file input element).
                *
                * @property callback.success
                * @type Function
                */
                success: null,

                /**
                * The function to execute upon failure of the
                * Connection submission
                * @property callback.failure
                * @type Function
                */
                failure: null,

                /**
                *<p>
                * The function to execute upon success of the
                * Connection submission, when the form contains
                * a file input element.
                * </p>
                * <p>
                * <em>NOTE:</em> Connection manager will not
                * invoke the success or failure handlers for the file
                * upload use case. This will be the only callback
                * handler invoked.
                * </p>
                * <p>
                * For more information, see the <a href="http://developer.yahoo.com/yui/connection/#file">
                * Connection Manager documenation on file uploads</a>.
                * </p>
                * @property callback.upload
                * @type Function
                */

                /**
                * The arbitraty argument or arguments to pass to the Connection
                * callback functions
                * @property callback.argument
                * @type Object
                */
                argument: null

            };

            /**
            * The method to use for posting the Dialog's form. Possible values
            * are "async", "form", and "manual".
            * @config postmethod
            * @type String
            * @default async
            */
            this.cfg.addProperty(DEFAULT_CONFIG.POST_METHOD.key, {
                handler: this.configPostMethod,
                value: DEFAULT_CONFIG.POST_METHOD.value,
                validator: function (val) {
                    if (val != "form" && val != "async" && val != "none" &&
                        val != "manual") {
                        return false;
                    } else {
                        return true;
                    }
                }
            });

            /**
            * Any additional post data which needs to be sent when using the
            * <a href="#config_postmethod">async</a> postmethod for dialog POST submissions.
            * The format for the post data string is defined by Connection Manager's
            * <a href="YAHOO.util.Connect.html#method_asyncRequest">asyncRequest</a>
            * method.
            * @config postdata
            * @type String
            * @default null
            */
            this.cfg.addProperty(DEFAULT_CONFIG.POST_DATA.key, {
                value: DEFAULT_CONFIG.POST_DATA.value
            });

            /**
            * This property is used to configure whether or not the
            * dialog should be automatically hidden after submit.
            *
            * @config hideaftersubmit
            * @type Boolean
            * @default true
            */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDEAFTERSUBMIT.key, {
                value: DEFAULT_CONFIG.HIDEAFTERSUBMIT.value
            });

            /**
            * Array of object literals, each containing a set of properties
            * defining a button to be appended into the Dialog's footer.
            *
            * <p>Each button object in the buttons array can have three properties:</p>
            * <dl>
            *    <dt>text:</dt>
            *    <dd>
            *       The text that will display on the face of the button. The text can
            *       include HTML, as long as it is compliant with HTML Button specifications.
            *    </dd>
            *    <dt>handler:</dt>
            *    <dd>Can be either:
            *    <ol>
            *       <li>A reference to a function that should fire when the
            *       button is clicked.  (In this case scope of this function is
            *       always its Dialog instance.)</li>
            *
            *       <li>An object literal representing the code to be
            *       executed when the button is clicked.
            *
            *       <p>Format:</p>
            *
            *       <p>
            *       <code>{
            *       <br>
            *       <strong>fn:</strong> Function, &#47;&#47;
            *       The handler to call when  the event fires.
            *       <br>
            *       <strong>obj:</strong> Object, &#47;&#47;
            *       An  object to pass back to the handler.
            *       <br>
            *       <strong>scope:</strong> Object &#47;&#47;
            *       The object to use for the scope of the handler.
            *       <br>
            *       }</code>
            *       </p>
            *       </li>
            *     </ol>
            *     </dd>
            *     <dt>isDefault:</dt>
            *     <dd>
            *        An optional boolean value that specifies that a button
            *        should be highlighted and focused by default.
            *     </dd>
            * </dl>
            *
            * <em>NOTE:</em>If the YUI Button Widget is included on the page,
            * the buttons created will be instances of YAHOO.widget.Button.
            * Otherwise, HTML Buttons (<code>&#60;BUTTON&#62;</code>) will be
            * created.
            *
            * @config buttons
            * @type {Array|String}
            * @default "none"
            */
            this.cfg.addProperty(DEFAULT_CONFIG.BUTTONS.key, {
                handler: this.configButtons,
                value: DEFAULT_CONFIG.BUTTONS.value,
                supercedes : DEFAULT_CONFIG.BUTTONS.supercedes
            });

        },

        /**
        * Initializes the custom events for Dialog which are fired
        * automatically at appropriate times by the Dialog class.
        * @method initEvents
        */
        initEvents: function () {
            Dialog.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
            * CustomEvent fired prior to submission
            * @event beforeSubmitEvent
            */
            this.beforeSubmitEvent =
                this.createEvent(EVENT_TYPES.BEFORE_SUBMIT);
            this.beforeSubmitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after submission
            * @event submitEvent
            */
            this.submitEvent = this.createEvent(EVENT_TYPES.SUBMIT);
            this.submitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired for manual submission, before the generic submit event is fired
            * @event manualSubmitEvent
            */
            this.manualSubmitEvent =
                this.createEvent(EVENT_TYPES.MANUAL_SUBMIT);
            this.manualSubmitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after asynchronous submission, before the generic submit event is fired
            *
            * @event asyncSubmitEvent
            * @param {Object} conn The connection object, returned by YAHOO.util.Connect.asyncRequest
            */
            this.asyncSubmitEvent = this.createEvent(EVENT_TYPES.ASYNC_SUBMIT);
            this.asyncSubmitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after form-based submission, before the generic submit event is fired
            * @event formSubmitEvent
            */
            this.formSubmitEvent = this.createEvent(EVENT_TYPES.FORM_SUBMIT);
            this.formSubmitEvent.signature = SIGNATURE;

            /**
            * CustomEvent fired after cancel
            * @event cancelEvent
            */
            this.cancelEvent = this.createEvent(EVENT_TYPES.CANCEL);
            this.cancelEvent.signature = SIGNATURE;

        },

        /**
        * The Dialog initialization method, which is executed for Dialog and
        * all of its subclasses. This method is automatically called by the
        * constructor, and  sets up all DOM references for pre-existing markup,
        * and creates required markup if it is not already present.
        *
        * @method init
        * @param {String} el The element ID representing the Dialog <em>OR</em>
        * @param {HTMLElement} el The element representing the Dialog
        * @param {Object} userConfig The configuration object literal
        * containing the configuration that should be set for this Dialog.
        * See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            /*
                 Note that we don't pass the user config in here yet because
                 we only want it executed once, at the lowest subclass level
            */

            Dialog.superclass.init.call(this, el/*, userConfig*/);

            this.beforeInitEvent.fire(Dialog);

            Dom.addClass(this.element, Dialog.CSS_DIALOG);

            this.cfg.setProperty("visible", false);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.showEvent.subscribe(this.focusFirst, this, true);
            this.beforeHideEvent.subscribe(this.blurButtons, this, true);

            this.subscribe("changeBody", this.registerForm);

            this.initEvent.fire(Dialog);
        },

        /**
        * Submits the Dialog's form depending on the value of the
        * "postmethod" configuration property.  <strong>Please note:
        * </strong> As of version 2.3 this method will automatically handle
        * asyncronous file uploads should the Dialog instance's form contain
        * <code>&#60;input type="file"&#62;</code> elements.  If a Dialog
        * instance will be handling asyncronous file uploads, its
        * <code>callback</code> property will need to be setup with a
        * <code>upload</code> handler rather than the standard
        * <code>success</code> and, or <code>failure</code> handlers.  For more
        * information, see the <a href="http://developer.yahoo.com/yui/
        * connection/#file">Connection Manager documenation on file uploads</a>.
        * @method doSubmit
        */
        doSubmit: function () {

            var Connect = YAHOO.util.Connect,
                oForm = this.form,
                bUseFileUpload = false,
                bUseSecureFileUpload = false,
                aElements,
                nElements,
                i,
                formAttrs;

            switch (this.cfg.getProperty("postmethod")) {

                case "async":
                    aElements = oForm.elements;
                    nElements = aElements.length;

                    if (nElements > 0) {
                        i = nElements - 1;
                        do {
                            if (aElements[i].type == "file") {
                                bUseFileUpload = true;
                                break;
                            }
                        }
                        while(i--);
                    }

                    if (bUseFileUpload && YAHOO.env.ua.ie && this.isSecure) {
                        bUseSecureFileUpload = true;
                    }

                    formAttrs = this._getFormAttributes(oForm);

                    Connect.setForm(oForm, bUseFileUpload, bUseSecureFileUpload);

                    var postData = this.cfg.getProperty("postdata");
                    var c = Connect.asyncRequest(formAttrs.method, formAttrs.action, this.callback, postData);

                    this.asyncSubmitEvent.fire(c);

                    break;

                case "form":
                    oForm.submit();
                    this.formSubmitEvent.fire();
                    break;

                case "none":
                case "manual":
                    this.manualSubmitEvent.fire();
                    break;
            }
        },

        /**
         * Retrieves important attributes (currently method and action) from
         * the form element, accounting for any elements which may have the same name
         * as the attributes. Defaults to "POST" and "" for method and action respectively
         * if the attribute cannot be retrieved.
         *
         * @method _getFormAttributes
         * @protected
         * @param {HTMLFormElement} oForm The HTML Form element from which to retrieve the attributes
         * @return {Object} Object literal, with method and action String properties.
         */
        _getFormAttributes : function(oForm){
            var attrs = {
                method : null,
                action : null
            };

            if (oForm) {
                if (oForm.getAttributeNode) {
                    var action = oForm.getAttributeNode("action");
                    var method = oForm.getAttributeNode("method");

                    if (action) {
                        attrs.action = action.value;
                    }

                    if (method) {
                        attrs.method = method.value;
                    }

                } else {
                    attrs.action = oForm.getAttribute("action");
                    attrs.method = oForm.getAttribute("method");
                }
            }

            attrs.method = (Lang.isString(attrs.method) ? attrs.method : "POST").toUpperCase();
            attrs.action = Lang.isString(attrs.action) ? attrs.action : "";

            return attrs;
        },

        /**
        * Prepares the Dialog's internal FORM object, creating one if one is
        * not currently present.
        * @method registerForm
        */
        registerForm: function() {

            var form = this.element.getElementsByTagName("form")[0];

            if (this.form) {
                if (this.form == form && Dom.isAncestor(this.element, this.form)) {
                    return;
                } else {
                    Event.purgeElement(this.form);
                    this.form = null;
                }
            }

            if (!form) {
                form = document.createElement("form");
                form.name = "frm_" + this.id;
                this.body.appendChild(form);
            }

            if (form) {
                this.form = form;
                Event.on(form, "submit", this._submitHandler, this, true);
            }
        },

        /**
         * Internal handler for the form submit event
         *
         * @method _submitHandler
         * @protected
         * @param {DOMEvent} e The DOM Event object
         */
        _submitHandler : function(e) {
            Event.stopEvent(e);
            this.submit();
            this.form.blur();
        },

        /**
         * Sets up a tab, shift-tab loop between the first and last elements
         * provided. NOTE: Sets up the preventBackTab and preventTabOut KeyListener
         * instance properties, which are reset everytime this method is invoked.
         *
         * @method setTabLoop
         * @param {HTMLElement} firstElement
         * @param {HTMLElement} lastElement
         *
         */
        setTabLoop : function(firstElement, lastElement) {

            firstElement = firstElement || this.firstButton;
            lastElement = this.lastButton || lastElement;

            Dialog.superclass.setTabLoop.call(this, firstElement, lastElement);
        },

        /**
         * Configures instance properties, pointing to the
         * first and last focusable elements in the Dialog's form.
         *
         * @method setFirstLastFocusable
         */
        setFirstLastFocusable : function() {

            Dialog.superclass.setFirstLastFocusable.call(this);

            var i, l, el, elements = this.focusableElements;

            this.firstFormElement = null;
            this.lastFormElement = null;

            if (this.form && elements && elements.length > 0) {
                l = elements.length;

                for (i = 0; i < l; ++i) {
                    el = elements[i];
                    if (this.form === el.form) {
                        this.firstFormElement = el;
                        break;
                    }
                }

                for (i = l-1; i >= 0; --i) {
                    el = elements[i];
                    if (this.form === el.form) {
                        this.lastFormElement = el;
                        break;
                    }
                }
            }
        },

        /**
        * The default event handler fired when the "close" property is
        * changed. The method controls the appending or hiding of the close
        * icon at the top right of the Dialog.
        * @method configClose
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For
        * configuration handlers, args[0] will equal the newly applied value
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configClose: function (type, args, obj) {
            Dialog.superclass.configClose.apply(this, arguments);
        },

        /**
         * Event handler for the close icon
         *
         * @method _doClose
         * @protected
         *
         * @param {DOMEvent} e
         */
         _doClose : function(e) {
            Event.preventDefault(e);
            this.cancel();
        },

        /**
        * The default event handler for the "buttons" configuration property
        * @method configButtons
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configButtons: function (type, args, obj) {

            var Button = YAHOO.widget.Button,
                aButtons = args[0],
                oInnerElement = this.innerElement,
                oButton,
                oButtonEl,
                oYUIButton,
                nButtons,
                oSpan,
                oFooter,
                i;

            removeButtonEventHandlers.call(this);

            this._aButtons = null;

            if (Lang.isArray(aButtons)) {

                oSpan = document.createElement("span");
                oSpan.className = "button-group";
                nButtons = aButtons.length;

                this._aButtons = [];
                this.defaultHtmlButton = null;

                for (i = 0; i < nButtons; i++) {
                    oButton = aButtons[i];

                    if (Button) {
                        oYUIButton = new Button({ label: oButton.text});
                        oYUIButton.appendTo(oSpan);

                        oButtonEl = oYUIButton.get("element");

                        if (oButton.isDefault) {
                            oYUIButton.addClass("default");
                            this.defaultHtmlButton = oButtonEl;
                        }

                        if (Lang.isFunction(oButton.handler)) {

                            oYUIButton.set("onclick", {
                                fn: oButton.handler,
                                obj: this,
                                scope: this
                            });

                        } else if (Lang.isObject(oButton.handler) && Lang.isFunction(oButton.handler.fn)) {

                            oYUIButton.set("onclick", {
                                fn: oButton.handler.fn,
                                obj: ((!Lang.isUndefined(oButton.handler.obj)) ? oButton.handler.obj : this),
                                scope: (oButton.handler.scope || this)
                            });

                        }

                        this._aButtons[this._aButtons.length] = oYUIButton;

                    } else {

                        oButtonEl = document.createElement("button");
                        oButtonEl.setAttribute("type", "button");

                        if (oButton.isDefault) {
                            oButtonEl.className = "default";
                            this.defaultHtmlButton = oButtonEl;
                        }

                        oButtonEl.innerHTML = oButton.text;

                        if (Lang.isFunction(oButton.handler)) {
                            Event.on(oButtonEl, "click", oButton.handler, this, true);
                        } else if (Lang.isObject(oButton.handler) &&
                            Lang.isFunction(oButton.handler.fn)) {

                            Event.on(oButtonEl, "click",
                                oButton.handler.fn,
                                ((!Lang.isUndefined(oButton.handler.obj)) ? oButton.handler.obj : this),
                                (oButton.handler.scope || this));
                        }

                        oSpan.appendChild(oButtonEl);
                        this._aButtons[this._aButtons.length] = oButtonEl;
                    }

                    oButton.htmlButton = oButtonEl;

                    if (i === 0) {
                        this.firstButton = oButtonEl;
                    }

                    if (i == (nButtons - 1)) {
                        this.lastButton = oButtonEl;
                    }
                }

                this.setFooter(oSpan);

                oFooter = this.footer;

                if (Dom.inDocument(this.element) && !Dom.isAncestor(oInnerElement, oFooter)) {
                    oInnerElement.appendChild(oFooter);
                }

                this.buttonSpan = oSpan;

            } else { // Do cleanup
                oSpan = this.buttonSpan;
                oFooter = this.footer;
                if (oSpan && oFooter) {
                    oFooter.removeChild(oSpan);
                    this.buttonSpan = null;
                    this.firstButton = null;
                    this.lastButton = null;
                    this.defaultHtmlButton = null;
                }
            }

            this.changeContentEvent.fire();
        },

        /**
        * @method getButtons
        * @description Returns an array containing each of the Dialog's
        * buttons, by default an array of HTML <code>&#60;BUTTON&#62;</code>
        * elements.  If the Dialog's buttons were created using the
        * YAHOO.widget.Button class (via the inclusion of the optional Button
        * dependancy on the page), an array of YAHOO.widget.Button instances
        * is returned.
        * @return {Array}
        */
        getButtons: function () {
            return this._aButtons || null;
        },

        /**
         * <p>
         * Sets focus to the first focusable element in the Dialog's form if found,
         * else, the default button if found, else the first button defined via the
         * "buttons" configuration property.
         * </p>
         * <p>
         * This method is invoked when the Dialog is made visible.
         * </p>
         * @method focusFirst
         */
        focusFirst: function (type, args, obj) {

            var el = this.firstFormElement;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (el) {
                try {
                    el.focus();
                } catch(oException) {
                }
            } else {
                if (this.defaultHtmlButton) {
                    this.focusDefaultButton();
                } else {
                    this.focusFirstButton();
                }
            }
        },

        /**
        * Sets focus to the last element in the Dialog's form or the last
        * button defined via the "buttons" configuration property.
        * @method focusLast
        */
        focusLast: function (type, args, obj) {

            var aButtons = this.cfg.getProperty("buttons"),
                el = this.lastFormElement;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (aButtons && Lang.isArray(aButtons)) {
                this.focusLastButton();
            } else {
                if (el) {
                    try {
                        el.focus();
                    } catch(oException) {
                    }
                }
            }
        },

        /**
         * Helper method to normalize button references. It either returns the
         * YUI Button instance for the given element if found,
         * or the passes back the HTMLElement reference if a corresponding YUI Button
         * reference is not found or YAHOO.widget.Button does not exist on the page.
         *
         * @method _getButton
         * @private
         * @param {HTMLElement} button
         * @return {YAHOO.widget.Button|HTMLElement}
         */
        _getButton : function(button) {
            var Button = YAHOO.widget.Button;

            if (Button && button && button.nodeName && button.id) {
                button = Button.getButton(button.id) || button;
            }

            return button;
        },

        /**
        * Sets the focus to the button that is designated as the default via
        * the "buttons" configuration property. By default, this method is
        * called when the Dialog is made visible.
        * @method focusDefaultButton
        */
        focusDefaultButton: function () {
            var button = this._getButton(this.defaultHtmlButton);
            if (button) {
                /*
                    Place the call to the "focus" method inside a try/catch
                    block to prevent IE from throwing JavaScript errors if
                    the element is disabled or hidden.
                */
                try {
                    button.focus();
                } catch(oException) {
                }
            }
        },

        /**
        * Blurs all the buttons defined via the "buttons"
        * configuration property.
        * @method blurButtons
        */
        blurButtons: function () {

            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement,
                i;

            if (aButtons && Lang.isArray(aButtons)) {
                nButtons = aButtons.length;
                if (nButtons > 0) {
                    i = (nButtons - 1);
                    do {
                        oButton = aButtons[i];
                        if (oButton) {
                            oElement = this._getButton(oButton.htmlButton);
                            if (oElement) {
                                /*
                                    Place the call to the "blur" method inside
                                    a try/catch block to prevent IE from
                                    throwing JavaScript errors if the element
                                    is disabled or hidden.
                                */
                                try {
                                    oElement.blur();
                                } catch(oException) {
                                }
                            }
                        }
                    } while(i--);
                }
            }
        },

        /**
        * Sets the focus to the first button created via the "buttons"
        * configuration property.
        * @method focusFirstButton
        */
        focusFirstButton: function () {

            var aButtons = this.cfg.getProperty("buttons"),
                oButton,
                oElement;

            if (aButtons && Lang.isArray(aButtons)) {
                oButton = aButtons[0];
                if (oButton) {
                    oElement = this._getButton(oButton.htmlButton);
                    if (oElement) {
                        /*
                            Place the call to the "focus" method inside a
                            try/catch block to prevent IE from throwing
                            JavaScript errors if the element is disabled
                            or hidden.
                        */
                        try {
                            oElement.focus();
                        } catch(oException) {
                        }
                    }
                }
            }
        },

        /**
        * Sets the focus to the last button created via the "buttons"
        * configuration property.
        * @method focusLastButton
        */
        focusLastButton: function () {

            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement;

            if (aButtons && Lang.isArray(aButtons)) {
                nButtons = aButtons.length;
                if (nButtons > 0) {
                    oButton = aButtons[(nButtons - 1)];

                    if (oButton) {
                        oElement = this._getButton(oButton.htmlButton);
                        if (oElement) {
                            /*
                                Place the call to the "focus" method inside a
                                try/catch block to prevent IE from throwing
                                JavaScript errors if the element is disabled
                                or hidden.
                            */

                            try {
                                oElement.focus();
                            } catch(oException) {
                            }
                        }
                    }
                }
            }
        },

        /**
        * The default event handler for the "postmethod" configuration property
        * @method configPostMethod
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For
        * configuration handlers, args[0] will equal the newly applied value
        * for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configPostMethod: function (type, args, obj) {
            this.registerForm();
        },


        /**
        * Built-in function hook for writing a validation function that will
        * be checked for a "true" value prior to a submit. This function, as
        * implemented by default, always returns true, so it should be
        * overridden if validation is necessary.
        * @method validate
        */
        validate: function () {
            return true;
        },

        /**
        * Executes a submit of the Dialog if validation
        * is successful. By default the Dialog is hidden
        * after submission, but you can set the "hideaftersubmit"
        * configuration property to false, to prevent the Dialog
        * from being hidden.
        *
        * @method submit
        */
        submit: function () {
            if (this.validate()) {
                if (this.beforeSubmitEvent.fire()) {
                    this.doSubmit();
                    this.submitEvent.fire();

                    if (this.cfg.getProperty("hideaftersubmit")) {
                        this.hide();
                    }

                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        },

        /**
        * Executes the cancel of the Dialog followed by a hide.
        * @method cancel
        */
        cancel: function () {
            this.cancelEvent.fire();
            this.hide();
        },

        /**
        * Returns a JSON-compatible data structure representing the data
        * currently contained in the form.
        * @method getData
        * @return {Object} A JSON object reprsenting the data of the
        * current form.
        */
        getData: function () {

            var oForm = this.form,
                aElements,
                nTotalElements,
                oData,
                sName,
                oElement,
                nElements,
                sType,
                sTagName,
                aOptions,
                nOptions,
                aValues,
                oOption,
                oRadio,
                oCheckbox,
                valueAttr,
                i,
                n;

            function isFormElement(p_oElement) {
                var sTag = p_oElement.tagName.toUpperCase();
                return ((sTag == "INPUT" || sTag == "TEXTAREA" ||
                        sTag == "SELECT") && p_oElement.name == sName);
            }

            if (oForm) {

                aElements = oForm.elements;
                nTotalElements = aElements.length;
                oData = {};

                for (i = 0; i < nTotalElements; i++) {
                    sName = aElements[i].name;

                    /*
                        Using "Dom.getElementsBy" to safeguard user from JS
                        errors that result from giving a form field (or set of
                        fields) the same name as a native method of a form
                        (like "submit") or a DOM collection (such as the "item"
                        method). Originally tried accessing fields via the
                        "namedItem" method of the "element" collection, but
                        discovered that it won't return a collection of fields
                        in Gecko.
                    */

                    oElement = Dom.getElementsBy(isFormElement, "*", oForm);
                    nElements = oElement.length;

                    if (nElements > 0) {
                        if (nElements == 1) {
                            oElement = oElement[0];

                            sType = oElement.type;
                            sTagName = oElement.tagName.toUpperCase();

                            switch (sTagName) {
                                case "INPUT":
                                    if (sType == "checkbox") {
                                        oData[sName] = oElement.checked;
                                    } else if (sType != "radio") {
                                        oData[sName] = oElement.value;
                                    }
                                    break;

                                case "TEXTAREA":
                                    oData[sName] = oElement.value;
                                    break;

                                case "SELECT":
                                    aOptions = oElement.options;
                                    nOptions = aOptions.length;
                                    aValues = [];

                                    for (n = 0; n < nOptions; n++) {
                                        oOption = aOptions[n];
                                        if (oOption.selected) {
                                            valueAttr = oOption.attributes.value;
                                            aValues[aValues.length] = (valueAttr && valueAttr.specified) ? oOption.value : oOption.text;
                                        }
                                    }
                                    oData[sName] = aValues;
                                    break;
                            }

                        } else {
                            sType = oElement[0].type;
                            switch (sType) {
                                case "radio":
                                    for (n = 0; n < nElements; n++) {
                                        oRadio = oElement[n];
                                        if (oRadio.checked) {
                                            oData[sName] = oRadio.value;
                                            break;
                                        }
                                    }
                                    break;

                                case "checkbox":
                                    aValues = [];
                                    for (n = 0; n < nElements; n++) {
                                        oCheckbox = oElement[n];
                                        if (oCheckbox.checked) {
                                            aValues[aValues.length] =  oCheckbox.value;
                                        }
                                    }
                                    oData[sName] = aValues;
                                    break;
                            }
                        }
                    }
                }
            }

            return oData;
        },

        /**
        * Removes the Panel element from the DOM and sets all child elements
        * to null.
        * @method destroy
        */
        destroy: function () {
            removeButtonEventHandlers.call(this);

            this._aButtons = null;

            var aForms = this.element.getElementsByTagName("form"),
                oForm;

            if (aForms.length > 0) {
                oForm = aForms[0];

                if (oForm) {
                    Event.purgeElement(oForm);
                    if (oForm.parentNode) {
                        oForm.parentNode.removeChild(oForm);
                    }
                    this.form = null;
                }
            }
            Dialog.superclass.destroy.call(this);
        },

        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the Dialog
        */
        toString: function () {
            return "Dialog " + this.id;
        }

    });

}());
(function () {

    /**
    * SimpleDialog is a simple implementation of Dialog that can be used to
    * submit a single value. Forms can be processed in 3 ways -- via an
    * asynchronous Connection utility call, a simple form POST or GET,
    * or manually.
    * @namespace YAHOO.widget
    * @class SimpleDialog
    * @extends YAHOO.widget.Dialog
    * @constructor
    * @param {String} el The element ID representing the SimpleDialog
    * <em>OR</em>
    * @param {HTMLElement} el The element representing the SimpleDialog
    * @param {Object} userConfig The configuration object literal containing
    * the configuration that should be set for this SimpleDialog. See
    * configuration documentation for more details.
    */
    YAHOO.widget.SimpleDialog = function (el, userConfig) {

        YAHOO.widget.SimpleDialog.superclass.constructor.call(this,
            el, userConfig);

    };

    var Dom = YAHOO.util.Dom,
        SimpleDialog = YAHOO.widget.SimpleDialog,

        /**
        * Constant representing the SimpleDialog's configuration properties
        * @property DEFAULT_CONFIG
        * @private
        * @final
        * @type Object
        */
        DEFAULT_CONFIG = {

            "ICON": {
                key: "icon",
                value: "none",
                suppressEvent: true
            },

            "TEXT": {
                key: "text",
                value: "",
                suppressEvent: true,
                supercedes: ["icon"]
            }

        };

    /**
    * Constant for the standard network icon for a blocking action
    * @property YAHOO.widget.SimpleDialog.ICON_BLOCK
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_BLOCK = "blckicon";

    /**
    * Constant for the standard network icon for alarm
    * @property YAHOO.widget.SimpleDialog.ICON_ALARM
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_ALARM = "alrticon";

    /**
    * Constant for the standard network icon for help
    * @property YAHOO.widget.SimpleDialog.ICON_HELP
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_HELP  = "hlpicon";

    /**
    * Constant for the standard network icon for info
    * @property YAHOO.widget.SimpleDialog.ICON_INFO
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_INFO  = "infoicon";

    /**
    * Constant for the standard network icon for warn
    * @property YAHOO.widget.SimpleDialog.ICON_WARN
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_WARN  = "warnicon";

    /**
    * Constant for the standard network icon for a tip
    * @property YAHOO.widget.SimpleDialog.ICON_TIP
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_TIP   = "tipicon";

    /**
    * Constant representing the name of the CSS class applied to the element
    * created by the "icon" configuration property.
    * @property YAHOO.widget.SimpleDialog.ICON_CSS_CLASSNAME
    * @static
    * @final
    * @type String
    */
    SimpleDialog.ICON_CSS_CLASSNAME = "yui-icon";

    /**
    * Constant representing the default CSS class used for a SimpleDialog
    * @property YAHOO.widget.SimpleDialog.CSS_SIMPLEDIALOG
    * @static
    * @final
    * @type String
    */
    SimpleDialog.CSS_SIMPLEDIALOG = "yui-simple-dialog";


    YAHOO.extend(SimpleDialog, YAHOO.widget.Dialog, {

        /**
        * Initializes the class's configurable properties which can be changed
        * using the SimpleDialog's Config object (cfg).
        * @method initDefaultConfig
        */
        initDefaultConfig: function () {

            SimpleDialog.superclass.initDefaultConfig.call(this);


            /**
            * Sets the informational icon for the SimpleDialog
            * @config icon
            * @type String
            * @default "none"
            */
            this.cfg.addProperty(DEFAULT_CONFIG.ICON.key, {
                handler: this.configIcon,
                value: DEFAULT_CONFIG.ICON.value,
                suppressEvent: DEFAULT_CONFIG.ICON.suppressEvent
            });

            /**
            * Sets the text for the SimpleDialog
            * @config text
            * @type String
            * @default ""
            */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, {
                handler: this.configText,
                value: DEFAULT_CONFIG.TEXT.value,
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent,
                supercedes: DEFAULT_CONFIG.TEXT.supercedes
            });

        },


        /**
        * The SimpleDialog initialization method, which is executed for
        * SimpleDialog and all of its subclasses. This method is automatically
        * called by the constructor, and  sets up all DOM references for
        * pre-existing markup, and creates required markup if it is not
        * already present.
        * @method init
        * @param {String} el The element ID representing the SimpleDialog
        * <em>OR</em>
        * @param {HTMLElement} el The element representing the SimpleDialog
        * @param {Object} userConfig The configuration object literal
        * containing the configuration that should be set for this
        * SimpleDialog. See configuration documentation for more details.
        */
        init: function (el, userConfig) {

            /*
                Note that we don't pass the user config in here yet because we
                only want it executed once, at the lowest subclass level
            */

            SimpleDialog.superclass.init.call(this, el/*, userConfig*/);

            this.beforeInitEvent.fire(SimpleDialog);

            Dom.addClass(this.element, SimpleDialog.CSS_SIMPLEDIALOG);

            this.cfg.queueProperty("postmethod", "manual");

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.beforeRenderEvent.subscribe(function () {
                if (! this.body) {
                    this.setBody("");
                }
            }, this, true);

            this.initEvent.fire(SimpleDialog);

        },

        /**
        * Prepares the SimpleDialog's internal FORM object, creating one if one
        * is not currently present, and adding the value hidden field.
        * @method registerForm
        */
        registerForm: function () {

            SimpleDialog.superclass.registerForm.call(this);

            this.form.innerHTML += "<input type=\"hidden\" name=\"" +
                this.id + "\" value=\"\"/>";

        },


        /**
        * Fired when the "icon" property is set.
        * @method configIcon
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configIcon: function (type,args,obj) {

            var sIcon = args[0],
                oBody = this.body,
                sCSSClass = SimpleDialog.ICON_CSS_CLASSNAME,
				aElements,
                oIcon,
                oIconParent;

            if (sIcon && sIcon != "none") {

                aElements = Dom.getElementsByClassName(sCSSClass, "*" , oBody);

				if (aElements.length === 1) {

					oIcon = aElements[0];
                    oIconParent = oIcon.parentNode;

                    if (oIconParent) {

                        oIconParent.removeChild(oIcon);

                        oIcon = null;

                    }

				}


                if (sIcon.indexOf(".") == -1) {

                    oIcon = document.createElement("span");
                    oIcon.className = (sCSSClass + " " + sIcon);
                    oIcon.innerHTML = "&#160;";

                } else {

                    oIcon = document.createElement("img");
                    oIcon.src = (this.imageRoot + sIcon);
                    oIcon.className = sCSSClass;

                }


                if (oIcon) {

                    oBody.insertBefore(oIcon, oBody.firstChild);

                }

            }

        },

        /**
        * Fired when the "text" property is set.
        * @method configText
        * @param {String} type The CustomEvent type (usually the property name)
        * @param {Object[]} args The CustomEvent arguments. For configuration
        * handlers, args[0] will equal the newly applied value for the property.
        * @param {Object} obj The scope object. For configuration handlers,
        * this will usually equal the owner.
        */
        configText: function (type,args,obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
                this.cfg.refireEvent("icon");
            }
        },


        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the SimpleDialog
        */
        toString: function () {
            return "SimpleDialog " + this.id;
        }

        /**
        * <p>
        * Sets the SimpleDialog's body content to the HTML specified.
        * If no body is present, one will be automatically created.
        * An empty string can be passed to the method to clear the contents of the body.
        * </p>
        * <p><strong>NOTE:</strong> SimpleDialog provides the <a href="#config_text">text</a>
        * and <a href="#config_icon">icon</a> configuration properties to set the contents
        * of it's body element in accordance with the UI design for a SimpleDialog (an
        * icon and message text). Calling setBody on the SimpleDialog will not enforce this
        * UI design constraint and will replace the entire contents of the SimpleDialog body.
        * It should only be used if you wish the replace the default icon/text body structure
        * of a SimpleDialog with your own custom markup.</p>
        *
        * @method setBody
        * @param {String} bodyContent The HTML used to set the body.
        * As a convenience, non HTMLElement objects can also be passed into
        * the method, and will be treated as strings, with the body innerHTML
        * set to their default toString implementations.
        * <em>OR</em>
        * @param {HTMLElement} bodyContent The HTMLElement to add as the first and only child of the body element.
        * <em>OR</em>
        * @param {DocumentFragment} bodyContent The document fragment
        * containing elements which are to be added to the body
        */
    });

}());
(function () {

    /**
    * ContainerEffect encapsulates animation transitions that are executed when
    * an Overlay is shown or hidden.
    * @namespace YAHOO.widget
    * @class ContainerEffect
    * @constructor
    * @param {YAHOO.widget.Overlay} overlay The Overlay that the animation
    * should be associated with
    * @param {Object} attrIn The object literal representing the animation
    * arguments to be used for the animate-in transition. The arguments for
    * this literal are: attributes(object, see YAHOO.util.Anim for description),
    * duration(Number), and method(i.e. Easing.easeIn).
    * @param {Object} attrOut The object literal representing the animation
    * arguments to be used for the animate-out transition. The arguments for
    * this literal are: attributes(object, see YAHOO.util.Anim for description),
    * duration(Number), and method(i.e. Easing.easeIn).
    * @param {HTMLElement} targetElement Optional. The target element that
    * should be animated during the transition. Defaults to overlay.element.
    * @param {class} Optional. The animation class to instantiate. Defaults to
    * YAHOO.util.Anim. Other options include YAHOO.util.Motion.
    */
    YAHOO.widget.ContainerEffect = function (overlay, attrIn, attrOut, targetElement, animClass) {

        if (!animClass) {
            animClass = YAHOO.util.Anim;
        }

        /**
        * The overlay to animate
        * @property overlay
        * @type YAHOO.widget.Overlay
        */
        this.overlay = overlay;

        /**
        * The animation attributes to use when transitioning into view
        * @property attrIn
        * @type Object
        */
        this.attrIn = attrIn;

        /**
        * The animation attributes to use when transitioning out of view
        * @property attrOut
        * @type Object
        */
        this.attrOut = attrOut;

        /**
        * The target element to be animated
        * @property targetElement
        * @type HTMLElement
        */
        this.targetElement = targetElement || overlay.element;

        /**
        * The animation class to use for animating the overlay
        * @property animClass
        * @type class
        */
        this.animClass = animClass;

    };


    var Dom = YAHOO.util.Dom,
        CustomEvent = YAHOO.util.CustomEvent,
        ContainerEffect = YAHOO.widget.ContainerEffect;


    /**
    * A pre-configured ContainerEffect instance that can be used for fading
    * an overlay in and out.
    * @method FADE
    * @static
    * @param {YAHOO.widget.Overlay} overlay The Overlay object to animate
    * @param {Number} dur The duration of the animation
    * @return {YAHOO.widget.ContainerEffect} The configured ContainerEffect object
    */
    ContainerEffect.FADE = function (overlay, dur) {

        var Easing = YAHOO.util.Easing,
            fin = {
                attributes: {opacity:{from:0, to:1}},
                duration: dur,
                method: Easing.easeIn
            },
            fout = {
                attributes: {opacity:{to:0}},
                duration: dur,
                method: Easing.easeOut
            },
            fade = new ContainerEffect(overlay, fin, fout, overlay.element);

        fade.handleUnderlayStart = function() {
            var underlay = this.overlay.underlay;
            if (underlay && YAHOO.env.ua.ie) {
                var hasFilters = (underlay.filters && underlay.filters.length > 0);
                if(hasFilters) {
                    Dom.addClass(overlay.element, "yui-effect-fade");
                }
            }
        };

        fade.handleUnderlayComplete = function() {
            var underlay = this.overlay.underlay;
            if (underlay && YAHOO.env.ua.ie) {
                Dom.removeClass(overlay.element, "yui-effect-fade");
            }
        };

        fade.handleStartAnimateIn = function (type, args, obj) {
            Dom.addClass(obj.overlay.element, "hide-select");

            if (!obj.overlay.underlay) {
                obj.overlay.cfg.refireEvent("underlay");
            }

            obj.handleUnderlayStart();

            obj.overlay._setDomVisibility(true);
            Dom.setStyle(obj.overlay.element, "opacity", 0);
        };

        fade.handleCompleteAnimateIn = function (type,args,obj) {
            Dom.removeClass(obj.overlay.element, "hide-select");

            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };

        fade.handleStartAnimateOut = function (type, args, obj) {
            Dom.addClass(obj.overlay.element, "hide-select");
            obj.handleUnderlayStart();
        };

        fade.handleCompleteAnimateOut =  function (type, args, obj) {
            Dom.removeClass(obj.overlay.element, "hide-select");
            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }
            obj.overlay._setDomVisibility(false);
            Dom.setStyle(obj.overlay.element, "opacity", 1);

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateOutCompleteEvent.fire();
        };

        fade.init();
        return fade;
    };


    /**
    * A pre-configured ContainerEffect instance that can be used for sliding an
    * overlay in and out.
    * @method SLIDE
    * @static
    * @param {YAHOO.widget.Overlay} overlay The Overlay object to animate
    * @param {Number} dur The duration of the animation
    * @return {YAHOO.widget.ContainerEffect} The configured ContainerEffect object
    */
    ContainerEffect.SLIDE = function (overlay, dur) {
        var Easing = YAHOO.util.Easing,

            x = overlay.cfg.getProperty("x") || Dom.getX(overlay.element),
            y = overlay.cfg.getProperty("y") || Dom.getY(overlay.element),
            clientWidth = Dom.getClientWidth(),
            offsetWidth = overlay.element.offsetWidth,

            sin =  {
                attributes: { points: { to: [x, y] } },
                duration: dur,
                method: Easing.easeIn
            },

            sout = {
                attributes: { points: { to: [(clientWidth + 25), y] } },
                duration: dur,
                method: Easing.easeOut
            },

            slide = new ContainerEffect(overlay, sin, sout, overlay.element, YAHOO.util.Motion);

        slide.handleStartAnimateIn = function (type,args,obj) {
            obj.overlay.element.style.left = ((-25) - offsetWidth) + "px";
            obj.overlay.element.style.top  = y + "px";
        };

        slide.handleTweenAnimateIn = function (type, args, obj) {

            var pos = Dom.getXY(obj.overlay.element),
                currentX = pos[0],
                currentY = pos[1];

            if (Dom.getStyle(obj.overlay.element, "visibility") ==
                "hidden" && currentX < x) {

                obj.overlay._setDomVisibility(true);

            }

            obj.overlay.cfg.setProperty("xy", [currentX, currentY], true);
            obj.overlay.cfg.refireEvent("iframe");
        };

        slide.handleCompleteAnimateIn = function (type, args, obj) {
            obj.overlay.cfg.setProperty("xy", [x, y], true);
            obj.startX = x;
            obj.startY = y;
            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };

        slide.handleStartAnimateOut = function (type, args, obj) {

            var vw = Dom.getViewportWidth(),
                pos = Dom.getXY(obj.overlay.element),
                yso = pos[1];

            obj.animOut.attributes.points.to = [(vw + 25), yso];
        };

        slide.handleTweenAnimateOut = function (type, args, obj) {

            var pos = Dom.getXY(obj.overlay.element),
                xto = pos[0],
                yto = pos[1];

            obj.overlay.cfg.setProperty("xy", [xto, yto], true);
            obj.overlay.cfg.refireEvent("iframe");
        };

        slide.handleCompleteAnimateOut = function (type, args, obj) {
            obj.overlay._setDomVisibility(false);

            obj.overlay.cfg.setProperty("xy", [x, y]);
            obj.animateOutCompleteEvent.fire();
        };

        slide.init();
        return slide;
    };

    ContainerEffect.prototype = {

        /**
        * Initializes the animation classes and events.
        * @method init
        */
        init: function () {

            this.beforeAnimateInEvent = this.createEvent("beforeAnimateIn");
            this.beforeAnimateInEvent.signature = CustomEvent.LIST;

            this.beforeAnimateOutEvent = this.createEvent("beforeAnimateOut");
            this.beforeAnimateOutEvent.signature = CustomEvent.LIST;

            this.animateInCompleteEvent = this.createEvent("animateInComplete");
            this.animateInCompleteEvent.signature = CustomEvent.LIST;

            this.animateOutCompleteEvent =
                this.createEvent("animateOutComplete");
            this.animateOutCompleteEvent.signature = CustomEvent.LIST;

            this.animIn = new this.animClass(this.targetElement,
                this.attrIn.attributes, this.attrIn.duration,
                this.attrIn.method);

            this.animIn.onStart.subscribe(this.handleStartAnimateIn, this);
            this.animIn.onTween.subscribe(this.handleTweenAnimateIn, this);

            this.animIn.onComplete.subscribe(this.handleCompleteAnimateIn,
                this);

            this.animOut = new this.animClass(this.targetElement,
                this.attrOut.attributes, this.attrOut.duration,
                this.attrOut.method);

            this.animOut.onStart.subscribe(this.handleStartAnimateOut, this);
            this.animOut.onTween.subscribe(this.handleTweenAnimateOut, this);
            this.animOut.onComplete.subscribe(this.handleCompleteAnimateOut,
                this);

        },

        /**
        * Triggers the in-animation.
        * @method animateIn
        */
        animateIn: function () {
            this.beforeAnimateInEvent.fire();
            this.animIn.animate();
        },

        /**
        * Triggers the out-animation.
        * @method animateOut
        */
        animateOut: function () {
            this.beforeAnimateOutEvent.fire();
            this.animOut.animate();
        },

        /**
        * The default onStart handler for the in-animation.
        * @method handleStartAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleStartAnimateIn: function (type, args, obj) { },

        /**
        * The default onTween handler for the in-animation.
        * @method handleTweenAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleTweenAnimateIn: function (type, args, obj) { },

        /**
        * The default onComplete handler for the in-animation.
        * @method handleCompleteAnimateIn
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleCompleteAnimateIn: function (type, args, obj) { },

        /**
        * The default onStart handler for the out-animation.
        * @method handleStartAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleStartAnimateOut: function (type, args, obj) { },

        /**
        * The default onTween handler for the out-animation.
        * @method handleTweenAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleTweenAnimateOut: function (type, args, obj) { },

        /**
        * The default onComplete handler for the out-animation.
        * @method handleCompleteAnimateOut
        * @param {String} type The CustomEvent type
        * @param {Object[]} args The CustomEvent arguments
        * @param {Object} obj The scope object
        */
        handleCompleteAnimateOut: function (type, args, obj) { },

        /**
        * Returns a string representation of the object.
        * @method toString
        * @return {String} The string representation of the ContainerEffect
        */
        toString: function () {
            var output = "ContainerEffect";
            if (this.overlay) {
                output += " [" + this.overlay.toString() + "]";
            }
            return output;
        }
    };

    YAHOO.lang.augmentProto(ContainerEffect, YAHOO.util.EventProvider);

})();
YAHOO.register("container", YAHOO.widget.Module, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * The Connection Manager provides a simplified interface to the XMLHttpRequest
 * object.  It handles cross-browser instantiantion of XMLHttpRequest, negotiates the
 * interactive states and server response, returning the results to a pre-defined
 * callback you create.
 *
 * @namespace YAHOO.util
 * @module connection
 * @requires yahoo
 * @requires event
 */

/**
 * The Connection Manager singleton provides methods for creating and managing
 * asynchronous transactions.
 *
 * @class Connect
 */

YAHOO.util.Connect =
{
  /**
   * @description Array of MSFT ActiveX ids for XMLHttpRequest.
   * @property _msxml_progid
   * @private
   * @static
   * @type array
   */
	_msxml_progid:[
		'Microsoft.XMLHTTP',
		'MSXML2.XMLHTTP.3.0',
		'MSXML2.XMLHTTP'
		],

  /**
   * @description Object literal of HTTP header(s)
   * @property _http_header
   * @private
   * @static
   * @type object
   */
	_http_headers:{},

  /**
   * @description Determines if HTTP headers are set.
   * @property _has_http_headers
   * @private
   * @static
   * @type boolean
   */
	_has_http_headers:false,

 /**
  * @description Determines if a default header of
  * Content-Type of 'application/x-www-form-urlencoded'
  * will be added to any client HTTP headers sent for POST
  * transactions.
  * @property _use_default_post_header
  * @private
  * @static
  * @type boolean
  */
    _use_default_post_header:true,

 /**
  * @description The default header used for POST transactions.
  * @property _default_post_header
  * @private
  * @static
  * @type boolean
  */
    _default_post_header:'application/x-www-form-urlencoded; charset=UTF-8',

 /**
  * @description The default header used for transactions involving the
  * use of HTML forms.
  * @property _default_form_header
  * @private
  * @static
  * @type boolean
  */
    _default_form_header:'application/x-www-form-urlencoded',

 /**
  * @description Determines if a default header of
  * 'X-Requested-With: XMLHttpRequest'
  * will be added to each transaction.
  * @property _use_default_xhr_header
  * @private
  * @static
  * @type boolean
  */
    _use_default_xhr_header:true,

 /**
  * @description The default header value for the label
  * "X-Requested-With".  This is sent with each
  * transaction, by default, to identify the
  * request as being made by YUI Connection Manager.
  * @property _default_xhr_header
  * @private
  * @static
  * @type boolean
  */
    _default_xhr_header:'XMLHttpRequest',

 /**
  * @description Determines if custom, default headers
  * are set for each transaction.
  * @property _has_default_header
  * @private
  * @static
  * @type boolean
  */
    _has_default_headers:true,

 /**
  * @description Determines if custom, default headers
  * are set for each transaction.
  * @property _has_default_header
  * @private
  * @static
  * @type boolean
  */
    _default_headers:{},

 /**
  * @description Collection of polling references to the polling mechanism in handleReadyState.
  * @property _poll
  * @private
  * @static
  * @type object
  */
    _poll:{},

 /**
  * @description Queue of timeout values for each transaction callback with a defined timeout value.
  * @property _timeOut
  * @private
  * @static
  * @type object
  */
    _timeOut:{},

  /**
   * @description The polling frequency, in milliseconds, for HandleReadyState.
   * when attempting to determine a transaction's XHR readyState.
   * The default is 50 milliseconds.
   * @property _polling_interval
   * @private
   * @static
   * @type int
   */
     _polling_interval:50,

  /**
   * @description A transaction counter that increments the transaction id for each transaction.
   * @property _transaction_id
   * @private
   * @static
   * @type int
   */
     _transaction_id:0,

  /**
   * @description Custom event that fires at the start of a transaction
   * @property startEvent
   * @private
   * @static
   * @type CustomEvent
   */
	startEvent: new YAHOO.util.CustomEvent('start'),

  /**
   * @description Custom event that fires when a transaction response has completed.
   * @property completeEvent
   * @private
   * @static
   * @type CustomEvent
   */
	completeEvent: new YAHOO.util.CustomEvent('complete'),

  /**
   * @description Custom event that fires when handleTransactionResponse() determines a
   * response in the HTTP 2xx range.
   * @property successEvent
   * @private
   * @static
   * @type CustomEvent
   */
	successEvent: new YAHOO.util.CustomEvent('success'),

  /**
   * @description Custom event that fires when handleTransactionResponse() determines a
   * response in the HTTP 4xx/5xx range.
   * @property failureEvent
   * @private
   * @static
   * @type CustomEvent
   */
	failureEvent: new YAHOO.util.CustomEvent('failure'),

  /**
   * @description Custom event that fires when a transaction is successfully aborted.
   * @property abortEvent
   * @private
   * @static
   * @type CustomEvent
   */
	abortEvent: new YAHOO.util.CustomEvent('abort'),

  /**
   * @description A reference table that maps callback custom events members to its specific
   * event name.
   * @property _customEvents
   * @private
   * @static
   * @type object
   */
	_customEvents:
	{
		onStart:['startEvent', 'start'],
		onComplete:['completeEvent', 'complete'],
		onSuccess:['successEvent', 'success'],
		onFailure:['failureEvent', 'failure'],
		onUpload:['uploadEvent', 'upload'],
		onAbort:['abortEvent', 'abort']
	},

  /**
   * @description Member to add an ActiveX id to the existing xml_progid array.
   * In the event(unlikely) a new ActiveX id is introduced, it can be added
   * without internal code modifications.
   * @method setProgId
   * @public
   * @static
   * @param {string} id The ActiveX id to be added to initialize the XHR object.
   * @return void
   */
	setProgId:function(id)
	{
		this._msxml_progid.unshift(id);
	},

  /**
   * @description Member to override the default POST header.
   * @method setDefaultPostHeader
   * @public
   * @static
   * @param {boolean} b Set and use default header - true or false .
   * @return void
   */
	setDefaultPostHeader:function(b)
	{
		if(typeof b == 'string'){
			this._default_post_header = b;
		}
		else if(typeof b == 'boolean'){
			this._use_default_post_header = b;
		}
	},

  /**
   * @description Member to override the default transaction header..
   * @method setDefaultXhrHeader
   * @public
   * @static
   * @param {boolean} b Set and use default header - true or false .
   * @return void
   */
	setDefaultXhrHeader:function(b)
	{
		if(typeof b == 'string'){
			this._default_xhr_header = b;
		}
		else{
			this._use_default_xhr_header = b;
		}
	},

  /**
   * @description Member to modify the default polling interval.
   * @method setPollingInterval
   * @public
   * @static
   * @param {int} i The polling interval in milliseconds.
   * @return void
   */
	setPollingInterval:function(i)
	{
		if(typeof i == 'number' && isFinite(i)){
			this._polling_interval = i;
		}
	},

  /**
   * @description Instantiates a XMLHttpRequest object and returns an object with two properties:
   * the XMLHttpRequest instance and the transaction id.
   * @method createXhrObject
   * @private
   * @static
   * @param {int} transactionId Property containing the transaction id for this transaction.
   * @return object
   */
	createXhrObject:function(transactionId)
	{
		var obj,http,i;
		try
		{
			http = new XMLHttpRequest();
			obj = { conn:http, tId:transactionId, xhr: true };
		}
		catch(e)
		{
			for(i=0; i<this._msxml_progid.length; ++i){
				try
				{
					http = new ActiveXObject(this._msxml_progid[i]);
					obj = { conn:http, tId:transactionId, xhr: true };
					break;
				}
				catch(e1){}
			}
		}
		finally
		{
			return obj;
		}
	},

  /**
   * @description This method is called by asyncRequest to create a
   * valid connection object for the transaction.  It also passes a
   * transaction id and increments the transaction id counter.
   * @method getConnectionObject
   * @private
   * @static
   * @return {object}
   */
	getConnectionObject:function(t)
	{
		var o, tId = this._transaction_id;

		try
		{
			if(!t){
				o = this.createXhrObject(tId);
			}
			else{
				o = {tId:tId};
				if(t==='xdr'){
					o.conn = this._transport;
					o.xdr = true;
				}
				else if(t==='upload'){
					o.upload = true;
				}
			}

			if(o){
				this._transaction_id++;
			}
		}
		catch(e){}
		return o;
	},

  /**
   * @description Method for initiating an asynchronous request via the XHR object.
   * @method asyncRequest
   * @public
   * @static
   * @param {string} method HTTP transaction method
   * @param {string} uri Fully qualified path of resource
   * @param {callback} callback User-defined callback function or object
   * @param {string} postData POST body
   * @return {object} Returns the connection object
   */
	asyncRequest:function(method, uri, callback, postData)
	{
		var o,t,args = (callback && callback.argument)?callback.argument:null;

		if(this._isFileUpload){
			t = 'upload';
		}
		else if(callback.xdr){
			t = 'xdr';
		}

		o = this.getConnectionObject(t);
		if(!o){
			return null;
		}
		else{

			if(callback && callback.customevents){
				this.initCustomEvents(o, callback);
			}

			if(this._isFormSubmit){
				if(this._isFileUpload){
					this.uploadFile(o, callback, uri, postData);
					return o;
				}

				if(method.toUpperCase() == 'GET'){
					if(this._sFormData.length !== 0){
						uri += ((uri.indexOf('?') == -1)?'?':'&') + this._sFormData;
					}
				}
				else if(method.toUpperCase() == 'POST'){
					postData = postData?this._sFormData + "&" + postData:this._sFormData;
				}
			}

			if(method.toUpperCase() == 'GET' && (callback && callback.cache === false)){
				uri += ((uri.indexOf('?') == -1)?'?':'&') + "rnd=" + new Date().valueOf().toString();
			}

			if(this._use_default_xhr_header){
				if(!this._default_headers['X-Requested-With']){
					this.initHeader('X-Requested-With', this._default_xhr_header, true);
				}
			}

			if((method.toUpperCase() === 'POST' && this._use_default_post_header) && this._isFormSubmit === false){
				this.initHeader('Content-Type', this._default_post_header);
			}

			if(o.xdr){
				this.xdr(o, method, uri, callback, postData);
				return o;
			}

			o.conn.open(method, uri, true);
			if(this._has_default_headers || this._has_http_headers){
				this.setHeader(o);
			}

			this.handleReadyState(o, callback);
			o.conn.send(postData || '');

			if(this._isFormSubmit === true){
				this.resetFormState();
			}

			this.startEvent.fire(o, args);

			if(o.startEvent){
				o.startEvent.fire(o, args);
			}

			return o;
		}
	},

  /**
   * @description This method creates and subscribes custom events,
   * specific to each transaction
   * @method initCustomEvents
   * @private
   * @static
   * @param {object} o The connection object
   * @param {callback} callback The user-defined callback object
   * @return {void}
   */
	initCustomEvents:function(o, callback)
	{
		var prop;
		for(prop in callback.customevents){
			if(this._customEvents[prop][0]){
				o[this._customEvents[prop][0]] = new YAHOO.util.CustomEvent(this._customEvents[prop][1], (callback.scope)?callback.scope:null);

				o[this._customEvents[prop][0]].subscribe(callback.customevents[prop]);
			}
		}
	},

  /**
   * @description This method serves as a timer that polls the XHR object's readyState
   * property during a transaction, instead of binding a callback to the
   * onreadystatechange event.  Upon readyState 4, handleTransactionResponse
   * will process the response, and the timer will be cleared.
   * @method handleReadyState
   * @private
   * @static
   * @param {object} o The connection object
   * @param {callback} callback The user-defined callback object
   * @return {void}
   */

    handleReadyState:function(o, callback)

    {
		var oConn = this,
			args = (callback && callback.argument)?callback.argument:null;

		if(callback && callback.timeout){
			this._timeOut[o.tId] = window.setTimeout(function(){ oConn.abort(o, callback, true); }, callback.timeout);
		}

		this._poll[o.tId] = window.setInterval(
			function(){
				if(o.conn && o.conn.readyState === 4){

					window.clearInterval(oConn._poll[o.tId]);
					delete oConn._poll[o.tId];

					if(callback && callback.timeout){
						window.clearTimeout(oConn._timeOut[o.tId]);
						delete oConn._timeOut[o.tId];
					}

					oConn.completeEvent.fire(o, args);

					if(o.completeEvent){
						o.completeEvent.fire(o, args);
					}

					oConn.handleTransactionResponse(o, callback);
				}
			}
		,this._polling_interval);
    },

  /**
   * @description This method attempts to interpret the server response and
   * determine whether the transaction was successful, or if an error or
   * exception was encountered.
   * @method handleTransactionResponse
   * @private
   * @static
   * @param {object} o The connection object
   * @param {object} callback The user-defined callback object
   * @param {boolean} isAbort Determines if the transaction was terminated via abort().
   * @return {void}
   */
    handleTransactionResponse:function(o, callback, isAbort)
    {
		var httpStatus, responseObject,
			args = (callback && callback.argument)?callback.argument:null,
			xdrS = (o.r && o.r.statusText === 'xdr:success')?true:false,
			xdrF = (o.r && o.r.statusText === 'xdr:failure')?true:false,
			xdrA = isAbort;

		try
		{
			if((o.conn.status !== undefined && o.conn.status !== 0) || xdrS){
				httpStatus = o.conn.status;
			}
			else if(xdrF && !xdrA){
				httpStatus = 0;
			}
			else{
				httpStatus = 13030;
			}
		}
		catch(e){

			httpStatus = 13030;
		}

		if((httpStatus >= 200 && httpStatus < 300) || httpStatus === 1223 || xdrS){
			responseObject = o.xdr ? o.r : this.createResponseObject(o, args);
			if(callback && callback.success){
				if(!callback.scope){
					callback.success(responseObject);
				}
				else{
					callback.success.apply(callback.scope, [responseObject]);
				}
			}

			this.successEvent.fire(responseObject);

			if(o.successEvent){
				o.successEvent.fire(responseObject);
			}
		}
		else{
			switch(httpStatus){
				case 12002: // Server timeout
				case 12029: // 12029 to 12031 correspond to dropped connections.
				case 12030:
				case 12031:
				case 12152: // Connection closed by server.
				case 13030: // See above comments for variable status.
					responseObject = this.createExceptionObject(o.tId, args, (isAbort?isAbort:false));
					if(callback && callback.failure){
						if(!callback.scope){
							callback.failure(responseObject);
						}
						else{
							callback.failure.apply(callback.scope, [responseObject]);
						}
					}

					break;
				default:
					responseObject = (o.xdr) ? o.response : this.createResponseObject(o, args);
					if(callback && callback.failure){
						if(!callback.scope){
							callback.failure(responseObject);
						}
						else{
							callback.failure.apply(callback.scope, [responseObject]);
						}
					}
			}

			this.failureEvent.fire(responseObject);

			if(o.failureEvent){
				o.failureEvent.fire(responseObject);
			}

		}

		this.releaseObject(o);
		responseObject = null;
    },

  /**
   * @description This method evaluates the server response, creates and returns the results via
   * its properties.  Success and failure cases will differ in the response
   * object's property values.
   * @method createResponseObject
   * @private
   * @static
   * @param {object} o The connection object
   * @param {callbackArg} callbackArg The user-defined argument or arguments to be passed to the callback
   * @return {object}
   */
    createResponseObject:function(o, callbackArg)
    {
		var obj = {}, headerObj = {},
			i, headerStr, header, delimitPos;

		try
		{
			headerStr = o.conn.getAllResponseHeaders();
			header = headerStr.split('\n');
			for(i=0; i<header.length; i++){
				delimitPos = header[i].indexOf(':');
				if(delimitPos != -1){
					headerObj[header[i].substring(0,delimitPos)] = YAHOO.lang.trim(header[i].substring(delimitPos+2));
				}
			}
		}
		catch(e){}

		obj.tId = o.tId;
		obj.status = (o.conn.status == 1223)?204:o.conn.status;
		obj.statusText = (o.conn.status == 1223)?"No Content":o.conn.statusText;
		obj.getResponseHeader = headerObj;
		obj.getAllResponseHeaders = headerStr;
		obj.responseText = o.conn.responseText;
		obj.responseXML = o.conn.responseXML;

		if(callbackArg){
			obj.argument = callbackArg;
		}

		return obj;
    },

  /**
   * @description If a transaction cannot be completed due to dropped or closed connections,
   * there may be not be enough information to build a full response object.
   * The failure callback will be fired and this specific condition can be identified
   * by a status property value of 0.
   *
   * If an abort was successful, the status property will report a value of -1.
   *
   * @method createExceptionObject
   * @private
   * @static
   * @param {int} tId The Transaction Id
   * @param {callbackArg} callbackArg The user-defined argument or arguments to be passed to the callback
   * @param {boolean} isAbort Determines if the exception case is caused by a transaction abort
   * @return {object}
   */
    createExceptionObject:function(tId, callbackArg, isAbort)
    {
		var COMM_CODE = 0,
			COMM_ERROR = 'communication failure',
			ABORT_CODE = -1,
			ABORT_ERROR = 'transaction aborted',
			obj = {};

		obj.tId = tId;
		if(isAbort){
			obj.status = ABORT_CODE;
			obj.statusText = ABORT_ERROR;
		}
		else{
			obj.status = COMM_CODE;
			obj.statusText = COMM_ERROR;
		}

		if(callbackArg){
			obj.argument = callbackArg;
		}

		return obj;
    },

  /**
   * @description Method that initializes the custom HTTP headers for the each transaction.
   * @method initHeader
   * @public
   * @static
   * @param {string} label The HTTP header label
   * @param {string} value The HTTP header value
   * @param {string} isDefault Determines if the specific header is a default header
   * automatically sent with each transaction.
   * @return {void}
   */
	initHeader:function(label, value, isDefault)
	{
		var headerObj = (isDefault)?this._default_headers:this._http_headers;

		headerObj[label] = value;
		if(isDefault){
			this._has_default_headers = true;
		}
		else{
			this._has_http_headers = true;
		}
	},


  /**
   * @description Accessor that sets the HTTP headers for each transaction.
   * @method setHeader
   * @private
   * @static
   * @param {object} o The connection object for the transaction.
   * @return {void}
   */
	setHeader:function(o)
	{
		var prop;
		if(this._has_default_headers){
			for(prop in this._default_headers){
				if(YAHOO.lang.hasOwnProperty(this._default_headers, prop)){
					o.conn.setRequestHeader(prop, this._default_headers[prop]);
				}
			}
		}

		if(this._has_http_headers){
			for(prop in this._http_headers){
				if(YAHOO.lang.hasOwnProperty(this._http_headers, prop)){
					o.conn.setRequestHeader(prop, this._http_headers[prop]);
				}
			}

			this._http_headers = {};
			this._has_http_headers = false;
		}
	},

  /**
   * @description Resets the default HTTP headers object
   * @method resetDefaultHeaders
   * @public
   * @static
   * @return {void}
   */
	resetDefaultHeaders:function(){
		this._default_headers = {};
		this._has_default_headers = false;
	},

  /**
   * @description Method to terminate a transaction, if it has not reached readyState 4.
   * @method abort
   * @public
   * @static
   * @param {object} o The connection object returned by asyncRequest.
   * @param {object} callback  User-defined callback object.
   * @param {string} isTimeout boolean to indicate if abort resulted from a callback timeout.
   * @return {boolean}
   */
	abort:function(o, callback, isTimeout)
	{
		var abortStatus,
			args = (callback && callback.argument)?callback.argument:null;
			o = o || {};

		if(o.conn){
			if(o.xhr){
				if(this.isCallInProgress(o)){
					o.conn.abort();

					window.clearInterval(this._poll[o.tId]);
					delete this._poll[o.tId];

					if(isTimeout){
						window.clearTimeout(this._timeOut[o.tId]);
						delete this._timeOut[o.tId];
					}

					abortStatus = true;
				}
			}
			else if(o.xdr){
				o.conn.abort(o.tId);
				abortStatus = true;
			}
		}
		else if(o.upload){
			var frameId = 'yuiIO' + o.tId;
			var io = document.getElementById(frameId);

			if(io){
				YAHOO.util.Event.removeListener(io, "load");
				document.body.removeChild(io);

				if(isTimeout){
					window.clearTimeout(this._timeOut[o.tId]);
					delete this._timeOut[o.tId];
				}

				abortStatus = true;
			}
		}
		else{
			abortStatus = false;
		}

		if(abortStatus === true){
			this.abortEvent.fire(o, args);

			if(o.abortEvent){
				o.abortEvent.fire(o, args);
			}

			this.handleTransactionResponse(o, callback, true);
		}

		return abortStatus;
	},

  /**
   * @description Determines if the transaction is still being processed.
   * @method isCallInProgress
   * @public
   * @static
   * @param {object} o The connection object returned by asyncRequest
   * @return {boolean}
   */
	isCallInProgress:function(o)
	{
		o = o || {};
		if(o.xhr && o.conn){
			return o.conn.readyState !== 4 && o.conn.readyState !== 0;
		}
		else if(o.xdr && o.conn){
			return o.conn.isCallInProgress(o.tId);
		}
		else if(o.upload === true){
			return document.getElementById('yuiIO' + o.tId)?true:false;
		}
		else{
			return false;
		}
	},

  /**
   * @description Dereference the XHR instance and the connection object after the transaction is completed.
   * @method releaseObject
   * @private
   * @static
   * @param {object} o The connection object
   * @return {void}
   */
	releaseObject:function(o)
	{
		if(o && o.conn){
			o.conn = null;


			o = null;
		}
	}
};

/**
  * @for Connect
  */
(function() {
	var YCM = YAHOO.util.Connect, _fn = {};

   /**
    * @description This method creates and instantiates the Flash transport.
    * @method _swf
    * @private
    * @static
    * @param {string} URI to connection.swf.
    * @return {void}
    */
	function _swf(uri) {
		var o = '<object id="YUIConnectionSwf" type="application/x-shockwave-flash" data="' +
		        uri + '" width="0" height="0">' +
		     	'<param name="movie" value="' + uri + '">' +
                '<param name="allowScriptAccess" value="always">' +
		    	'</object>',
		    c = document.createElement('div');

		document.body.appendChild(c);
		c.innerHTML = o;
	}

   /**
    * @description This method calls the public method on the
    * Flash transport to start the XDR transaction.  It is analogous
    * to Connection Manager's asyncRequest method.
    * @method xdr
    * @private
    * @static
    * @param {object} The transaction object.
    * @param {string} HTTP request method.
    * @param {string} URI for the transaction.
    * @param {object} The transaction's callback object.
    * @param {object} The JSON object used as HTTP POST data.
    * @return {void}
    */
	function _xdr(o, m, u, c, d) {
		_fn[parseInt(o.tId)] = { 'o':o, 'c':c };
		if (d) {
			c.method = m;
			c.data = d;
		}

		o.conn.send(u, c, o.tId);
	}

   /**
    * @description This method instantiates the Flash transport and
    * establishes a static reference to it, used for all XDR requests.
    * @method transport
    * @public
    * @static
    * @param {string} URI to connection.swf.
    * @return {void}
    */
	function _init(uri) {
		_swf(uri);
		YCM._transport = document.getElementById('YUIConnectionSwf');
	}

	function _xdrReady() {
		YCM.xdrReadyEvent.fire();
	}

   /**
    * @description This method fires the global and transaction start
    * events.
    * @method _xdrStart
    * @private
    * @static
    * @param {object} The transaction object.
    * @param {string} The transaction's callback object.
    * @return {void}
    */
	function _xdrStart(o, cb) {
		if (o) {
			YCM.startEvent.fire(o, cb.argument);

			if(o.startEvent){
				o.startEvent.fire(o, cb.argument);
			}
		}
	}

   /**
    * @description This method is the initial response handler
    * for XDR transactions.  The Flash transport calls this
    * function and sends the response payload.
    * @method handleXdrResponse
    * @private
    * @static
    * @param {object} The response object sent from the Flash transport.
    * @return {void}
    */
	function _handleXdrResponse(r) {
		var o = _fn[r.tId].o,
			cb = _fn[r.tId].c;

		if (r.statusText === 'xdr:start') {
			_xdrStart(o, cb);
			return;
		}

		r.responseText = decodeURI(r.responseText);
		o.r = r;
		if (cb.argument) {
			o.r.argument = cb.argument;
		}

		this.handleTransactionResponse(o, cb, r.statusText === 'xdr:abort' ? true : false);
		delete _fn[r.tId];
	}

	YCM.xdr = _xdr;
	YCM.swf = _swf;
	YCM.transport = _init;
	YCM.xdrReadyEvent = new YAHOO.util.CustomEvent('xdrReady');
	YCM.xdrReady = _xdrReady;
	YCM.handleXdrResponse = _handleXdrResponse;
})();

/**
  * @for Connect
  */
(function(){
	var YCM = YAHOO.util.Connect,
		YE = YAHOO.util.Event;
   /**
	* @description Property modified by setForm() to determine if the data
	* should be submitted as an HTML form.
	* @property _isFormSubmit
	* @private
	* @static
	* @type boolean
	*/
	YCM._isFormSubmit = false;

   /**
	* @description Property modified by setForm() to determine if a file(s)
	* upload is expected.
	* @property _isFileUpload
	* @private
	* @static
	* @type boolean
	*/
	YCM._isFileUpload = false;

   /**
	* @description Property modified by setForm() to set a reference to the HTML
	* form node if the desired action is file upload.
	* @property _formNode
	* @private
	* @static
	* @type object
	*/
	YCM._formNode = null;

   /**
	* @description Property modified by setForm() to set the HTML form data
	* for each transaction.
	* @property _sFormData
	* @private
	* @static
	* @type string
	*/
	YCM._sFormData = null;

   /**
	* @description Tracks the name-value pair of the "clicked" submit button if multiple submit
	* buttons are present in an HTML form; and, if YAHOO.util.Event is available.
	* @property _submitElementValue
	* @private
	* @static
	* @type string
	*/
	YCM._submitElementValue = null;

   /**
    * @description Custom event that fires when handleTransactionResponse() determines a
    * response in the HTTP 4xx/5xx range.
    * @property failureEvent
    * @private
    * @static
    * @type CustomEvent
    */
	YCM.uploadEvent = new YAHOO.util.CustomEvent('upload'),

   /**
	* @description Determines whether YAHOO.util.Event is available and returns true or false.
	* If true, an event listener is bound at the document level to trap click events that
	* resolve to a target type of "Submit".  This listener will enable setForm() to determine
	* the clicked "Submit" value in a multi-Submit button, HTML form.
	* @property _hasSubmitListener
	* @private
	* @static
	*/
	YCM._hasSubmitListener = function() {
		if(YE){
			YE.addListener(
				document,
				'click',
				function(e){
					var obj = YE.getTarget(e),
						name = obj.nodeName.toLowerCase();

					if((name === 'input' || name === 'button') && (obj.type && obj.type.toLowerCase() == 'submit')){
						YCM._submitElementValue = encodeURIComponent(obj.name) + "=" + encodeURIComponent(obj.value);
					}
				});
			return true;
		}
		return false;
	}();

  /**
   * @description This method assembles the form label and value pairs and
   * constructs an encoded string.
   * asyncRequest() will automatically initialize the transaction with a
   * a HTTP header Content-Type of application/x-www-form-urlencoded.
   * @method setForm
   * @public
   * @static
   * @param {string || object} form id or name attribute, or form object.
   * @param {boolean} optional enable file upload.
   * @param {boolean} optional enable file upload over SSL in IE only.
   * @return {string} string of the HTML form field name and value pairs..
   */
	function _setForm(formId, isUpload, secureUri)
	{
		var oForm, oElement, oName, oValue, oDisabled,
			hasSubmit = false,
			data = [], item = 0,
			i,len,j,jlen,opt;

		this.resetFormState();

		if(typeof formId == 'string'){
			oForm = (document.getElementById(formId) || document.forms[formId]);
		}
		else if(typeof formId == 'object'){
			oForm = formId;
		}
		else{
			return;
		}

		if(isUpload){

			this.createFrame(secureUri?secureUri:null);

			this._isFormSubmit = true;
			this._isFileUpload = true;
			this._formNode = oForm;

			return;
		}

		for (i=0,len=oForm.elements.length; i<len; ++i){
			oElement  = oForm.elements[i];
			oDisabled = oElement.disabled;
			oName     = oElement.name;

			if(!oDisabled && oName)
			{
				oName  = encodeURIComponent(oName)+'=';
				oValue = encodeURIComponent(oElement.value);

				switch(oElement.type)
				{
					case 'select-one':
						if (oElement.selectedIndex > -1) {
							opt = oElement.options[oElement.selectedIndex];
							data[item++] = oName + encodeURIComponent(
								(opt.attributes.value && opt.attributes.value.specified) ? opt.value : opt.text);
						}
						break;
					case 'select-multiple':
						if (oElement.selectedIndex > -1) {
							for(j=oElement.selectedIndex, jlen=oElement.options.length; j<jlen; ++j){
								opt = oElement.options[j];
								if (opt.selected) {
									data[item++] = oName + encodeURIComponent(
										(opt.attributes.value && opt.attributes.value.specified) ? opt.value : opt.text);
								}
							}
						}
						break;
					case 'radio':
					case 'checkbox':
						if(oElement.checked){
							data[item++] = oName + oValue;
						}
						break;
					case 'file':
					case undefined:
					case 'reset':
					case 'button':
						break;
					case 'submit':
						if(hasSubmit === false){
							if(this._hasSubmitListener && this._submitElementValue){
								data[item++] = this._submitElementValue;
							}
							hasSubmit = true;
						}
						break;
					default:
						data[item++] = oName + oValue;
				}
			}
		}

		this._isFormSubmit = true;
		this._sFormData = data.join('&');


		this.initHeader('Content-Type', this._default_form_header);

		return this._sFormData;
	}

   /**
    * @description Resets HTML form properties when an HTML form or HTML form
    * with file upload transaction is sent.
    * @method resetFormState
    * @private
    * @static
    * @return {void}
    */
	function _resetFormState(){
		this._isFormSubmit = false;
		this._isFileUpload = false;
		this._formNode = null;
		this._sFormData = "";
	}


   /**
    * @description Creates an iframe to be used for form file uploads.  It is remove from the
    * document upon completion of the upload transaction.
    * @method createFrame
    * @private
    * @static
    * @param {string} optional qualified path of iframe resource for SSL in IE.
    * @return {void}
    */
	function _createFrame(secureUri){

		var frameId = 'yuiIO' + this._transaction_id,
			io;
		if(YAHOO.env.ua.ie){
			io = document.createElement('<iframe id="' + frameId + '" name="' + frameId + '" />');

			if(typeof secureUri == 'boolean'){
				io.src = 'javascript:false';
			}
		}
		else{
			io = document.createElement('iframe');
			io.id = frameId;
			io.name = frameId;
		}

		io.style.position = 'absolute';
		io.style.top = '-1000px';
		io.style.left = '-1000px';

		document.body.appendChild(io);
	}

   /**
    * @description Parses the POST data and creates hidden form elements
    * for each key-value, and appends them to the HTML form object.
    * @method appendPostData
    * @private
    * @static
    * @param {string} postData The HTTP POST data
    * @return {array} formElements Collection of hidden fields.
    */
	function _appendPostData(postData){
		var formElements = [],
			postMessage = postData.split('&'),
			i, delimitPos;

		for(i=0; i < postMessage.length; i++){
			delimitPos = postMessage[i].indexOf('=');
			if(delimitPos != -1){
				formElements[i] = document.createElement('input');
				formElements[i].type = 'hidden';
				formElements[i].name = decodeURIComponent(postMessage[i].substring(0,delimitPos));
				formElements[i].value = decodeURIComponent(postMessage[i].substring(delimitPos+1));
				this._formNode.appendChild(formElements[i]);
			}
		}

		return formElements;
	}

   /**
    * @description Uploads HTML form, inclusive of files/attachments, using the
    * iframe created in createFrame to facilitate the transaction.
    * @method uploadFile
    * @private
    * @static
    * @param {int} id The transaction id.
    * @param {object} callback User-defined callback object.
    * @param {string} uri Fully qualified path of resource.
    * @param {string} postData POST data to be submitted in addition to HTML form.
    * @return {void}
    */
	function _uploadFile(o, callback, uri, postData){
		var frameId = 'yuiIO' + o.tId,
		    uploadEncoding = 'multipart/form-data',
		    io = document.getElementById(frameId),
		    ie8 = (document.documentMode && document.documentMode === 8) ? true : false,
		    oConn = this,
			args = (callback && callback.argument)?callback.argument:null,
            oElements,i,prop,obj, rawFormAttributes, uploadCallback;

		rawFormAttributes = {
			action:this._formNode.getAttribute('action'),
			method:this._formNode.getAttribute('method'),
			target:this._formNode.getAttribute('target')
		};

		this._formNode.setAttribute('action', uri);
		this._formNode.setAttribute('method', 'POST');
		this._formNode.setAttribute('target', frameId);

		if(YAHOO.env.ua.ie && !ie8){
			this._formNode.setAttribute('encoding', uploadEncoding);
		}
		else{
			this._formNode.setAttribute('enctype', uploadEncoding);
		}

		if(postData){
			oElements = this.appendPostData(postData);
		}

		this._formNode.submit();

		this.startEvent.fire(o, args);

		if(o.startEvent){
			o.startEvent.fire(o, args);
		}

		if(callback && callback.timeout){
			this._timeOut[o.tId] = window.setTimeout(function(){ oConn.abort(o, callback, true); }, callback.timeout);
		}

		if(oElements && oElements.length > 0){
			for(i=0; i < oElements.length; i++){
				this._formNode.removeChild(oElements[i]);
			}
		}

		for(prop in rawFormAttributes){
			if(YAHOO.lang.hasOwnProperty(rawFormAttributes, prop)){
				if(rawFormAttributes[prop]){
					this._formNode.setAttribute(prop, rawFormAttributes[prop]);
				}
				else{
					this._formNode.removeAttribute(prop);
				}
			}
		}

		this.resetFormState();

		uploadCallback = function() {
			if(callback && callback.timeout){
				window.clearTimeout(oConn._timeOut[o.tId]);
				delete oConn._timeOut[o.tId];
			}

			oConn.completeEvent.fire(o, args);

			if(o.completeEvent){
				o.completeEvent.fire(o, args);
			}

			obj = {
			    tId : o.tId,
			    argument : callback.argument
            };

			try
			{
				obj.responseText = io.contentWindow.document.body?io.contentWindow.document.body.innerHTML:io.contentWindow.document.documentElement.textContent;
				obj.responseXML = io.contentWindow.document.XMLDocument?io.contentWindow.document.XMLDocument:io.contentWindow.document;
			}
			catch(e){}

			if(callback && callback.upload){
				if(!callback.scope){
					callback.upload(obj);
				}
				else{
					callback.upload.apply(callback.scope, [obj]);
				}
			}

			oConn.uploadEvent.fire(obj);

			if(o.uploadEvent){
				o.uploadEvent.fire(obj);
			}

			YE.removeListener(io, "load", uploadCallback);

			setTimeout(
				function(){
					document.body.removeChild(io);
					oConn.releaseObject(o);
				}, 100);
		};

		YE.addListener(io, "load", uploadCallback);
	}

	YCM.setForm = _setForm;
	YCM.resetFormState = _resetFormState;
	YCM.createFrame = _createFrame;
	YCM.appendPostData = _appendPostData;
	YCM.uploadFile = _uploadFile;
})();

YAHOO.register("connection", YAHOO.util.Connect, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
(function () {
    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Widget = YAHOO.widget;



/**
 * The treeview widget is a generic tree building tool.
 * @module treeview
 * @title TreeView Widget
 * @requires yahoo, dom, event
 * @optional animation, json, calendar
 * @namespace YAHOO.widget
 */

/**
 * Contains the tree view state data and the root node.
 *
 * @class TreeView
 * @uses YAHOO.util.EventProvider
 * @constructor
 * @param {string|HTMLElement} id The id of the element, or the element itself that the tree will be inserted into.
 *        Existing markup in this element, if valid, will be used to build the tree
 * @param {Array|Object|String}  oConfig (optional)  If present, it will be used to build the tree via method <a href="#method_buildTreeFromObject">buildTreeFromObject</a>
 *
 */
YAHOO.widget.TreeView = function(id, oConfig) {
    if (id) { this.init(id); }
    if (oConfig) {
        this.buildTreeFromObject(oConfig);
    } else if (Lang.trim(this._el.innerHTML)) {
        this.buildTreeFromMarkup(id);
    }
};

var TV = Widget.TreeView;

TV.prototype = {

    /**
     * The id of tree container element
     * @property id
     * @type String
     */
    id: null,

    /**
     * The host element for this tree
     * @property _el
     * @private
     * @type HTMLelement
     */
    _el: null,

     /**
     * Flat collection of all nodes in this tree.  This is a sparse
     * array, so the length property can't be relied upon for a
     * node count for the tree.
     * @property _nodes
     * @type Node[]
     * @private
     */
    _nodes: null,

    /**
     * We lock the tree control while waiting for the dynamic loader to return
     * @property locked
     * @type boolean
     */
    locked: false,

    /**
     * The animation to use for expanding children, if any
     * @property _expandAnim
     * @type string
     * @private
     */
    _expandAnim: null,

    /**
     * The animation to use for collapsing children, if any
     * @property _collapseAnim
     * @type string
     * @private
     */
    _collapseAnim: null,

    /**
     * The current number of animations that are executing
     * @property _animCount
     * @type int
     * @private
     */
    _animCount: 0,

    /**
     * The maximum number of animations to run at one time.
     * @property maxAnim
     * @type int
     */
    maxAnim: 2,

    /**
     * Whether there is any subscriber to dblClickEvent
     * @property _hasDblClickSubscriber
     * @type boolean
     * @private
     */
    _hasDblClickSubscriber: false,

    /**
     * Stores the timer used to check for double clicks
     * @property _dblClickTimer
     * @type window.timer object
     * @private
     */
    _dblClickTimer: null,

  /**
     * A reference to the Node currently having the focus or null if none.
     * @property currentFocus
     * @type YAHOO.widget.Node
     */
    currentFocus: null,

    /**
    * If true, only one Node can be highlighted at a time
    * @property singleNodeHighlight
    * @type boolean
    * @default false
    */

    singleNodeHighlight: false,

    /**
    * A reference to the Node that is currently highlighted.
    * It is only meaningful if singleNodeHighlight is enabled
    * @property _currentlyHighlighted
    * @type YAHOO.widget.Node
    * @default null
    * @private
    */

    _currentlyHighlighted: null,

    /**
     * Sets up the animation for expanding children
     * @method setExpandAnim
     * @param {string} type the type of animation (acceptable values defined
     * in YAHOO.widget.TVAnim)
     */
    setExpandAnim: function(type) {
        this._expandAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    /**
     * Sets up the animation for collapsing children
     * @method setCollapseAnim
     * @param {string} type of animation (acceptable values defined in
     * YAHOO.widget.TVAnim)
     */
    setCollapseAnim: function(type) {
        this._collapseAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    /**
     * Perform the expand animation if configured, or just show the
     * element if not configured or too many animations are in progress
     * @method animateExpand
     * @param el {HTMLElement} the element to animate
     * @param node {YAHOO.util.Node} the node that was expanded
     * @return {boolean} true if animation could be invoked, false otherwise
     */
    animateExpand: function(el, node) {

        if (this._expandAnim && this._animCount < this.maxAnim) {
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._expandAnim, el,
                            function() { tree.expandComplete(node); });
            if (a) {
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node,
                        "type": "expand"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    /**
     * Perform the collapse animation if configured, or just show the
     * element if not configured or too many animations are in progress
     * @method animateCollapse
     * @param el {HTMLElement} the element to animate
     * @param node {YAHOO.util.Node} the node that was expanded
     * @return {boolean} true if animation could be invoked, false otherwise
     */
    animateCollapse: function(el, node) {

        if (this._collapseAnim && this._animCount < this.maxAnim) {
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._collapseAnim, el,
                            function() { tree.collapseComplete(node); });
            if (a) {
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node,
                        "type": "collapse"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    /**
     * Function executed when the expand animation completes
     * @method expandComplete
     */
    expandComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node,
                "type": "expand"
            });
    },

    /**
     * Function executed when the collapse animation completes
     * @method collapseComplete
     */
    collapseComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node,
                "type": "collapse"
            });
    },

    /**
     * Initializes the tree
     * @method init
     * @parm {string|HTMLElement} id the id of the element that will hold the tree
     * @private
     */
    init: function(id) {
        this._el = Dom.get(id);
        this.id = Dom.generateId(this._el,"yui-tv-auto-id-");

    /**
         * When animation is enabled, this event fires when the animation
         * starts
         * @event animStart
         * @type CustomEvent
         * @param {YAHOO.widget.Node} oArgs.node the node that is expanding/collapsing
         * @param {String} oArgs.type the type of animation ("expand" or "collapse")
         */
        this.createEvent("animStart", this);

        /**
         * When animation is enabled, this event fires when the animation
         * completes
         * @event animComplete
         * @type CustomEvent
         * @param {YAHOO.widget.Node} oArgs.node the node that is expanding/collapsing
         * @param {String} oArgs.type the type of animation ("expand" or "collapse")
         */
        this.createEvent("animComplete", this);

        /**
         * Fires when a node is going to be collapsed.  Return false to stop
         * the collapse.
         * @event collapse
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node that is collapsing
         */
        this.createEvent("collapse", this);

        /**
         * Fires after a node is successfully collapsed.  This event will not fire
         * if the "collapse" event was cancelled.
         * @event collapseComplete
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node that was collapsed
         */
        this.createEvent("collapseComplete", this);

        /**
         * Fires when a node is going to be expanded.  Return false to stop
         * the collapse.
         * @event expand
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node that is expanding
         */
        this.createEvent("expand", this);

        /**
         * Fires after a node is successfully expanded.  This event will not fire
         * if the "expand" event was cancelled.
         * @event expandComplete
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node that was expanded
         */
        this.createEvent("expandComplete", this);

    /**
         * Fires when the Enter key is pressed on a node that has the focus
         * @event enterKeyPressed
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node that has the focus
         */
        this.createEvent("enterKeyPressed", this);

    /**
         * Fires when the label in a TextNode or MenuNode or content in an HTMLNode receives a Click.
    * The listener may return false to cancel toggling and focusing on the node.
         * @event clickEvent
         * @type CustomEvent
         * @param oArgs.event  {HTMLEvent} The event object
         * @param oArgs.node {YAHOO.widget.Node} node the node that was clicked
         */
        this.createEvent("clickEvent", this);

    /**
         * Fires when the focus receives the focus, when it changes from a Node
    * to another Node or when it is completely lost (blurred)
         * @event focusChanged
         * @type CustomEvent
         * @param oArgs.oldNode  {YAHOO.widget.Node} Node that had the focus or null if none
         * @param oArgs.newNode {YAHOO.widget.Node} Node that receives the focus or null if none
         */

        this.createEvent('focusChanged',this);

    /**
         * Fires when the label in a TextNode or MenuNode or content in an HTMLNode receives a double Click
         * @event dblClickEvent
         * @type CustomEvent
         * @param oArgs.event  {HTMLEvent} The event object
         * @param oArgs.node {YAHOO.widget.Node} node the node that was clicked
         */
        var self = this;
        this.createEvent("dblClickEvent", {
            scope:this,
            onSubscribeCallback: function() {
                self._hasDblClickSubscriber = true;
            }
        });

    /**
         * Custom event that is fired when the text node label is clicked.
         *  The node clicked is  provided as an argument
         *
         * @event labelClick
         * @type CustomEvent
         * @param {YAHOO.widget.Node} node the node clicked
    * @deprecated use clickEvent or dblClickEvent
         */
        this.createEvent("labelClick", this);

    /**
     * Custom event fired when the highlight of a node changes.
     * The node that triggered the change is provided as an argument:
     * The status of the highlight can be checked in
     * <a href="YAHOO.widget.Node.html#property_highlightState">nodeRef.highlightState</a>.
     * Depending on <a href="YAHOO.widget.Node.html#property_propagateHighlight">nodeRef.propagateHighlight</a>, other nodes might have changed
     * @event highlightEvent
     * @type CustomEvent
     * @param node {YAHOO.widget.Node} the node that started the change in highlighting state
    */
        this.createEvent("highlightEvent",this);



        this._nodes = [];

        TV.trees[this.id] = this;

        this.root = new Widget.RootNode(this);

        var LW = Widget.LogWriter;



		if (this._initEditor) {
			this._initEditor();
		}

    },

 /**
     * Builds the TreeView from an object.
     * This is the method called by the constructor to build the tree when it has a second argument.
     *  A tree can be described by an array of objects, each object corresponding to a node.
     *  Node descriptions may contain values for any property of a node plus the following extra properties: <ul>
     * <li>type:  can be one of the following:<ul>
     *    <li> A shortname for a node type (<code>'text','menu','html'</code>) </li>
     *    <li>The name of a Node class under YAHOO.widget (<code>'TextNode', 'MenuNode', 'DateNode'</code>, etc) </li>
     *    <li>a reference to an actual class: <code>YAHOO.widget.DateNode</code></li>
	 * </ul></li>
     * <li>children: an array containing further node definitions</li></ul>
	 * A string instead of an object will produce a node of type 'text' with the given string as its label.
     * @method buildTreeFromObject
     * @param  oConfig {Array|Object|String}  array containing a full description of the tree.
     *        An object or a string will be turned into an array with the given object or string as its only element.
     *
     */
    buildTreeFromObject: function (oConfig) {
        var build = function (parent, oConfig) {
            var i, item, node, children, type, NodeType, ThisType;
            for (i = 0; i < oConfig.length; i++) {
                item = oConfig[i];
                if (Lang.isString(item)) {
                    node = new Widget.TextNode(item, parent);
                } else if (Lang.isObject(item)) {
                    children = item.children;
                    delete item.children;
                    type = item.type || 'text';
                    delete item.type;
                    switch (Lang.isString(type) && type.toLowerCase()) {
                        case 'text':
                            node = new Widget.TextNode(item, parent);
                            break;
                        case 'menu':
                            node = new Widget.MenuNode(item, parent);
                            break;
                        case 'html':
                            node = new Widget.HTMLNode(item, parent);
                            break;
                        default:
                            if (Lang.isString(type)) {
                                NodeType = Widget[type];
                            } else {
                                NodeType = type;
                            }
                            if (Lang.isObject(NodeType)) {
                                for (ThisType = NodeType; ThisType && ThisType !== Widget.Node; ThisType = ThisType.superclass.constructor) {}
                                if (ThisType) {
                                    node = new NodeType(item, parent);
                                } else {
                                }
                            } else {
                            }
                    }
                    if (children) {
                        build(node,children);
                    }
                } else {
                }
            }
        };
        if (!Lang.isArray(oConfig)) {
            oConfig = [oConfig];
        }


        build(this.root,oConfig);
    },
/**
     * Builds the TreeView from existing markup.   Markup should consist of &lt;UL&gt; or &lt;OL&gt; elements containing &lt;LI&gt; elements.
     * Each &lt;LI&gt; can have one element used as label and a second optional element which is to be a &lt;UL&gt; or &lt;OL&gt;
     * containing nested nodes.
     * Depending on what the first element of the &lt;LI&gt; element is, the following Nodes will be created: <ul>
     *           <li>plain text:  a regular TextNode</li>
     *           <li>anchor &lt;A&gt;: a TextNode with its <code>href</code> and <code>target</code> taken from the anchor</li>
     *           <li>anything else: an HTMLNode</li></ul>
     * Only the first  outermost (un-)ordered list in the markup and its children will be parsed.
     * Nodes will be collapsed unless  an  &lt;LI&gt;  tag has a className called 'expanded'.
     * All other className attributes will be copied over to the Node className property.
     * If the &lt;LI&gt; element contains an attribute called <code>yuiConfig</code>, its contents should be a JSON-encoded object
     * as the one used in method <a href="#method_buildTreeFromObject">buildTreeFromObject</a>.
     * @method buildTreeFromMarkup
     * @param  id {string|HTMLElement} The id of the element that contains the markup or a reference to it.
     */
    buildTreeFromMarkup: function (id) {
        var build = function (markup) {
            var el, child, branch = [], config = {}, label, yuiConfig;
            for (el = Dom.getFirstChild(markup); el; el = Dom.getNextSibling(el)) {
                switch (el.tagName.toUpperCase()) {
                    case 'LI':
                        label = '';
                        config = {
                            expanded: Dom.hasClass(el,'expanded'),
                            title: el.title || el.alt || null,
                            className: Lang.trim(el.className.replace(/\bexpanded\b/,'')) || null
                        };
                        child = el.firstChild;
                        if (child.nodeType == 3) {
                            label = Lang.trim(child.nodeValue.replace(/[\n\t\r]*/g,''));
                            if (label) {
                                config.type = 'text';
                                config.label = label;
                            } else {
                                child = Dom.getNextSibling(child);
                            }
                        }
                        if (!label) {
                            if (child.tagName.toUpperCase() == 'A') {
                                config.type = 'text';
                                config.label = child.innerHTML;
                                config.href = child.href;
                                config.target = child.target;
                                config.title = child.title || child.alt || config.title;
                            } else {
                                config.type = 'html';
                                var d = document.createElement('div');
                                d.appendChild(child.cloneNode(true));
                                config.html = d.innerHTML;
                                config.hasIcon = true;
                            }
                        }
                        child = Dom.getNextSibling(child);
                        switch (child && child.tagName.toUpperCase()) {
                            case 'UL':
                            case 'OL':
                                config.children = build(child);
                                break;
                        }

                        if (YAHOO.lang.JSON) {
                            yuiConfig = el.getAttribute('yuiConfig');
                            if (yuiConfig) {
                                yuiConfig = YAHOO.lang.JSON.parse(yuiConfig);
                                config = YAHOO.lang.merge(config,yuiConfig);
                            }
                        }

                        branch.push(config);
                        break;
                    case 'UL':
                    case 'OL':
                        config = {
                            type: 'text',
                            label: '',
                            children: build(child)
                        };
                        branch.push(config);
                        break;
                }
            }
            return branch;
        };

        var markup = Dom.getChildrenBy(Dom.get(id),function (el) {
            var tag = el.tagName.toUpperCase();
            return  tag == 'UL' || tag == 'OL';
        });
        if (markup.length) {
            this.buildTreeFromObject(build(markup[0]));
        } else {
        }
    },
  /**
     * Returns the TD element where the event has occurred
     * @method _getEventTargetTdEl
     * @private
     */
    _getEventTargetTdEl: function (ev) {
        var target = Event.getTarget(ev);
        while (target && !(target.tagName.toUpperCase() == 'TD' && Dom.hasClass(target.parentNode,'ygtvrow'))) {
            target = Dom.getAncestorByTagName(target,'td');
        }
        if (Lang.isNull(target)) { return null; }
        if (/\bygtv(blank)?depthcell/.test(target.className)) { return null;}
        if (target.id) {
            var m = target.id.match(/\bygtv([^\d]*)(.*)/);
            if (m && m[2] && this._nodes[m[2]]) {
                return target;
            }
        }
        return null;
    },
  /**
     * Event listener for click events
     * @method _onClickEvent
     * @private
     */
    _onClickEvent: function (ev) {
        var self = this,
            td = this._getEventTargetTdEl(ev),
            node,
            target,
            toggle = function (force) {
                node.focus();
				if (force || !node.href) {
					node.toggle();
					try {
						Event.preventDefault(ev);
					} catch (e) {
					}
                }
            };

        if (!td) {
            return;
        }

        node = this.getNodeByElement(td);
        if (!node) {
            return;
        }

        target = Event.getTarget(ev);
        if (Dom.hasClass(target, node.labelStyle) || Dom.getAncestorByClassName(target,node.labelStyle)) {
            this.fireEvent('labelClick',node);
        }

        if (/\bygtv[tl][mp]h?h?/.test(td.className)) {
            toggle(true);
        } else {
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            } else {
                if (this._hasDblClickSubscriber) {
                    this._dblClickTimer = window.setTimeout(function () {
                        self._dblClickTimer = null;
                        if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) {
                            toggle();
                        }
                    }, 200);
                } else {
                    if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) {
                        toggle();
                    }
                }
            }
        }
    },

  /**
     * Event listener for double-click events
     * @method _onDblClickEvent
     * @private
     */
    _onDblClickEvent: function (ev) {
        if (!this._hasDblClickSubscriber) { return; }
        var td = this._getEventTargetTdEl(ev);
        if (!td) {return;}

        if (!(/\bygtv[tl][mp]h?h?/.test(td.className))) {
            this.fireEvent('dblClickEvent', {event:ev, node:this.getNodeByElement(td)});
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            }
        }
    },
  /**
     * Event listener for mouse over events
     * @method _onMouseOverEvent
     * @private
     */
    _onMouseOverEvent:function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])\b/gi,'ygtv$1$2h');
        }
    },
  /**
     * Event listener for mouse out events
     * @method _onMouseOutEvent
     * @private
     */
    _onMouseOutEvent: function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])h\b/gi,'ygtv$1$2');
        }
    },
  /**
     * Event listener for key down events
     * @method _onKeyDownEvent
     * @private
     */
    _onKeyDownEvent: function (ev) {
        var target = Event.getTarget(ev),
            node = this.getNodeByElement(target),
            newNode = node,
            KEY = YAHOO.util.KeyListener.KEY;

        switch(ev.keyCode) {
            case KEY.UP:
                do {
                    if (newNode.previousSibling) {
                        newNode = newNode.previousSibling;
                    } else {
                        newNode = newNode.parent;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.DOWN:
                do {
                    if (newNode.nextSibling) {
                        newNode = newNode.nextSibling;
                    } else {
                        newNode.expand();
                        newNode = (newNode.children.length || null) && newNode.children[0];
                    }
                } while (newNode && !newNode._canHaveFocus);
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
            case KEY.LEFT:
                do {
                    if (newNode.parent) {
                        newNode = newNode.parent;
                    } else {
                        newNode = newNode.previousSibling;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
			case KEY.RIGHT:
				var self = this,
					moveFocusRight,
					focusOnExpand = function (newNode) {
						self.unsubscribe('expandComplete',focusOnExpand);
						moveFocusRight(newNode);
					};
				moveFocusRight = function (newNode) {
					do {
						if (newNode.isDynamic() && !newNode.childrenRendered) {
							self.subscribe('expandComplete',focusOnExpand);
							newNode.expand();
							newNode = null;
							break;
						} else {
							newNode.expand();
							if (newNode.children.length) {
								newNode = newNode.children[0];
							} else {
								newNode = newNode.nextSibling;
							}
						}
					} while (newNode && !newNode._canHaveFocus());
					if (newNode) { newNode.focus();}
				};

				moveFocusRight(newNode);
				Event.preventDefault(ev);
				break;
            case KEY.ENTER:
                if (node.href) {
                    if (node.target) {
                        window.open(node.href,node.target);
                    } else {
                        window.location(node.href);
                    }
                } else {
                    node.toggle();
                }
                this.fireEvent('enterKeyPressed',node);
                Event.preventDefault(ev);
                break;
            case KEY.HOME:
                newNode = this.getRoot();
                if (newNode.children.length) {newNode = newNode.children[0];}
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.END:
                newNode = newNode.parent.children;
                newNode = newNode[newNode.length -1];
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case 107:  // plus key
                if (ev.shiftKey) {
                    node.parent.expandAll();
                } else {
                    node.expand();
                }
                break;
            case 109: // minus key
                if (ev.shiftKey) {
                    node.parent.collapseAll();
                } else {
                    node.collapse();
                }
                break;
            default:
                break;
        }
    },
    /**
     * Renders the tree boilerplate and visible nodes
     * @method render
     */
    render: function() {
        var html = this.root.getHtml(),
            el = this.getEl();
        el.innerHTML = html;
        if (!this._hasEvents) {
            Event.on(el, 'click', this._onClickEvent, this, true);
            Event.on(el, 'dblclick', this._onDblClickEvent, this, true);
            Event.on(el, 'mouseover', this._onMouseOverEvent, this, true);
            Event.on(el, 'mouseout', this._onMouseOutEvent, this, true);
            Event.on(el, 'keydown', this._onKeyDownEvent, this, true);
        }
        this._hasEvents = true;
    },

  /**
     * Returns the tree's host element
     * @method getEl
     * @return {HTMLElement} the host element
     */
    getEl: function() {
        if (! this._el) {
            this._el = Dom.get(this.id);
        }
        return this._el;
    },

    /**
     * Nodes register themselves with the tree instance when they are created.
     * @method regNode
     * @param node {Node} the node to register
     * @private
     */
    regNode: function(node) {
        this._nodes[node.index] = node;
    },

    /**
     * Returns the root node of this tree
     * @method getRoot
     * @return {Node} the root node
     */
    getRoot: function() {
        return this.root;
    },

    /**
     * Configures this tree to dynamically load all child data
     * @method setDynamicLoad
     * @param {function} fnDataLoader the function that will be called to get the data
     * @param iconMode {int} configures the icon that is displayed when a dynamic
     * load node is expanded the first time without children.  By default, the
     * "collapse" icon will be used.  If set to 1, the leaf node icon will be
     * displayed.
     */
    setDynamicLoad: function(fnDataLoader, iconMode) {
        this.root.setDynamicLoad(fnDataLoader, iconMode);
    },

    /**
     * Expands all child nodes.  Note: this conflicts with the "multiExpand"
     * node property.  If expand all is called in a tree with nodes that
     * do not allow multiple siblings to be displayed, only the last sibling
     * will be expanded.
     * @method expandAll
     */
    expandAll: function() {
        if (!this.locked) {
            this.root.expandAll();
        }
    },

    /**
     * Collapses all expanded child nodes in the entire tree.
     * @method collapseAll
     */
    collapseAll: function() {
        if (!this.locked) {
            this.root.collapseAll();
        }
    },

    /**
     * Returns a node in the tree that has the specified index (this index
     * is created internally, so this function probably will only be used
     * in html generated for a given node.)
     * @method getNodeByIndex
     * @param {int} nodeIndex the index of the node wanted
     * @return {Node} the node with index=nodeIndex, null if no match
     */
    getNodeByIndex: function(nodeIndex) {
        var n = this._nodes[nodeIndex];
        return (n) ? n : null;
    },

    /**
     * Returns a node that has a matching property and value in the data
     * object that was passed into its constructor.
     * @method getNodeByProperty
     * @param {object} property the property to search (usually a string)
     * @param {object} value the value we want to find (usuall an int or string)
     * @return {Node} the matching node, null if no match
     */
    getNodeByProperty: function(property, value) {
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    return n;
                }
            }
        }

        return null;
    },

    /**
     * Returns a collection of nodes that have a matching property
     * and value in the data object that was passed into its constructor.
     * @method getNodesByProperty
     * @param {object} property the property to search (usually a string)
     * @param {object} value the value we want to find (usuall an int or string)
     * @return {Array} the matching collection of nodes, null if no match
     */
    getNodesByProperty: function(property, value) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    values.push(n);
                }
            }
        }

        return (values.length) ? values : null;
    },


    /**
     * Returns a collection of nodes that have passed the test function
	 * passed as its only argument.
	 * The function will receive a reference to each node to be tested.
     * @method getNodesBy
     * @param {function} a boolean function that receives a Node instance and returns true to add the node to the results list
     * @return {Array} the matching collection of nodes, null if no match
     */
    getNodesBy: function(fn) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if (fn(n)) {
                    values.push(n);
                }
            }
        }
        return (values.length) ? values : null;
    },
    /**
     * Returns the treeview node reference for an ancestor element
     * of the node, or null if it is not contained within any node
     * in this tree.
     * @method getNodeByElement
     * @param el {HTMLElement} the element to test
     * @return {YAHOO.widget.Node} a node reference or null
     */
    getNodeByElement: function(el) {

        var p=el, m, re=/ygtv([^\d]*)(.*)/;

        do {

            if (p && p.id) {
                m = p.id.match(re);
                if (m && m[2]) {
                    return this.getNodeByIndex(m[2]);
                }
            }

            p = p.parentNode;

            if (!p || !p.tagName) {
                break;
            }

        }
        while (p.id !== this.id && p.tagName.toLowerCase() !== "body");

        return null;
    },

    /**
     * When in singleNodeHighlight it returns the node highlighted
	 * or null if none.  Returns null if singleNodeHighlight is false.
     * @method getHighlightedNode
     * @return {YAHOO.widget.Node} a node reference or null
     */
	getHighlightedNode: function() {
		return this._currentlyHighlighted;
	},


    /**
     * Removes the node and its children, and optionally refreshes the
     * branch of the tree that was affected.
     * @method removeNode
     * @param {Node} node to remove
     * @param {boolean} autoRefresh automatically refreshes branch if true
     * @return {boolean} False is there was a problem, true otherwise.
     */
    removeNode: function(node, autoRefresh) {

        if (node.isRoot()) {
            return false;
        }

        var p = node.parent;
        if (p.parent) {
            p = p.parent;
        }

        this._deleteNode(node);

        if (autoRefresh && p && p.childrenRendered) {
            p.refresh();
        }

        return true;
    },

    /**
     * wait until the animation is complete before deleting
     * to avoid javascript errors
     * @method _removeChildren_animComplete
     * @param o the custom event payload
     * @private
     */
    _removeChildren_animComplete: function(o) {
        this.unsubscribe(this._removeChildren_animComplete);
        this.removeChildren(o.node);
    },

    /**
     * Deletes this nodes child collection, recursively.  Also collapses
     * the node, and resets the dynamic load flag.  The primary use for
     * this method is to purge a node and allow it to fetch its data
     * dynamically again.
     * @method removeChildren
     * @param {Node} node the node to purge
     */
    removeChildren: function(node) {

        if (node.expanded) {
            if (this._collapseAnim) {
                this.subscribe("animComplete",
                        this._removeChildren_animComplete, this, true);
                Widget.Node.prototype.collapse.call(node);
                return;
            }

            node.collapse();
        }

        while (node.children.length) {
            this._deleteNode(node.children[0]);
        }

        if (node.isRoot()) {
            Widget.Node.prototype.expand.call(node);
        }

        node.childrenRendered = false;
        node.dynamicLoadComplete = false;

        node.updateIcon();
    },

    /**
     * Deletes the node and recurses children
     * @method _deleteNode
     * @private
     */
    _deleteNode: function(node) {
        this.removeChildren(node);

        this.popNode(node);
    },

    /**
     * Removes the node from the tree, preserving the child collection
     * to make it possible to insert the branch into another part of the
     * tree, or another tree.
     * @method popNode
     * @param {Node} node to remove
     */
    popNode: function(node) {
        var p = node.parent;

        var a = [];

        for (var i=0, len=p.children.length;i<len;++i) {
            if (p.children[i] != node) {
                a[a.length] = p.children[i];
            }
        }

        p.children = a;

        p.childrenRendered = false;

        if (node.previousSibling) {
            node.previousSibling.nextSibling = node.nextSibling;
        }

        if (node.nextSibling) {
            node.nextSibling.previousSibling = node.previousSibling;
        }

		if (this.currentFocus == node) {
			this.currentFocus = null;
		}
		if (this._currentlyHighlighted == node) {
			this._currentlyHighlighted = null;
		}

        node.parent = null;
        node.previousSibling = null;
        node.nextSibling = null;
        node.tree = null;

        delete this._nodes[node.index];
    },

    /**
    * Nulls out the entire TreeView instance and related objects, removes attached
    * event listeners, and clears out DOM elements inside the container. After
    * calling this method, the instance reference should be expliclitly nulled by
    * implementer, as in myDataTable = null. Use with caution!
    *
    * @method destroy
    */
    destroy : function() {
        if (this._destroyEditor) { this._destroyEditor(); }
        var el = this.getEl();
        Event.removeListener(el,'click');
        Event.removeListener(el,'dblclick');
        Event.removeListener(el,'mouseover');
        Event.removeListener(el,'mouseout');
        Event.removeListener(el,'keydown');
        for (var i = 0 ; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            if (node && node.destroy) {node.destroy(); }
        }
        el.innerHTML = '';
        this._hasEvents = false;
    },




    /**
     * TreeView instance toString
     * @method toString
     * @return {string} string representation of the tree
     */
    toString: function() {
        return "TreeView " + this.id;
    },

    /**
     * Count of nodes in tree
     * @method getNodeCount
     * @return {int} number of nodes in the tree
     */
    getNodeCount: function() {
        return this.getRoot().getNodeCount();
    },

    /**
     * Returns an object which could be used to rebuild the tree.
     * It can be passed to the tree constructor to reproduce the same tree.
     * It will return false if any node loads dynamically, regardless of whether it is loaded or not.
     * @method getTreeDefinition
     * @return {Object | false}  definition of the tree or false if any node is defined as dynamic
     */
    getTreeDefinition: function() {
        return this.getRoot().getNodeDefinition();
    },

    /**
     * Abstract method that is executed when a node is expanded
     * @method onExpand
     * @param node {Node} the node that was expanded
     * @deprecated use treeobj.subscribe("expand") instead
     */
    onExpand: function(node) { },

    /**
     * Abstract method that is executed when a node is collapsed.
     * @method onCollapse
     * @param node {Node} the node that was collapsed.
     * @deprecated use treeobj.subscribe("collapse") instead
     */
    onCollapse: function(node) { },

    /**
    * Sets the value of a property for all loaded nodes in the tree.
    * @method setNodesProperty
    * @param name {string} Name of the property to be set
    * @param value {any} value to be set
    * @param refresh {boolean} if present and true, it does a refresh
    */
    setNodesProperty: function(name, value, refresh) {
        this.root.setNodesProperty(name,value);
        if (refresh) {
            this.root.refresh();
        }
    },
    /**
    * Event listener to toggle node highlight.
    * Can be assigned as listener to clickEvent, dblClickEvent and enterKeyPressed.
    * It returns false to prevent the default action.
    * @method onEventToggleHighlight
    * @param oArgs {any} it takes the arguments of any of the events mentioned above
    * @return {false} Always cancels the default action for the event
    */
    onEventToggleHighlight: function (oArgs) {
        var node;
        if ('node' in oArgs && oArgs.node instanceof Widget.Node) {
            node = oArgs.node;
        } else if (oArgs instanceof Widget.Node) {
            node = oArgs;
        } else {
            return false;
        }
        node.toggleHighlight();
        return false;
    }


};

/* Backwards compatibility aliases */
var PROT = TV.prototype;
 /**
     * Renders the tree boilerplate and visible nodes.
     *  Alias for render
     * @method draw
     * @deprecated Use render instead
     */
PROT.draw = PROT.render;

/* end backwards compatibility aliases */

YAHOO.augment(TV, YAHOO.util.EventProvider);

/**
 * Running count of all nodes created in all trees.  This is
 * used to provide unique identifies for all nodes.  Deleting
 * nodes does not change the nodeCount.
 * @property YAHOO.widget.TreeView.nodeCount
 * @type int
 * @static
 */
TV.nodeCount = 0;

/**
 * Global cache of tree instances
 * @property YAHOO.widget.TreeView.trees
 * @type Array
 * @static
 * @private
 */
TV.trees = [];

/**
 * Global method for getting a tree by its id.  Used in the generated
 * tree html.
 * @method YAHOO.widget.TreeView.getTree
 * @param treeId {String} the id of the tree instance
 * @return {TreeView} the tree instance requested, null if not found.
 * @static
 */
TV.getTree = function(treeId) {
    var t = TV.trees[treeId];
    return (t) ? t : null;
};


/**
 * Global method for getting a node by its id.  Used in the generated
 * tree html.
 * @method YAHOO.widget.TreeView.getNode
 * @param treeId {String} the id of the tree instance
 * @param nodeIndex {String} the index of the node to return
 * @return {Node} the node instance requested, null if not found
 * @static
 */
TV.getNode = function(treeId, nodeIndex) {
    var t = TV.getTree(treeId);
    return (t) ? t.getNodeByIndex(nodeIndex) : null;
};


/**
     * Class name assigned to elements that have the focus
     *
     * @property TreeView.FOCUS_CLASS_NAME
     * @type String
     * @static
     * @final
     * @default "ygtvfocus"

    */
TV.FOCUS_CLASS_NAME = 'ygtvfocus';



})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;
/**
 * The base class for all tree nodes.  The node's presentation and behavior in
 * response to mouse events is handled in Node subclasses.
 * @namespace YAHOO.widget
 * @class Node
 * @uses YAHOO.util.EventProvider
 * @param oData {object} a string or object containing the data that will
 * be used to render this node, and any custom attributes that should be
 * stored with the node (which is available in noderef.data).
 * All values in oData will be used to set equally named properties in the node
 * as long as the node does have such properties, they are not undefined, private or functions,
 * the rest of the values will be stored in noderef.data
 * @param oParent {Node} this node's parent node
 * @param expanded {boolean} the initial expanded/collapsed state (deprecated, use oData.expanded)
 * @constructor
 */
YAHOO.widget.Node = function(oData, oParent, expanded) {
    if (oData) { this.init(oData, oParent, expanded); }
};

YAHOO.widget.Node.prototype = {

    /**
     * The index for this instance obtained from global counter in YAHOO.widget.TreeView.
     * @property index
     * @type int
     */
    index: 0,

    /**
     * This node's child node collection.
     * @property children
     * @type Node[]
     */
    children: null,

    /**
     * Tree instance this node is part of
     * @property tree
     * @type TreeView
     */
    tree: null,

    /**
     * The data linked to this node.  This can be any object or primitive
     * value, and the data can be used in getNodeHtml().
     * @property data
     * @type object
     */
    data: null,

    /**
     * Parent node
     * @property parent
     * @type Node
     */
    parent: null,

    /**
     * The depth of this node.  We start at -1 for the root node.
     * @property depth
     * @type int
     */
    depth: -1,

    /**
     * The node's expanded/collapsed state
     * @property expanded
     * @type boolean
     */
    expanded: false,

    /**
     * Can multiple children be expanded at once?
     * @property multiExpand
     * @type boolean
     */
    multiExpand: true,

    /**
     * Should we render children for a collapsed node?  It is possible that the
     * implementer will want to render the hidden data...  @todo verify that we
     * need this, and implement it if we do.
     * @property renderHidden
     * @type boolean
     */
    renderHidden: false,

    /**
     * This flag is set to true when the html is generated for this node's
     * children, and set to false when new children are added.
     * @property childrenRendered
     * @type boolean
     */
    childrenRendered: false,

    /**
     * Dynamically loaded nodes only fetch the data the first time they are
     * expanded.  This flag is set to true once the data has been fetched.
     * @property dynamicLoadComplete
     * @type boolean
     */
    dynamicLoadComplete: false,

    /**
     * This node's previous sibling
     * @property previousSibling
     * @type Node
     */
    previousSibling: null,

    /**
     * This node's next sibling
     * @property nextSibling
     * @type Node
     */
    nextSibling: null,

    /**
     * We can set the node up to call an external method to get the child
     * data dynamically.
     * @property _dynLoad
     * @type boolean
     * @private
     */
    _dynLoad: false,

    /**
     * Function to execute when we need to get this node's child data.
     * @property dataLoader
     * @type function
     */
    dataLoader: null,

    /**
     * This is true for dynamically loading nodes while waiting for the
     * callback to return.
     * @property isLoading
     * @type boolean
     */
    isLoading: false,

    /**
     * The toggle/branch icon will not show if this is set to false.  This
     * could be useful if the implementer wants to have the child contain
     * extra info about the parent, rather than an actual node.
     * @property hasIcon
     * @type boolean
     */
    hasIcon: true,

    /**
     * Used to configure what happens when a dynamic load node is expanded
     * and we discover that it does not have children.  By default, it is
     * treated as if it still could have children (plus/minus icon).  Set
     * iconMode to have it display like a leaf node instead.
     * @property iconMode
     * @type int
     */
    iconMode: 0,

    /**
     * Specifies whether or not the content area of the node should be allowed
     * to wrap.
     * @property nowrap
     * @type boolean
     * @default false
     */
    nowrap: false,

 /**
     * If true, the node will alway be rendered as a leaf node.  This can be
     * used to override the presentation when dynamically loading the entire
     * tree.  Setting this to true also disables the dynamic load call for the
     * node.
     * @property isLeaf
     * @type boolean
     * @default false
     */
    isLeaf: false,

/**
     * The CSS class for the html content container.  Defaults to ygtvhtml, but
     * can be overridden to provide a custom presentation for a specific node.
     * @property contentStyle
     * @type string
     */
    contentStyle: "",


    /**
     * The generated id that will contain the data passed in by the implementer.
     * @property contentElId
     * @type string
     */
    contentElId: null,

/**
 * Enables node highlighting.  If true, the node can be highlighted and/or propagate highlighting
 * @property enableHighlight
 * @type boolean
 * @default true
 */
    enableHighlight: true,

/**
 * Stores the highlight state.  Can be any of:
 * <ul>
 * <li>0 - not highlighted</li>
 * <li>1 - highlighted</li>
 * <li>2 - some children highlighted</li>
 * </ul>
 * @property highlightState
 * @type integer
 * @default 0
 */

 highlightState: 0,

 /**
 * Tells whether highlighting will be propagated up to the parents of the clicked node
 * @property propagateHighlightUp
 * @type boolean
 * @default false
 */

 propagateHighlightUp: false,

 /**
 * Tells whether highlighting will be propagated down to the children of the clicked node
 * @property propagateHighlightDown
 * @type boolean
 * @default false
 */

 propagateHighlightDown: false,

 /**
  * User-defined className to be added to the Node
  * @property className
  * @type string
  * @default null
  */

 className: null,

 /**
     * The node type
     * @property _type
     * @private
     * @type string
     * @default "Node"
*/
    _type: "Node",

    /*
    spacerPath: "http://l.yimg.com/a/i/space.gif",
    expandedText: "Expanded",
    collapsedText: "Collapsed",
    loadingText: "Loading",
    */

    /**
     * Initializes this node, gets some of the properties from the parent
     * @method init
     * @param oData {object} a string or object containing the data that will
     * be used to render this node
     * @param oParent {Node} this node's parent node
     * @param expanded {boolean} the initial expanded/collapsed state
     */
    init: function(oData, oParent, expanded) {

        this.data = {};
        this.children   = [];
        this.index      = YAHOO.widget.TreeView.nodeCount;
        ++YAHOO.widget.TreeView.nodeCount;
        this.contentElId = "ygtvcontentel" + this.index;

        if (Lang.isObject(oData)) {
            for (var property in oData) {
                if (oData.hasOwnProperty(property)) {
                    if (property.charAt(0) != '_'  && !Lang.isUndefined(this[property]) && !Lang.isFunction(this[property]) ) {
                        this[property] = oData[property];
                    } else {
                        this.data[property] = oData[property];
                    }
                }
            }
        }
        if (!Lang.isUndefined(expanded) ) { this.expanded  = expanded;  }


        /**
         * The parentChange event is fired when a parent element is applied
         * to the node.  This is useful if you need to apply tree-level
         * properties to a tree that need to happen if a node is moved from
         * one tree to another.
         *
         * @event parentChange
         * @type CustomEvent
         */
        this.createEvent("parentChange", this);

        if (oParent) {
            oParent.appendChild(this);
        }
    },

    /**
     * Certain properties for the node cannot be set until the parent
     * is known. This is called after the node is inserted into a tree.
     * the parent is also applied to this node's children in order to
     * make it possible to move a branch from one tree to another.
     * @method applyParent
     * @param {Node} parentNode this node's parent node
     * @return {boolean} true if the application was successful
     */
    applyParent: function(parentNode) {
        if (!parentNode) {
            return false;
        }

        this.tree   = parentNode.tree;
        this.parent = parentNode;
        this.depth  = parentNode.depth + 1;


        this.tree.regNode(this);
        parentNode.childrenRendered = false;

        for (var i=0, len=this.children.length;i<len;++i) {
            this.children[i].applyParent(this);
        }

        this.fireEvent("parentChange");

        return true;
    },

    /**
     * Appends a node to the child collection.
     * @method appendChild
     * @param childNode {Node} the new node
     * @return {Node} the child node
     * @private
     */
    appendChild: function(childNode) {
        if (this.hasChildren()) {
            var sib = this.children[this.children.length - 1];
            sib.nextSibling = childNode;
            childNode.previousSibling = sib;
        }
        this.children[this.children.length] = childNode;
        childNode.applyParent(this);

        if (this.childrenRendered && this.expanded) {
            this.getChildrenEl().style.display = "";
        }

        return childNode;
    },

    /**
     * Appends this node to the supplied node's child collection
     * @method appendTo
     * @param parentNode {Node} the node to append to.
     * @return {Node} The appended node
     */
    appendTo: function(parentNode) {
        return parentNode.appendChild(this);
    },

    /**
    * Inserts this node before this supplied node
    * @method insertBefore
    * @param node {Node} the node to insert this node before
    * @return {Node} the inserted node
    */
    insertBefore: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);
            p.children.splice(refIndex, 0, this);
            if (node.previousSibling) {
                node.previousSibling.nextSibling = this;
            }
            this.previousSibling = node.previousSibling;
            this.nextSibling = node;
            node.previousSibling = this;

            this.applyParent(p);
        }

        return this;
    },

    /**
    * Inserts this node after the supplied node
    * @method insertAfter
    * @param node {Node} the node to insert after
    * @return {Node} the inserted node
    */
    insertAfter: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);

            if (!node.nextSibling) {
                this.nextSibling = null;
                return this.appendTo(p);
            }

            p.children.splice(refIndex + 1, 0, this);

            node.nextSibling.previousSibling = this;
            this.previousSibling = node;
            this.nextSibling = node.nextSibling;
            node.nextSibling = this;

            this.applyParent(p);
        }

        return this;
    },

    /**
    * Returns true if the Node is a child of supplied Node
    * @method isChildOf
    * @param parentNode {Node} the Node to check
    * @return {boolean} The node index if this Node is a child of
    *                   supplied Node, else -1.
    * @private
    */
    isChildOf: function(parentNode) {
        if (parentNode && parentNode.children) {
            for (var i=0, len=parentNode.children.length; i<len ; ++i) {
                if (parentNode.children[i] === this) {
                    return i;
                }
            }
        }

        return -1;
    },

    /**
     * Returns a node array of this node's siblings, null if none.
     * @method getSiblings
     * @return Node[]
     */
    getSiblings: function() {
        var sib =  this.parent.children.slice(0);
        for (var i=0;i < sib.length && sib[i] != this;i++) {}
        sib.splice(i,1);
        if (sib.length) { return sib; }
        return null;
    },

    /**
     * Shows this node's children
     * @method showChildren
     */
    showChildren: function() {
        if (!this.tree.animateExpand(this.getChildrenEl(), this)) {
            if (this.hasChildren()) {
                this.getChildrenEl().style.display = "";
            }
        }
    },

    /**
     * Hides this node's children
     * @method hideChildren
     */
    hideChildren: function() {

        if (!this.tree.animateCollapse(this.getChildrenEl(), this)) {
            this.getChildrenEl().style.display = "none";
        }
    },

    /**
     * Returns the id for this node's container div
     * @method getElId
     * @return {string} the element id
     */
    getElId: function() {
        return "ygtv" + this.index;
    },

    /**
     * Returns the id for this node's children div
     * @method getChildrenElId
     * @return {string} the element id for this node's children div
     */
    getChildrenElId: function() {
        return "ygtvc" + this.index;
    },

    /**
     * Returns the id for this node's toggle element
     * @method getToggleElId
     * @return {string} the toggel element id
     */
    getToggleElId: function() {
        return "ygtvt" + this.index;
    },


    /*
     * Returns the id for this node's spacer image.  The spacer is positioned
     * over the toggle and provides feedback for screen readers.
     * @method getSpacerId
     * @return {string} the id for the spacer image
     */
    /*
    getSpacerId: function() {
        return "ygtvspacer" + this.index;
    },
    */

    /**
     * Returns this node's container html element
     * @method getEl
     * @return {HTMLElement} the container html element
     */
    getEl: function() {
        return Dom.get(this.getElId());
    },

    /**
     * Returns the div that was generated for this node's children
     * @method getChildrenEl
     * @return {HTMLElement} this node's children div
     */
    getChildrenEl: function() {
        return Dom.get(this.getChildrenElId());
    },

    /**
     * Returns the element that is being used for this node's toggle.
     * @method getToggleEl
     * @return {HTMLElement} this node's toggle html element
     */
    getToggleEl: function() {
        return Dom.get(this.getToggleElId());
    },
    /**
    * Returns the outer html element for this node's content
    * @method getContentEl
    * @return {HTMLElement} the element
    */
    getContentEl: function() {
        return Dom.get(this.contentElId);
    },


    /*
     * Returns the element that is being used for this node's spacer.
     * @method getSpacer
     * @return {HTMLElement} this node's spacer html element
     */
    /*
    getSpacer: function() {
        return document.getElementById( this.getSpacerId() ) || {};
    },
    */

    /*
    getStateText: function() {
        if (this.isLoading) {
            return this.loadingText;
        } else if (this.hasChildren(true)) {
            if (this.expanded) {
                return this.expandedText;
            } else {
                return this.collapsedText;
            }
        } else {
            return "";
        }
    },
    */

  /**
     * Hides this nodes children (creating them if necessary), changes the toggle style.
     * @method collapse
     */
    collapse: function() {
        if (!this.expanded) { return; }

        var ret = this.tree.onCollapse(this);

        if (false === ret) {
            return;
        }

        ret = this.tree.fireEvent("collapse", this);

        if (false === ret) {
            return;
        }


        if (!this.getEl()) {
            this.expanded = false;
        } else {
            this.hideChildren();
            this.expanded = false;

            this.updateIcon();
        }


        ret = this.tree.fireEvent("collapseComplete", this);

    },

    /**
     * Shows this nodes children (creating them if necessary), changes the
     * toggle style, and collapses its siblings if multiExpand is not set.
     * @method expand
     */
    expand: function(lazySource) {
        if (this.isLoading || (this.expanded && !lazySource)) {
            return;
        }

        var ret = true;

        if (!lazySource) {
            ret = this.tree.onExpand(this);

            if (false === ret) {
                return;
            }

            ret = this.tree.fireEvent("expand", this);
        }

        if (false === ret) {
            return;
        }

        if (!this.getEl()) {
            this.expanded = true;
            return;
        }

        if (!this.childrenRendered) {
            this.getChildrenEl().innerHTML = this.renderChildren();
        } else {
        }

        this.expanded = true;

        this.updateIcon();



        if (this.isLoading) {
            this.expanded = false;
            return;
        }

        if (! this.multiExpand) {
            var sibs = this.getSiblings();
            for (var i=0; sibs && i<sibs.length; ++i) {
                if (sibs[i] != this && sibs[i].expanded) {
                    sibs[i].collapse();
                }
            }
        }

        this.showChildren();

        ret = this.tree.fireEvent("expandComplete", this);
    },

    updateIcon: function() {
        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv(([tl][pmn]h?)|(loading))\b/gi,this.getStyle());
            }
        }
    },

    /**
     * Returns the css style name for the toggle
     * @method getStyle
     * @return {string} the css class for this node's toggle
     */
    getStyle: function() {
        if (this.isLoading) {
            return "ygtvloading";
        } else {
            var loc = (this.nextSibling) ? "t" : "l";

            var type = "n";
            if (this.hasChildren(true) || (this.isDynamic() && !this.getIconMode())) {
                type = (this.expanded) ? "m" : "p";
            }

            return "ygtv" + loc + type;
        }
    },

    /**
     * Returns the hover style for the icon
     * @return {string} the css class hover state
     * @method getHoverStyle
     */
    getHoverStyle: function() {
        var s = this.getStyle();
        if (this.hasChildren(true) && !this.isLoading) {
            s += "h";
        }
        return s;
    },

    /**
     * Recursively expands all of this node's children.
     * @method expandAll
     */
    expandAll: function() {
        var l = this.children.length;
        for (var i=0;i<l;++i) {
            var c = this.children[i];
            if (c.isDynamic()) {
                break;
            } else if (! c.multiExpand) {
                break;
            } else {
                c.expand();
                c.expandAll();
            }
        }
    },

    /**
     * Recursively collapses all of this node's children.
     * @method collapseAll
     */
    collapseAll: function() {
        for (var i=0;i<this.children.length;++i) {
            this.children[i].collapse();
            this.children[i].collapseAll();
        }
    },

    /**
     * Configures this node for dynamically obtaining the child data
     * when the node is first expanded.  Calling it without the callback
     * will turn off dynamic load for the node.
     * @method setDynamicLoad
     * @param fmDataLoader {function} the function that will be used to get the data.
     * @param iconMode {int} configures the icon that is displayed when a dynamic
     * load node is expanded the first time without children.  By default, the
     * "collapse" icon will be used.  If set to 1, the leaf node icon will be
     * displayed.
     */
    setDynamicLoad: function(fnDataLoader, iconMode) {
        if (fnDataLoader) {
            this.dataLoader = fnDataLoader;
            this._dynLoad = true;
        } else {
            this.dataLoader = null;
            this._dynLoad = false;
        }

        if (iconMode) {
            this.iconMode = iconMode;
        }
    },

    /**
     * Evaluates if this node is the root node of the tree
     * @method isRoot
     * @return {boolean} true if this is the root node
     */
    isRoot: function() {
        return (this == this.tree.root);
    },

    /**
     * Evaluates if this node's children should be loaded dynamically.  Looks for
     * the property both in this instance and the root node.  If the tree is
     * defined to load all children dynamically, the data callback function is
     * defined in the root node
     * @method isDynamic
     * @return {boolean} true if this node's children are to be loaded dynamically
     */
    isDynamic: function() {
        if (this.isLeaf) {
            return false;
        } else {
            return (!this.isRoot() && (this._dynLoad || this.tree.root._dynLoad));
        }
    },

    /**
     * Returns the current icon mode.  This refers to the way childless dynamic
     * load nodes appear (this comes into play only after the initial dynamic
     * load request produced no children).
     * @method getIconMode
     * @return {int} 0 for collapse style, 1 for leaf node style
     */
    getIconMode: function() {
        return (this.iconMode || this.tree.root.iconMode);
    },

    /**
     * Checks if this node has children.  If this node is lazy-loading and the
     * children have not been rendered, we do not know whether or not there
     * are actual children.  In most cases, we need to assume that there are
     * children (for instance, the toggle needs to show the expandable
     * presentation state).  In other times we want to know if there are rendered
     * children.  For the latter, "checkForLazyLoad" should be false.
     * @method hasChildren
     * @param checkForLazyLoad {boolean} should we check for unloaded children?
     * @return {boolean} true if this has children or if it might and we are
     * checking for this condition.
     */
    hasChildren: function(checkForLazyLoad) {
        if (this.isLeaf) {
            return false;
        } else {
            return ( this.children.length > 0 ||
				(checkForLazyLoad && this.isDynamic() && !this.dynamicLoadComplete)
			);
        }
    },

    /**
     * Expands if node is collapsed, collapses otherwise.
     * @method toggle
     */
    toggle: function() {
        if (!this.tree.locked && ( this.hasChildren(true) || this.isDynamic()) ) {
            if (this.expanded) { this.collapse(); } else { this.expand(); }
        }
    },

    /**
     * Returns the markup for this node and its children.
     * @method getHtml
     * @return {string} the markup for this node and its expanded children.
     */
    getHtml: function() {

        this.childrenRendered = false;

        return ['<div class="ygtvitem" id="' , this.getElId() , '">' ,this.getNodeHtml() , this.getChildrenHtml() ,'</div>'].join("");
    },

    /**
     * Called when first rendering the tree.  We always build the div that will
     * contain this nodes children, but we don't render the children themselves
     * unless this node is expanded.
     * @method getChildrenHtml
     * @return {string} the children container div html and any expanded children
     * @private
     */
    getChildrenHtml: function() {


        var sb = [];
        sb[sb.length] = '<div class="ygtvchildren" id="' + this.getChildrenElId() + '"';

        if (!this.expanded || !this.hasChildren()) {
            sb[sb.length] = ' style="display:none;"';
        }
        sb[sb.length] = '>';


        if ( (this.hasChildren(true) && this.expanded) ||
                (this.renderHidden && !this.isDynamic()) ) {
            sb[sb.length] = this.renderChildren();
        }

        sb[sb.length] = '</div>';

        return sb.join("");
    },

    /**
     * Generates the markup for the child nodes.  This is not done until the node
     * is expanded.
     * @method renderChildren
     * @return {string} the html for this node's children
     * @private
     */
    renderChildren: function() {


        var node = this;

        if (this.isDynamic() && !this.dynamicLoadComplete) {
            this.isLoading = true;
            this.tree.locked = true;

            if (this.dataLoader) {

                setTimeout(
                    function() {
                        node.dataLoader(node,
                            function() {
                                node.loadComplete();
                            });
                    }, 10);

            } else if (this.tree.root.dataLoader) {

                setTimeout(
                    function() {
                        node.tree.root.dataLoader(node,
                            function() {
                                node.loadComplete();
                            });
                    }, 10);

            } else {
                return "Error: data loader not found or not specified.";
            }

            return "";

        } else {
            return this.completeRender();
        }
    },

    /**
     * Called when we know we have all the child data.
     * @method completeRender
     * @return {string} children html
     */
    completeRender: function() {
        var sb = [];

        for (var i=0; i < this.children.length; ++i) {
            sb[sb.length] = this.children[i].getHtml();
        }

        this.childrenRendered = true;

        return sb.join("");
    },

    /**
     * Load complete is the callback function we pass to the data provider
     * in dynamic load situations.
     * @method loadComplete
     */
    loadComplete: function() {
        this.getChildrenEl().innerHTML = this.completeRender();
		if (this.propagateHighlightDown) {
			if (this.highlightState === 1 && !this.tree.singleNodeHighlight) {
				for (var i = 0; i < this.children.length; i++) {
				this.children[i].highlight(true);
			}
			} else if (this.highlightState === 0 || this.tree.singleNodeHighlight) {
				for (i = 0; i < this.children.length; i++) {
					this.children[i].unhighlight(true);
				}
			} // if (highlighState == 2) leave child nodes with whichever highlight state they are set
		}

        this.dynamicLoadComplete = true;
        this.isLoading = false;
        this.expand(true);
        this.tree.locked = false;
    },

    /**
     * Returns this node's ancestor at the specified depth.
     * @method getAncestor
     * @param {int} depth the depth of the ancestor.
     * @return {Node} the ancestor
     */
    getAncestor: function(depth) {
        if (depth >= this.depth || depth < 0)  {
            return null;
        }

        var p = this.parent;

        while (p.depth > depth) {
            p = p.parent;
        }

        return p;
    },

    /**
     * Returns the css class for the spacer at the specified depth for
     * this node.  If this node's ancestor at the specified depth
     * has a next sibling the presentation is different than if it
     * does not have a next sibling
     * @method getDepthStyle
     * @param {int} depth the depth of the ancestor.
     * @return {string} the css class for the spacer
     */
    getDepthStyle: function(depth) {
        return (this.getAncestor(depth).nextSibling) ?
            "ygtvdepthcell" : "ygtvblankdepthcell";
    },

    /**
     * Get the markup for the node.  This may be overrided so that we can
     * support different types of nodes.
     * @method getNodeHtml
     * @return {string} The HTML that will render this node.
     */
    getNodeHtml: function() {
        var sb = [];

        sb[sb.length] = '<table id="ygtvtableel' + this.index + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
        if (this.enableHighlight) {
            sb[sb.length] = ' ygtv-highlight' + this.highlightState;
        }
        if (this.className) {
            sb[sb.length] = ' ' + this.className;
        }
        sb[sb.length] = '"><tr class="ygtvrow">';

        for (var i=0;i<this.depth;++i) {
            sb[sb.length] = '<td class="ygtvcell ' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
        }

        if (this.hasIcon) {
            sb[sb.length] = '<td id="' + this.getToggleElId();
            sb[sb.length] = '" class="ygtvcell ';
            sb[sb.length] = this.getStyle() ;
            sb[sb.length] = '"><a href="#" class="ygtvspacer">&#160;</a></td>';
        }

        sb[sb.length] = '<td id="' + this.contentElId;
        sb[sb.length] = '" class="ygtvcell ';
        sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
        sb[sb.length] = (this.nowrap) ? ' nowrap="nowrap" ' : '';
        sb[sb.length] = ' >';
        sb[sb.length] = this.getContentHtml();
        sb[sb.length] = '</td></tr></table>';

        return sb.join("");

    },
    /**
     * Get the markup for the contents of the node.  This is designed to be overrided so that we can
     * support different types of nodes.
     * @method getContentHtml
     * @return {string} The HTML that will render the content of this node.
     */
    getContentHtml: function () {
        return "";
    },

    /**
     * Regenerates the html for this node and its children.  To be used when the
     * node is expanded and new children have been added.
     * @method refresh
     */
    refresh: function() {
        this.getChildrenEl().innerHTML = this.completeRender();

        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv[lt][nmp]h*\b/gi,this.getStyle());
            }
        }
    },

    /**
     * Node toString
     * @method toString
     * @return {string} string representation of the node
     */
    toString: function() {
        return this._type + " (" + this.index + ")";
    },
    /**
    * array of items that had the focus set on them
    * so that they can be cleaned when focus is lost
    * @property _focusHighlightedItems
    * @type Array of DOM elements
    * @private
    */
    _focusHighlightedItems: [],
    /**
    * DOM element that actually got the browser focus
    * @property _focusedItem
    * @type DOM element
    * @private
    */
    _focusedItem: null,

    /**
    * Returns true if there are any elements in the node that can
    * accept the real actual browser focus
    * @method _canHaveFocus
    * @return {boolean} success
    * @private
    */
    _canHaveFocus: function() {
        return this.getEl().getElementsByTagName('a').length > 0;
    },
    /**
    * Removes the focus of previously selected Node
    * @method _removeFocus
    * @private
    */
    _removeFocus:function () {
        if (this._focusedItem) {
            Event.removeListener(this._focusedItem,'blur');
            this._focusedItem = null;
        }
        var el;
        while ((el = this._focusHighlightedItems.shift())) {  // yes, it is meant as an assignment, really
            Dom.removeClass(el,YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
        }
    },
    /**
    * Sets the focus on the node element.
    * It will only be able to set the focus on nodes that have anchor elements in it.
    * Toggle or branch icons have anchors and can be focused on.
    * If will fail in nodes that have no anchor
    * @method focus
    * @return {boolean} success
    */
    focus: function () {
        var focused = false, self = this;

        if (this.tree.currentFocus) {
            this.tree.currentFocus._removeFocus();
        }

        var  expandParent = function (node) {
            if (node.parent) {
                expandParent(node.parent);
                node.parent.expand();
            }
        };
        expandParent(this);

        Dom.getElementsBy  (
            function (el) {
                return (/ygtv(([tl][pmn]h?)|(content))/).test(el.className);
            } ,
            'td' ,
            self.getEl().firstChild ,
            function (el) {
                Dom.addClass(el, YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
                if (!focused) {
                    var aEl = el.getElementsByTagName('a');
                    if (aEl.length) {
                        aEl = aEl[0];
                        aEl.focus();
                        self._focusedItem = aEl;
                        Event.on(aEl,'blur',function () {
                            self.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
                            self.tree.currentFocus = null;
                            self._removeFocus();
                        });
                        focused = true;
                    }
                }
                self._focusHighlightedItems.push(el);
            }
        );
        if (focused) {
            this.tree.fireEvent('focusChanged',{oldNode:this.tree.currentFocus,newNode:this});
            this.tree.currentFocus = this;
        } else {
            this.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
            this.tree.currentFocus = null;
            this._removeFocus();
        }
        return focused;
    },

  /**
     * Count of nodes in a branch
     * @method getNodeCount
     * @return {int} number of nodes in the branch
     */
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count + 1;
    },

      /**
     * Returns an object which could be used to build a tree out of this node and its children.
     * It can be passed to the tree constructor to reproduce this node as a tree.
     * It will return false if the node or any children loads dynamically, regardless of whether it is loaded or not.
     * @method getNodeDefinition
     * @return {Object | false}  definition of the tree or false if the node or any children is defined as dynamic
     */
    getNodeDefinition: function() {

        if (this.isDynamic()) { return false; }

        var def, defs = Lang.merge(this.data), children = [];



        if (this.expanded) {defs.expanded = this.expanded; }
        if (!this.multiExpand) { defs.multiExpand = this.multiExpand; }
        if (!this.renderHidden) { defs.renderHidden = this.renderHidden; }
        if (!this.hasIcon) { defs.hasIcon = this.hasIcon; }
        if (this.nowrap) { defs.nowrap = this.nowrap; }
        if (this.className) { defs.className = this.className; }
        if (this.editable) { defs.editable = this.editable; }
        if (this.enableHighlight) { defs.enableHighlight = this.enableHighlight; }
        if (this.highlightState) { defs.highlightState = this.highlightState; }
        if (this.propagateHighlightUp) { defs.propagateHighlightUp = this.propagateHighlightUp; }
        if (this.propagateHighlightDown) { defs.propagateHighlightDown = this.propagateHighlightDown; }
        defs.type = this._type;



        for (var i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            children.push(def);
        }
        if (children.length) { defs.children = children; }
        return defs;
    },


    /**
     * Generates the link that will invoke this node's toggle method
     * @method getToggleLink
     * @return {string} the javascript url for toggling this node
     */
    getToggleLink: function() {
        return 'return false;';
    },

    /**
    * Sets the value of property for this node and all loaded descendants.
    * Only public and defined properties can be set, not methods.
    * Values for unknown properties will be assigned to the refNode.data object
    * @method setNodesProperty
    * @param name {string} Name of the property to be set
    * @param value {any} value to be set
    * @param refresh {boolean} if present and true, it does a refresh
    */
    setNodesProperty: function(name, value, refresh) {
        if (name.charAt(0) != '_'  && !Lang.isUndefined(this[name]) && !Lang.isFunction(this[name]) ) {
            this[name] = value;
        } else {
            this.data[name] = value;
        }
        for (var i = 0; i < this.children.length;i++) {
            this.children[i].setNodesProperty(name,value);
        }
        if (refresh) {
            this.refresh();
        }
    },
    /**
    * Toggles the highlighted state of a Node
    * @method toggleHighlight
    */
    toggleHighlight: function() {
        if (this.enableHighlight) {
            if (this.highlightState == 1) {
                this.unhighlight();
            } else {
                this.highlight();
            }
        }
    },

    /**
    * Turns highlighting on node.
    * @method highlight
    * @param _silent {boolean} optional, don't fire the highlightEvent
    */
    highlight: function(_silent) {
        if (this.enableHighlight) {
            if (this.tree.singleNodeHighlight) {
                if (this.tree._currentlyHighlighted) {
                    this.tree._currentlyHighlighted.unhighlight(_silent);
                }
                this.tree._currentlyHighlighted = this;
            }
            this.highlightState = 1;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
				if (this.propagateHighlightDown) {
					for (var i = 0;i < this.children.length;i++) {
						this.children[i].highlight(true);
					}
				}
				if (this.propagateHighlightUp) {
					if (this.parent) {
						this.parent._childrenHighlighted();
					}
				}
			}
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    /**
    * Turns highlighting off a node.
    * @method unhighlight
    * @param _silent {boolean} optional, don't fire the highlightEvent
    */
    unhighlight: function(_silent) {
        if (this.enableHighlight) {
            this.tree._currentlyHighlighted = null;
            this.highlightState = 0;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
				if (this.propagateHighlightDown) {
					for (var i = 0;i < this.children.length;i++) {
						this.children[i].unhighlight(true);
					}
				}
				if (this.propagateHighlightUp) {
					if (this.parent) {
						this.parent._childrenHighlighted();
					}
				}
			}
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    /**
    * Checks whether all or part of the children of a node are highlighted and
    * sets the node highlight to full, none or partial highlight.
    * If set to propagate it will further call the parent
    * @method _childrenHighlighted
    * @private
    */
    _childrenHighlighted: function() {
        var yes = false, no = false;
        if (this.enableHighlight) {
            for (var i = 0;i < this.children.length;i++) {
                switch(this.children[i].highlightState) {
                    case 0:
                        no = true;
                        break;
                    case 1:
                        yes = true;
                        break;
                    case 2:
                        yes = no = true;
                        break;
                }
            }
            if (yes && no) {
                this.highlightState = 2;
            } else if (yes) {
                this.highlightState = 1;
            } else {
                this.highlightState = 0;
            }
            this._setHighlightClassName();
            if (this.propagateHighlightUp) {
                if (this.parent) {
                    this.parent._childrenHighlighted();
                }
            }
        }
    },

    /**
    * Changes the classNames on the toggle and content containers to reflect the current highlighting
    * @method _setHighlightClassName
    * @private
    */
    _setHighlightClassName: function() {
        var el = Dom.get('ygtvtableel' + this.index);
        if (el) {
            el.className = el.className.replace(/\bygtv-highlight\d\b/gi,'ygtv-highlight' + this.highlightState);
        }
    }

};

YAHOO.augment(YAHOO.widget.Node, YAHOO.util.EventProvider);
})();

/**
 * A custom YAHOO.widget.Node that handles the unique nature of
 * the virtual, presentationless root node.
 * @namespace YAHOO.widget
 * @class RootNode
 * @extends YAHOO.widget.Node
 * @param oTree {YAHOO.widget.TreeView} The tree instance this node belongs to
 * @constructor
 */
YAHOO.widget.RootNode = function(oTree) {
    this.init(null, null, true);

    /*
     * For the root node, we get the tree reference from as a param
     * to the constructor instead of from the parent element.
     */
    this.tree = oTree;
};

YAHOO.extend(YAHOO.widget.RootNode, YAHOO.widget.Node, {

   /**
     * The node type
     * @property _type
      * @type string
     * @private
     * @default "RootNode"
     */
    _type: "RootNode",

    getNodeHtml: function() {
        return "";
    },

    toString: function() {
        return this._type;
    },

    loadComplete: function() {
        this.tree.draw();
    },

   /**
     * Count of nodes in tree.
    * It overrides Nodes.getNodeCount because the root node should not be counted.
     * @method getNodeCount
     * @return {int} number of nodes in the tree
     */
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count;
    },

  /**
     * Returns an object which could be used to build a tree out of this node and its children.
     * It can be passed to the tree constructor to reproduce this node as a tree.
     * Since the RootNode is automatically created by treeView,
     * its own definition is excluded from the returned node definition
     * which only contains its children.
     * @method getNodeDefinition
     * @return {Object | false}  definition of the tree or false if any child node is defined as dynamic
     */
    getNodeDefinition: function() {

        for (var def, defs = [], i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            defs.push(def);
        }
        return defs;
    },

    collapse: function() {},
    expand: function() {},
    getSiblings: function() { return null; },
    focus: function () {}

});

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;
/**
 * The default node presentation.  The first parameter should be
 * either a string that will be used as the node's label, or an object
 * that has at least a string property called label.  By default,  clicking the
 * label will toggle the expanded/collapsed state of the node.  By
 * setting the href property of the instance, this behavior can be
 * changed so that the label will go to the specified href.
 * @namespace YAHOO.widget
 * @class TextNode
 * @extends YAHOO.widget.Node
 * @constructor
 * @param oData {object} a string or object containing the data that will
 * be used to render this node.
 * Providing a string is the same as providing an object with a single property named label.
 * All values in the oData will be used to set equally named properties in the node
 * as long as the node does have such properties, they are not undefined, private or functions.
 * All attributes are made available in noderef.data, which
 * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
 * can be used to retrieve a node by one of the attributes.
 * @param oParent {YAHOO.widget.Node} this node's parent node
 * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded)
 */
YAHOO.widget.TextNode = function(oData, oParent, expanded) {

    if (oData) {
        if (Lang.isString(oData)) {
            oData = { label: oData };
        }
        this.init(oData, oParent, expanded);
        this.setUpLabel(oData);
    }

};

YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {

    /**
     * The CSS class for the label href.  Defaults to ygtvlabel, but can be
     * overridden to provide a custom presentation for a specific node.
     * @property labelStyle
     * @type string
     */
    labelStyle: "ygtvlabel",

    /**
     * The derived element id of the label for this node
     * @property labelElId
     * @type string
     */
    labelElId: null,

    /**
     * The text for the label.  It is assumed that the oData parameter will
     * either be a string that will be used as the label, or an object that
     * has a property called "label" that we will use.
     * @property label
     * @type string
     */
    label: null,

    /**
     * The text for the title (tooltip) for the label element
     * @property title
     * @type string
     */
    title: null,

    /**
     * The href for the node's label.  If one is not specified, the href will
     * be set so that it toggles the node.
     * @property href
     * @type string
     */
    href: null,

    /**
     * The label href target, defaults to current window
     * @property target
     * @type string
     */
    target: "_self",

    /**
     * The node type
     * @property _type
     * @private
     * @type string
     * @default "TextNode"
     */
    _type: "TextNode",


    /**
     * Sets up the node label
     * @method setUpLabel
     * @param oData string containing the label, or an object with a label property
     */
    setUpLabel: function(oData) {

        if (Lang.isString(oData)) {
            oData = {
                label: oData
            };
        } else {
            if (oData.style) {
                this.labelStyle = oData.style;
            }
        }

        this.label = oData.label;

        this.labelElId = "ygtvlabelel" + this.index;

    },

    /**
     * Returns the label element
     * @for YAHOO.widget.TextNode
     * @method getLabelEl
     * @return {object} the element
     */
    getLabelEl: function() {
        return Dom.get(this.labelElId);
    },

    getContentHtml: function() {
        var sb = [];
        sb[sb.length] = this.href?'<a':'<span';
        sb[sb.length] = ' id="' + this.labelElId + '"';
        sb[sb.length] = ' class="' + this.labelStyle  + '"';
        if (this.href) {
            sb[sb.length] = ' href="' + this.href + '"';
            sb[sb.length] = ' target="' + this.target + '"';
        }
        if (this.title) {
            sb[sb.length] = ' title="' + this.title + '"';
        }
        sb[sb.length] = ' >';
        sb[sb.length] = this.label;
        sb[sb.length] = this.href?'</a>':'</span>';
        return sb.join("");
    },



  /**
     * Returns an object which could be used to build a tree out of this node and its children.
     * It can be passed to the tree constructor to reproduce this node as a tree.
     * It will return false if the node or any descendant loads dynamically, regardless of whether it is loaded or not.
     * @method getNodeDefinition
     * @return {Object | false}  definition of the tree or false if this node or any descendant is defined as dynamic
     */
    getNodeDefinition: function() {
        var def = YAHOO.widget.TextNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }

        def.label = this.label;
        if (this.labelStyle != 'ygtvlabel') { def.style = this.labelStyle; }
        if (this.title) { def.title = this.title; }
        if (this.href) { def.href = this.href; }
        if (this.target != '_self') { def.target = this.target; }

        return def;

    },

    toString: function() {
        return YAHOO.widget.TextNode.superclass.toString.call(this) + ": " + this.label;
    },

    onLabelClick: function() {
        return false;
    },
    refresh: function() {
        YAHOO.widget.TextNode.superclass.refresh.call(this);
        var label = this.getLabelEl();
        label.innerHTML = this.label;
        if (label.tagName.toUpperCase() == 'A') {
            label.href = this.href;
            label.target = this.target;
        }
    }




});
})();

/**
 * A menu-specific implementation that differs from TextNode in that only
 * one sibling can be expanded at a time.
 * @namespace YAHOO.widget
 * @class MenuNode
 * @extends YAHOO.widget.TextNode
 * @param oData {object} a string or object containing the data that will
 * be used to render this node.
 * Providing a string is the same as providing an object with a single property named label.
 * All values in the oData will be used to set equally named properties in the node
 * as long as the node does have such properties, they are not undefined, private or functions.
 * All attributes are made available in noderef.data, which
 * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
 * can be used to retrieve a node by one of the attributes.
 * @param oParent {YAHOO.widget.Node} this node's parent node
 * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded)
 * @constructor
 */
YAHOO.widget.MenuNode = function(oData, oParent, expanded) {
    YAHOO.widget.MenuNode.superclass.constructor.call(this,oData,oParent,expanded);

   /*
     * Menus usually allow only one branch to be open at a time.
     */
    this.multiExpand = false;

};

YAHOO.extend(YAHOO.widget.MenuNode, YAHOO.widget.TextNode, {

    /**
     * The node type
     * @property _type
     * @private
    * @default "MenuNode"
     */
    _type: "MenuNode"

});

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;

/**
 * This implementation takes either a string or object for the
 * oData argument.  If is it a string, it will use it for the display
 * of this node (and it can contain any html code).  If the parameter
 * is an object,it looks for a parameter called "html" that will be
 * used for this node's display.
 * @namespace YAHOO.widget
 * @class HTMLNode
 * @extends YAHOO.widget.Node
 * @constructor
 * @param oData {object} a string or object containing the data that will
 * be used to render this node.
 * Providing a string is the same as providing an object with a single property named html.
 * All values in the oData will be used to set equally named properties in the node
 * as long as the node does have such properties, they are not undefined, private or functions.
 * All other attributes are made available in noderef.data, which
 * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
 * can be used to retrieve a node by one of the attributes.
 * @param oParent {YAHOO.widget.Node} this node's parent node
 * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded)
 * @param hasIcon {boolean} specifies whether or not leaf nodes should
 * be rendered with or without a horizontal line line and/or toggle icon. If the icon
 * is not displayed, the content fills the space it would have occupied.
 * This option operates independently of the leaf node presentation logic
 * for dynamic nodes.
 * (deprecated; use oData.hasIcon)
 */
YAHOO.widget.HTMLNode = function(oData, oParent, expanded, hasIcon) {
    if (oData) {
        this.init(oData, oParent, expanded);
        this.initContent(oData, hasIcon);
    }
};

YAHOO.extend(YAHOO.widget.HTMLNode, YAHOO.widget.Node, {

    /**
     * The CSS class for the html content container.  Defaults to ygtvhtml, but
     * can be overridden to provide a custom presentation for a specific node.
     * @property contentStyle
     * @type string
     */
    contentStyle: "ygtvhtml",


    /**
     * The HTML content to use for this node's display
     * @property html
     * @type string
     */
    html: null,

/**
     * The node type
     * @property _type
     * @private
     * @type string
     * @default "HTMLNode"
     */
    _type: "HTMLNode",

    /**
     * Sets up the node label
     * @property initContent
     * @param oData {object} An html string or object containing an html property
     * @param hasIcon {boolean} determines if the node will be rendered with an
     * icon or not
     */
    initContent: function(oData, hasIcon) {
        this.setHtml(oData);
        this.contentElId = "ygtvcontentel" + this.index;
        if (!Lang.isUndefined(hasIcon)) { this.hasIcon  = hasIcon; }

    },

    /**
     * Synchronizes the node.html, and the node's content
     * @property setHtml
     * @param o {object} An html string or object containing an html property
     */
    setHtml: function(o) {

        this.html = (typeof o === "string") ? o : o.html;

        var el = this.getContentEl();
        if (el) {
            el.innerHTML = this.html;
        }

    },

    getContentHtml: function() {
        return this.html;
    },

      /**
     * Returns an object which could be used to build a tree out of this node and its children.
     * It can be passed to the tree constructor to reproduce this node as a tree.
     * It will return false if any node loads dynamically, regardless of whether it is loaded or not.
     * @method getNodeDefinition
     * @return {Object | false}  definition of the tree or false if any node is defined as dynamic
     */
    getNodeDefinition: function() {
        var def = YAHOO.widget.HTMLNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        def.html = this.html;
        return def;

    }
});
})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        Calendar = YAHOO.widget.Calendar;

/**
 * A Date-specific implementation that differs from TextNode in that it uses
 * YAHOO.widget.Calendar as an in-line editor, if available
 * If Calendar is not available, it behaves as a plain TextNode.
 * @namespace YAHOO.widget
 * @class DateNode
 * @extends YAHOO.widget.TextNode
 * @param oData {object} a string or object containing the data that will
 * be used to render this node.
 * Providing a string is the same as providing an object with a single property named label.
 * All values in the oData will be used to set equally named properties in the node
 * as long as the node does have such properties, they are not undefined, private nor functions.
 * All attributes are made available in noderef.data, which
 * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
 * can be used to retrieve a node by one of the attributes.
 * @param oParent {YAHOO.widget.Node} this node's parent node
 * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded)
 * @constructor
 */
YAHOO.widget.DateNode = function(oData, oParent, expanded) {
    YAHOO.widget.DateNode.superclass.constructor.call(this,oData, oParent, expanded);
};

YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {

    /**
     * The node type
     * @property _type
     * @type string
     * @private
     * @default  "DateNode"
     */
    _type: "DateNode",

    /**
    * Configuration object for the Calendar editor, if used.
    * See <a href="http://developer.yahoo.com/yui/calendar/#internationalization">http://developer.yahoo.com/yui/calendar/#internationalization</a>
    * @property calendarConfig
    */
    calendarConfig: null,



    /**
     *  If YAHOO.widget.Calendar is available, it will pop up a Calendar to enter a new date.  Otherwise, it falls back to a plain &lt;input&gt;  textbox
     * @method fillEditorContainer
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return void
     */
    fillEditorContainer: function (editorData) {

        var cal, container = editorData.inputContainer;

        if (Lang.isUndefined(Calendar)) {
            Dom.replaceClass(editorData.editorPanel,'ygtv-edit-DateNode','ygtv-edit-TextNode');
            YAHOO.widget.DateNode.superclass.fillEditorContainer.call(this, editorData);
            return;
        }

        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = false;

            editorData.node.destroyEditorContents(editorData);

            editorData.inputObject = cal = new Calendar(container.appendChild(document.createElement('div')));
            if (this.calendarConfig) {
                cal.cfg.applyConfig(this.calendarConfig,true);
                cal.cfg.fireQueue();
            }
            cal.selectEvent.subscribe(function () {
                this.tree._closeEditor(true);
            },this,true);
        } else {
            cal = editorData.inputObject;
        }

		editorData.oldValue = this.label;
        cal.cfg.setProperty("selected",this.label, false);

        var delim = cal.cfg.getProperty('DATE_FIELD_DELIMITER');
        var pageDate = this.label.split(delim);
        cal.cfg.setProperty('pagedate',pageDate[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] + delim + pageDate[cal.cfg.getProperty('MDY_YEAR_POSITION') -1]);
        cal.cfg.fireQueue();

        cal.render();
        cal.oDomContainer.focus();
    },
     /**
    * Returns the value from the input element.
    * Overrides Node.getEditorValue.
    * @method getEditorValue
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return {string} date entered
     */

	getEditorValue: function (editorData) {
        if (Lang.isUndefined(Calendar)) {
            return editorData.inputElement.value;
        } else {
            var cal = editorData.inputObject,
                date = cal.getSelectedDates()[0],
                dd = [];

            dd[cal.cfg.getProperty('MDY_DAY_POSITION') -1] = date.getDate();
            dd[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] = date.getMonth() + 1;
            dd[cal.cfg.getProperty('MDY_YEAR_POSITION') -1] = date.getFullYear();
            return dd.join(cal.cfg.getProperty('DATE_FIELD_DELIMITER'));
        }
	},

	/**
    * Finally displays the newly entered date in the tree.
    * Overrides Node.displayEditedValue.
    * @method displayEditedValue
     *  @param value {string} date to be displayed and stored in the node
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     */
	displayEditedValue: function (value,editorData) {
		var node = editorData.node;
		node.label = value;
		node.getLabelEl().innerHTML = value;
	},
  /**
     * Returns an object which could be used to build a tree out of this node and its children.
     * It can be passed to the tree constructor to reproduce this node as a tree.
     * It will return false if the node or any descendant loads dynamically, regardless of whether it is loaded or not.
     * @method getNodeDefinition
     * @return {Object | false}  definition of the node or false if this node or any descendant is defined as dynamic
     */
    getNodeDefinition: function() {
        var def = YAHOO.widget.DateNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        if (this.calendarConfig) { def.calendarConfig = this.calendarConfig; }
        return def;
    }


});
})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        TV = YAHOO.widget.TreeView,
        TVproto = TV.prototype;

    /**
     * An object to store information used for in-line editing
     * for all Nodes of all TreeViews. It contains:
     * <ul>
    * <li>active {boolean}, whether there is an active cell editor </li>
    * <li>whoHasIt {YAHOO.widget.TreeView} TreeView instance that is currently using the editor</li>
    * <li>nodeType {string} value of static Node._type property, allows reuse of input element if node is of the same type.</li>
    * <li>editorPanel {HTMLelement (&lt;div&gt;)} element holding the in-line editor</li>
    * <li>inputContainer {HTMLelement (&lt;div&gt;)} element which will hold the type-specific input element(s) to be filled by the fillEditorContainer method</li>
    * <li>buttonsContainer {HTMLelement (&lt;div&gt;)} element which holds the &lt;button&gt; elements for Ok/Cancel.  If you don't want any of the buttons, hide it via CSS styles, don't destroy it</li>
    * <li>node {YAHOO.widget.Node} reference to the Node being edited</li>
    * <li>saveOnEnter {boolean}, whether the Enter key should be accepted as a Save command (Esc. is always taken as Cancel), disable for multi-line input elements </li>
    * <li>oldValue {any}  value before editing</li>
    * </ul>
    *  Editors are free to use this object to store additional data.
     * @property editorData
     * @static
     * @for YAHOO.widget.TreeView
     */
    TV.editorData = {
        active:false,
        whoHasIt:null, // which TreeView has it
        nodeType:null,
        editorPanel:null,
        inputContainer:null,
        buttonsContainer:null,
        node:null, // which Node is being edited
        saveOnEnter:true,
		oldValue:undefined
    };

    /**
    * Validator function for edited data, called from the TreeView instance scope,
    * receives the arguments (newValue, oldValue, nodeInstance)
    * and returns either the validated (or type-converted) value or undefined.
    * An undefined return will prevent the editor from closing
    * @property validator
    * @type function
    * @default null
     * @for YAHOO.widget.TreeView
     */
    TVproto.validator = null;

    /**
    * Entry point for initializing the editing plug-in.
    * TreeView will call this method on initializing if it exists
    * @method _initEditor
     * @for YAHOO.widget.TreeView
     * @private
    */

	TVproto._initEditor = function () {
		/**
	 	* Fires when the user clicks on the ok button of a node editor
	 	* @event editorSaveEvent
	 	* @type CustomEvent
	 	* @param oArgs.newValue {mixed} the new value just entered
	 	* @param oArgs.oldValue {mixed} the value originally in the tree
	 	* @param oArgs.node {YAHOO.widget.Node} the node that has the focus
	        * @for YAHOO.widget.TreeView
	 	*/
	 	this.createEvent("editorSaveEvent", this);

		/**
	 	* Fires when the user clicks on the cancel button of a node editor
	 	* @event editorCancelEvent
	 	* @type CustomEvent
	 	* @param {YAHOO.widget.Node} node the node that has the focus
	        * @for YAHOO.widget.TreeView
	 	*/
	 	this.createEvent("editorCancelEvent", this);

	};

    /**
    * Entry point of the editing plug-in.
    * TreeView will call this method if it exists when a node label is clicked
    * @method _nodeEditing
    * @param node {YAHOO.widget.Node} the node to be edited
    * @return {Boolean} true to indicate that the node is editable and prevent any further bubbling of the click.
     * @for YAHOO.widget.TreeView
     * @private
    */



    TVproto._nodeEditing = function (node) {
        if (node.fillEditorContainer && node.editable) {
            var ed, topLeft, buttons, button, editorData = TV.editorData;
            editorData.active = true;
            editorData.whoHasIt = this;
            if (!editorData.nodeType) {
                editorData.editorPanel = ed = document.body.appendChild(document.createElement('div'));
                Dom.addClass(ed,'ygtv-label-editor');

                buttons = editorData.buttonsContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(buttons,'ygtv-button-container');
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvok');
                button.innerHTML = ' ';
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvcancel');
                button.innerHTML = ' ';
                Event.on(buttons, 'click', function (ev) {
                    var target = Event.getTarget(ev);
                    var node = TV.editorData.node;
                    if (Dom.hasClass(target,'ygtvok')) {
                        Event.stopEvent(ev);
                        this._closeEditor(true);
                    }
                    if (Dom.hasClass(target,'ygtvcancel')) {
                        Event.stopEvent(ev);
                        this._closeEditor(false);
                    }
                }, this, true);

                editorData.inputContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(editorData.inputContainer,'ygtv-input');

                Event.on(ed,'keydown',function (ev) {
                    var editorData = TV.editorData,
                        KEY = YAHOO.util.KeyListener.KEY;
                    switch (ev.keyCode) {
                        case KEY.ENTER:
                            Event.stopEvent(ev);
                            if (editorData.saveOnEnter) {
                                this._closeEditor(true);
                            }
                            break;
                        case KEY.ESCAPE:
                            Event.stopEvent(ev);
                            this._closeEditor(false);
                            break;
                    }
                },this,true);



            } else {
                ed = editorData.editorPanel;
            }
            editorData.node = node;
            if (editorData.nodeType) {
                Dom.removeClass(ed,'ygtv-edit-' + editorData.nodeType);
            }
            Dom.addClass(ed,' ygtv-edit-' + node._type);
            topLeft = Dom.getXY(node.getContentEl());
            Dom.setStyle(ed,'left',topLeft[0] + 'px');
            Dom.setStyle(ed,'top',topLeft[1] + 'px');
            Dom.setStyle(ed,'display','block');
            ed.focus();
            node.fillEditorContainer(editorData);

            return true;  // If inline editor available, don't do anything else.
        }
    };

    /**
    * Method to be associated with an event (clickEvent, dblClickEvent or enterKeyPressed) to pop up the contents editor
    *  It calls the corresponding node editNode method.
    * @method onEventEditNode
    * @param oArgs {object} Object passed as arguments to TreeView event listeners
     * @for YAHOO.widget.TreeView
    */

    TVproto.onEventEditNode = function (oArgs) {
        if (oArgs instanceof YAHOO.widget.Node) {
            oArgs.editNode();
        } else if (oArgs.node instanceof YAHOO.widget.Node) {
            oArgs.node.editNode();
        }
    };

    /**
    * Method to be called when the inline editing is finished and the editor is to be closed
    * @method _closeEditor
    * @param save {Boolean} true if the edited value is to be saved, false if discarded
    * @private
     * @for YAHOO.widget.TreeView
    */

    TVproto._closeEditor = function (save) {
        var ed = TV.editorData,
            node = ed.node,
            close = true;
        if (save) {
            close = ed.node.saveEditorValue(ed) !== false;
        } else {
			this.fireEvent( 'editorCancelEvent', node);
		}

        if (close) {
            Dom.setStyle(ed.editorPanel,'display','none');
            ed.active = false;
            node.focus();
        }
    };

    /**
    *  Entry point for TreeView's destroy method to destroy whatever the editing plug-in has created
    * @method _destroyEditor
    * @private
     * @for YAHOO.widget.TreeView
    */
    TVproto._destroyEditor = function() {
        var ed = TV.editorData;
        if (ed && ed.nodeType && (!ed.active || ed.whoHasIt === this)) {
            Event.removeListener(ed.editorPanel,'keydown');
            Event.removeListener(ed.buttonContainer,'click');
            ed.node.destroyEditorContents(ed);
            document.body.removeChild(ed.editorPanel);
            ed.nodeType = ed.editorPanel = ed.inputContainer = ed.buttonsContainer = ed.whoHasIt = ed.node = null;
            ed.active = false;
        }
    };

    var Nproto = YAHOO.widget.Node.prototype;

    /**
    * Signals if the label is editable.  (Ignored on TextNodes with href set.)
    * @property editable
    * @type boolean
         * @for YAHOO.widget.Node
    */
    Nproto.editable = false;

    /**
    * pops up the contents editor, if there is one and the node is declared editable
    * @method editNode
     * @for YAHOO.widget.Node
    */

    Nproto.editNode = function () {
        this.tree._nodeEditing(this);
    };




    /** Placeholder for a function that should provide the inline node label editor.
     *   Leaving it set to null will indicate that this node type is not editable.
     * It should be overridden by nodes that provide inline editing.
     *  The Node-specific editing element (input box, textarea or whatever) should be inserted into editorData.inputContainer.
     * @method fillEditorContainer
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return void
     * @for YAHOO.widget.Node
     */
    Nproto.fillEditorContainer = null;


    /**
    * Node-specific destroy function to empty the contents of the inline editor panel.
    * This function is the worst case alternative that will purge all possible events and remove the editor contents.
    * Method Event.purgeElement is somewhat costly so if it can be replaced by specifc Event.removeListeners, it is better to do so.
    * @method destroyEditorContents
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @for YAHOO.widget.Node
     */
    Nproto.destroyEditorContents = function (editorData) {
        Event.purgeElement(editorData.inputContainer,true);
        editorData.inputContainer.innerHTML = '';
    };

    /**
    * Saves the value entered into the editor.
    * @method saveEditorValue
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return {false or none} a return of exactly false will prevent the editor from closing
     * @for YAHOO.widget.Node
     */
    Nproto.saveEditorValue = function (editorData) {
        var node = editorData.node,
			value,
            validator = node.tree.validator;

		value = this.getEditorValue(editorData);

        if (Lang.isFunction(validator)) {
            value = validator(value,editorData.oldValue,node);
            if (Lang.isUndefined(value)) {
				return false;
			}
        }

		if (this.tree.fireEvent( 'editorSaveEvent', {
			newValue:value,
			oldValue:editorData.oldValue,
			node:node
		}) !== false) {
			this.displayEditedValue(value,editorData);
		}
	};


    /**
    * Returns the value(s) from the input element(s) .
    * Should be overridden by each node type.
    * @method getEditorValue
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return {any} value entered
     * @for YAHOO.widget.Node
     */

	 Nproto.getEditorValue = function (editorData) {
	};

	/**
    * Finally displays the newly edited value(s) in the tree.
    * Should be overridden by each node type.
    * @method displayEditedValue
     *  @param value {any} value to be displayed and stored in the node
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @for YAHOO.widget.Node
     */
	Nproto.displayEditedValue = function (value,editorData) {
	};

    var TNproto = YAHOO.widget.TextNode.prototype;



    /**
     *  Places an &lt;input&gt;  textbox in the input container and loads the label text into it.
     * @method fillEditorContainer
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return void
     * @for YAHOO.widget.TextNode
     */
    TNproto.fillEditorContainer = function (editorData) {

        var input;
        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = true;
            editorData.node.destroyEditorContents(editorData);

            editorData.inputElement = input = editorData.inputContainer.appendChild(document.createElement('input'));

        } else {
            input = editorData.inputElement;
        }
		editorData.oldValue = this.label;
        input.value = this.label;
        input.focus();
        input.select();
    };

    /**
    * Returns the value from the input element.
    * Overrides Node.getEditorValue.
    * @method getEditorValue
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @return {string} value entered
     * @for YAHOO.widget.TextNode
     */

    TNproto.getEditorValue = function (editorData) {
        return editorData.inputElement.value;
	};

	/**
    * Finally displays the newly edited value in the tree.
    * Overrides Node.displayEditedValue.
    * @method displayEditedValue
     *  @param value {string} value to be displayed and stored in the node
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @for YAHOO.widget.TextNode
     */
	TNproto.displayEditedValue = function (value,editorData) {
		var node = editorData.node;
		node.label = value;
		node.getLabelEl().innerHTML = value;
	};

    /**
    * Destroys the contents of the inline editor panel.
    * Overrides Node.destroyEditorContent.
    * Since we didn't set any event listeners on this inline editor, it is more efficient to avoid the generic method in Node.
    * @method destroyEditorContents
     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
     * @for YAHOO.widget.TextNode
     */
    TNproto.destroyEditorContents = function (editorData) {
        editorData.inputContainer.innerHTML = '';
    };
})();

/**
 * A static factory class for tree view expand/collapse animations
 * @class TVAnim
 * @static
 */
YAHOO.widget.TVAnim = function() {
    return {
        /**
         * Constant for the fade in animation
         * @property FADE_IN
         * @type string
         * @static
         */
        FADE_IN: "TVFadeIn",

        /**
         * Constant for the fade out animation
         * @property FADE_OUT
         * @type string
         * @static
         */
        FADE_OUT: "TVFadeOut",

        /**
         * Returns a ygAnim instance of the given type
         * @method getAnim
         * @param type {string} the type of animation
         * @param el {HTMLElement} the element to element (probably the children div)
         * @param callback {function} function to invoke when the animation is done.
         * @return {YAHOO.util.Animation} the animation instance
         * @static
         */
        getAnim: function(type, el, callback) {
            if (YAHOO.widget[type]) {
                return new YAHOO.widget[type](el, callback);
            } else {
                return null;
            }
        },

        /**
         * Returns true if the specified animation class is available
         * @method isValid
         * @param type {string} the type of animation
         * @return {boolean} true if valid, false if not
         * @static
         */
        isValid: function(type) {
            return (YAHOO.widget[type]);
        }
    };
} ();

/**
 * A 1/2 second fade-in animation.
 * @class TVFadeIn
 * @constructor
 * @param el {HTMLElement} the element to animate
 * @param callback {function} function to invoke when the animation is finished
 */
YAHOO.widget.TVFadeIn = function(el, callback) {
    /**
     * The element to animate
     * @property el
     * @type HTMLElement
     */
    this.el = el;

    /**
     * the callback to invoke when the animation is complete
     * @property callback
     * @type function
     */
    this.callback = callback;

};

YAHOO.widget.TVFadeIn.prototype = {
    /**
     * Performs the animation
     * @method animate
     */
    animate: function() {
        var tvanim = this;

        var s = this.el.style;
        s.opacity = 0.1;
        s.filter = "alpha(opacity=10)";
        s.display = "";

        var dur = 0.4;
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 0.1, to: 1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    /**
     * Clean up and invoke callback
     * @method onComplete
     */
    onComplete: function() {
        this.callback();
    },

    /**
     * toString
     * @method toString
     * @return {string} the string representation of the instance
     */
    toString: function() {
        return "TVFadeIn";
    }
};

/**
 * A 1/2 second fade out animation.
 * @class TVFadeOut
 * @constructor
 * @param el {HTMLElement} the element to animate
 * @param callback {Function} function to invoke when the animation is finished
 */
YAHOO.widget.TVFadeOut = function(el, callback) {
    /**
     * The element to animate
     * @property el
     * @type HTMLElement
     */
    this.el = el;

    /**
     * the callback to invoke when the animation is complete
     * @property callback
     * @type function
     */
    this.callback = callback;

};

YAHOO.widget.TVFadeOut.prototype = {
    /**
     * Performs the animation
     * @method animate
     */
    animate: function() {
        var tvanim = this;
        var dur = 0.4;
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 1, to: 0.1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    /**
     * Clean up and invoke callback
     * @method onComplete
     */
    onComplete: function() {
        var s = this.el.style;
        s.display = "none";
        s.opacity = 1;
        s.filter = "alpha(opacity=100)";
        this.callback();
    },

    /**
     * toString
     * @method toString
     * @return {string} the string representation of the instance
     */
    toString: function() {
        return "TVFadeOut";
    }
};

YAHOO.register("treeview", YAHOO.widget.TreeView, {version: "2.8.2r1", build: "7"});

/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright  2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This class must be extended to suit the comms library
 * being used.
 */
function callback(oMediator, oObserver, oContext) {
	this.m_mediator = oMediator;
	this.m_observer = oObserver;
	this.m_context = oContext;
}

callback.prototype.processResult = function(data, isFailure) {
	this.m_mediator.processResult(data, isFailure, this.m_observer, this.m_context);
};

callback.prototype.success = function(o) {
	throw "callback::success() has not been implemented";
};

callback.prototype.failure = function(o) {
	throw "callback::failure() has not been implemented";
};

/*
 * [TODO] Use some kind of addFeature thing.
 */

function submission() {
	this.navigateForReplaceAll = true;
}

document.submission = new submission();

/*
 * The comms library being used must override this.
 */

submission.prototype.request = function(sMethod, sAction, sBody, nTimeout, oCallback) {
	throw "submission::request() has not been implemented";
};

submission.prototype.getConnection = function() {
	throw "submission::getConnection() has not been implemented";
};

submission.prototype.setHeader = function(header, value) {
	throw "submission::setHeader() has not been implemented";
};

submission.prototype.init = function() {
	throw "submission::init() has not been implemented";
};

submission.prototype.processResult = function(oResult, isFailure, oObserver, oContext) {

	var sData, sReplace, sInstance, oInstance, eventContext, oNewDom, contentType = "",
		sTarget, oTargetContext, oTarget, newXhtml;

	if (oObserver) {
		eventContext = {
			"resource-uri": oResult.resourceURI,
			"response-status-code": oResult.status,
			"response-reason-phrase": oResult.statusText,
			"response-headers": this.processResponseHeaders(oResult.responseHeaders)
		};

		if (isFailure) {
			eventContext["error-type"] = "resource-error";
			if (oResult.responseHeaders) {
				contentType = oResult.responseHeaders["Content-Type"] || oResult.responseHeaders["Content-type"];
			}
			if (contentType && this.contentTypeIsXML(contentType)) {
				try {
					eventContext["response-body"] = xmlParse(oResult.responseText);
				} catch(e) {
					eventContext["response-body"] = oResult.responseText;
				}
			} else {
				eventContext["response-body"] = oResult.responseText;
			}
			this.dispatchSubmitError(oObserver, eventContext);
		} else {
			sData = oResult.responseText;

			if (sData) {
				sReplace = oObserver.getAttribute("replace") || "all";

				switch (sReplace) {
				case "all":
					oObserver.ownerDocument.logger.log("@replace = 'all'", "submission");

					if (oResult.method === "PUT") {
						document.location.href = oResult.resourceURI;
					} else {
						this.replaceDocumentContent(sData);
					}
					break;

				case "instance":
					oObserver.ownerDocument.logger.log("@replace = 'instance'", "submission");
					sInstance = oObserver.getAttribute("instance");

					if (oResult.responseHeaders) {
						contentType = oResult.responseHeaders["Content-Type"] || oResult.responseHeaders["Content-type"];
					}
					if (contentType && this.contentTypeIsXML(contentType)) {
						try {
							oNewDom = xmlParse(sData);
						} catch(e) {
							eventContext["error-type"] = "parse-error";
							this.dispatchSubmitError(oObserver, eventContext);
							return;
						}
					} else {
						eventContext["error-type"] = "resource-error";
						this.dispatchSubmitError(oObserver, eventContext);
						return;
					}

					sTarget = oObserver.getAttribute("targetref") || oObserver.getAttribute("target");
					if (sTarget) {
						oTarget = this.processTargetAttribute(sTarget, sInstance, oContext, oObserver, eventContext);
						if (!oTarget) {
							return;
						} else {
							oInstance = sInstance ? oContext.model.getInstanceDocument(sInstance).documentElement : null;
							if (oTarget === oInstance) {
								oContext.model.replaceInstanceDocument(sInstance, oNewDom);
							} else {
								oTarget.parentNode.replaceChild(oNewDom.documentElement, oTarget);
							}
						}
					} else {
						if (sInstance) {
							oContext.model.replaceInstanceDocument(sInstance, oNewDom);
						} else if (oObserver.srcInstance) {
							__replaceInstanceDocument(oContext.model, oObserver.srcInstance, oNewDom);
						} else {
							console.log("Don't know where to put instance!");
						}
					}
					break;

				case "text":
					oObserver.ownerDocument.logger.log("@replace = 'text'", "submission");

					sInstance = oObserver.getAttribute("instance");
					sTarget = oObserver.getAttribute("targetref") || oObserver.getAttribute("target");

					if (sTarget) {
						oTarget = this.processTargetAttribute(sTarget, sInstance, oContext, oObserver, eventContext);
						if (!oTarget) {
							return;
						}
					} else {
						oTarget = oContext.node;
					}

					if (!oTarget || UX.isNodeReadonly(oTarget.parentNode)) {
						eventContext["error-type"] = "target-error";
						this.dispatchSubmitError(oObserver, eventContext);
						return;
					} else {
						oTarget.firstChild.nodeValue = sData;
						oContext.model.flagRebuild();
					}
					break;

				case "none":
					oObserver.ownerDocument.logger.log("@replace = 'none'", "submission");
					break;

				default:
					oObserver.ownerDocument.logger.log("Invalid replace value.", "submission");
					break;
				}
			}
			this.dispatchSubmitDone(oObserver, eventContext);
		}
	}
};

submission.prototype.processResponseHeaders = function(oHeaders) {
	var xmlDoc, headerElt, nameElt, valueElt, name, value, responseHeaders = [];

	for (name in oHeaders) {
		value = oHeaders[name];

		xmlDoc = new XDocument();
		headerElt = xmlDoc.createElement("header");
		nameElt = xmlDoc.createElement("name");
		nameElt.appendChild(xmlDoc.createTextNode(name));
		headerElt.appendChild(nameElt);
		valueElt = xmlDoc.createElement("value");
		valueElt.appendChild(xmlDoc.createTextNode(value));
		headerElt.appendChild(valueElt);

		responseHeaders.push(headerElt);
	}

	return responseHeaders;
};

submission.prototype.processTargetAttribute = function(sTarget, sInstance, oContext, oObserver, eventContext) {
	var oTarget = null,
		oTargetContext;

	if (sTarget) {
		oTargetContext = sInstance ? oContext.model.getInstanceDocument(sInstance).documentElement : oContext;
		oTarget = oContext.model.EvaluateXPath(sTarget, oTargetContext).nodeSetValue()[0];
		if (!oTarget || oTarget.nodeType !== DOM_ELEMENT_NODE || UX.isNodeReadonly(oTarget.parentNode)) {
			eventContext["error-type"] = "target-error";
			this.dispatchSubmitError(oObserver, eventContext);
		}
	}
	return oTarget;
};

/*
 * We give the submit function an object that contains all of the parameters.
 * This is also the object to which we want all of our events targetted.
 */
submission.prototype.submit = function(oSubmission) {
	var sResource = null;
	var currentUrl; // URL of the current document
	var oEvt = null;
	var ns = null;
	var instanceId = oSubmission.getAttribute("instance");
	var instance;
	var sMethod = null;
	var sMediatype = oSubmission.getAttribute("mediatype");
	var sEncoding = oSubmission.getAttribute("encoding") || "UTF-8";
	var sSerialization = oSubmission.getAttribute("serialization") ? (oSubmission.getAttribute("serialization") !== "none") : "";
	var bSerialize = (oSubmission.getAttribute("serialization") !== "none");
	var sSeparator = oSubmission.getAttribute("separator") || "&";
	var oBody;
	var oContext;
	var bHasHeaders = false;
	var isSetSoapHeaders = false;
	var sReplace = null;
	var relevancePruning = oSubmission.getAttribute("relevant") ? (oSubmission.getAttribute("relevant") !== "false") : bSerialize;
	var validation = oSubmission.getAttribute("validate") ? (oSubmission.getAttribute("validate") !== "false") : bSerialize;
	var submitDataList = [];
	var oForm;
	var cdataSectionElements = oSubmission.getAttribute("cdata-section-elements") ? oSubmission.getAttribute("cdata-section-elements").split(" ") : false;
	var sContentType = null;
	var bOmitXmlDeclaration = UX.JsBooleanFromXsdBoolean(oSubmission.getAttribute("omit-xml-declaration"), "false");
	var sStandalone = UX.JsBooleanFromXsdBoolean(oSubmission.getAttribute("standalone"));
	var schemeHandler;
	var includeNamespacePrefixes = oSubmission.getAttribute("includenamespaceprefixes");

	if (includeNamespacePrefixes) {
		includeNamespacePrefixes = includeNamespacePrefixes.split(" ");
	}

	/*
     * XForms 1.0
     *
     * var sVersion = this.element["version"]; var sIndent =
     * this.element["indent"]; var sMediaType = this.element["mediatype"]; var
     * sEncoding = this.element["encoding"]; var sOmitXmlDeclaration =
     * this.element["omit-xml-declaration"]; var sCdataSectionElements =
     * this.element["cdata-section-elements"]; var sReplace =
     * this.element["replace"]; var sInstance = this.element["instance"]; var
     * sSeparator = this.element["separator"]; var sIncludeNamespacePrefixes =
     * this.element["includenamespaceprefixes"];
     *
     */

	var nTimeout = oSubmission.getAttribute("timeout");
	if (nTimeout === null) {
		nTimeout = 5000;
	}

	oContext = DECORATOR.getBehaviour(oSubmission).getBoundNode();
	if (!oContext.model) {
		oContext = DECORATOR.getBehaviour(oSubmission).getEvaluationContext();
	}

	if (!oContext.node) {
		this.dispatchSubmitError(oSubmission, {
			"error-type": "no-data"
		});
		return;
	}

	if (bSerialize) {
		submitDataList = this.constructSubmitDataList(oContext, relevancePruning);
	}
	if (relevancePruning && submitDataList.length === 0) {
		this.dispatchSubmitError(oSubmission, {
			"error-type": "no-data"
		});
		return;
	}

	if (validation && !this.validateSubmitDataList(submitDataList)) {
		this.dispatchSubmitError(oSubmission, {
			"error-type": "validation-error"
		});
		return;
	}

	ns = NamespaceManager.getElementsByTagNameNS(oSubmission, "http://www.w3.org/2002/xforms", "resource");

	sResource = (ns && ns.length > 0) ? UX.getElementValueOrContent(oContext, ns[0]) : null;

	sResource = sResource || oSubmission.getAttribute("resource") || oSubmission.getAttribute("action");

	if (!sResource) {
		this.dispatchSubmitError(oSubmission, {
			"error-type": "resource-error"
		});
		return;
	}

	if (instanceId) {
		instance = oSubmission.ownerDocument.getElementById(instanceId);
		if (!instance || !NamespaceManager.compareFullName(instance, "instance", "http://www.w3.org/2002/xforms")) {
			UX.dispatchEvent(oSubmission, "xforms-binding-exception", true, false, false);
			return;
		}
	} else if (oContext.node) {
		DECORATOR.getBehaviour(oSubmission).srcInstance = oContext.node.ownerDocument.XFormsInstance;
	}

	ns = NamespaceManager.getElementsByTagNameNS(oSubmission, "http://www.w3.org/2002/xforms", "method");

	sMethod = (ns && ns.length > 0) ? UX.getElementValueOrContent(oContext, ns[0]) : oSubmission.getAttribute("method") || "get";

	switch (sMethod) {
	case "get":
		sMethod = "GET";
		sSerialization = "application/x-www-form-urlencoded";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);

		if (sMediatype && sMediatype.indexOf("application/soap+xml") === 0) {
			isSetSoapHeaders = this.setSOAPHeaders(oContext.node, sMethod, sMediatype, sEncoding);
		}
		break;

	case "form-data-post":
		sMethod = "POST";
		sSerialization = sSerialization || "multipart/form-data";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);
		break;

	case "urlencoded-post":
		sMethod = "POST";
		sSerialization = "application/x-www-form-urlencoded";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);
		break;

	case "post":
		sMethod = "POST";
		sSerialization = "application/xml";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);

		if (sMediatype && sMediatype.indexOf("application/soap+xml") === 0) {
			isSetSoapHeaders = this.setSOAPHeaders(oContext.node, sMethod, sMediatype, sEncoding);
		}

		break;

	case "put":
		sMethod = "PUT";
		sSerialization = "application/xml";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);
		break;

	case "delete":
		sMethod = "DELETE";
		sSerialization = "application/x-www-form-urlencoded";
		oBody = this.serializeSubmitDataList(submitDataList, sSerialization, sSeparator, sEncoding, cdataSectionElements, bOmitXmlDeclaration, sStandalone, includeNamespacePrefixes);
		break;

	default:
		/* the submission method being used needs to be implemented */
		oSubmission.ownerDocument.logger.log("Submission method '" + sMethod + "' is not defined.", "error");
		break;
	}

	sContentType = sMediatype || sSerialization;
	if (!isSetSoapHeaders) {
		this.setHeader("content-type", sContentType);
	}

	try {
		var xmlDoc = document.DOMImplementation.createDocument('', '', null);
		var oSubmissionBody = xmlDoc.createTextNode("");
		this.dispatchSubmitSerialize(oSubmission, {
			"submission-body": [oSubmissionBody]
		});
	} catch(e) {
		oSubmission.ownerDocument.logger.log("Error: " + e.description, "error");
	}

	bHasHeaders = isSetSoapHeaders || (NamespaceManager.getElementsByTagNameNS(oSubmission, "http://www.w3.org/2002/xforms", "header").length > 0);

	sReplace = oSubmission.getAttribute("replace") || "all";

	if (
	sReplace === 'all' && (
	this.navigateForReplaceAll && (sMethod === "GET" || sMethod === "POST") && !bHasHeaders && (
	sContentType === sSerialization && (sSerialization === "application/x-www-form-urlencoded" || sSerialization === "multipart/form-data")))) {
		oForm = this.buildFormFromObject(oBody);
		oForm.encoding = sSerialization;
		oForm.action = sResource;
		oForm.method = sMethod.toLowerCase();
		document.body.appendChild(oForm);

		try {
			oForm.submit();
		} catch(e) {
			this.dispatchSubmitError(oSubmission, {
				"error-type": "resource-error",
				"resource-uri": sResource
			});
		} finally {
			oForm.parentNode.removeChild(oForm);
		}
	} else {
		var oCallback = new callback(this, oSubmission, oContext);
		this.setHeaders(oContext.model, oSubmission);

		try {
			if ((oBody || oBody !== "") && sSerialization === "application/x-www-form-urlencoded") {
				switch (sMethod) {
				case "GET":
				case "DELETE":
					sResource = this.buildGetUrl(sResource, oBody, sSeparator);
					oBody = null;
					break;

				case "POST":
					oBody = this.buildEncodedParameters(oBody, sSeparator);
					break;

				default:
					break;
				}
			}

			currentUrl = getBaseUrl();
			sResource = makeAbsoluteURI(currentUrl, sResource);
			schemeHandler = schemeHandlers[spliturl(sResource).scheme];

			if ((UX.isFF || UX.isWebKit) && schemeHandler && schemeHandler[sMethod]) {
				spawn(function() {
					schemeHandler[sMethod](sResource, oBody, nTimeout, oCallback);
				});
			}

			else {
				if (UX.isFF && "file" === spliturl(currentUrl).scheme) {
					netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				}

				return this.request(sMethod, sResource, oBody, nTimeout, oCallback);
			}
		} catch(e) {
			this.dispatchSubmitError(oSubmission, {
				"error-type": "resource-error",
				"resource-uri": sResource
			});
		}
	}
};

submission.prototype.constructSubmitDataList = function(oContext, relevancePruning) {
	var submitDataList = [];
	var stack = [oContext.node];
	var proxyNode, l;

	while (stack.length > 0) {
		proxyNode = UX.getProxyNode(stack.pop());
		if (proxyNode.enabled.value || !relevancePruning) {
			submitDataList.push(proxyNode);
			if(proxyNode.m_oNode.nodeType != 1) continue;
			for(l = proxyNode.m_oNode.childNodes.length - 1; l >= 0; l--) {
				stack.push(proxyNode.m_oNode.childNodes[l]);
			}
			for(l = proxyNode.m_oNode.attributes.length - 1; l >= 0; l--) {
				stack.push(proxyNode.m_oNode.attributes[l]);
			}
		}
	}
	return submitDataList;
};

submission.prototype.validateSubmitDataList = function(submitDataList) {
	for (var i = 0, l = submitDataList.length; i < l; i++) {
		if (!submitDataList[i].valid.getValue()) {
			return false;
		}
	}
	return true;
};

submission.prototype.serializeSubmitDataList = function(submitDataList, serializationFormat, separator, encoding, cdataSectionElements, omitXmlDeclaration, standalone, includeNamespacePrefixes) {
	var serialization = "";
	var xmlDoc = this.constructSubmitDataListDOM(submitDataList);

	if (xmlDoc) {
		if (serializationFormat === "application/xml") {
			encoding = encoding || "UTF-8";

			this.setHeader("Content-Type", serializationFormat + "; charset=" + encoding);
			if (!omitXmlDeclaration) {
				xmlDoc.insertBefore(
				xmlDoc.createProcessingInstruction("xml", "version=\"1.0\"" + " encoding=\"" + encoding + "\"" + ((standalone !== undefined) ? (" standalone=\"" + ((standalone) ? "yes" : "no") + "\"") : "")), xmlDoc.firstChild);
			}
			return new XMLSerializer().serializeToString(xmlDoc);
		}

		if (serializationFormat === "application/x-www-form-urlencoded" || serializationFormat === "multipart/form-data") {
			return this.serializeURLEncoded(xmlDoc);
		}
	} //if ( there is something to serialize )
	return "";
};

submission.prototype.constructSubmitDataListDOM = function(submitDataList) {
	if (!submitDataList.length) {
		return null;
	}

	var root = UX.cloneNode(submitDataList[0].m_oNode, false);
	var xmlDoc;
	if (root.nodeType === DOM_DOCUMENT_NODE) {
		xmlDoc = root;
	} else if (root.nodeType === DOM_ELEMENT_NODE) {
		xmlDoc = document.DOMImplementation.createDocument('', '', null);
		xmlDoc.appendChild(root);
		while(root.attributes.length) {
			root.removeAttribute(root.attributes[0].nodeName);
		}
	} else {
		throw ("Submission data must be rooted by an element or a document node");
	}

	this._constructSubmitDataListDOM(submitDataList, 0, root);

	return xmlDoc;
};


submission.prototype._constructSubmitDataListDOM = function(submitDataList, listPos, parentNode) {
	var node, submitListParent;

	submitListParent = submitDataList[listPos].m_oNode;

	listPos++;

	if (parentNode.nodeType === DOM_ELEMENT_NODE) {
		while (listPos < submitDataList.length && submitDataList[listPos].m_oNode.nodeType === DOM_ATTRIBUTE_NODE) {
			var name = submitDataList[listPos].m_oNode.nodeName;
			if(!(/^ux_uid/).test(name)) {
				parentNode.setAttribute(name, submitDataList[listPos].m_oNode.nodeValue);
			}
			listPos++;
		}
	}

	if (parentNode.nodeType === DOM_ELEMENT_NODE || parentNode.nodeType === DOM_DOCUMENT_NODE) {
		while (listPos < submitDataList.length && submitDataList[listPos].m_oNode.parentNode === submitListParent) {
			node = submitDataList[listPos].m_oNode.cloneNode(false);
			parentNode.appendChild(node);
			if (node.nodeType === DOM_ELEMENT_NODE) {
				while(node.attributes.length) {
					node.removeAttribute(node.attributes[0].nodeName);
				}
				listPos = this._constructSubmitDataListDOM(submitDataList, listPos, node);
			} else {
				listPos++;
			}
		}
	}

	return listPos;
};

submission.prototype.serializeURLEncoded = function(node) {
	var stack = [node];
	var taggedValues = {};
	var i, isLeaf, tag, value, childNode;

	while (stack.length > 0) {
		node = stack.pop();
		if (node.nodeType === DOM_ELEMENT_NODE || node.nodeType === DOM_DOCUMENT_NODE || node.nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
			isLeaf = true;
			value = "";
			for (i = node.childNodes.length - 1; i >= 0; i--) {
				childNode = node.childNodes[i];
				if (childNode.nodeType === DOM_TEXT_NODE || childNode.nodeType === DOM_CDATA_SECTION_NODE) {
					value = childNode.nodeValue + value;
				} else if (childNode.nodeType === DOM_ELEMENT_NODE) {
					isLeaf = false;
					stack.push(childNode);
				}
			}
			if (isLeaf && node.nodeType === DOM_ELEMENT_NODE) {
				tag = node.nodeName;
				if (tag.indexOf(':') != 0) {
					tag = tag.slice(tag.indexOf(':') + 1);
				}

				taggedValues[tag] = value;
			}
		}
	}

	return taggedValues;
};

/**
 * Builds an HTML form element from an object.
 */
submission.prototype.buildFormFromObject = function(object) {
	var form = document.createElement("form");
	var field = null;
	var key, value;

	for (key in object) {
		if (object.hasOwnProperty(key) && typeof(object[key]) !== "function") {
			field = document.createElement("input");
			field.type = "hidden";
			field.name = key;
			field.value = object[key];

			form.appendChild(field);
		}
	}

	return form;
};

submission.prototype.setHeaders = function(oModel, oSubmission) {
	var headers = {};
	var header;
	var i, j;
	var elements;
	var nodelist;
	var name;
	var values;
	var value;
	var combine;

	elements = NamespaceManager.getElementsByTagNameNS(oSubmission, "http://www.w3.org/2002/xforms", "header");
	for (i = 0; i < elements.length; ++i) {
		header = elements[i];

		if (NamespaceManager.getElementsByTagNameNS(header, "http://www.w3.org/2002/xforms", "header").length > 0) {
			continue;
		}

		nodelist = NamespaceManager.getElementsByTagNameNS(header, "http://www.w3.org/2002/xforms", "name");
		if (nodelist.length === 0) {
			document.logger.log("INFO: Ignoring xf:header whose xf:name is empty");
			continue;
		} else {
			name = DECORATOR.getBehaviour(nodelist[0]).getValue();

			if (!name || name.trim() === '') {
				document.logger.log("INFO: Ignoring xf:header whose xf:name is empty");
				continue;
			}
		}

		combine = header.getAttribute("combine");

		values = [];
		nodelist = NamespaceManager.getElementsByTagNameNS(elements[i], "http://www.w3.org/2002/xforms", "value");
		for (j = 0; j < nodelist.length; ++j) {
			value = DECORATOR.getBehaviour(nodelist[j]).getValue();
			if (value) {
				values.push(value);
			}
		}

		if (headers[name]) {
			if (!combine || combine === "append") {
				headers[name] = headers[name].concat(values);
			} else if (combine === "prepend") {
				while (values.length > 0) {
					headers[name].unshift(values.pop());
				}
			} else if (combine === "replace") {
				headers[name] = values;
			}
		} else {
			headers[name] = values;
		}
	}

	for (name in headers) {
		this.setHeader(name, headers[name].join(','));
	}
};

submission.prototype.buildEncodedParameters = function(params, separator, queryString) {
	var key, pairs = [];

	if (params) {
		for (key in params) {
			if (params.hasOwnProperty(key) && typeof(params[key]) !== "function") {
				pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
			}
		}
	} //if ( there are parameters to add to the action )
	return ((queryString) ? queryString : "") + pairs.join(separator || "&");
}; //buildEncodedParameters()
submission.prototype.buildGetUrl = function(action, params, separator) {
	return action + this.buildEncodedParameters(params, separator, "?");
}; //buildGetUrl()
submission.prototype.setSOAPHeaders = function(oContextNode, sMethod, sMediatype, sEncoding) {

	var result = false;
	var action = (/action=([^\s\t\r\n\v\f;]+);?/.exec(sMediatype || "") || [])[1];
	var charset = (/charset=([\w-]+);?/.exec(sMediatype || "") || [])[1] || sEncoding || "UTF-8";

	var namespaceURI = oContextNode && NamespaceManager.getNamespaceURI(oContextNode);
	if (sMethod === "POST") {

		if (namespaceURI === "http://schemas.xmlsoap.org/soap/envelope/") {

			if (action) {
				this.setHeader("SOAPAction", action);
			}

			this.setHeader("content-type", "text/xml; charset=" + charset);
			result = true;
		} else if (namespaceURI === "http://www.w3.org/2003/05/soap-envelope") {
			this.setHeader("content-type", sMediatype);
			result = true;
		}

	} else if (sMethod === "GET") {

		if (namespaceURI === "http://www.w3.org/2003/05/soap-envelope") {
			this.setHeader("accept", "application/soap+xml; charset=" + charset);
			result = true;
		}
	}

	return result;
};

submission.prototype.replaceDocumentContent = function(data) {
	var xhtmlContainer, htmlElement;

	if (UX.isFF || UX.isWebKit) {
		if (data.indexOf("<?", 0) === 0) {
			data = data.substr(data.indexOf("?>") + 2);
		}
	}

	if (UX.isXHTML) {
		xhtmlContainer = document.createElement("div");
		xhtmlContainer.innerHTML = data;
		htmlElement = xhtmlContainer.getElementsByTagName("html")[0];
		if (htmlElement) {
			document.documentElement.innerHTML = htmlElement.innerHTML;
		} else {
			document.documentElement.innerHTML = xhtmlContainer.innerHTML;
		}
	} else {
		document.write(data);
		document.close();
	}
};

submission.prototype.dispatchSubmitSerialize = function(eventTarget, eventContext) {
	this.dispatchSubmissionEvent(eventTarget, 'serialize', eventContext);
};

submission.prototype.dispatchSubmitError = function(eventTarget, eventContext) {
	this.dispatchSubmissionEvent(eventTarget, 'error', eventContext);
};

submission.prototype.dispatchSubmitDone = function(eventTarget, eventContext) {
	this.dispatchSubmissionEvent(eventTarget, 'done', eventContext);
};

submission.prototype.dispatchSubmissionEvent = function(eventTarget, eventSuffix, eventContext) {
	try {
		var doc = eventTarget.ownerDocument;
	} catch(e) {
		return;
	}
	var evt = doc.createEvent('Events');
	evt.initEvent('xforms-submit-' + eventSuffix, true, false);
	evt.context = eventContext;
	FormsProcessor.dispatchEvent(eventTarget, evt);
};

submission.prototype.contentTypeIsXML = function(contentType) {
	contentType.toLowerCase().match(/(.*\/[^;]*)(;(.*))?/);

	var mediatype = RegExp.$1;

	return (
	mediatype === 'text/xml' || mediatype === 'application/xml' || mediatype.indexOf('+xml') === mediatype.length - 4);
};

/*
 * [TODO] Could probably turn this into one object.
 */

callback.prototype.success = function(o) {
    this.processResult(
           {
             status : o.status || NaN,
             statusText : o.statusText || "",
             responseText : o.responseText || "",
             responseHeaders : o.getResponseHeader,
             resourceURI : this.resourceURI
     }
           , false);
};

callback.prototype.failure = function(o) {
    this.processResult(
        {
          status : o.status || NaN,
          statusText : o.statusText || "",
          responseText : o.responseText || "",
          responseHeaders : o.getResponseHeader,
          resourceURI : this.resourceURI
}
        , true);
};

submission.prototype.request = function(sMethod, sAction, sBody, nTimeout, oCallback) {
	if (nTimeout) {
		oCallback.timeout = nTimeout;
    }

    oCallback.resourceURI = sAction;

	return YAHOO.util.Connect.asyncRequest(
		sMethod,
		sAction,
		oCallback,
		sBody
	);
};

submission.prototype.getConnection = function() {
	return YAHOO.util.Connect;
};

submission.prototype.init = function() {
    this.getConnection().setDefaultPostHeader(false);
    return true;
};

submission.prototype.setHeader = function(header, value) {
    return this.getConnection().initHeader(header, value);
};

document.submission.init();
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * Provides Attribute configurations.
 * @namespace YAHOO.util
 * @class Attribute
 * @constructor
 * @param hash {Object} The intial Attribute.
 * @param {YAHOO.util.AttributeProvider} The owner of the Attribute instance.
 */

YAHOO.util.Attribute = function(hash, owner) {
    if (owner) {
        this.owner = owner;
        this.configure(hash, true);
    }
};

YAHOO.util.Attribute.prototype = {
    /**
     * The name of the attribute.
     * @property name
     * @type String
     */
    name: undefined,

    /**
     * The value of the attribute.
     * @property value
     * @type String
     */
    value: null,

    /**
     * The owner of the attribute.
     * @property owner
     * @type YAHOO.util.AttributeProvider
     */
    owner: null,

    /**
     * Whether or not the attribute is read only.
     * @property readOnly
     * @type Boolean
     */
    readOnly: false,

    /**
     * Whether or not the attribute can only be written once.
     * @property writeOnce
     * @type Boolean
     */
    writeOnce: false,

    /**
     * The attribute's initial configuration.
     * @private
     * @property _initialConfig
     * @type Object
     */
    _initialConfig: null,

    /**
     * Whether or not the attribute's value has been set.
     * @private
     * @property _written
     * @type Boolean
     */
    _written: false,

    /**
     * A function to call when setting the attribute's value.
     * The method receives the new value as the first arg and the attribute name as the 2nd
     * @property method
     * @type Function
     */
    method: null,

    /**
     * The function to use when setting the attribute's value.
     * The setter receives the new value as the first arg and the attribute name as the 2nd
     * The return value of the setter replaces the value passed to set().
     * @property setter
     * @type Function
     */
    setter: null,

    /**
     * The function to use when getting the attribute's value.
     * The getter receives the new value as the first arg and the attribute name as the 2nd
     * The return value of the getter will be used as the return from get().
     * @property getter
     * @type Function
     */
    getter: null,

    /**
     * The validator to use when setting the attribute's value.
     * @property validator
     * @type Function
     * @return Boolean
     */
    validator: null,

    /**
     * Retrieves the current value of the attribute.
     * @method getValue
     * @return {any} The current value of the attribute.
     */
    getValue: function() {
        var val = this.value;

        if (this.getter) {
            val = this.getter.call(this.owner, this.name, val);
        }

        return val;
    },

    /**
     * Sets the value of the attribute and fires beforeChange and change events.
     * @method setValue
     * @param {Any} value The value to apply to the attribute.
     * @param {Boolean} silent If true the change events will not be fired.
     * @return {Boolean} Whether or not the value was set.
     */
    setValue: function(value, silent) {
        var beforeRetVal,
            owner = this.owner,
            name = this.name;

        var event = {
            type: name,
            prevValue: this.getValue(),
            newValue: value
        };

        if (this.readOnly || ( this.writeOnce && this._written) ) {
            return false; // write not allowed
        }

        if (this.validator && !this.validator.call(owner, value) ) {
            return false; // invalid value
        }

        if (!silent) {
            beforeRetVal = owner.fireBeforeChangeEvent(event);
            if (beforeRetVal === false) {
                return false;
            }
        }

        if (this.setter) {
            value = this.setter.call(owner, value, this.name);
            if (value === undefined) {
            }
        }

        if (this.method) {
            this.method.call(owner, value, this.name);
        }

        this.value = value; // TODO: set before calling setter/method?
        this._written = true;

        event.type = name;

        if (!silent) {
            this.owner.fireChangeEvent(event);
        }

        return true;
    },

    /**
     * Allows for configuring the Attribute's properties.
     * @method configure
     * @param {Object} map A key-value map of Attribute properties.
     * @param {Boolean} init Whether or not this should become the initial config.
     */
    configure: function(map, init) {
        map = map || {};

        if (init) {
            this._written = false; // reset writeOnce
        }

        this._initialConfig = this._initialConfig || {};

        for (var key in map) {
            if ( map.hasOwnProperty(key) ) {
                this[key] = map[key];
                if (init) {
                    this._initialConfig[key] = map[key];
                }
            }
        }
    },

    /**
     * Resets the value to the initial config value.
     * @method resetValue
     * @return {Boolean} Whether or not the value was set.
     */
    resetValue: function() {
        return this.setValue(this._initialConfig.value);
    },

    /**
     * Resets the attribute config to the initial config state.
     * @method resetConfig
     */
    resetConfig: function() {
        this.configure(this._initialConfig, true);
    },

    /**
     * Resets the value to the current value.
     * Useful when values may have gotten out of sync with actual properties.
     * @method refresh
     * @return {Boolean} Whether or not the value was set.
     */
    refresh: function(silent) {
        this.setValue(this.value, silent);
    }
};

(function() {
    var Lang = YAHOO.util.Lang;

    /*
    Copyright (c) 2006, Yahoo! Inc. All rights reserved.
    Code licensed under the BSD License:
    http://developer.yahoo.net/yui/license.txt
    */

    /**
     * Provides and manages YAHOO.util.Attribute instances
     * @namespace YAHOO.util
     * @class AttributeProvider
     * @uses YAHOO.util.EventProvider
     */
    YAHOO.util.AttributeProvider = function() {};

    YAHOO.util.AttributeProvider.prototype = {

        /**
         * A key-value map of Attribute configurations
         * @property _configs
         * @protected (may be used by subclasses and augmentors)
         * @private
         * @type {Object}
         */
        _configs: null,
        /**
         * Returns the current value of the attribute.
         * @method get
         * @param {String} key The attribute whose value will be returned.
         * @return {Any} The current value of the attribute.
         */
        get: function(key){
            this._configs = this._configs || {};
            var config = this._configs[key];

            if (!config || !this._configs.hasOwnProperty(key)) {
                return null;
            }

            return config.getValue();
        },

        /**
         * Sets the value of a config.
         * @method set
         * @param {String} key The name of the attribute
         * @param {Any} value The value to apply to the attribute
         * @param {Boolean} silent Whether or not to suppress change events
         * @return {Boolean} Whether or not the value was set.
         */
        set: function(key, value, silent){
            this._configs = this._configs || {};
            var config = this._configs[key];

            if (!config) {
                return false;
            }

            return config.setValue(value, silent);
        },

        /**
         * Returns an array of attribute names.
         * @method getAttributeKeys
         * @return {Array} An array of attribute names.
         */
        getAttributeKeys: function(){
            this._configs = this._configs;
            var keys = [], key;

            for (key in this._configs) {
                if ( Lang.hasOwnProperty(this._configs, key) &&
                        !Lang.isUndefined(this._configs[key]) ) {
                    keys[keys.length] = key;
                }
            }

            return keys;
        },

        /**
         * Sets multiple attribute values.
         * @method setAttributes
         * @param {Object} map  A key-value map of attributes
         * @param {Boolean} silent Whether or not to suppress change events
         */
        setAttributes: function(map, silent){
            for (var key in map) {
                if ( Lang.hasOwnProperty(map, key) ) {
                    this.set(key, map[key], silent);
                }
            }
        },

        /**
         * Resets the specified attribute's value to its initial value.
         * @method resetValue
         * @param {String} key The name of the attribute
         * @param {Boolean} silent Whether or not to suppress change events
         * @return {Boolean} Whether or not the value was set
         */
        resetValue: function(key, silent){
            this._configs = this._configs || {};
            if (this._configs[key]) {
                this.set(key, this._configs[key]._initialConfig.value, silent);
                return true;
            }
            return false;
        },

        /**
         * Sets the attribute's value to its current value.
         * @method refresh
         * @param {String | Array} key The attribute(s) to refresh
         * @param {Boolean} silent Whether or not to suppress change events
         */
        refresh: function(key, silent) {
            this._configs = this._configs || {};
            var configs = this._configs;

            key = ( ( Lang.isString(key) ) ? [key] : key ) ||
                    this.getAttributeKeys();

            for (var i = 0, len = key.length; i < len; ++i) {
                if (configs.hasOwnProperty(key[i])) {
                    this._configs[key[i]].refresh(silent);
                }
            }
        },

        /**
         * Adds an Attribute to the AttributeProvider instance.
         * @method register
         * @param {String} key The attribute's name
         * @param {Object} map A key-value map containing the
         * attribute's properties.
         * @deprecated Use setAttributeConfig
         */
        register: function(key, map) {
            this.setAttributeConfig(key, map);
        },


        /**
         * Returns the attribute's properties.
         * @method getAttributeConfig
         * @param {String} key The attribute's name
         * @private
         * @return {object} A key-value map containing all of the
         * attribute's properties.
         */
        getAttributeConfig: function(key) {
            this._configs = this._configs || {};
            var config = this._configs[key] || {};
            var map = {}; // returning a copy to prevent overrides

            for (key in config) {
                if ( Lang.hasOwnProperty(config, key) ) {
                    map[key] = config[key];
                }
            }

            return map;
        },

        /**
         * Sets or updates an Attribute instance's properties.
         * @method setAttributeConfig
         * @param {String} key The attribute's name.
         * @param {Object} map A key-value map of attribute properties
         * @param {Boolean} init Whether or not this should become the intial config.
         */
        setAttributeConfig: function(key, map, init) {
            this._configs = this._configs || {};
            map = map || {};
            if (!this._configs[key]) {
                map.name = key;
                this._configs[key] = this.createAttribute(map);
            } else {
                this._configs[key].configure(map, init);
            }
        },

        /**
         * Sets or updates an Attribute instance's properties.
         * @method configureAttribute
         * @param {String} key The attribute's name.
         * @param {Object} map A key-value map of attribute properties
         * @param {Boolean} init Whether or not this should become the intial config.
         * @deprecated Use setAttributeConfig
         */
        configureAttribute: function(key, map, init) {
            this.setAttributeConfig(key, map, init);
        },

        /**
         * Resets an attribute to its intial configuration.
         * @method resetAttributeConfig
         * @param {String} key The attribute's name.
         * @private
         */
        resetAttributeConfig: function(key){
            this._configs = this._configs || {};
            this._configs[key].resetConfig();
        },

        subscribe: function(type, callback) {
            this._events = this._events || {};

            if ( !(type in this._events) ) {
                this._events[type] = this.createEvent(type);
            }

            YAHOO.util.EventProvider.prototype.subscribe.apply(this, arguments);
        },

        on: function() {
            this.subscribe.apply(this, arguments);
        },

        addListener: function() {
            this.subscribe.apply(this, arguments);
        },

        /**
         * Fires the attribute's beforeChange event.
         * @method fireBeforeChangeEvent
         * @param {String} key The attribute's name.
         * @param {Obj} e The event object to pass to handlers.
         */
        fireBeforeChangeEvent: function(e) {
            var type = 'before';
            type += e.type.charAt(0).toUpperCase() + e.type.substr(1) + 'Change';
            e.type = type;
            return this.fireEvent(e.type, e);
        },

        /**
         * Fires the attribute's change event.
         * @method fireChangeEvent
         * @param {String} key The attribute's name.
         * @param {Obj} e The event object to pass to the handlers.
         */
        fireChangeEvent: function(e) {
            e.type += 'Change';
            return this.fireEvent(e.type, e);
        },

        createAttribute: function(map) {
            return new YAHOO.util.Attribute(map, this);
        }
    };

    YAHOO.augment(YAHOO.util.AttributeProvider, YAHOO.util.EventProvider);
})();

(function() {
var Dom = YAHOO.util.Dom,
    AttributeProvider = YAHOO.util.AttributeProvider,
	specialTypes = {
		mouseenter: true,
		mouseleave: true
	};

/**
 * Element provides an wrapper object to simplify adding
 * event listeners, using dom methods, and managing attributes.
 * @module element
 * @namespace YAHOO.util
 * @requires yahoo, dom, event
 */

/**
 * Element provides an wrapper object to simplify adding
 * event listeners, using dom methods, and managing attributes.
 * @class Element
 * @uses YAHOO.util.AttributeProvider
 * @constructor
 * @param el {HTMLElement | String} The html element that
 * represents the Element.
 * @param {Object} map A key-value map of initial config names and values
 */
var Element = function(el, map) {
    this.init.apply(this, arguments);
};

Element.DOM_EVENTS = {
    'click': true,
    'dblclick': true,
    'keydown': true,
    'keypress': true,
    'keyup': true,
    'mousedown': true,
    'mousemove': true,
    'mouseout': true,
    'mouseover': true,
    'mouseup': true,
    'mouseenter': true,
    'mouseleave': true,
    'focus': true,
    'blur': true,
    'submit': true,
    'change': true
};

Element.prototype = {
    /**
     * Dom events supported by the Element instance.
     * @property DOM_EVENTS
     * @type Object
     */
    DOM_EVENTS: null,

    DEFAULT_HTML_SETTER: function(value, key) {
        var el = this.get('element');

        if (el) {
            el[key] = value;
        }

		return value;

    },

    DEFAULT_HTML_GETTER: function(key) {
        var el = this.get('element'),
            val;

        if (el) {
            val = el[key];
        }

        return val;
    },

    /**
     * Wrapper for HTMLElement method.
     * @method appendChild
     * @param {YAHOO.util.Element || HTMLElement} child The element to append.
     * @return {HTMLElement} The appended DOM element.
     */
    appendChild: function(child) {
        child = child.get ? child.get('element') : child;
        return this.get('element').appendChild(child);
    },

    /**
     * Wrapper for HTMLElement method.
     * @method getElementsByTagName
     * @param {String} tag The tagName to collect
     * @return {HTMLCollection} A collection of DOM elements.
     */
    getElementsByTagName: function(tag) {
        return this.get('element').getElementsByTagName(tag);
    },

    /**
     * Wrapper for HTMLElement method.
     * @method hasChildNodes
     * @return {Boolean} Whether or not the element has childNodes
     */
    hasChildNodes: function() {
        return this.get('element').hasChildNodes();
    },

    /**
     * Wrapper for HTMLElement method.
     * @method insertBefore
     * @param {HTMLElement} element The HTMLElement to insert
     * @param {HTMLElement} before The HTMLElement to insert
     * the element before.
     * @return {HTMLElement} The inserted DOM element.
     */
    insertBefore: function(element, before) {
        element = element.get ? element.get('element') : element;
        before = (before && before.get) ? before.get('element') : before;

        return this.get('element').insertBefore(element, before);
    },

    /**
     * Wrapper for HTMLElement method.
     * @method removeChild
     * @param {HTMLElement} child The HTMLElement to remove
     * @return {HTMLElement} The removed DOM element.
     */
    removeChild: function(child) {
        child = child.get ? child.get('element') : child;
        return this.get('element').removeChild(child);
    },

    /**
     * Wrapper for HTMLElement method.
     * @method replaceChild
     * @param {HTMLElement} newNode The HTMLElement to insert
     * @param {HTMLElement} oldNode The HTMLElement to replace
     * @return {HTMLElement} The replaced DOM element.
     */
    replaceChild: function(newNode, oldNode) {
        newNode = newNode.get ? newNode.get('element') : newNode;
        oldNode = oldNode.get ? oldNode.get('element') : oldNode;
        return this.get('element').replaceChild(newNode, oldNode);
    },


    /**
     * Registers Element specific attributes.
     * @method initAttributes
     * @param {Object} map A key-value map of initial attribute configs
     */
    initAttributes: function(map) {
    },

    /**
     * Adds a listener for the given event.  These may be DOM or
     * customEvent listeners.  Any event that is fired via fireEvent
     * can be listened for.  All handlers receive an event object.
     * @method addListener
     * @param {String} type The name of the event to listen for
     * @param {Function} fn The handler to call when the event fires
     * @param {Any} obj A variable to pass to the handler
     * @param {Object} scope The object to use for the scope of the handler
     */
    addListener: function(type, fn, obj, scope) {

        scope = scope || this;

        var Event = YAHOO.util.Event,
			el = this.get('element') || this.get('id'),
        	self = this;


		if (specialTypes[type] && !Event._createMouseDelegate) {
	        return false;
		}


        if (!this._events[type]) { // create on the fly

            if (el && this.DOM_EVENTS[type]) {
				Event.on(el, type, function(e, matchedEl) {


	                if (e.srcElement && !e.target) {
	                    e.target = e.srcElement;
	                }

					if ((e.toElement && !e.relatedTarget) || (e.fromElement && !e.relatedTarget)) {
						e.relatedTarget = Event.getRelatedTarget(e);
					}

					if (!e.currentTarget) {
						e.currentTarget = el;
					}

		            self.fireEvent(type, e, matchedEl);

		        }, obj, scope);
            }
            this.createEvent(type, {scope: this});
        }

        return YAHOO.util.EventProvider.prototype.subscribe.apply(this, arguments); // notify via customEvent
    },


    /**
     * Alias for addListener
     * @method on
     * @param {String} type The name of the event to listen for
     * @param {Function} fn The function call when the event fires
     * @param {Any} obj A variable to pass to the handler
     * @param {Object} scope The object to use for the scope of the handler
     */
    on: function() {
        return this.addListener.apply(this, arguments);
    },

    /**
     * Alias for addListener
     * @method subscribe
     * @param {String} type The name of the event to listen for
     * @param {Function} fn The function call when the event fires
     * @param {Any} obj A variable to pass to the handler
     * @param {Object} scope The object to use for the scope of the handler
     */
    subscribe: function() {
        return this.addListener.apply(this, arguments);
    },

    /**
     * Remove an event listener
     * @method removeListener
     * @param {String} type The name of the event to listen for
     * @param {Function} fn The function call when the event fires
     */
    removeListener: function(type, fn) {
        return this.unsubscribe.apply(this, arguments);
    },

    /**
     * Wrapper for Dom method.
     * @method addClass
     * @param {String} className The className to add
     */
    addClass: function(className) {
        Dom.addClass(this.get('element'), className);
    },

    /**
     * Wrapper for Dom method.
     * @method getElementsByClassName
     * @param {String} className The className to collect
     * @param {String} tag (optional) The tag to use in
     * conjunction with class name
     * @return {Array} Array of HTMLElements
     */
    getElementsByClassName: function(className, tag) {
        return Dom.getElementsByClassName(className, tag,
                this.get('element') );
    },

    /**
     * Wrapper for Dom method.
     * @method hasClass
     * @param {String} className The className to add
     * @return {Boolean} Whether or not the element has the class name
     */
    hasClass: function(className) {
        return Dom.hasClass(this.get('element'), className);
    },

    /**
     * Wrapper for Dom method.
     * @method removeClass
     * @param {String} className The className to remove
     */
    removeClass: function(className) {
        return Dom.removeClass(this.get('element'), className);
    },

    /**
     * Wrapper for Dom method.
     * @method replaceClass
     * @param {String} oldClassName The className to replace
     * @param {String} newClassName The className to add
     */
    replaceClass: function(oldClassName, newClassName) {
        return Dom.replaceClass(this.get('element'),
                oldClassName, newClassName);
    },

    /**
     * Wrapper for Dom method.
     * @method setStyle
     * @param {String} property The style property to set
     * @param {String} value The value to apply to the style property
     */
    setStyle: function(property, value) {
        return Dom.setStyle(this.get('element'),  property, value); // TODO: always queuing?
    },

    /**
     * Wrapper for Dom method.
     * @method getStyle
     * @param {String} property The style property to retrieve
     * @return {String} The current value of the property
     */
    getStyle: function(property) {
        return Dom.getStyle(this.get('element'),  property);
    },

    /**
     * Apply any queued set calls.
     * @method fireQueue
     */
    fireQueue: function() {
        var queue = this._queue;
        for (var i = 0, len = queue.length; i < len; ++i) {
            this[queue[i][0]].apply(this, queue[i][1]);
        }
    },

    /**
     * Appends the HTMLElement into either the supplied parentNode.
     * @method appendTo
     * @param {HTMLElement | Element} parentNode The node to append to
     * @param {HTMLElement | Element} before An optional node to insert before
     * @return {HTMLElement} The appended DOM element.
     */
    appendTo: function(parent, before) {
        parent = (parent.get) ?  parent.get('element') : Dom.get(parent);

        this.fireEvent('beforeAppendTo', {
            type: 'beforeAppendTo',
            target: parent
        });


        before = (before && before.get) ?
                before.get('element') : Dom.get(before);
        var element = this.get('element');

        if (!element) {
            return false;
        }

        if (!parent) {
            return false;
        }

        if (element.parent != parent) {
            if (before) {
                parent.insertBefore(element, before);
            } else {
                parent.appendChild(element);
            }
        }


        this.fireEvent('appendTo', {
            type: 'appendTo',
            target: parent
        });

        return element;
    },

    get: function(key) {
        var configs = this._configs || {},
            el = configs.element; // avoid loop due to 'element'

        if (el && !configs[key] && !YAHOO.lang.isUndefined(el.value[key]) ) {
            this._setHTMLAttrConfig(key);
        }

        return AttributeProvider.prototype.get.call(this, key);
    },

    setAttributes: function(map, silent) {
        var done = {},
            configOrder = this._configOrder;

        for (var i = 0, len = configOrder.length; i < len; ++i) {
            if (map[configOrder[i]] !== undefined) {
                done[configOrder[i]] = true;
                this.set(configOrder[i], map[configOrder[i]], silent);
            }
        }

        for (var att in map) {
            if (map.hasOwnProperty(att) && !done[att]) {
                this.set(att, map[att], silent);
            }
        }
    },

    set: function(key, value, silent) {
        var el = this.get('element');
        if (!el) {
            this._queue[this._queue.length] = ['set', arguments];
            if (this._configs[key]) {
                this._configs[key].value = value; // so "get" works while queueing

            }
            return;
        }

        if ( !this._configs[key] && !YAHOO.lang.isUndefined(el[key]) ) {
            this._setHTMLAttrConfig(key);
        }

        return AttributeProvider.prototype.set.apply(this, arguments);
    },

    setAttributeConfig: function(key, map, init) {
        this._configOrder.push(key);
        AttributeProvider.prototype.setAttributeConfig.apply(this, arguments);
    },

    createEvent: function(type, config) {
        this._events[type] = true;
        return AttributeProvider.prototype.createEvent.apply(this, arguments);
    },

    init: function(el, attr) {
        this._initElement(el, attr);
    },

    destroy: function() {
        var el = this.get('element');
        YAHOO.util.Event.purgeElement(el, true); // purge DOM listeners recursively
        this.unsubscribeAll(); // unsubscribe all custom events

        if (el && el.parentNode) {
            el.parentNode.removeChild(el); // pull from the DOM
        }

        this._queue = [];
        this._events = {};
        this._configs = {};
        this._configOrder = [];
    },

    _initElement: function(el, attr) {
        this._queue = this._queue || [];
        this._events = this._events || {};
        this._configs = this._configs || {};
        this._configOrder = [];
        attr = attr || {};
        attr.element = attr.element || el || null;

        var isReady = false;  // to determine when to init HTMLElement and content

        var DOM_EVENTS = Element.DOM_EVENTS;
        this.DOM_EVENTS = this.DOM_EVENTS || {};

        for (var event in DOM_EVENTS) {
            if (DOM_EVENTS.hasOwnProperty(event)) {
                this.DOM_EVENTS[event] = DOM_EVENTS[event];
            }
        }

        if (typeof attr.element === 'string') { // register ID for get() access
            this._setHTMLAttrConfig('id', { value: attr.element });
        }

        if (Dom.get(attr.element)) {
            isReady = true;
            this._initHTMLElement(attr);
            this._initContent(attr);
        }

        YAHOO.util.Event.onAvailable(attr.element, function() {
            if (!isReady) { // otherwise already done
                this._initHTMLElement(attr);
            }

            this.fireEvent('available', { type: 'available', target: Dom.get(attr.element) });
        }, this, true);

        YAHOO.util.Event.onContentReady(attr.element, function() {
            if (!isReady) { // otherwise already done
                this._initContent(attr);
            }
            this.fireEvent('contentReady', { type: 'contentReady', target: Dom.get(attr.element) });
        }, this, true);
    },

    _initHTMLElement: function(attr) {
        /**
         * The HTMLElement the Element instance refers to.
         * @attribute element
         * @type HTMLElement
         */
        this.setAttributeConfig('element', {
            value: Dom.get(attr.element),
            readOnly: true
         });
    },

    _initContent: function(attr) {
        this.initAttributes(attr);
        this.setAttributes(attr, true);
        this.fireQueue();

    },

    /**
     * Sets the value of the property and fires beforeChange and change events.
     * @private
     * @method _setHTMLAttrConfig
     * @param {YAHOO.util.Element} element The Element instance to
     * register the config to.
     * @param {String} key The name of the config to register
     * @param {Object} map A key-value map of the config's params
     */
    _setHTMLAttrConfig: function(key, map) {
        var el = this.get('element');
        map = map || {};
        map.name = key;

        map.setter = map.setter || this.DEFAULT_HTML_SETTER;
        map.getter = map.getter || this.DEFAULT_HTML_GETTER;

        map.value = map.value || el[key];
        this._configs[key] = new YAHOO.util.Attribute(map, this);
    }
};

/**
 * Fires when the Element's HTMLElement can be retrieved by Id.
 * <p>See: <a href="#addListener">Element.addListener</a></p>
 * <p><strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> available<br>
 * <code>&lt;HTMLElement&gt;
 * target</code> the HTMLElement bound to this Element instance<br>
 * <p><strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('available', handler);</code></p>
 * @event available
 */

/**
 * Fires when the Element's HTMLElement subtree is rendered.
 * <p>See: <a href="#addListener">Element.addListener</a></p>
 * <p><strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> contentReady<br>
 * <code>&lt;HTMLElement&gt;
 * target</code> the HTMLElement bound to this Element instance<br>
 * <p><strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('contentReady', handler);</code></p>
 * @event contentReady
 */

/**
 * Fires before the Element is appended to another Element.
 * <p>See: <a href="#addListener">Element.addListener</a></p>
 * <p><strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> beforeAppendTo<br>
 * <code>&lt;HTMLElement/Element&gt;
 * target</code> the HTMLElement/Element being appended to
 * <p><strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('beforeAppendTo', handler);</code></p>
 * @event beforeAppendTo
 */

/**
 * Fires after the Element is appended to another Element.
 * <p>See: <a href="#addListener">Element.addListener</a></p>
 * <p><strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> appendTo<br>
 * <code>&lt;HTMLElement/Element&gt;
 * target</code> the HTMLElement/Element being appended to
 * <p><strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('appendTo', handler);</code></p>
 * @event appendTo
 */

YAHOO.augment(Element, AttributeProvider);
YAHOO.util.Element = Element;
})();

YAHOO.register("element", YAHOO.util.Element, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/


/**
* @module menu
* @description <p>The Menu family of components features a collection of
* controls that make it easy to add menus to your website or web application.
* With the Menu Controls you can create website fly-out menus, customized
* context menus, or application-style menu bars with just a small amount of
* scripting.</p><p>The Menu family of controls features:</p>
* <ul>
*    <li>Keyboard and mouse navigation.</li>
*    <li>A rich event model that provides access to all of a menu's
*    interesting moments.</li>
*    <li>Support for
*    <a href="http://en.wikipedia.org/wiki/Progressive_Enhancement">Progressive
*    Enhancement</a>; Menus can be created from simple,
*    semantic markup on the page or purely through JavaScript.</li>
* </ul>
* @title Menu
* @namespace YAHOO.widget
* @requires Event, Dom, Container
*/
(function () {

    var UA = YAHOO.env.ua,
		Dom = YAHOO.util.Dom,
	    Event = YAHOO.util.Event,
	    Lang = YAHOO.lang,

		_DIV = "DIV",
    	_HD = "hd",
    	_BD = "bd",
    	_FT = "ft",
    	_LI = "LI",
    	_DISABLED = "disabled",
		_MOUSEOVER = "mouseover",
		_MOUSEOUT = "mouseout",
		_MOUSEDOWN = "mousedown",
		_MOUSEUP = "mouseup",
		_CLICK = "click",
		_KEYDOWN = "keydown",
		_KEYUP = "keyup",
		_KEYPRESS = "keypress",
		_CLICK_TO_HIDE = "clicktohide",
		_POSITION = "position",
		_DYNAMIC = "dynamic",
		_SHOW_DELAY = "showdelay",
		_SELECTED = "selected",
		_VISIBLE = "visible",
		_UL = "UL",
		_MENUMANAGER = "MenuManager";


    /**
    * Singleton that manages a collection of all menus and menu items.  Listens
    * for DOM events at the document level and dispatches the events to the
    * corresponding menu or menu item.
    *
    * @namespace YAHOO.widget
    * @class MenuManager
    * @static
    */
    YAHOO.widget.MenuManager = function () {




        var m_bInitializedEventHandlers = false,



        m_oMenus = {},



        m_oVisibleMenus = {},



        m_oItems = {},



        m_oEventTypes = {
            "click": "clickEvent",
            "mousedown": "mouseDownEvent",
            "mouseup": "mouseUpEvent",
            "mouseover": "mouseOverEvent",
            "mouseout": "mouseOutEvent",
            "keydown": "keyDownEvent",
            "keyup": "keyUpEvent",
            "keypress": "keyPressEvent",
            "focus": "focusEvent",
            "focusin": "focusEvent",
            "blur": "blurEvent",
            "focusout": "blurEvent"
        },


        m_oFocusedMenuItem = null;





        /**
        * @method getMenuRootElement
        * @description Finds the root DIV node of a menu or the root LI node of
        * a menu item.
        * @private
        * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-58190037">HTMLElement</a>} p_oElement Object
        * specifying an HTML element.
        */
        function getMenuRootElement(p_oElement) {

            var oParentNode,
            	returnVal;

            if (p_oElement && p_oElement.tagName) {

                switch (p_oElement.tagName.toUpperCase()) {

                case _DIV:

                    oParentNode = p_oElement.parentNode;


                    if ((
                            Dom.hasClass(p_oElement, _HD) ||
                            Dom.hasClass(p_oElement, _BD) ||
                            Dom.hasClass(p_oElement, _FT)
                        ) &&
                        oParentNode &&
                        oParentNode.tagName &&
                        oParentNode.tagName.toUpperCase() == _DIV) {

                        returnVal = oParentNode;

                    }
                    else {

                        returnVal = p_oElement;

                    }

                    break;

                case _LI:

                    returnVal = p_oElement;

                    break;

                default:

                    oParentNode = p_oElement.parentNode;

                    if (oParentNode) {

                        returnVal = getMenuRootElement(oParentNode);

                    }

                    break;

                }

            }

            return returnVal;

        }





        /**
        * @method onDOMEvent
        * @description Generic, global event handler for all of a menu's
        * DOM-based events.  This listens for events against the document
        * object.  If the target of a given event is a member of a menu or
        * menu item's DOM, the instance's corresponding Custom Event is fired.
        * @private
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        function onDOMEvent(p_oEvent) {


            var oTarget = Event.getTarget(p_oEvent),


            oElement = getMenuRootElement(oTarget),
			bFireEvent = true,
			sEventType = p_oEvent.type,
            sCustomEventType,
            sTagName,
            sId,
            oMenuItem,
            oMenu;


            if (oElement) {

                sTagName = oElement.tagName.toUpperCase();

                if (sTagName == _LI) {

                    sId = oElement.id;

                    if (sId && m_oItems[sId]) {

                        oMenuItem = m_oItems[sId];
                        oMenu = oMenuItem.parent;

                    }

                }
                else if (sTagName == _DIV) {

                    if (oElement.id) {

                        oMenu = m_oMenus[oElement.id];

                    }

                }

            }


            if (oMenu) {

                sCustomEventType = m_oEventTypes[sEventType];

				/*
					There is an inconsistency between Firefox for Mac OS X and
					Firefox Windows & Linux regarding the triggering of the
					display of the browser's context menu and the subsequent
					firing of the "click" event. In Firefox for Windows & Linux,
					when the user triggers the display of the browser's context
					menu the "click" event also fires for the document object,
					even though the "click" event did not fire for the element
					that was the original target of the "contextmenu" event.
					This is unique to Firefox on Windows & Linux.  For all
					other A-Grade browsers, including Firefox for Mac OS X, the
					"click" event doesn't fire for the document object.

					This bug in Firefox for Windows affects Menu, as Menu
					instances listen for events at the document level and
					dispatches Custom Events of the same name.  Therefore users
					of Menu will get an unwanted firing of the "click"
					custom event.  The following line fixes this bug.
				*/



				if (sEventType == "click" &&
					(UA.gecko && oMenu.platform != "mac") &&
					p_oEvent.button > 0) {

					bFireEvent = false;

				}


                if (bFireEvent && oMenuItem && !oMenuItem.cfg.getProperty(_DISABLED)) {
                    oMenuItem[sCustomEventType].fire(p_oEvent);
                }

				if (bFireEvent) {
                	oMenu[sCustomEventType].fire(p_oEvent, oMenuItem);
				}

            }
            else if (sEventType == _MOUSEDOWN) {

                /*
                    If the target of the event wasn't a menu, hide all
                    dynamically positioned menus
                */

                for (var i in m_oVisibleMenus) {

                    if (Lang.hasOwnProperty(m_oVisibleMenus, i)) {

                        oMenu = m_oVisibleMenus[i];

                        if (oMenu.cfg.getProperty(_CLICK_TO_HIDE) &&
                            !(oMenu instanceof YAHOO.widget.MenuBar) &&
                            oMenu.cfg.getProperty(_POSITION) == _DYNAMIC) {

                            oMenu.hide();


							if (UA.ie && oTarget.focus) {
								oTarget.setActive();
							}

                        }
                        else {

							if (oMenu.cfg.getProperty(_SHOW_DELAY) > 0) {

								oMenu._cancelShowDelay();

							}


							if (oMenu.activeItem) {

								oMenu.activeItem.blur();
								oMenu.activeItem.cfg.setProperty(_SELECTED, false);

								oMenu.activeItem = null;

							}

                        }

                    }

                }

            }

        }


        /**
        * @method onMenuDestroy
        * @description "destroy" event handler for a menu.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        * @param {YAHOO.widget.Menu} p_oMenu The menu that fired the event.
        */
        function onMenuDestroy(p_sType, p_aArgs, p_oMenu) {

            if (m_oMenus[p_oMenu.id]) {

                this.removeMenu(p_oMenu);

            }

        }


        /**
        * @method onMenuFocus
        * @description "focus" event handler for a MenuItem instance.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        function onMenuFocus(p_sType, p_aArgs) {

            var oItem = p_aArgs[1];

            if (oItem) {

                m_oFocusedMenuItem = oItem;

            }

        }


        /**
        * @method onMenuBlur
        * @description "blur" event handler for a MenuItem instance.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        function onMenuBlur(p_sType, p_aArgs) {

            m_oFocusedMenuItem = null;

        }


        /**
        * @method onMenuVisibleConfigChange
        * @description Event handler for when the "visible" configuration
        * property of a Menu instance changes.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        function onMenuVisibleConfigChange(p_sType, p_aArgs) {

            var bVisible = p_aArgs[0],
                sId = this.id;

            if (bVisible) {

                m_oVisibleMenus[sId] = this;


            }
            else if (m_oVisibleMenus[sId]) {

                delete m_oVisibleMenus[sId];


            }

        }


        /**
        * @method onItemDestroy
        * @description "destroy" event handler for a MenuItem instance.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        function onItemDestroy(p_sType, p_aArgs) {

            removeItem(this);

        }


        /**
        * @method removeItem
        * @description Removes a MenuItem instance from the MenuManager's collection of MenuItems.
        * @private
        * @param {MenuItem} p_oMenuItem The MenuItem instance to be removed.
        */
        function removeItem(p_oMenuItem) {

            var sId = p_oMenuItem.id;

            if (sId && m_oItems[sId]) {

                if (m_oFocusedMenuItem == p_oMenuItem) {

                    m_oFocusedMenuItem = null;

                }

                delete m_oItems[sId];

                p_oMenuItem.destroyEvent.unsubscribe(onItemDestroy);


            }

        }


        /**
        * @method onItemAdded
        * @description "itemadded" event handler for a Menu instance.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        function onItemAdded(p_sType, p_aArgs) {

            var oItem = p_aArgs[0],
                sId;

            if (oItem instanceof YAHOO.widget.MenuItem) {

                sId = oItem.id;

                if (!m_oItems[sId]) {

                    m_oItems[sId] = oItem;

                    oItem.destroyEvent.subscribe(onItemDestroy);


                }

            }

        }


        return {



            /**
            * @method addMenu
            * @description Adds a menu to the collection of known menus.
            * @param {YAHOO.widget.Menu} p_oMenu Object specifying the Menu
            * instance to be added.
            */
            addMenu: function (p_oMenu) {

                var oDoc;

                if (p_oMenu instanceof YAHOO.widget.Menu && p_oMenu.id &&
                    !m_oMenus[p_oMenu.id]) {

                    m_oMenus[p_oMenu.id] = p_oMenu;


                    if (!m_bInitializedEventHandlers) {

                        oDoc = document;

                        Event.on(oDoc, _MOUSEOVER, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEOUT, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEDOWN, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEUP, onDOMEvent, this, true);
                        Event.on(oDoc, _CLICK, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYDOWN, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYUP, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYPRESS, onDOMEvent, this, true);

						Event.onFocus(oDoc, onDOMEvent, this, true);
						Event.onBlur(oDoc, onDOMEvent, this, true);

                        m_bInitializedEventHandlers = true;


                    }

                    p_oMenu.cfg.subscribeToConfigEvent(_VISIBLE, onMenuVisibleConfigChange);
                    p_oMenu.destroyEvent.subscribe(onMenuDestroy, p_oMenu, this);
                    p_oMenu.itemAddedEvent.subscribe(onItemAdded);
                    p_oMenu.focusEvent.subscribe(onMenuFocus);
                    p_oMenu.blurEvent.subscribe(onMenuBlur);


                }

            },


            /**
            * @method removeMenu
            * @description Removes a menu from the collection of known menus.
            * @param {YAHOO.widget.Menu} p_oMenu Object specifying the Menu
            * instance to be removed.
            */
            removeMenu: function (p_oMenu) {

                var sId,
                    aItems,
                    i;

                if (p_oMenu) {

                    sId = p_oMenu.id;

                    if ((sId in m_oMenus) && (m_oMenus[sId] == p_oMenu)) {


                        aItems = p_oMenu.getItems();

                        if (aItems && aItems.length > 0) {

                            i = aItems.length - 1;

                            do {

                                removeItem(aItems[i]);

                            }
                            while (i--);

                        }



                        delete m_oMenus[sId];



                        /*
                             Unregister the menu from the collection of
                             visible menus
                        */

                        if ((sId in m_oVisibleMenus) && (m_oVisibleMenus[sId] == p_oMenu)) {

                            delete m_oVisibleMenus[sId];


                        }



                        if (p_oMenu.cfg) {

                            p_oMenu.cfg.unsubscribeFromConfigEvent(_VISIBLE,
                                onMenuVisibleConfigChange);

                        }

                        p_oMenu.destroyEvent.unsubscribe(onMenuDestroy,
                            p_oMenu);

                        p_oMenu.itemAddedEvent.unsubscribe(onItemAdded);
                        p_oMenu.focusEvent.unsubscribe(onMenuFocus);
                        p_oMenu.blurEvent.unsubscribe(onMenuBlur);

                    }

                }

            },


            /**
            * @method hideVisible
            * @description Hides all visible, dynamically positioned menus
            * (excluding instances of YAHOO.widget.MenuBar).
            */
            hideVisible: function () {

                var oMenu;

                for (var i in m_oVisibleMenus) {

                    if (Lang.hasOwnProperty(m_oVisibleMenus, i)) {

                        oMenu = m_oVisibleMenus[i];

                        if (!(oMenu instanceof YAHOO.widget.MenuBar) &&
                            oMenu.cfg.getProperty(_POSITION) == _DYNAMIC) {

                            oMenu.hide();

                        }

                    }

                }

            },


            /**
            * @method getVisible
            * @description Returns a collection of all visible menus registered
            * with the menu manger.
            * @return {Object}
            */
            getVisible: function () {

                return m_oVisibleMenus;

            },


            /**
            * @method getMenus
            * @description Returns a collection of all menus registered with the
            * menu manger.
            * @return {Object}
            */
            getMenus: function () {

                return m_oMenus;

            },


            /**
            * @method getMenu
            * @description Returns a menu with the specified id.
            * @param {String} p_sId String specifying the id of the
            * <code>&#60;div&#62;</code> element representing the menu to
            * be retrieved.
            * @return {YAHOO.widget.Menu}
            */
            getMenu: function (p_sId) {

                var returnVal;

                if (p_sId in m_oMenus) {

					returnVal = m_oMenus[p_sId];

				}

            	return returnVal;

            },


            /**
            * @method getMenuItem
            * @description Returns a menu item with the specified id.
            * @param {String} p_sId String specifying the id of the
            * <code>&#60;li&#62;</code> element representing the menu item to
            * be retrieved.
            * @return {YAHOO.widget.MenuItem}
            */
            getMenuItem: function (p_sId) {

    			var returnVal;

    			if (p_sId in m_oItems) {

					returnVal = m_oItems[p_sId];

				}

				return returnVal;

            },


            /**
            * @method getMenuItemGroup
            * @description Returns an array of menu item instances whose
            * corresponding <code>&#60;li&#62;</code> elements are child
            * nodes of the <code>&#60;ul&#62;</code> element with the
            * specified id.
            * @param {String} p_sId String specifying the id of the
            * <code>&#60;ul&#62;</code> element representing the group of
            * menu items to be retrieved.
            * @return {Array}
            */
            getMenuItemGroup: function (p_sId) {

                var oUL = Dom.get(p_sId),
                    aItems,
                    oNode,
                    oItem,
                    sId,
                    returnVal;


                if (oUL && oUL.tagName && oUL.tagName.toUpperCase() == _UL) {

                    oNode = oUL.firstChild;

                    if (oNode) {

                        aItems = [];

                        do {

                            sId = oNode.id;

                            if (sId) {

                                oItem = this.getMenuItem(sId);

                                if (oItem) {

                                    aItems[aItems.length] = oItem;

                                }

                            }

                        }
                        while ((oNode = oNode.nextSibling));


                        if (aItems.length > 0) {

                            returnVal = aItems;

                        }

                    }

                }

				return returnVal;

            },


            /**
            * @method getFocusedMenuItem
            * @description Returns a reference to the menu item that currently
            * has focus.
            * @return {YAHOO.widget.MenuItem}
            */
            getFocusedMenuItem: function () {

                return m_oFocusedMenuItem;

            },


            /**
            * @method getFocusedMenu
            * @description Returns a reference to the menu that currently
            * has focus.
            * @return {YAHOO.widget.Menu}
            */
            getFocusedMenu: function () {

				var returnVal;

                if (m_oFocusedMenuItem) {

                    returnVal = m_oFocusedMenuItem.parent.getRoot();

                }

    			return returnVal;

            },


            /**
            * @method toString
            * @description Returns a string representing the menu manager.
            * @return {String}
            */
            toString: function () {

                return _MENUMANAGER;

            }

        };

    }();

})();



(function () {

	var Lang = YAHOO.lang,


		_MENU = "Menu",
		_DIV_UPPERCASE = "DIV",
		_DIV_LOWERCASE = "div",
		_ID = "id",
		_SELECT = "SELECT",
		_XY = "xy",
		_Y = "y",
		_UL_UPPERCASE = "UL",
		_UL_LOWERCASE = "ul",
		_FIRST_OF_TYPE = "first-of-type",
		_LI = "LI",
		_OPTGROUP = "OPTGROUP",
		_OPTION = "OPTION",
		_DISABLED = "disabled",
		_NONE = "none",
		_SELECTED = "selected",
		_GROUP_INDEX = "groupindex",
		_INDEX = "index",
		_SUBMENU = "submenu",
		_VISIBLE = "visible",
		_HIDE_DELAY = "hidedelay",
		_POSITION = "position",
		_DYNAMIC = "dynamic",
		_STATIC = "static",
		_DYNAMIC_STATIC = _DYNAMIC + "," + _STATIC,
		_URL = "url",
		_HASH = "#",
		_TARGET = "target",
		_MAX_HEIGHT = "maxheight",
        _TOP_SCROLLBAR = "topscrollbar",
        _BOTTOM_SCROLLBAR = "bottomscrollbar",
        _UNDERSCORE = "_",
		_TOP_SCROLLBAR_DISABLED = _TOP_SCROLLBAR + _UNDERSCORE + _DISABLED,
		_BOTTOM_SCROLLBAR_DISABLED = _BOTTOM_SCROLLBAR + _UNDERSCORE + _DISABLED,
		_MOUSEMOVE = "mousemove",
		_SHOW_DELAY = "showdelay",
		_SUBMENU_HIDE_DELAY = "submenuhidedelay",
		_IFRAME = "iframe",
		_CONSTRAIN_TO_VIEWPORT = "constraintoviewport",
		_PREVENT_CONTEXT_OVERLAP = "preventcontextoverlap",
		_SUBMENU_ALIGNMENT = "submenualignment",
		_AUTO_SUBMENU_DISPLAY = "autosubmenudisplay",
		_CLICK_TO_HIDE = "clicktohide",
		_CONTAINER = "container",
		_SCROLL_INCREMENT = "scrollincrement",
		_MIN_SCROLL_HEIGHT = "minscrollheight",
		_CLASSNAME = "classname",
		_SHADOW = "shadow",
		_KEEP_OPEN = "keepopen",
		_HD = "hd",
		_HAS_TITLE = "hastitle",
		_CONTEXT = "context",
		_EMPTY_STRING = "",
		_MOUSEDOWN = "mousedown",
		_KEYDOWN = "keydown",
		_HEIGHT = "height",
		_WIDTH = "width",
		_PX = "px",
		_EFFECT = "effect",
		_MONITOR_RESIZE = "monitorresize",
		_DISPLAY = "display",
		_BLOCK = "block",
		_VISIBILITY = "visibility",
		_ABSOLUTE = "absolute",
		_ZINDEX = "zindex",
		_YUI_MENU_BODY_SCROLLED = "yui-menu-body-scrolled",
		_NON_BREAKING_SPACE = "&#32;",
		_SPACE = " ",
		_MOUSEOVER = "mouseover",
		_MOUSEOUT = "mouseout",
        _ITEM_ADDED = "itemAdded",
        _ITEM_REMOVED = "itemRemoved",
        _HIDDEN = "hidden",
        _YUI_MENU_SHADOW = "yui-menu-shadow",
        _YUI_MENU_SHADOW_VISIBLE = _YUI_MENU_SHADOW + "-visible",
        _YUI_MENU_SHADOW_YUI_MENU_SHADOW_VISIBLE = _YUI_MENU_SHADOW + _SPACE + _YUI_MENU_SHADOW_VISIBLE;


/**
* The Menu class creates a container that holds a vertical list representing
* a set of options or commands.  Menu is the base class for all
* menu containers.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the menu.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source
* for the menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
* level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
* specifying the <code>&#60;div&#62;</code> element of the menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
* level-one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement
* Object specifying the <code>&#60;select&#62;</code> element to be used as
* the data source for the menu.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu. See configuration class documentation for
* more details.
* @namespace YAHOO.widget
* @class Menu
* @constructor
* @extends YAHOO.widget.Overlay
*/
YAHOO.widget.Menu = function (p_oElement, p_oConfig) {

    if (p_oConfig) {

        this.parent = p_oConfig.parent;
        this.lazyLoad = p_oConfig.lazyLoad || p_oConfig.lazyload;
        this.itemData = p_oConfig.itemData || p_oConfig.itemdata;

    }


    YAHOO.widget.Menu.superclass.constructor.call(this, p_oElement, p_oConfig);

};



/**
* @method checkPosition
* @description Checks to make sure that the value of the "position" property
* is one of the supported strings. Returns true if the position is supported.
* @private
* @param {Object} p_sPosition String specifying the position of the menu.
* @return {Boolean}
*/
function checkPosition(p_sPosition) {

	var returnVal = false;

    if (Lang.isString(p_sPosition)) {

        returnVal = (_DYNAMIC_STATIC.indexOf((p_sPosition.toLowerCase())) != -1);

    }

	return returnVal;

}


var Dom = YAHOO.util.Dom,
    Event = YAHOO.util.Event,
    Module = YAHOO.widget.Module,
    Overlay = YAHOO.widget.Overlay,
    Menu = YAHOO.widget.Menu,
    MenuManager = YAHOO.widget.MenuManager,
    CustomEvent = YAHOO.util.CustomEvent,
    UA = YAHOO.env.ua,

    m_oShadowTemplate,

	bFocusListenerInitialized = false,

	oFocusedElement,

	EVENT_TYPES = [

		["mouseOverEvent", _MOUSEOVER],
		["mouseOutEvent", _MOUSEOUT],
		["mouseDownEvent", _MOUSEDOWN],
		["mouseUpEvent", "mouseup"],
		["clickEvent", "click"],
		["keyPressEvent", "keypress"],
		["keyDownEvent", _KEYDOWN],
		["keyUpEvent", "keyup"],
		["focusEvent", "focus"],
		["blurEvent", "blur"],
		["itemAddedEvent", _ITEM_ADDED],
		["itemRemovedEvent", _ITEM_REMOVED]

	],

	VISIBLE_CONFIG =  {
		key: _VISIBLE,
		value: false,
		validator: Lang.isBoolean
	},

	CONSTRAIN_TO_VIEWPORT_CONFIG =  {
		key: _CONSTRAIN_TO_VIEWPORT,
		value: true,
		validator: Lang.isBoolean,
		supercedes: [_IFRAME,"x",_Y,_XY]
	},

	PREVENT_CONTEXT_OVERLAP_CONFIG =  {
		key: _PREVENT_CONTEXT_OVERLAP,
		value: true,
		validator: Lang.isBoolean,
		supercedes: [_CONSTRAIN_TO_VIEWPORT]
	},

	POSITION_CONFIG =  {
		key: _POSITION,
		value: _DYNAMIC,
		validator: checkPosition,
		supercedes: [_VISIBLE, _IFRAME]
	},

	SUBMENU_ALIGNMENT_CONFIG =  {
		key: _SUBMENU_ALIGNMENT,
		value: ["tl","tr"]
	},

	AUTO_SUBMENU_DISPLAY_CONFIG =  {
		key: _AUTO_SUBMENU_DISPLAY,
		value: true,
		validator: Lang.isBoolean,
		suppressEvent: true
	},

	SHOW_DELAY_CONFIG =  {
		key: _SHOW_DELAY,
		value: 250,
		validator: Lang.isNumber,
		suppressEvent: true
	},

	HIDE_DELAY_CONFIG =  {
		key: _HIDE_DELAY,
		value: 0,
		validator: Lang.isNumber,
		suppressEvent: true
	},

	SUBMENU_HIDE_DELAY_CONFIG =  {
		key: _SUBMENU_HIDE_DELAY,
		value: 250,
		validator: Lang.isNumber,
		suppressEvent: true
	},

	CLICK_TO_HIDE_CONFIG =  {
		key: _CLICK_TO_HIDE,
		value: true,
		validator: Lang.isBoolean,
		suppressEvent: true
	},

	CONTAINER_CONFIG =  {
		key: _CONTAINER,
		suppressEvent: true
	},

	SCROLL_INCREMENT_CONFIG =  {
		key: _SCROLL_INCREMENT,
		value: 1,
		validator: Lang.isNumber,
		supercedes: [_MAX_HEIGHT],
		suppressEvent: true
	},

	MIN_SCROLL_HEIGHT_CONFIG =  {
		key: _MIN_SCROLL_HEIGHT,
		value: 90,
		validator: Lang.isNumber,
		supercedes: [_MAX_HEIGHT],
		suppressEvent: true
	},

	MAX_HEIGHT_CONFIG =  {
		key: _MAX_HEIGHT,
		value: 0,
		validator: Lang.isNumber,
		supercedes: [_IFRAME],
		suppressEvent: true
	},

	CLASS_NAME_CONFIG =  {
		key: _CLASSNAME,
		value: null,
		validator: Lang.isString,
		suppressEvent: true
	},

	DISABLED_CONFIG =  {
		key: _DISABLED,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true
	},

	SHADOW_CONFIG =  {
		key: _SHADOW,
		value: true,
		validator: Lang.isBoolean,
		suppressEvent: true,
		supercedes: [_VISIBLE]
	},

	KEEP_OPEN_CONFIG = {
		key: _KEEP_OPEN,
		value: false,
		validator: Lang.isBoolean
	};


function onDocFocus(event) {

	oFocusedElement = Event.getTarget(event);

}



YAHOO.lang.extend(Menu, Overlay, {




/**
* @property CSS_CLASS_NAME
* @description String representing the CSS class(es) to be applied to the
* menu's <code>&#60;div&#62;</code> element.
* @default "yuimenu"
* @final
* @type String
*/
CSS_CLASS_NAME: "yuimenu",


/**
* @property ITEM_TYPE
* @description Object representing the type of menu item to instantiate and
* add when parsing the child nodes (either <code>&#60;li&#62;</code> element,
* <code>&#60;optgroup&#62;</code> element or <code>&#60;option&#62;</code>)
* of the menu's source HTML element.
* @default YAHOO.widget.MenuItem
* @final
* @type YAHOO.widget.MenuItem
*/
ITEM_TYPE: null,


/**
* @property GROUP_TITLE_TAG_NAME
* @description String representing the tagname of the HTML element used to
* title the menu's item groups.
* @default H6
* @final
* @type String
*/
GROUP_TITLE_TAG_NAME: "h6",


/**
* @property OFF_SCREEN_POSITION
* @description Array representing the default x and y position that a menu
* should have when it is positioned outside the viewport by the
* "poistionOffScreen" method.
* @default "-999em"
* @final
* @type String
*/
OFF_SCREEN_POSITION: "-999em",




/**
* @property _useHideDelay
* @description Boolean indicating if the "mouseover" and "mouseout" event
* handlers used for hiding the menu via a call to "YAHOO.lang.later" have
* already been assigned.
* @default false
* @private
* @type Boolean
*/
_useHideDelay: false,


/**
* @property _bHandledMouseOverEvent
* @description Boolean indicating the current state of the menu's
* "mouseover" event.
* @default false
* @private
* @type Boolean
*/
_bHandledMouseOverEvent: false,


/**
* @property _bHandledMouseOutEvent
* @description Boolean indicating the current state of the menu's
* "mouseout" event.
* @default false
* @private
* @type Boolean
*/
_bHandledMouseOutEvent: false,


/**
* @property _aGroupTitleElements
* @description Array of HTML element used to title groups of menu items.
* @default []
* @private
* @type Array
*/
_aGroupTitleElements: null,


/**
* @property _aItemGroups
* @description Multi-dimensional Array representing the menu items as they
* are grouped in the menu.
* @default []
* @private
* @type Array
*/
_aItemGroups: null,


/**
* @property _aListElements
* @description Array of <code>&#60;ul&#62;</code> elements, each of which is
* the parent node for each item's <code>&#60;li&#62;</code> element.
* @default []
* @private
* @type Array
*/
_aListElements: null,


/**
* @property _nCurrentMouseX
* @description The current x coordinate of the mouse inside the area of
* the menu.
* @default 0
* @private
* @type Number
*/
_nCurrentMouseX: 0,


/**
* @property _bStopMouseEventHandlers
* @description Stops "mouseover," "mouseout," and "mousemove" event handlers
* from executing.
* @default false
* @private
* @type Boolean
*/
_bStopMouseEventHandlers: false,


/**
* @property _sClassName
* @description The current value of the "classname" configuration attribute.
* @default null
* @private
* @type String
*/
_sClassName: null,





/**
* @property lazyLoad
* @description Boolean indicating if the menu's "lazy load" feature is
* enabled.  If set to "true," initialization and rendering of the menu's
* items will be deferred until the first time it is made visible.  This
* property should be set via the constructor using the configuration
* object literal.
* @default false
* @type Boolean
*/
lazyLoad: false,


/**
* @property itemData
* @description Array of items to be added to the menu.  The array can contain
* strings representing the text for each item to be created, object literals
* representing the menu item configuration properties, or MenuItem instances.
* This property should be set via the constructor using the configuration
* object literal.
* @default null
* @type Array
*/
itemData: null,


/**
* @property activeItem
* @description Object reference to the item in the menu that has is selected.
* @default null
* @type YAHOO.widget.MenuItem
*/
activeItem: null,


/**
* @property parent
* @description Object reference to the menu's parent menu or menu item.
* This property can be set via the constructor using the configuration
* object literal.
* @default null
* @type YAHOO.widget.MenuItem
*/
parent: null,


/**
* @property srcElement
* @description Object reference to the HTML element (either
* <code>&#60;select&#62;</code> or <code>&#60;div&#62;</code>) used to
* create the menu.
* @default null
* @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
* level-one-html.html#ID-94282980">HTMLSelectElement</a>|<a
* href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.
* html#ID-22445964">HTMLDivElement</a>
*/
srcElement: null,





/**
* @event mouseOverEvent
* @description Fires when the mouse has entered the menu.  Passes back
* the DOM Event object as an argument.
*/


/**
* @event mouseOutEvent
* @description Fires when the mouse has left the menu.  Passes back the DOM
* Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event mouseDownEvent
* @description Fires when the user mouses down on the menu.  Passes back the
* DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event mouseUpEvent
* @description Fires when the user releases a mouse button while the mouse is
* over the menu.  Passes back the DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event clickEvent
* @description Fires when the user clicks the on the menu.  Passes back the
* DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event keyPressEvent
* @description Fires when the user presses an alphanumeric key when one of the
* menu's items has focus.  Passes back the DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event keyDownEvent
* @description Fires when the user presses a key when one of the menu's items
* has focus.  Passes back the DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event keyUpEvent
* @description Fires when the user releases a key when one of the menu's items
* has focus.  Passes back the DOM Event object as an argument.
* @type YAHOO.util.CustomEvent
*/


/**
* @event itemAddedEvent
* @description Fires when an item is added to the menu.
* @type YAHOO.util.CustomEvent
*/


/**
* @event itemRemovedEvent
* @description Fires when an item is removed to the menu.
* @type YAHOO.util.CustomEvent
*/


/**
* @method init
* @description The Menu class's initialization method. This method is
* automatically called by the constructor, and sets up all DOM references
* for pre-existing markup, and creates required markup if it is not
* already present.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the menu.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source
* for the menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
* level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
* specifying the <code>&#60;div&#62;</code> element of the menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
* level-one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement
* Object specifying the <code>&#60;select&#62;</code> element to be used as
* the data source for the menu.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu. See configuration class documentation for
* more details.
*/
init: function (p_oElement, p_oConfig) {

    this._aItemGroups = [];
    this._aListElements = [];
    this._aGroupTitleElements = [];

    if (!this.ITEM_TYPE) {

        this.ITEM_TYPE = YAHOO.widget.MenuItem;

    }


    var oElement;

    if (Lang.isString(p_oElement)) {

        oElement = Dom.get(p_oElement);

    }
    else if (p_oElement.tagName) {

        oElement = p_oElement;

    }


    if (oElement && oElement.tagName) {

        switch(oElement.tagName.toUpperCase()) {

            case _DIV_UPPERCASE:

                this.srcElement = oElement;

                if (!oElement.id) {

                    oElement.setAttribute(_ID, Dom.generateId());

                }


                /*
                    Note: we don't pass the user config in here yet
                    because we only want it executed once, at the lowest
                    subclass level.
                */

                Menu.superclass.init.call(this, oElement);

                this.beforeInitEvent.fire(Menu);


            break;

            case _SELECT:

                this.srcElement = oElement;


                /*
                    The source element is not something that we can use
                    outright, so we need to create a new Overlay

                    Note: we don't pass the user config in here yet
                    because we only want it executed once, at the lowest
                    subclass level.
                */

                Menu.superclass.init.call(this, Dom.generateId());

                this.beforeInitEvent.fire(Menu);


            break;

        }

    }
    else {

        /*
            Note: we don't pass the user config in here yet
            because we only want it executed once, at the lowest
            subclass level.
        */

        Menu.superclass.init.call(this, p_oElement);

        this.beforeInitEvent.fire(Menu);


    }


    if (this.element) {

        Dom.addClass(this.element, this.CSS_CLASS_NAME);



        this.initEvent.subscribe(this._onInit);
        this.beforeRenderEvent.subscribe(this._onBeforeRender);
        this.renderEvent.subscribe(this._onRender);
        this.beforeShowEvent.subscribe(this._onBeforeShow);
		this.hideEvent.subscribe(this._onHide);
        this.showEvent.subscribe(this._onShow);
		this.beforeHideEvent.subscribe(this._onBeforeHide);
        this.mouseOverEvent.subscribe(this._onMouseOver);
        this.mouseOutEvent.subscribe(this._onMouseOut);
        this.clickEvent.subscribe(this._onClick);
        this.keyDownEvent.subscribe(this._onKeyDown);
        this.keyPressEvent.subscribe(this._onKeyPress);
        this.blurEvent.subscribe(this._onBlur);


		if (!bFocusListenerInitialized) {
			Event.onFocus(document, onDocFocus);
			bFocusListenerInitialized = true;
		}



        if ((UA.gecko && UA.gecko < 1.9) || UA.webkit) {

            this.cfg.subscribeToConfigEvent(_Y, this._onYChange);

        }


        if (p_oConfig) {

            this.cfg.applyConfig(p_oConfig, true);

        }



        MenuManager.addMenu(this);


        this.initEvent.fire(Menu);

    }

},





/**
* @method _initSubTree
* @description Iterates the childNodes of the source element to find nodes
* used to instantiate menu and menu items.
* @private
*/
_initSubTree: function () {

    var oSrcElement = this.srcElement,
        sSrcElementTagName,
        nGroup,
        sGroupTitleTagName,
        oNode,
        aListElements,
        nListElements,
        i;


    if (oSrcElement) {

        sSrcElementTagName =
            (oSrcElement.tagName && oSrcElement.tagName.toUpperCase());


        if (sSrcElementTagName == _DIV_UPPERCASE) {


            oNode = this.body.firstChild;


            if (oNode) {

                nGroup = 0;
                sGroupTitleTagName = this.GROUP_TITLE_TAG_NAME.toUpperCase();

                do {


                    if (oNode && oNode.tagName) {

                        switch (oNode.tagName.toUpperCase()) {

                            case sGroupTitleTagName:

                                this._aGroupTitleElements[nGroup] = oNode;

                            break;

                            case _UL_UPPERCASE:

                                this._aListElements[nGroup] = oNode;
                                this._aItemGroups[nGroup] = [];
                                nGroup++;

                            break;

                        }

                    }

                }
                while ((oNode = oNode.nextSibling));


                /*
                    Apply the "first-of-type" class to the first UL to mimic
                    the ":first-of-type" CSS3 psuedo class.
                */

                if (this._aListElements[0]) {

                    Dom.addClass(this._aListElements[0], _FIRST_OF_TYPE);

                }

            }

        }


        oNode = null;



        if (sSrcElementTagName) {

            switch (sSrcElementTagName) {

                case _DIV_UPPERCASE:

                    aListElements = this._aListElements;
                    nListElements = aListElements.length;

                    if (nListElements > 0) {


                        i = nListElements - 1;

                        do {

                            oNode = aListElements[i].firstChild;

                            if (oNode) {


                                do {

                                    if (oNode && oNode.tagName &&
                                        oNode.tagName.toUpperCase() == _LI) {


                                        this.addItem(new this.ITEM_TYPE(oNode,
                                                    { parent: this }), i);

                                    }

                                }
                                while ((oNode = oNode.nextSibling));

                            }

                        }
                        while (i--);

                    }

                break;

                case _SELECT:


                    oNode = oSrcElement.firstChild;

                    do {

                        if (oNode && oNode.tagName) {

                            switch (oNode.tagName.toUpperCase()) {

                                case _OPTGROUP:
                                case _OPTION:


                                    this.addItem(
                                            new this.ITEM_TYPE(
                                                    oNode,
                                                    { parent: this }
                                                )
                                            );

                                break;

                            }

                        }

                    }
                    while ((oNode = oNode.nextSibling));

                break;

            }

        }

    }

},


/**
* @method _getFirstEnabledItem
* @description Returns the first enabled item in the menu.
* @return {YAHOO.widget.MenuItem}
* @private
*/
_getFirstEnabledItem: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        oItem,
        returnVal;


    for(var i=0; i<nItems; i++) {

        oItem = aItems[i];

        if (oItem && !oItem.cfg.getProperty(_DISABLED) && oItem.element.style.display != _NONE) {

            returnVal = oItem;
            break;

        }

    }

    return returnVal;

},


/**
* @method _addItemToGroup
* @description Adds a menu item to a group.
* @private
* @param {Number} p_nGroupIndex Number indicating the group to which the
* item belongs.
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance to be added to the menu.
* @param {String} p_oItem String specifying the text of the item to be added
* to the menu.
* @param {Object} p_oItem Object literal containing a set of menu item
* configuration properties.
* @param {Number} p_nItemIndex Optional. Number indicating the index at
* which the menu item should be added.
* @return {YAHOO.widget.MenuItem}
*/
_addItemToGroup: function (p_nGroupIndex, p_oItem, p_nItemIndex) {

    var oItem,
        nGroupIndex,
        aGroup,
        oGroupItem,
        bAppend,
        oNextItemSibling,
        nItemIndex,
        returnVal;


    function getNextItemSibling(p_aArray, p_nStartIndex) {

        return (p_aArray[p_nStartIndex] || getNextItemSibling(p_aArray, (p_nStartIndex+1)));

    }


    if (p_oItem instanceof this.ITEM_TYPE) {

        oItem = p_oItem;
        oItem.parent = this;

    }
    else if (Lang.isString(p_oItem)) {

        oItem = new this.ITEM_TYPE(p_oItem, { parent: this });

    }
    else if (Lang.isObject(p_oItem)) {

        p_oItem.parent = this;

        oItem = new this.ITEM_TYPE(p_oItem.text, p_oItem);

    }


    if (oItem) {

        if (oItem.cfg.getProperty(_SELECTED)) {

            this.activeItem = oItem;

        }


        nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0;
        aGroup = this._getItemGroup(nGroupIndex);



        if (!aGroup) {

            aGroup = this._createItemGroup(nGroupIndex);

        }


        if (Lang.isNumber(p_nItemIndex)) {

            bAppend = (p_nItemIndex >= aGroup.length);


            if (aGroup[p_nItemIndex]) {

                aGroup.splice(p_nItemIndex, 0, oItem);

            }
            else {

                aGroup[p_nItemIndex] = oItem;

            }


            oGroupItem = aGroup[p_nItemIndex];

            if (oGroupItem) {

                if (bAppend && (!oGroupItem.element.parentNode ||
                        oGroupItem.element.parentNode.nodeType == 11)) {

                    this._aListElements[nGroupIndex].appendChild(oGroupItem.element);

                }
                else {

                    oNextItemSibling = getNextItemSibling(aGroup, (p_nItemIndex+1));

                    if (oNextItemSibling && (!oGroupItem.element.parentNode ||
                            oGroupItem.element.parentNode.nodeType == 11)) {

                        this._aListElements[nGroupIndex].insertBefore(
                                oGroupItem.element, oNextItemSibling.element);

                    }

                }


                oGroupItem.parent = this;

                this._subscribeToItemEvents(oGroupItem);

                this._configureSubmenu(oGroupItem);

                this._updateItemProperties(nGroupIndex);


                this.itemAddedEvent.fire(oGroupItem);
                this.changeContentEvent.fire();

                returnVal = oGroupItem;

            }

        }
        else {

            nItemIndex = aGroup.length;

            aGroup[nItemIndex] = oItem;

            oGroupItem = aGroup[nItemIndex];


            if (oGroupItem) {

                if (!Dom.isAncestor(this._aListElements[nGroupIndex], oGroupItem.element)) {

                    this._aListElements[nGroupIndex].appendChild(oGroupItem.element);

                }

                oGroupItem.element.setAttribute(_GROUP_INDEX, nGroupIndex);
                oGroupItem.element.setAttribute(_INDEX, nItemIndex);

                oGroupItem.parent = this;

                oGroupItem.index = nItemIndex;
                oGroupItem.groupIndex = nGroupIndex;

                this._subscribeToItemEvents(oGroupItem);

                this._configureSubmenu(oGroupItem);

                if (nItemIndex === 0) {

                    Dom.addClass(oGroupItem.element, _FIRST_OF_TYPE);

                }



                this.itemAddedEvent.fire(oGroupItem);
                this.changeContentEvent.fire();

                returnVal = oGroupItem;

            }

        }

    }

    return returnVal;

},


/**
* @method _removeItemFromGroupByIndex
* @description Removes a menu item from a group by index.  Returns the menu
* item that was removed.
* @private
* @param {Number} p_nGroupIndex Number indicating the group to which the menu
* item belongs.
* @param {Number} p_nItemIndex Number indicating the index of the menu item
* to be removed.
* @return {YAHOO.widget.MenuItem}
*/
_removeItemFromGroupByIndex: function (p_nGroupIndex, p_nItemIndex) {

    var nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0,
        aGroup = this._getItemGroup(nGroupIndex),
        aArray,
        oItem,
        oUL;

    if (aGroup) {

        aArray = aGroup.splice(p_nItemIndex, 1);
        oItem = aArray[0];

        if (oItem) {


            this._updateItemProperties(nGroupIndex);

            if (aGroup.length === 0) {


                oUL = this._aListElements[nGroupIndex];

                if (this.body && oUL) {

                    this.body.removeChild(oUL);

                }


                this._aItemGroups.splice(nGroupIndex, 1);



                this._aListElements.splice(nGroupIndex, 1);


                /*
                     Assign the "first-of-type" class to the new first UL
                     in the collection
                */

                oUL = this._aListElements[0];

                if (oUL) {

                    Dom.addClass(oUL, _FIRST_OF_TYPE);

                }

            }


            this.itemRemovedEvent.fire(oItem);
            this.changeContentEvent.fire();

        }

    }


	return oItem;

},


/**
* @method _removeItemFromGroupByValue
* @description Removes a menu item from a group by reference.  Returns the
* menu item that was removed.
* @private
* @param {Number} p_nGroupIndex Number indicating the group to which the
* menu item belongs.
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance to be removed.
* @return {YAHOO.widget.MenuItem}
*/
_removeItemFromGroupByValue: function (p_nGroupIndex, p_oItem) {

    var aGroup = this._getItemGroup(p_nGroupIndex),
        nItems,
        nItemIndex,
        returnVal,
        i;

    if (aGroup) {

        nItems = aGroup.length;
        nItemIndex = -1;

        if (nItems > 0) {

            i = nItems-1;

            do {

                if (aGroup[i] == p_oItem) {

                    nItemIndex = i;
                    break;

                }

            }
            while (i--);

            if (nItemIndex > -1) {

                returnVal = this._removeItemFromGroupByIndex(p_nGroupIndex, nItemIndex);

            }

        }

    }

    return returnVal;

},


/**
* @method _updateItemProperties
* @description Updates the "index," "groupindex," and "className" properties
* of the menu items in the specified group.
* @private
* @param {Number} p_nGroupIndex Number indicating the group of items to update.
*/
_updateItemProperties: function (p_nGroupIndex) {

    var aGroup = this._getItemGroup(p_nGroupIndex),
        nItems = aGroup.length,
        oItem,
        oLI,
        i;


    if (nItems > 0) {

        i = nItems - 1;


        do {

            oItem = aGroup[i];

            if (oItem) {

                oLI = oItem.element;

                oItem.index = i;
                oItem.groupIndex = p_nGroupIndex;

                oLI.setAttribute(_GROUP_INDEX, p_nGroupIndex);
                oLI.setAttribute(_INDEX, i);

                Dom.removeClass(oLI, _FIRST_OF_TYPE);

            }

        }
        while (i--);


        if (oLI) {

            Dom.addClass(oLI, _FIRST_OF_TYPE);

        }

    }

},


/**
* @method _createItemGroup
* @description Creates a new menu item group (array) and its associated
* <code>&#60;ul&#62;</code> element. Returns an aray of menu item groups.
* @private
* @param {Number} p_nIndex Number indicating the group to create.
* @return {Array}
*/
_createItemGroup: function (p_nIndex) {

    var oUL,
    	returnVal;

    if (!this._aItemGroups[p_nIndex]) {

        this._aItemGroups[p_nIndex] = [];

        oUL = document.createElement(_UL_LOWERCASE);

        this._aListElements[p_nIndex] = oUL;

        returnVal = this._aItemGroups[p_nIndex];

    }

    return returnVal;

},


/**
* @method _getItemGroup
* @description Returns the menu item group at the specified index.
* @private
* @param {Number} p_nIndex Number indicating the index of the menu item group
* to be retrieved.
* @return {Array}
*/
_getItemGroup: function (p_nIndex) {

    var nIndex = Lang.isNumber(p_nIndex) ? p_nIndex : 0,
    	aGroups = this._aItemGroups,
    	returnVal;

	if (nIndex in aGroups) {

	    returnVal = aGroups[nIndex];

	}

	return returnVal;

},


/**
* @method _configureSubmenu
* @description Subscribes the menu item's submenu to its parent menu's events.
* @private
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance with the submenu to be configured.
*/
_configureSubmenu: function (p_oItem) {

    var oSubmenu = p_oItem.cfg.getProperty(_SUBMENU);

    if (oSubmenu) {

        /*
            Listen for configuration changes to the parent menu
            so they they can be applied to the submenu.
        */

        this.cfg.configChangedEvent.subscribe(this._onParentMenuConfigChange, oSubmenu, true);

        this.renderEvent.subscribe(this._onParentMenuRender, oSubmenu, true);

    }

},




/**
* @method _subscribeToItemEvents
* @description Subscribes a menu to a menu item's event.
* @private
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance whose events should be subscribed to.
*/
_subscribeToItemEvents: function (p_oItem) {

    p_oItem.destroyEvent.subscribe(this._onMenuItemDestroy, p_oItem, this);
    p_oItem.cfg.configChangedEvent.subscribe(this._onMenuItemConfigChange, p_oItem, this);

},


/**
* @method _onVisibleChange
* @description Change event handler for the the menu's "visible" configuration
* property.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onVisibleChange: function (p_sType, p_aArgs) {

    var bVisible = p_aArgs[0];

    if (bVisible) {

        Dom.addClass(this.element, _VISIBLE);

    }
    else {

        Dom.removeClass(this.element, _VISIBLE);

    }

},


/**
* @method _cancelHideDelay
* @description Cancels the call to "hideMenu."
* @private
*/
_cancelHideDelay: function () {

    var oTimer = this.getRoot()._hideDelayTimer;

    if (oTimer) {

		oTimer.cancel();

    }

},


/**
* @method _execHideDelay
* @description Hides the menu after the number of milliseconds specified by
* the "hidedelay" configuration property.
* @private
*/
_execHideDelay: function () {

    this._cancelHideDelay();

    var oRoot = this.getRoot();

	oRoot._hideDelayTimer = Lang.later(oRoot.cfg.getProperty(_HIDE_DELAY), this, function () {

        if (oRoot.activeItem) {

			if (oRoot.hasFocus()) {

				oRoot.activeItem.focus();

			}

            oRoot.clearActiveItem();

        }

        if (oRoot == this && !(this instanceof YAHOO.widget.MenuBar) &&
            this.cfg.getProperty(_POSITION) == _DYNAMIC) {

            this.hide();

        }

    });

},


/**
* @method _cancelShowDelay
* @description Cancels the call to the "showMenu."
* @private
*/
_cancelShowDelay: function () {

    var oTimer = this.getRoot()._showDelayTimer;

    if (oTimer) {

        oTimer.cancel();

    }

},


/**
* @method _execSubmenuHideDelay
* @description Hides a submenu after the number of milliseconds specified by
* the "submenuhidedelay" configuration property have ellapsed.
* @private
* @param {YAHOO.widget.Menu} p_oSubmenu Object specifying the submenu that
* should be hidden.
* @param {Number} p_nMouseX The x coordinate of the mouse when it left
* the specified submenu's parent menu item.
* @param {Number} p_nHideDelay The number of milliseconds that should ellapse
* before the submenu is hidden.
*/
_execSubmenuHideDelay: function (p_oSubmenu, p_nMouseX, p_nHideDelay) {

	p_oSubmenu._submenuHideDelayTimer = Lang.later(50, this, function () {

        if (this._nCurrentMouseX > (p_nMouseX + 10)) {

            p_oSubmenu._submenuHideDelayTimer = Lang.later(p_nHideDelay, p_oSubmenu, function () {

                this.hide();

            });

        }
        else {

            p_oSubmenu.hide();

        }

	});

},





/**
* @method _disableScrollHeader
* @description Disables the header used for scrolling the body of the menu.
* @protected
*/
_disableScrollHeader: function () {

    if (!this._bHeaderDisabled) {

        Dom.addClass(this.header, _TOP_SCROLLBAR_DISABLED);
        this._bHeaderDisabled = true;

    }

},


/**
* @method _disableScrollFooter
* @description Disables the footer used for scrolling the body of the menu.
* @protected
*/
_disableScrollFooter: function () {

    if (!this._bFooterDisabled) {

        Dom.addClass(this.footer, _BOTTOM_SCROLLBAR_DISABLED);
        this._bFooterDisabled = true;

    }

},


/**
* @method _enableScrollHeader
* @description Enables the header used for scrolling the body of the menu.
* @protected
*/
_enableScrollHeader: function () {

    if (this._bHeaderDisabled) {

        Dom.removeClass(this.header, _TOP_SCROLLBAR_DISABLED);
        this._bHeaderDisabled = false;

    }

},


/**
* @method _enableScrollFooter
* @description Enables the footer used for scrolling the body of the menu.
* @protected
*/
_enableScrollFooter: function () {

    if (this._bFooterDisabled) {

        Dom.removeClass(this.footer, _BOTTOM_SCROLLBAR_DISABLED);
        this._bFooterDisabled = false;

    }

},


/**
* @method _onMouseOver
* @description "mouseover" event handler for the menu.
* @protected
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onMouseOver: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oTarget = Event.getTarget(oEvent),
        oRoot = this.getRoot(),
        oSubmenuHideDelayTimer = this._submenuHideDelayTimer,
        oParentMenu,
        nShowDelay,
        bShowDelay,
        oActiveItem,
        oItemCfg,
        oSubmenu;


    var showSubmenu = function () {

        if (this.parent.cfg.getProperty(_SELECTED)) {

            this.show();

        }

    };


    if (!this._bStopMouseEventHandlers) {

		if (!this._bHandledMouseOverEvent && (oTarget == this.element ||
				Dom.isAncestor(this.element, oTarget))) {


	        if (this._useHideDelay) {
	        	this._cancelHideDelay();
	        }

			this._nCurrentMouseX = 0;

			Event.on(this.element, _MOUSEMOVE, this._onMouseMove, this, true);


			/*
				If the mouse is moving from the submenu back to its corresponding menu item,
				don't hide the submenu or clear the active MenuItem.
			*/

			if (!(oItem && Dom.isAncestor(oItem.element, Event.getRelatedTarget(oEvent)))) {

				this.clearActiveItem();

			}


			if (this.parent && oSubmenuHideDelayTimer) {

				oSubmenuHideDelayTimer.cancel();

				this.parent.cfg.setProperty(_SELECTED, true);

				oParentMenu = this.parent.parent;

				oParentMenu._bHandledMouseOutEvent = true;
				oParentMenu._bHandledMouseOverEvent = false;

			}


			this._bHandledMouseOverEvent = true;
			this._bHandledMouseOutEvent = false;

		}


		if (oItem && !oItem.handledMouseOverEvent && !oItem.cfg.getProperty(_DISABLED) &&
			(oTarget == oItem.element || Dom.isAncestor(oItem.element, oTarget))) {


			nShowDelay = this.cfg.getProperty(_SHOW_DELAY);
			bShowDelay = (nShowDelay > 0);


			if (bShowDelay) {

				this._cancelShowDelay();

			}


			oActiveItem = this.activeItem;

			if (oActiveItem) {

				oActiveItem.cfg.setProperty(_SELECTED, false);

			}


			oItemCfg = oItem.cfg;


			oItemCfg.setProperty(_SELECTED, true);


			if (this.hasFocus() || oRoot._hasFocus) {

				oItem.focus();

				oRoot._hasFocus = false;

			}


			if (this.cfg.getProperty(_AUTO_SUBMENU_DISPLAY)) {


				oSubmenu = oItemCfg.getProperty(_SUBMENU);

				if (oSubmenu) {

					if (bShowDelay) {

						oRoot._showDelayTimer =
							Lang.later(oRoot.cfg.getProperty(_SHOW_DELAY), oSubmenu, showSubmenu);

					}
					else {

						oSubmenu.show();

					}

				}

			}

			oItem.handledMouseOverEvent = true;
			oItem.handledMouseOutEvent = false;

		}

    }

},


/**
* @method _onMouseOut
* @description "mouseout" event handler for the menu.
* @protected
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onMouseOut: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oRelatedTarget = Event.getRelatedTarget(oEvent),
        bMovingToSubmenu = false,
        oItemCfg,
        oSubmenu,
        nSubmenuHideDelay,
        nShowDelay;


    if (!this._bStopMouseEventHandlers) {

		if (oItem && !oItem.cfg.getProperty(_DISABLED)) {

			oItemCfg = oItem.cfg;
			oSubmenu = oItemCfg.getProperty(_SUBMENU);


			if (oSubmenu && (oRelatedTarget == oSubmenu.element ||
					Dom.isAncestor(oSubmenu.element, oRelatedTarget))) {

				bMovingToSubmenu = true;

			}


			if (!oItem.handledMouseOutEvent && ((oRelatedTarget != oItem.element &&
				!Dom.isAncestor(oItem.element, oRelatedTarget)) || bMovingToSubmenu)) {


				if (!bMovingToSubmenu) {

					oItem.cfg.setProperty(_SELECTED, false);


					if (oSubmenu) {

						nSubmenuHideDelay = this.cfg.getProperty(_SUBMENU_HIDE_DELAY);

						nShowDelay = this.cfg.getProperty(_SHOW_DELAY);

						if (!(this instanceof YAHOO.widget.MenuBar) && nSubmenuHideDelay > 0 &&
							nShowDelay >= nSubmenuHideDelay) {

							this._execSubmenuHideDelay(oSubmenu, Event.getPageX(oEvent),
									nSubmenuHideDelay);

						}
						else {

							oSubmenu.hide();

						}

					}

				}


				oItem.handledMouseOutEvent = true;
				oItem.handledMouseOverEvent = false;

			}

		}


		if (!this._bHandledMouseOutEvent && ((oRelatedTarget != this.element &&
			!Dom.isAncestor(this.element, oRelatedTarget)) || bMovingToSubmenu)) {


	        if (this._useHideDelay) {
	        	this._execHideDelay();
	        }

			Event.removeListener(this.element, _MOUSEMOVE, this._onMouseMove);

			this._nCurrentMouseX = Event.getPageX(oEvent);

			this._bHandledMouseOutEvent = true;
			this._bHandledMouseOverEvent = false;

		}

    }

},


/**
* @method _onMouseMove
* @description "click" event handler for the menu.
* @protected
* @param {Event} p_oEvent Object representing the DOM event object passed
* back by the event utility (YAHOO.util.Event).
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
_onMouseMove: function (p_oEvent, p_oMenu) {

    if (!this._bStopMouseEventHandlers) {

	    this._nCurrentMouseX = Event.getPageX(p_oEvent);

    }

},


/**
* @method _onClick
* @description "click" event handler for the menu.
* @protected
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onClick: function (p_sType, p_aArgs) {

	var oEvent = p_aArgs[0],
		oItem = p_aArgs[1],
		bInMenuAnchor = false,
		oSubmenu,
		oMenu,
		oRoot,
		sId,
		sURL,
		nHashPos,
		nLen;


	var hide = function () {

		oRoot = this.getRoot();

		if (oRoot instanceof YAHOO.widget.MenuBar ||
			oRoot.cfg.getProperty(_POSITION) == _STATIC) {

			oRoot.clearActiveItem();

		}
		else {

			oRoot.hide();

		}

	};


	if (oItem) {

		if (oItem.cfg.getProperty(_DISABLED)) {

			Event.preventDefault(oEvent);

			hide.call(this);

		}
		else {

			oSubmenu = oItem.cfg.getProperty(_SUBMENU);


			/*
				 Check if the URL of the anchor is pointing to an element that is
				 a child of the menu.
			*/

			sURL = oItem.cfg.getProperty(_URL);


			if (sURL) {

				nHashPos = sURL.indexOf(_HASH);

				nLen = sURL.length;


				if (nHashPos != -1) {

					sURL = sURL.substr(nHashPos, nLen);

					nLen = sURL.length;


					if (nLen > 1) {

						sId = sURL.substr(1, nLen);

						oMenu = YAHOO.widget.MenuManager.getMenu(sId);

						if (oMenu) {

							bInMenuAnchor =
								(this.getRoot() === oMenu.getRoot());

						}

					}
					else if (nLen === 1) {

						bInMenuAnchor = true;

					}

				}

			}


			if (bInMenuAnchor && !oItem.cfg.getProperty(_TARGET)) {

				Event.preventDefault(oEvent);


				if (UA.webkit) {

					oItem.focus();

				}
				else {

					oItem.focusEvent.fire();

				}

			}


			if (!oSubmenu && !this.cfg.getProperty(_KEEP_OPEN)) {

				hide.call(this);

			}

		}

	}

},


/**
* @method _onKeyDown
* @description "keydown" event handler for the menu.
* @protected
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onKeyDown: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oSubmenu,
        oItemCfg,
        oParentItem,
        oRoot,
        oNextItem,
        oBody,
        nBodyScrollTop,
        nBodyOffsetHeight,
        aItems,
        nItems,
        nNextItemOffsetTop,
        nScrollTarget,
        oParentMenu,
		oFocusedEl;


	if (this._useHideDelay) {
		this._cancelHideDelay();
	}


    /*
        This function is called to prevent a bug in Firefox.  In Firefox,
        moving a DOM element into a stationary mouse pointer will cause the
        browser to fire mouse events.  This can result in the menu mouse
        event handlers being called uncessarily, especially when menus are
        moved into a stationary mouse pointer as a result of a
        key event handler.
    */
    function stopMouseEventHandlers() {

        this._bStopMouseEventHandlers = true;

        Lang.later(10, this, function () {

            this._bStopMouseEventHandlers = false;

        });

    }


    if (oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oItemCfg = oItem.cfg;
        oParentItem = this.parent;

        switch(oEvent.keyCode) {

            case 38:    // Up arrow
            case 40:    // Down arrow

                oNextItem = (oEvent.keyCode == 38) ?
                    oItem.getPreviousEnabledSibling() :
                    oItem.getNextEnabledSibling();

                if (oNextItem) {

                    this.clearActiveItem();

                    oNextItem.cfg.setProperty(_SELECTED, true);
                    oNextItem.focus();


                    if (this.cfg.getProperty(_MAX_HEIGHT) > 0) {

                        oBody = this.body;
                        nBodyScrollTop = oBody.scrollTop;
                        nBodyOffsetHeight = oBody.offsetHeight;
                        aItems = this.getItems();
                        nItems = aItems.length - 1;
                        nNextItemOffsetTop = oNextItem.element.offsetTop;


                        if (oEvent.keyCode == 40 ) {    // Down

                            if (nNextItemOffsetTop >= (nBodyOffsetHeight + nBodyScrollTop)) {

                                oBody.scrollTop = nNextItemOffsetTop - nBodyOffsetHeight;

                            }
                            else if (nNextItemOffsetTop <= nBodyScrollTop) {

                                oBody.scrollTop = 0;

                            }


                            if (oNextItem == aItems[nItems]) {

                                oBody.scrollTop = oNextItem.element.offsetTop;

                            }

                        }
                        else {  // Up

                            if (nNextItemOffsetTop <= nBodyScrollTop) {

                                oBody.scrollTop = nNextItemOffsetTop - oNextItem.element.offsetHeight;

                            }
                            else if (nNextItemOffsetTop >= (nBodyScrollTop + nBodyOffsetHeight)) {

                                oBody.scrollTop = nNextItemOffsetTop;

                            }


                            if (oNextItem == aItems[0]) {

                                oBody.scrollTop = 0;

                            }

                        }


                        nBodyScrollTop = oBody.scrollTop;
                        nScrollTarget = oBody.scrollHeight - oBody.offsetHeight;

                        if (nBodyScrollTop === 0) {

                            this._disableScrollHeader();
                            this._enableScrollFooter();

                        }
                        else if (nBodyScrollTop == nScrollTarget) {

                             this._enableScrollHeader();
                             this._disableScrollFooter();

                        }
                        else {

                            this._enableScrollHeader();
                            this._enableScrollFooter();

                        }

                    }

                }


                Event.preventDefault(oEvent);

                stopMouseEventHandlers();

            break;


            case 39:    // Right arrow

                oSubmenu = oItemCfg.getProperty(_SUBMENU);

                if (oSubmenu) {

                    if (!oItemCfg.getProperty(_SELECTED)) {

                        oItemCfg.setProperty(_SELECTED, true);

                    }

                    oSubmenu.show();
                    oSubmenu.setInitialFocus();
                    oSubmenu.setInitialSelection();

                }
                else {

                    oRoot = this.getRoot();

                    if (oRoot instanceof YAHOO.widget.MenuBar) {

                        oNextItem = oRoot.activeItem.getNextEnabledSibling();

                        if (oNextItem) {

                            oRoot.clearActiveItem();

                            oNextItem.cfg.setProperty(_SELECTED, true);

                            oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);

                            if (oSubmenu) {

                                oSubmenu.show();
                                oSubmenu.setInitialFocus();

                            }
                            else {

                            	oNextItem.focus();

                            }

                        }

                    }

                }


                Event.preventDefault(oEvent);

                stopMouseEventHandlers();

            break;


            case 37:    // Left arrow

                if (oParentItem) {

                    oParentMenu = oParentItem.parent;

                    if (oParentMenu instanceof YAHOO.widget.MenuBar) {

                        oNextItem =
                            oParentMenu.activeItem.getPreviousEnabledSibling();

                        if (oNextItem) {

                            oParentMenu.clearActiveItem();

                            oNextItem.cfg.setProperty(_SELECTED, true);

                            oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);

                            if (oSubmenu) {

                                oSubmenu.show();
								oSubmenu.setInitialFocus();

                            }
                            else {

                            	oNextItem.focus();

                            }

                        }

                    }
                    else {

                        this.hide();

                        oParentItem.focus();

                    }

                }

                Event.preventDefault(oEvent);

                stopMouseEventHandlers();

            break;

        }


    }


    if (oEvent.keyCode == 27) { // Esc key

        if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

            this.hide();

            if (this.parent) {

                this.parent.focus();

            }
			else {

				oFocusedEl = this._focusedElement;

				if (oFocusedEl && oFocusedEl.focus) {

					try {
						oFocusedEl.focus();
					}
					catch(ex) {
					}

				}

			}

        }
        else if (this.activeItem) {

            oSubmenu = this.activeItem.cfg.getProperty(_SUBMENU);

            if (oSubmenu && oSubmenu.cfg.getProperty(_VISIBLE)) {

                oSubmenu.hide();
                this.activeItem.focus();

            }
            else {

                this.activeItem.blur();
                this.activeItem.cfg.setProperty(_SELECTED, false);

            }

        }


        Event.preventDefault(oEvent);

    }

},


/**
* @method _onKeyPress
* @description "keypress" event handler for a Menu instance.
* @protected
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
*/
_onKeyPress: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0];


    if (oEvent.keyCode == 40 || oEvent.keyCode == 38) {

        Event.preventDefault(oEvent);

    }

},


/**
* @method _onBlur
* @description "blur" event handler for a Menu instance.
* @protected
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
*/
_onBlur: function (p_sType, p_aArgs) {

	if (this._hasFocus) {
		this._hasFocus = false;
	}

},

/**
* @method _onYChange
* @description "y" event handler for a Menu instance.
* @protected
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
*/
_onYChange: function (p_sType, p_aArgs) {

    var oParent = this.parent,
        nScrollTop,
        oIFrame,
        nY;


    if (oParent) {

        nScrollTop = oParent.parent.body.scrollTop;


        if (nScrollTop > 0) {

            nY = (this.cfg.getProperty(_Y) - nScrollTop);

            Dom.setY(this.element, nY);

            oIFrame = this.iframe;


            if (oIFrame) {

                Dom.setY(oIFrame, nY);

            }

            this.cfg.setProperty(_Y, nY, true);

        }

    }

},


/**
* @method _onScrollTargetMouseOver
* @description "mouseover" event handler for the menu's "header" and "footer"
* elements.  Used to scroll the body of the menu up and down when the
* menu's "maxheight" configuration property is set to a value greater than 0.
* @protected
* @param {Event} p_oEvent Object representing the DOM event object passed
* back by the event utility (YAHOO.util.Event).
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
_onScrollTargetMouseOver: function (p_oEvent, p_oMenu) {

	var oBodyScrollTimer = this._bodyScrollTimer;


	if (oBodyScrollTimer) {

		oBodyScrollTimer.cancel();

	}


	this._cancelHideDelay();


    var oTarget = Event.getTarget(p_oEvent),
        oBody = this.body,
        nScrollIncrement = this.cfg.getProperty(_SCROLL_INCREMENT),
        nScrollTarget,
        fnScrollFunction;


    function scrollBodyDown() {

        var nScrollTop = oBody.scrollTop;


        if (nScrollTop < nScrollTarget) {

            oBody.scrollTop = (nScrollTop + nScrollIncrement);

            this._enableScrollHeader();

        }
        else {

            oBody.scrollTop = nScrollTarget;

            this._bodyScrollTimer.cancel();

            this._disableScrollFooter();

        }

    }


    function scrollBodyUp() {

        var nScrollTop = oBody.scrollTop;


        if (nScrollTop > 0) {

            oBody.scrollTop = (nScrollTop - nScrollIncrement);

            this._enableScrollFooter();

        }
        else {

            oBody.scrollTop = 0;

			this._bodyScrollTimer.cancel();

            this._disableScrollHeader();

        }

    }


    if (Dom.hasClass(oTarget, _HD)) {

        fnScrollFunction = scrollBodyUp;

    }
    else {

        nScrollTarget = oBody.scrollHeight - oBody.offsetHeight;

        fnScrollFunction = scrollBodyDown;

    }


    this._bodyScrollTimer = Lang.later(10, this, fnScrollFunction, null, true);

},


/**
* @method _onScrollTargetMouseOut
* @description "mouseout" event handler for the menu's "header" and "footer"
* elements.  Used to stop scrolling the body of the menu up and down when the
* menu's "maxheight" configuration property is set to a value greater than 0.
* @protected
* @param {Event} p_oEvent Object representing the DOM event object passed
* back by the event utility (YAHOO.util.Event).
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
_onScrollTargetMouseOut: function (p_oEvent, p_oMenu) {

	var oBodyScrollTimer = this._bodyScrollTimer;

	if (oBodyScrollTimer) {

		oBodyScrollTimer.cancel();

	}

    this._cancelHideDelay();

},





/**
* @method _onInit
* @description "init" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onInit: function (p_sType, p_aArgs) {

    this.cfg.subscribeToConfigEvent(_VISIBLE, this._onVisibleChange);

    var bRootMenu = !this.parent,
        bLazyLoad = this.lazyLoad;


    /*
        Automatically initialize a menu's subtree if:

        1) This is the root menu and lazyload is off

        2) This is the root menu, lazyload is on, but the menu is
           already visible

        3) This menu is a submenu and lazyload is off
    */



    if (((bRootMenu && !bLazyLoad) ||
        (bRootMenu && (this.cfg.getProperty(_VISIBLE) ||
        this.cfg.getProperty(_POSITION) == _STATIC)) ||
        (!bRootMenu && !bLazyLoad)) && this.getItemGroups().length === 0) {

        if (this.srcElement) {

            this._initSubTree();

        }


        if (this.itemData) {

            this.addItems(this.itemData);

        }

    }
    else if (bLazyLoad) {

        this.cfg.fireQueue();

    }

},


/**
* @method _onBeforeRender
* @description "beforerender" event handler for the menu.  Appends all of the
* <code>&#60;ul&#62;</code>, <code>&#60;li&#62;</code> and their accompanying
* title elements to the body element of the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onBeforeRender: function (p_sType, p_aArgs) {

    var oEl = this.element,
        nListElements = this._aListElements.length,
        bFirstList = true,
        i = 0,
        oUL,
        oGroupTitle;

    if (nListElements > 0) {

        do {

            oUL = this._aListElements[i];

            if (oUL) {

                if (bFirstList) {

                    Dom.addClass(oUL, _FIRST_OF_TYPE);
                    bFirstList = false;

                }


                if (!Dom.isAncestor(oEl, oUL)) {

                    this.appendToBody(oUL);

                }


                oGroupTitle = this._aGroupTitleElements[i];

                if (oGroupTitle) {

                    if (!Dom.isAncestor(oEl, oGroupTitle)) {

                        oUL.parentNode.insertBefore(oGroupTitle, oUL);

                    }


                    Dom.addClass(oUL, _HAS_TITLE);

                }

            }

            i++;

        }
        while (i < nListElements);

    }

},


/**
* @method _onRender
* @description "render" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onRender: function (p_sType, p_aArgs) {

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        if (!this.cfg.getProperty(_VISIBLE)) {

            this.positionOffScreen();

        }

    }

},





/**
* @method _onBeforeShow
* @description "beforeshow" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onBeforeShow: function (p_sType, p_aArgs) {

    var nOptions,
        n,
        oSrcElement,
        oContainer = this.cfg.getProperty(_CONTAINER);


    if (this.lazyLoad && this.getItemGroups().length === 0) {

        if (this.srcElement) {

            this._initSubTree();

        }


        if (this.itemData) {

            if (this.parent && this.parent.parent &&
                this.parent.parent.srcElement &&
                this.parent.parent.srcElement.tagName.toUpperCase() ==
                _SELECT) {

                nOptions = this.itemData.length;

                for(n=0; n<nOptions; n++) {

                    if (this.itemData[n].tagName) {

                        this.addItem((new this.ITEM_TYPE(this.itemData[n])));

                    }

                }

            }
            else {

                this.addItems(this.itemData);

            }

        }


        oSrcElement = this.srcElement;

        if (oSrcElement) {

            if (oSrcElement.tagName.toUpperCase() == _SELECT) {

                if (Dom.inDocument(oSrcElement)) {

                    this.render(oSrcElement.parentNode);

                }
                else {

                    this.render(oContainer);

                }

            }
            else {

                this.render();

            }

        }
        else {

            if (this.parent) {

                this.render(this.parent.element);

            }
            else {

                this.render(oContainer);

            }

        }

    }



    var oParent = this.parent,
		aAlignment;


    if (!oParent && this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        this.cfg.refireEvent(_XY);

    }


	if (oParent) {

		aAlignment = oParent.parent.cfg.getProperty(_SUBMENU_ALIGNMENT);

		this.cfg.setProperty(_CONTEXT, [oParent.element, aAlignment[0], aAlignment[1]]);
		this.align();

	}

},


getConstrainedY: function (y) {

	var oMenu = this,

		aContext = oMenu.cfg.getProperty(_CONTEXT),
		nInitialMaxHeight = oMenu.cfg.getProperty(_MAX_HEIGHT),

		nMaxHeight,

		oOverlapPositions = {

			"trbr": true,
			"tlbl": true,
			"bltl": true,
			"brtr": true

		},

		bPotentialContextOverlap = (aContext && oOverlapPositions[aContext[1] + aContext[2]]),

		oMenuEl = oMenu.element,
		nMenuOffsetHeight = oMenuEl.offsetHeight,

		nViewportOffset = Overlay.VIEWPORT_OFFSET,
		viewPortHeight = Dom.getViewportHeight(),
		scrollY = Dom.getDocumentScrollTop(),

		bCanConstrain =
			(oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT) + nViewportOffset < viewPortHeight),

		nAvailableHeight,

		oContextEl,
		nContextElY,
		nContextElHeight,

		bFlipped = false,

		nTopRegionHeight,
		nBottomRegionHeight,

		topConstraint = scrollY + nViewportOffset,
		bottomConstraint = scrollY + viewPortHeight - nMenuOffsetHeight - nViewportOffset,

		yNew = y;


	var flipVertical = function () {

		var nNewY;

		if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) {
			nNewY = (nContextElY - nMenuOffsetHeight);
		}
		else {	// The Menu is above the context element, flip it below
			nNewY = (nContextElY + nContextElHeight);
		}

		oMenu.cfg.setProperty(_Y, (nNewY + scrollY), true);

		return nNewY;

	};


	/*
		 Uses the context element's position to calculate the availble height
		 above and below it to display its corresponding Menu.
	*/

	var getDisplayRegionHeight = function () {

		if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) {
			return (nBottomRegionHeight - nViewportOffset);
		}
		else {	// The Menu is above the context element
			return (nTopRegionHeight - nViewportOffset);
		}

	};


	/*
		Sets the Menu's "y" configuration property to the correct value based on its
		current orientation.
	*/

	var alignY = function () {

		var nNewY;

		if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) {
			nNewY = (nContextElY + nContextElHeight);
		}
		else {
			nNewY = (nContextElY - oMenuEl.offsetHeight);
		}

		oMenu.cfg.setProperty(_Y, (nNewY + scrollY), true);

	};



	var resetMaxHeight = function () {

		oMenu._setScrollHeight(this.cfg.getProperty(_MAX_HEIGHT));

		oMenu.hideEvent.unsubscribe(resetMaxHeight);

	};


	/*
		Trys to place the Menu in the best possible position (either above or
		below its corresponding context element).
	*/

	var setVerticalPosition = function () {

		var nDisplayRegionHeight = getDisplayRegionHeight(),
			bMenuHasItems = (oMenu.getItems().length > 0),
			nMenuMinScrollHeight,
			fnReturnVal;


		if (nMenuOffsetHeight > nDisplayRegionHeight) {

			nMenuMinScrollHeight =
				bMenuHasItems ? oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT) : nMenuOffsetHeight;


			if ((nDisplayRegionHeight > nMenuMinScrollHeight) && bMenuHasItems) {
				nMaxHeight = nDisplayRegionHeight;
			}
			else {
				nMaxHeight = nInitialMaxHeight;
			}


			oMenu._setScrollHeight(nMaxHeight);
			oMenu.hideEvent.subscribe(resetMaxHeight);



			alignY();


			if (nDisplayRegionHeight < nMenuMinScrollHeight) {

				if (bFlipped) {

					/*
						 All possible positions and values for the "maxheight"
						 configuration property have been tried, but none were
						 successful, so fall back to the original size and position.
					*/

					flipVertical();

				}
				else {

					flipVertical();

					bFlipped = true;

					fnReturnVal = setVerticalPosition();

				}

			}

		}
		else if (nMaxHeight && (nMaxHeight !== nInitialMaxHeight)) {

			oMenu._setScrollHeight(nInitialMaxHeight);
			oMenu.hideEvent.subscribe(resetMaxHeight);


			alignY();

		}

		return fnReturnVal;

	};



	if (y < topConstraint || y  > bottomConstraint) {


		if (bCanConstrain) {

			if (oMenu.cfg.getProperty(_PREVENT_CONTEXT_OVERLAP) && bPotentialContextOverlap) {


				oContextEl = aContext[0];
				nContextElHeight = oContextEl.offsetHeight;
				nContextElY = (Dom.getY(oContextEl) - scrollY);

				nTopRegionHeight = nContextElY;
				nBottomRegionHeight = (viewPortHeight - (nContextElY + nContextElHeight));

				setVerticalPosition();

				yNew = oMenu.cfg.getProperty(_Y);

			}
			else if (!(oMenu instanceof YAHOO.widget.MenuBar) &&
				nMenuOffsetHeight >= viewPortHeight) {


				nAvailableHeight = (viewPortHeight - (nViewportOffset * 2));

				if (nAvailableHeight > oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT)) {

					oMenu._setScrollHeight(nAvailableHeight);
					oMenu.hideEvent.subscribe(resetMaxHeight);

					alignY();

					yNew = oMenu.cfg.getProperty(_Y);

				}

			}
			else {


				if (y < topConstraint) {
					yNew  = topConstraint;
				} else if (y  > bottomConstraint) {
					yNew  = bottomConstraint;
				}

			}

		}
		else {
			yNew = nViewportOffset + scrollY;
		}

	}

	return yNew;

},


/**
* @method _onHide
* @description "hide" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onHide: function (p_sType, p_aArgs) {

	if (this.cfg.getProperty(_POSITION) === _DYNAMIC) {

		this.positionOffScreen();

	}

},


/**
* @method _onShow
* @description "show" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onShow: function (p_sType, p_aArgs) {

    var oParent = this.parent,
        oParentMenu,
		oElement,
		nOffsetWidth,
		sWidth;


    function disableAutoSubmenuDisplay(p_oEvent) {

        var oTarget;

        if (p_oEvent.type == _MOUSEDOWN || (p_oEvent.type == _KEYDOWN && p_oEvent.keyCode == 27)) {

            /*
                Set the "autosubmenudisplay" to "false" if the user
                clicks outside the menu bar.
            */

            oTarget = Event.getTarget(p_oEvent);

            if (oTarget != oParentMenu.element || !Dom.isAncestor(oParentMenu.element, oTarget)) {

                oParentMenu.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, false);

                Event.removeListener(document, _MOUSEDOWN, disableAutoSubmenuDisplay);
                Event.removeListener(document, _KEYDOWN, disableAutoSubmenuDisplay);

            }

        }

    }


	function onSubmenuHide(p_sType, p_aArgs, p_sWidth) {

		this.cfg.setProperty(_WIDTH, _EMPTY_STRING);
		this.hideEvent.unsubscribe(onSubmenuHide, p_sWidth);

	}


    if (oParent) {

        oParentMenu = oParent.parent;


        if (!oParentMenu.cfg.getProperty(_AUTO_SUBMENU_DISPLAY) &&
            (oParentMenu instanceof YAHOO.widget.MenuBar ||
            oParentMenu.cfg.getProperty(_POSITION) == _STATIC)) {

            oParentMenu.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, true);

            Event.on(document, _MOUSEDOWN, disableAutoSubmenuDisplay);
            Event.on(document, _KEYDOWN, disableAutoSubmenuDisplay);

        }



		if ((this.cfg.getProperty("x") < oParentMenu.cfg.getProperty("x")) &&
			(UA.gecko && UA.gecko < 1.9) && !this.cfg.getProperty(_WIDTH)) {

			oElement = this.element;
			nOffsetWidth = oElement.offsetWidth;

			/*
				Measuring the difference of the offsetWidth before and after
				setting the "width" style attribute allows us to compute the
				about of padding and borders applied to the element, which in
				turn allows us to set the "width" property correctly.
			*/

			oElement.style.width = nOffsetWidth + _PX;

			sWidth = (nOffsetWidth - (oElement.offsetWidth - nOffsetWidth)) + _PX;

			this.cfg.setProperty(_WIDTH, sWidth);

			this.hideEvent.subscribe(onSubmenuHide, sWidth);

		}

    }


	/*
		Dynamically positioned, root Menus focus themselves when visible, and
		will then, when hidden, restore focus to the UI control that had focus
		before the Menu was made visible.
	*/

	if (this === this.getRoot() && this.cfg.getProperty(_POSITION) === _DYNAMIC) {

		this._focusedElement = oFocusedElement;

		this.focus();

	}


},


/**
* @method _onBeforeHide
* @description "beforehide" event handler for the menu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
*/
_onBeforeHide: function (p_sType, p_aArgs) {

    var oActiveItem = this.activeItem,
        oRoot = this.getRoot(),
        oConfig,
        oSubmenu;


    if (oActiveItem) {

        oConfig = oActiveItem.cfg;

        oConfig.setProperty(_SELECTED, false);

        oSubmenu = oConfig.getProperty(_SUBMENU);

        if (oSubmenu) {

            oSubmenu.hide();

        }

    }


	/*
		Focus can get lost in IE when the mouse is moving from a submenu back to its parent Menu.
		For this reason, it is necessary to maintain the focused state in a private property
		so that the _onMouseOver event handler is able to determined whether or not to set focus
		to MenuItems as the user is moving the mouse.
	*/

	if (UA.ie && this.cfg.getProperty(_POSITION) === _DYNAMIC && this.parent) {

		oRoot._hasFocus = this.hasFocus();

	}


    if (oRoot == this) {

        oRoot.blur();

    }

},


/**
* @method _onParentMenuConfigChange
* @description "configchange" event handler for a submenu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oSubmenu Object representing the submenu that
* subscribed to the event.
*/
_onParentMenuConfigChange: function (p_sType, p_aArgs, p_oSubmenu) {

    var sPropertyName = p_aArgs[0][0],
        oPropertyValue = p_aArgs[0][1];

    switch(sPropertyName) {

        case _IFRAME:
        case _CONSTRAIN_TO_VIEWPORT:
        case _HIDE_DELAY:
        case _SHOW_DELAY:
        case _SUBMENU_HIDE_DELAY:
        case _CLICK_TO_HIDE:
        case _EFFECT:
        case _CLASSNAME:
        case _SCROLL_INCREMENT:
        case _MAX_HEIGHT:
        case _MIN_SCROLL_HEIGHT:
        case _MONITOR_RESIZE:
        case _SHADOW:
        case _PREVENT_CONTEXT_OVERLAP:
		case _KEEP_OPEN:

            p_oSubmenu.cfg.setProperty(sPropertyName, oPropertyValue);

        break;

        case _SUBMENU_ALIGNMENT:

			if (!(this.parent.parent instanceof YAHOO.widget.MenuBar)) {

				p_oSubmenu.cfg.setProperty(sPropertyName, oPropertyValue);

			}

        break;

    }

},


/**
* @method _onParentMenuRender
* @description "render" event handler for a submenu.  Renders a
* submenu in response to the firing of its parent's "render" event.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oSubmenu Object representing the submenu that
* subscribed to the event.
*/
_onParentMenuRender: function (p_sType, p_aArgs, p_oSubmenu) {

    var oParentMenu = p_oSubmenu.parent.parent,
    	oParentCfg = oParentMenu.cfg,

        oConfig = {

            constraintoviewport: oParentCfg.getProperty(_CONSTRAIN_TO_VIEWPORT),

            xy: [0,0],

            clicktohide: oParentCfg.getProperty(_CLICK_TO_HIDE),

            effect: oParentCfg.getProperty(_EFFECT),

            showdelay: oParentCfg.getProperty(_SHOW_DELAY),

            hidedelay: oParentCfg.getProperty(_HIDE_DELAY),

            submenuhidedelay: oParentCfg.getProperty(_SUBMENU_HIDE_DELAY),

            classname: oParentCfg.getProperty(_CLASSNAME),

            scrollincrement: oParentCfg.getProperty(_SCROLL_INCREMENT),

			maxheight: oParentCfg.getProperty(_MAX_HEIGHT),

            minscrollheight: oParentCfg.getProperty(_MIN_SCROLL_HEIGHT),

            iframe: oParentCfg.getProperty(_IFRAME),

            shadow: oParentCfg.getProperty(_SHADOW),

			preventcontextoverlap: oParentCfg.getProperty(_PREVENT_CONTEXT_OVERLAP),

            monitorresize: oParentCfg.getProperty(_MONITOR_RESIZE),

			keepopen: oParentCfg.getProperty(_KEEP_OPEN)

        },

        oLI;



	if (!(oParentMenu instanceof YAHOO.widget.MenuBar)) {

		oConfig[_SUBMENU_ALIGNMENT] = oParentCfg.getProperty(_SUBMENU_ALIGNMENT);

	}


    p_oSubmenu.cfg.applyConfig(oConfig);


    if (!this.lazyLoad) {

        oLI = this.parent.element;

        if (this.element.parentNode == oLI) {

            this.render();

        }
        else {

            this.render(oLI);

        }

    }

},


/**
* @method _onMenuItemDestroy
* @description "destroy" event handler for the menu's items.
* @private
* @param {String} p_sType String representing the name of the event
* that was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
* that fired the event.
*/
_onMenuItemDestroy: function (p_sType, p_aArgs, p_oItem) {

    this._removeItemFromGroupByValue(p_oItem.groupIndex, p_oItem);

},


/**
* @method _onMenuItemConfigChange
* @description "configchange" event handler for the menu's items.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
* that fired the event.
*/
_onMenuItemConfigChange: function (p_sType, p_aArgs, p_oItem) {

    var sPropertyName = p_aArgs[0][0],
        oPropertyValue = p_aArgs[0][1],
        oSubmenu;


    switch(sPropertyName) {

        case _SELECTED:

            if (oPropertyValue === true) {

                this.activeItem = p_oItem;

            }

        break;

        case _SUBMENU:

            oSubmenu = p_aArgs[0][1];

            if (oSubmenu) {

                this._configureSubmenu(p_oItem);

            }

        break;

    }

},





/**
* @method configVisible
* @description Event handler for when the "visible" configuration property
* the menu changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
configVisible: function (p_sType, p_aArgs, p_oMenu) {

    var bVisible,
        sDisplay;

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        Menu.superclass.configVisible.call(this, p_sType, p_aArgs, p_oMenu);

    }
    else {

        bVisible = p_aArgs[0];
        sDisplay = Dom.getStyle(this.element, _DISPLAY);

        Dom.setStyle(this.element, _VISIBILITY, _VISIBLE);

        if (bVisible) {

            if (sDisplay != _BLOCK) {
                this.beforeShowEvent.fire();
                Dom.setStyle(this.element, _DISPLAY, _BLOCK);
                this.showEvent.fire();
            }

        }
        else {

			if (sDisplay == _BLOCK) {
				this.beforeHideEvent.fire();
				Dom.setStyle(this.element, _DISPLAY, _NONE);
				this.hideEvent.fire();
			}

        }

    }

},


/**
* @method configPosition
* @description Event handler for when the "position" configuration property
* of the menu changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
configPosition: function (p_sType, p_aArgs, p_oMenu) {

    var oElement = this.element,
        sCSSPosition = p_aArgs[0] == _STATIC ? _STATIC : _ABSOLUTE,
        oCfg = this.cfg,
        nZIndex;


    Dom.setStyle(oElement, _POSITION, sCSSPosition);


    if (sCSSPosition == _STATIC) {


        Dom.setStyle(oElement, _DISPLAY, _BLOCK);

        oCfg.setProperty(_VISIBLE, true);

    }
    else {

        /*
            Even though the "visible" property is queued to
            "false" by default, we need to set the "visibility" property to
            "hidden" since Overlay's "configVisible" implementation checks the
            element's "visibility" style property before deciding whether
            or not to show an Overlay instance.
        */

        Dom.setStyle(oElement, _VISIBILITY, _HIDDEN);

    }


     if (sCSSPosition == _ABSOLUTE) {

         nZIndex = oCfg.getProperty(_ZINDEX);

         if (!nZIndex || nZIndex === 0) {

             oCfg.setProperty(_ZINDEX, 1);

         }

     }

},


/**
* @method configIframe
* @description Event handler for when the "iframe" configuration property of
* the menu changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
configIframe: function (p_sType, p_aArgs, p_oMenu) {

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        Menu.superclass.configIframe.call(this, p_sType, p_aArgs, p_oMenu);

    }

},


/**
* @method configHideDelay
* @description Event handler for when the "hidedelay" configuration property
* of the menu changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
configHideDelay: function (p_sType, p_aArgs, p_oMenu) {

    var nHideDelay = p_aArgs[0];

	this._useHideDelay = (nHideDelay > 0);

},


/**
* @method configContainer
* @description Event handler for when the "container" configuration property
* of the menu changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu Object representing the menu that
* fired the event.
*/
configContainer: function (p_sType, p_aArgs, p_oMenu) {

	var oElement = p_aArgs[0];

	if (Lang.isString(oElement)) {

        this.cfg.setProperty(_CONTAINER, Dom.get(oElement), true);

	}

},


/**
* @method _clearSetWidthFlag
* @description Change event listener for the "width" configuration property.  This listener is
* added when a Menu's "width" configuration property is set by the "_setScrollHeight" method, and
* is used to set the "_widthSetForScroll" property to "false" if the "width" configuration property
* is changed after it was set by the "_setScrollHeight" method.  If the "_widthSetForScroll"
* property is set to "false", and the "_setScrollHeight" method is in the process of tearing down
* scrolling functionality, it will maintain the Menu's new width rather than reseting it.
* @private
*/
_clearSetWidthFlag: function () {

	this._widthSetForScroll = false;

	this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);

},


/**
* @method _setScrollHeight
* @description
* @param {String} p_nScrollHeight Number representing the scrolling height of the Menu.
* @private
*/
_setScrollHeight: function (p_nScrollHeight) {

    var nScrollHeight = p_nScrollHeight,
		bRefireIFrameAndShadow = false,
		bSetWidth = false,
        oElement,
        oBody,
        oHeader,
        oFooter,
        fnMouseOver,
        fnMouseOut,
        nMinScrollHeight,
        nHeight,
        nOffsetWidth,
        sWidth;


	if (this.getItems().length > 0) {

        oElement = this.element;
        oBody = this.body;
        oHeader = this.header;
        oFooter = this.footer;
        fnMouseOver = this._onScrollTargetMouseOver;
        fnMouseOut = this._onScrollTargetMouseOut;
        nMinScrollHeight = this.cfg.getProperty(_MIN_SCROLL_HEIGHT);


		if (nScrollHeight > 0 && nScrollHeight < nMinScrollHeight) {

			nScrollHeight = nMinScrollHeight;

		}


		Dom.setStyle(oBody, _HEIGHT, _EMPTY_STRING);
		Dom.removeClass(oBody, _YUI_MENU_BODY_SCROLLED);
		oBody.scrollTop = 0;






		bSetWidth = ((UA.gecko && UA.gecko < 1.9) || UA.ie);

		if (nScrollHeight > 0 && bSetWidth && !this.cfg.getProperty(_WIDTH)) {

			nOffsetWidth = oElement.offsetWidth;

			/*
				Measuring the difference of the offsetWidth before and after
				setting the "width" style attribute allows us to compute the
				about of padding and borders applied to the element, which in
				turn allows us to set the "width" property correctly.
			*/

			oElement.style.width = nOffsetWidth + _PX;

			sWidth = (nOffsetWidth - (oElement.offsetWidth - nOffsetWidth)) + _PX;


			this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);


			this.cfg.setProperty(_WIDTH, sWidth);


			/*
				Set a flag (_widthSetForScroll) to maintain some history regarding how the
				"width" configuration property was set.  If the "width" configuration property
				is set by something other than the "_setScrollHeight" method, it will be
				necessary to maintain that new value and not clear the width if scrolling
				is turned off.
			*/

			this._widthSetForScroll = true;

			this.cfg.subscribeToConfigEvent(_WIDTH, this._clearSetWidthFlag);

		}


		if (nScrollHeight > 0 && (!oHeader && !oFooter)) {


			this.setHeader(_NON_BREAKING_SPACE);
			this.setFooter(_NON_BREAKING_SPACE);

			oHeader = this.header;
			oFooter = this.footer;

			Dom.addClass(oHeader, _TOP_SCROLLBAR);
			Dom.addClass(oFooter, _BOTTOM_SCROLLBAR);

			oElement.insertBefore(oHeader, oBody);
			oElement.appendChild(oFooter);

		}


		nHeight = nScrollHeight;


		if (oHeader && oFooter) {
			nHeight = (nHeight - (oHeader.offsetHeight + oFooter.offsetHeight));
		}


		if ((nHeight > 0) && (oBody.offsetHeight > nScrollHeight)) {


			Dom.addClass(oBody, _YUI_MENU_BODY_SCROLLED);
			Dom.setStyle(oBody, _HEIGHT, (nHeight + _PX));

			if (!this._hasScrollEventHandlers) {

				Event.on(oHeader, _MOUSEOVER, fnMouseOver, this, true);
				Event.on(oHeader, _MOUSEOUT, fnMouseOut, this, true);
				Event.on(oFooter, _MOUSEOVER, fnMouseOver, this, true);
				Event.on(oFooter, _MOUSEOUT, fnMouseOut, this, true);

				this._hasScrollEventHandlers = true;

			}

			this._disableScrollHeader();
			this._enableScrollFooter();

			bRefireIFrameAndShadow = true;

		}
		else if (oHeader && oFooter) {



			/*
				Only clear the the "width" configuration property if it was set the
				"_setScrollHeight" method and wasn't changed by some other means after it was set.
			*/

			if (this._widthSetForScroll) {


				this._widthSetForScroll = false;

				this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);

				this.cfg.setProperty(_WIDTH, _EMPTY_STRING);

			}


			this._enableScrollHeader();
			this._enableScrollFooter();

			if (this._hasScrollEventHandlers) {

				Event.removeListener(oHeader, _MOUSEOVER, fnMouseOver);
				Event.removeListener(oHeader, _MOUSEOUT, fnMouseOut);
				Event.removeListener(oFooter, _MOUSEOVER, fnMouseOver);
				Event.removeListener(oFooter, _MOUSEOUT, fnMouseOut);

				this._hasScrollEventHandlers = false;

			}

			oElement.removeChild(oHeader);
			oElement.removeChild(oFooter);

			this.header = null;
			this.footer = null;

			bRefireIFrameAndShadow = true;

		}


		if (bRefireIFrameAndShadow) {

			this.cfg.refireEvent(_IFRAME);
			this.cfg.refireEvent(_SHADOW);

		}

	}

},


/**
* @method _setMaxHeight
* @description "renderEvent" handler used to defer the setting of the
* "maxheight" configuration property until the menu is rendered in lazy
* load scenarios.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
* @param {Number} p_nMaxHeight Number representing the value to set for the
* "maxheight" configuration property.
* @private
*/
_setMaxHeight: function (p_sType, p_aArgs, p_nMaxHeight) {

    this._setScrollHeight(p_nMaxHeight);
    this.renderEvent.unsubscribe(this._setMaxHeight);

},


/**
* @method configMaxHeight
* @description Event handler for when the "maxheight" configuration property of
* a Menu changes.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
* @param {YAHOO.widget.Menu} p_oMenu The Menu instance fired
* the event.
*/
configMaxHeight: function (p_sType, p_aArgs, p_oMenu) {

	var nMaxHeight = p_aArgs[0];

	if (this.lazyLoad && !this.body && nMaxHeight > 0) {

		this.renderEvent.subscribe(this._setMaxHeight, nMaxHeight, this);

	}
	else {

		this._setScrollHeight(nMaxHeight);

	}

},


/**
* @method configClassName
* @description Event handler for when the "classname" configuration property of
* a menu changes.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu The Menu instance fired the event.
*/
configClassName: function (p_sType, p_aArgs, p_oMenu) {

    var sClassName = p_aArgs[0];

    if (this._sClassName) {

        Dom.removeClass(this.element, this._sClassName);

    }

    Dom.addClass(this.element, sClassName);
    this._sClassName = sClassName;

},


/**
* @method _onItemAdded
* @description "itemadded" event handler for a Menu instance.
* @private
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event
* was fired.
*/
_onItemAdded: function (p_sType, p_aArgs) {

    var oItem = p_aArgs[0];

    if (oItem) {

        oItem.cfg.setProperty(_DISABLED, true);

    }

},


/**
* @method configDisabled
* @description Event handler for when the "disabled" configuration property of
* a menu changes.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu The Menu instance fired the event.
*/
configDisabled: function (p_sType, p_aArgs, p_oMenu) {

    var bDisabled = p_aArgs[0],
        aItems = this.getItems(),
        nItems,
        i;

    if (Lang.isArray(aItems)) {

        nItems = aItems.length;

        if (nItems > 0) {

            i = nItems - 1;

            do {

                aItems[i].cfg.setProperty(_DISABLED, bDisabled);

            }
            while (i--);

        }


        if (bDisabled) {

            this.clearActiveItem(true);

            Dom.addClass(this.element, _DISABLED);

            this.itemAddedEvent.subscribe(this._onItemAdded);

        }
        else {

            Dom.removeClass(this.element, _DISABLED);

            this.itemAddedEvent.unsubscribe(this._onItemAdded);

        }

    }

},


/**
* @method configShadow
* @description Event handler for when the "shadow" configuration property of
* a menu changes.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event was fired.
* @param {YAHOO.widget.Menu} p_oMenu The Menu instance fired the event.
*/
configShadow: function (p_sType, p_aArgs, p_oMenu) {

    var sizeShadow = function () {

        var oElement = this.element,
            oShadow = this._shadow;

        if (oShadow && oElement) {


			if (oShadow.style.width && oShadow.style.height) {

				oShadow.style.width = _EMPTY_STRING;
				oShadow.style.height = _EMPTY_STRING;

			}

            oShadow.style.width = (oElement.offsetWidth + 6) + _PX;
            oShadow.style.height = (oElement.offsetHeight + 1) + _PX;

        }

    };


    var replaceShadow = function () {

        this.element.appendChild(this._shadow);

    };


    var addShadowVisibleClass = function () {

        Dom.addClass(this._shadow, _YUI_MENU_SHADOW_VISIBLE);

    };


    var removeShadowVisibleClass = function () {

        Dom.removeClass(this._shadow, _YUI_MENU_SHADOW_VISIBLE);

    };


    var createShadow = function () {

        var oShadow = this._shadow,
            oElement;

        if (!oShadow) {

            oElement = this.element;


            if (!m_oShadowTemplate) {

                m_oShadowTemplate = document.createElement(_DIV_LOWERCASE);
                m_oShadowTemplate.className = _YUI_MENU_SHADOW_YUI_MENU_SHADOW_VISIBLE;

            }

            oShadow = m_oShadowTemplate.cloneNode(false);

            oElement.appendChild(oShadow);

            this._shadow = oShadow;

            this.beforeShowEvent.subscribe(addShadowVisibleClass);
            this.beforeHideEvent.subscribe(removeShadowVisibleClass);


            if (UA.ie) {

                /*
                     Need to call sizeShadow & syncIframe via setTimeout for
                     IE 7 Quirks Mode and IE 6 Standards Mode and Quirks Mode
                     or the shadow and iframe shim will not be sized and
                     positioned properly.
                */

				Lang.later(0, this, function () {

                    sizeShadow.call(this);
                    this.syncIframe();

				});


                this.cfg.subscribeToConfigEvent(_WIDTH, sizeShadow);
                this.cfg.subscribeToConfigEvent(_HEIGHT, sizeShadow);
                this.cfg.subscribeToConfigEvent(_MAX_HEIGHT, sizeShadow);
                this.changeContentEvent.subscribe(sizeShadow);

                Module.textResizeEvent.subscribe(sizeShadow, this, true);

                this.destroyEvent.subscribe(function () {

                    Module.textResizeEvent.unsubscribe(sizeShadow, this);

                });

            }

            this.cfg.subscribeToConfigEvent(_MAX_HEIGHT, replaceShadow);

        }

    };


    var onBeforeShow = function () {

    	if (this._shadow) {


			replaceShadow.call(this);

			if (UA.ie) {
				sizeShadow.call(this);
			}

    	}
    	else {

        	createShadow.call(this);

        }

        this.beforeShowEvent.unsubscribe(onBeforeShow);

    };


	var bShadow = p_aArgs[0];


    if (bShadow && this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        if (this.cfg.getProperty(_VISIBLE)) {

			if (this._shadow) {


				replaceShadow.call(this);

				if (UA.ie) {
					sizeShadow.call(this);
				}

			}
			else {
            	createShadow.call(this);
            }

        }
        else {

            this.beforeShowEvent.subscribe(onBeforeShow);

        }

    }

},





/**
* @method initEvents
* @description Initializes the custom events for the menu.
*/
initEvents: function () {

	Menu.superclass.initEvents.call(this);


	var i = EVENT_TYPES.length - 1,
		aEventData,
		oCustomEvent;


	do {

		aEventData = EVENT_TYPES[i];

		oCustomEvent = this.createEvent(aEventData[1]);
		oCustomEvent.signature = CustomEvent.LIST;

		this[aEventData[0]] = oCustomEvent;

	}
	while (i--);

},


/**
* @method positionOffScreen
* @description Positions the menu outside of the boundaries of the browser's
* viewport.  Called automatically when a menu is hidden to ensure that
* it doesn't force the browser to render uncessary scrollbars.
*/
positionOffScreen: function () {

    var oIFrame = this.iframe,
    	oElement = this.element,
        sPos = this.OFF_SCREEN_POSITION;

    oElement.style.top = _EMPTY_STRING;
    oElement.style.left = _EMPTY_STRING;

    if (oIFrame) {

		oIFrame.style.top = sPos;
		oIFrame.style.left = sPos;

    }

},


/**
* @method getRoot
* @description Finds the menu's root menu.
*/
getRoot: function () {

    var oItem = this.parent,
        oParentMenu,
        returnVal;

    if (oItem) {

        oParentMenu = oItem.parent;

        returnVal = oParentMenu ? oParentMenu.getRoot() : this;

    }
    else {

        returnVal = this;

    }

    return returnVal;

},


/**
* @method toString
* @description Returns a string representing the menu.
* @return {String}
*/
toString: function () {

    var sReturnVal = _MENU,
        sId = this.id;

    if (sId) {

        sReturnVal += (_SPACE + sId);

    }

    return sReturnVal;

},


/**
* @method setItemGroupTitle
* @description Sets the title of a group of menu items.
* @param {String} p_sGroupTitle String specifying the title of the group.
* @param {Number} p_nGroupIndex Optional. Number specifying the group to which
* the title belongs.
*/
setItemGroupTitle: function (p_sGroupTitle, p_nGroupIndex) {

    var nGroupIndex,
        oTitle,
        i,
        nFirstIndex;

    if (Lang.isString(p_sGroupTitle) && p_sGroupTitle.length > 0) {

        nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0;
        oTitle = this._aGroupTitleElements[nGroupIndex];


        if (oTitle) {

            oTitle.innerHTML = p_sGroupTitle;

        }
        else {

            oTitle = document.createElement(this.GROUP_TITLE_TAG_NAME);

            oTitle.innerHTML = p_sGroupTitle;

            this._aGroupTitleElements[nGroupIndex] = oTitle;

        }


        i = this._aGroupTitleElements.length - 1;

        do {

            if (this._aGroupTitleElements[i]) {

                Dom.removeClass(this._aGroupTitleElements[i], _FIRST_OF_TYPE);

                nFirstIndex = i;

            }

        }
        while (i--);


        if (nFirstIndex !== null) {

            Dom.addClass(this._aGroupTitleElements[nFirstIndex],
                _FIRST_OF_TYPE);

        }

        this.changeContentEvent.fire();

    }

},



/**
* @method addItem
* @description Appends an item to the menu.
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance to be added to the menu.
* @param {String} p_oItem String specifying the text of the item to be added
* to the menu.
* @param {Object} p_oItem Object literal containing a set of menu item
* configuration properties.
* @param {Number} p_nGroupIndex Optional. Number indicating the group to
* which the item belongs.
* @return {YAHOO.widget.MenuItem}
*/
addItem: function (p_oItem, p_nGroupIndex) {

	return this._addItemToGroup(p_nGroupIndex, p_oItem);

},


/**
* @method addItems
* @description Adds an array of items to the menu.
* @param {Array} p_aItems Array of items to be added to the menu.  The array
* can contain strings specifying the text for each item to be created, object
* literals specifying each of the menu item configuration properties,
* or MenuItem instances.
* @param {Number} p_nGroupIndex Optional. Number specifying the group to
* which the items belongs.
* @return {Array}
*/
addItems: function (p_aItems, p_nGroupIndex) {

    var nItems,
        aItems,
        oItem,
        i,
        returnVal;


    if (Lang.isArray(p_aItems)) {

        nItems = p_aItems.length;
        aItems = [];

        for(i=0; i<nItems; i++) {

            oItem = p_aItems[i];

            if (oItem) {

                if (Lang.isArray(oItem)) {

                    aItems[aItems.length] = this.addItems(oItem, i);

                }
                else {

                    aItems[aItems.length] = this._addItemToGroup(p_nGroupIndex, oItem);

                }

            }

        }


        if (aItems.length) {

            returnVal = aItems;

        }

    }

	return returnVal;

},


/**
* @method insertItem
* @description Inserts an item into the menu at the specified index.
* @param {YAHOO.widget.MenuItem} p_oItem Object reference for the MenuItem
* instance to be added to the menu.
* @param {String} p_oItem String specifying the text of the item to be added
* to the menu.
* @param {Object} p_oItem Object literal containing a set of menu item
* configuration properties.
* @param {Number} p_nItemIndex Number indicating the ordinal position at which
* the item should be added.
* @param {Number} p_nGroupIndex Optional. Number indicating the group to which
* the item belongs.
* @return {YAHOO.widget.MenuItem}
*/
insertItem: function (p_oItem, p_nItemIndex, p_nGroupIndex) {

	return this._addItemToGroup(p_nGroupIndex, p_oItem, p_nItemIndex);

},


/**
* @method removeItem
* @description Removes the specified item from the menu.
* @param {YAHOO.widget.MenuItem} p_oObject Object reference for the MenuItem
* instance to be removed from the menu.
* @param {Number} p_oObject Number specifying the index of the item
* to be removed.
* @param {Number} p_nGroupIndex Optional. Number specifying the group to
* which the item belongs.
* @return {YAHOO.widget.MenuItem}
*/
removeItem: function (p_oObject, p_nGroupIndex) {

    var oItem,
    	returnVal;

    if (!Lang.isUndefined(p_oObject)) {

        if (p_oObject instanceof YAHOO.widget.MenuItem) {

            oItem = this._removeItemFromGroupByValue(p_nGroupIndex, p_oObject);

        }
        else if (Lang.isNumber(p_oObject)) {

            oItem = this._removeItemFromGroupByIndex(p_nGroupIndex, p_oObject);

        }

        if (oItem) {

            oItem.destroy();


            returnVal = oItem;

        }

    }

	return returnVal;

},


/**
* @method getItems
* @description Returns an array of all of the items in the menu.
* @return {Array}
*/
getItems: function () {

    var aGroups = this._aItemGroups,
        nGroups,
        returnVal,
        aItems = [];


    if (Lang.isArray(aGroups)) {

        nGroups = aGroups.length;

        returnVal = ((nGroups == 1) ? aGroups[0] : (Array.prototype.concat.apply(aItems, aGroups)));

    }

	return returnVal;

},


/**
* @method getItemGroups
* @description Multi-dimensional Array representing the menu items as they
* are grouped in the menu.
* @return {Array}
*/
getItemGroups: function () {

    return this._aItemGroups;

},


/**
* @method getItem
* @description Returns the item at the specified index.
* @param {Number} p_nItemIndex Number indicating the ordinal position of the
* item to be retrieved.
* @param {Number} p_nGroupIndex Optional. Number indicating the group to which
* the item belongs.
* @return {YAHOO.widget.MenuItem}
*/
getItem: function (p_nItemIndex, p_nGroupIndex) {

    var aGroup,
    	returnVal;

    if (Lang.isNumber(p_nItemIndex)) {

        aGroup = this._getItemGroup(p_nGroupIndex);

        if (aGroup) {

            returnVal = aGroup[p_nItemIndex];

        }

    }

    return returnVal;

},


/**
* @method getSubmenus
* @description Returns an array of all of the submenus that are immediate
* children of the menu.
* @return {Array}
*/
getSubmenus: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        aSubmenus,
        oSubmenu,
        oItem,
        i;


    if (nItems > 0) {

        aSubmenus = [];

        for(i=0; i<nItems; i++) {

            oItem = aItems[i];

            if (oItem) {

                oSubmenu = oItem.cfg.getProperty(_SUBMENU);

                if (oSubmenu) {

                    aSubmenus[aSubmenus.length] = oSubmenu;

                }

            }

        }

    }

    return aSubmenus;

},


/**
* @method clearContent
* @description Removes all of the content from the menu, including the menu
* items, group titles, header and footer.
*/
clearContent: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        oElement = this.element,
        oBody = this.body,
        oHeader = this.header,
        oFooter = this.footer,
        oItem,
        oSubmenu,
        i;


    if (nItems > 0) {

        i = nItems - 1;

        do {

            oItem = aItems[i];

            if (oItem) {

                oSubmenu = oItem.cfg.getProperty(_SUBMENU);

                if (oSubmenu) {

                    this.cfg.configChangedEvent.unsubscribe(
                        this._onParentMenuConfigChange, oSubmenu);

                    this.renderEvent.unsubscribe(this._onParentMenuRender,
                        oSubmenu);

                }

                this.removeItem(oItem, oItem.groupIndex);

            }

        }
        while (i--);

    }


    if (oHeader) {

        Event.purgeElement(oHeader);
        oElement.removeChild(oHeader);

    }


    if (oFooter) {

        Event.purgeElement(oFooter);
        oElement.removeChild(oFooter);
    }


    if (oBody) {

        Event.purgeElement(oBody);

        oBody.innerHTML = _EMPTY_STRING;

    }

    this.activeItem = null;

    this._aItemGroups = [];
    this._aListElements = [];
    this._aGroupTitleElements = [];

    this.cfg.setProperty(_WIDTH, null);

},


/**
* @method destroy
* @description Removes the menu's <code>&#60;div&#62;</code> element
* (and accompanying child nodes) from the document.
*/
destroy: function () {


    this.clearContent();

    this._aItemGroups = null;
    this._aListElements = null;
    this._aGroupTitleElements = null;



    Menu.superclass.destroy.call(this);


},


/**
* @method setInitialFocus
* @description Sets focus to the menu's first enabled item.
*/
setInitialFocus: function () {

    var oItem = this._getFirstEnabledItem();

    if (oItem) {

        oItem.focus();

    }

},


/**
* @method setInitialSelection
* @description Sets the "selected" configuration property of the menu's first
* enabled item to "true."
*/
setInitialSelection: function () {

    var oItem = this._getFirstEnabledItem();

    if (oItem) {

        oItem.cfg.setProperty(_SELECTED, true);
    }

},


/**
* @method clearActiveItem
* @description Sets the "selected" configuration property of the menu's active
* item to "false" and hides the item's submenu.
* @param {Boolean} p_bBlur Boolean indicating if the menu's active item
* should be blurred.
*/
clearActiveItem: function (p_bBlur) {

    if (this.cfg.getProperty(_SHOW_DELAY) > 0) {

        this._cancelShowDelay();

    }


    var oActiveItem = this.activeItem,
        oConfig,
        oSubmenu;

    if (oActiveItem) {

        oConfig = oActiveItem.cfg;

        if (p_bBlur) {

            oActiveItem.blur();

            this.getRoot()._hasFocus = true;

        }

        oConfig.setProperty(_SELECTED, false);

        oSubmenu = oConfig.getProperty(_SUBMENU);


        if (oSubmenu) {

            oSubmenu.hide();

        }

        this.activeItem = null;

    }

},


/**
* @method focus
* @description Causes the menu to receive focus and fires the "focus" event.
*/
focus: function () {

    if (!this.hasFocus()) {

        this.setInitialFocus();

    }

},


/**
* @method blur
* @description Causes the menu to lose focus and fires the "blur" event.
*/
blur: function () {

    var oItem;

    if (this.hasFocus()) {

        oItem = MenuManager.getFocusedMenuItem();

        if (oItem) {

            oItem.blur();

        }

    }

},


/**
* @method hasFocus
* @description Returns a boolean indicating whether or not the menu has focus.
* @return {Boolean}
*/
hasFocus: function () {

    return (MenuManager.getFocusedMenu() == this.getRoot());

},


_doItemSubmenuSubscribe: function (p_sType, p_aArgs, p_oObject) {

    var oItem = p_aArgs[0],
        oSubmenu = oItem.cfg.getProperty(_SUBMENU);

    if (oSubmenu) {
        oSubmenu.subscribe.apply(oSubmenu, p_oObject);
    }

},


_doSubmenuSubscribe: function (p_sType, p_aArgs, p_oObject) {

    var oSubmenu = this.cfg.getProperty(_SUBMENU);

    if (oSubmenu) {
        oSubmenu.subscribe.apply(oSubmenu, p_oObject);
    }

},


/**
* Adds the specified CustomEvent subscriber to the menu and each of
* its submenus.
* @method subscribe
* @param p_type     {string}   the type, or name of the event
* @param p_fn       {function} the function to exectute when the event fires
* @param p_obj      {Object}   An object to be passed along when the event
*                              fires
* @param p_override {boolean}  If true, the obj passed in becomes the
*                              execution scope of the listener
*/
subscribe: function () {

    Menu.superclass.subscribe.apply(this, arguments);

    Menu.superclass.subscribe.call(this, _ITEM_ADDED, this._doItemSubmenuSubscribe, arguments);


    var aItems = this.getItems(),
        nItems,
        oItem,
        oSubmenu,
        i;


    if (aItems) {

        nItems = aItems.length;

        if (nItems > 0) {

            i = nItems - 1;

            do {

                oItem = aItems[i];
                oSubmenu = oItem.cfg.getProperty(_SUBMENU);

                if (oSubmenu) {
                    oSubmenu.subscribe.apply(oSubmenu, arguments);
                }
                else {
                    oItem.cfg.subscribeToConfigEvent(_SUBMENU, this._doSubmenuSubscribe, arguments);
                }

            }
            while (i--);

        }

    }

},


unsubscribe: function () {

    Menu.superclass.unsubscribe.apply(this, arguments);

    Menu.superclass.unsubscribe.call(this, _ITEM_ADDED, this._doItemSubmenuSubscribe, arguments);


    var aItems = this.getItems(),
        nItems,
        oItem,
        oSubmenu,
        i;


    if (aItems) {

        nItems = aItems.length;

        if (nItems > 0) {

            i = nItems - 1;

            do {

                oItem = aItems[i];
                oSubmenu = oItem.cfg.getProperty(_SUBMENU);

                if (oSubmenu) {
                    oSubmenu.unsubscribe.apply(oSubmenu, arguments);
                }
                else {
                    oItem.cfg.unsubscribeFromConfigEvent(_SUBMENU, this._doSubmenuSubscribe, arguments);
                }

            }
            while (i--);

        }

    }

},


/**
* @description Initializes the class's configurable properties which can be
* changed using the menu's Config object ("cfg").
* @method initDefaultConfig
*/
initDefaultConfig: function () {

    Menu.superclass.initDefaultConfig.call(this);

    var oConfig = this.cfg;



    /**
    * @config effect
    * @description Object or array of objects representing the ContainerEffect
    * classes that are active for animating the container.  When set this
    * property is automatically applied to all submenus.
    * @type Object
    * @default null
    */



    /**
    * @config x
    * @description Number representing the absolute x-coordinate position of
    * the Menu.  This property is only applied when the "position"
    * configuration property is set to dynamic.
    * @type Number
    * @default null
    */


    /**
    * @config y
    * @description Number representing the absolute y-coordinate position of
    * the Menu.  This property is only applied when the "position"
    * configuration property is set to dynamic.
    * @type Number
    * @default null
    */


    /**
    * @description Array of the absolute x and y positions of the Menu.  This
    * property is only applied when the "position" configuration property is
    * set to dynamic.
    * @config xy
    * @type Number[]
    * @default null
    */


    /**
    * @config context
    * @description Array of context arguments for context-sensitive positioning.
    * The format is: [id or element, element corner, context corner].
    * For example, setting this property to ["img1", "tl", "bl"] would
    * align the Menu's top left corner to the context element's
    * bottom left corner.  This property is only applied when the "position"
    * configuration property is set to dynamic.
    * @type Array
    * @default null
    */


    /**
    * @config fixedcenter
    * @description Boolean indicating if the Menu should be anchored to the
    * center of the viewport.  This property is only applied when the
    * "position" configuration property is set to dynamic.
    * @type Boolean
    * @default false
    */


    /**
    * @config iframe
    * @description Boolean indicating whether or not the Menu should
    * have an IFRAME shim; used to prevent SELECT elements from
    * poking through an Overlay instance in IE6.  When set to "true",
    * the iframe shim is created when the Menu instance is intially
    * made visible.  This property is only applied when the "position"
    * configuration property is set to dynamic and is automatically applied
    * to all submenus.
    * @type Boolean
    * @default true for IE6 and below, false for all other browsers.
    */



    /*
        Change the default value for the "visible" configuration
        property to "false" by re-adding the property.
    */

    /**
    * @config visible
    * @description Boolean indicating whether or not the menu is visible.  If
    * the menu's "position" configuration property is set to "dynamic" (the
    * default), this property toggles the menu's <code>&#60;div&#62;</code>
    * element's "visibility" style property between "visible" (true) or
    * "hidden" (false).  If the menu's "position" configuration property is
    * set to "static" this property toggles the menu's
    * <code>&#60;div&#62;</code> element's "display" style property
    * between "block" (true) or "none" (false).
    * @default false
    * @type Boolean
    */
    oConfig.addProperty(
        VISIBLE_CONFIG.key,
        {
            handler: this.configVisible,
            value: VISIBLE_CONFIG.value,
            validator: VISIBLE_CONFIG.validator
        }
     );


    /*
        Change the default value for the "constraintoviewport" configuration
        property (inherited by YAHOO.widget.Overlay) to "true" by re-adding the property.
    */

    /**
    * @config constraintoviewport
    * @description Boolean indicating if the menu will try to remain inside
    * the boundaries of the size of viewport.  This property is only applied
    * when the "position" configuration property is set to dynamic and is
    * automatically applied to all submenus.
    * @default true
    * @type Boolean
    */
    oConfig.addProperty(
        CONSTRAIN_TO_VIEWPORT_CONFIG.key,
        {
            handler: this.configConstrainToViewport,
            value: CONSTRAIN_TO_VIEWPORT_CONFIG.value,
            validator: CONSTRAIN_TO_VIEWPORT_CONFIG.validator,
            supercedes: CONSTRAIN_TO_VIEWPORT_CONFIG.supercedes
        }
    );


    /*
        Change the default value for the "preventcontextoverlap" configuration
        property (inherited by YAHOO.widget.Overlay) to "true" by re-adding the property.
    */

	/**
	* @config preventcontextoverlap
	* @description Boolean indicating whether or not a submenu should overlap its parent MenuItem
	* when the "constraintoviewport" configuration property is set to "true".
	* @type Boolean
	* @default true
	*/
	oConfig.addProperty(PREVENT_CONTEXT_OVERLAP_CONFIG.key, {

		value: PREVENT_CONTEXT_OVERLAP_CONFIG.value,
		validator: PREVENT_CONTEXT_OVERLAP_CONFIG.validator,
		supercedes: PREVENT_CONTEXT_OVERLAP_CONFIG.supercedes

	});


    /**
    * @config position
    * @description String indicating how a menu should be positioned on the
    * screen.  Possible values are "static" and "dynamic."  Static menus are
    * visible by default and reside in the normal flow of the document
    * (CSS position: static).  Dynamic menus are hidden by default, reside
    * out of the normal flow of the document (CSS position: absolute), and
    * can overlay other elements on the screen.
    * @default dynamic
    * @type String
    */
    oConfig.addProperty(
        POSITION_CONFIG.key,
        {
            handler: this.configPosition,
            value: POSITION_CONFIG.value,
            validator: POSITION_CONFIG.validator,
            supercedes: POSITION_CONFIG.supercedes
        }
    );


    /**
    * @config submenualignment
    * @description Array defining how submenus should be aligned to their
    * parent menu item. The format is: [itemCorner, submenuCorner]. By default
    * a submenu's top left corner is aligned to its parent menu item's top
    * right corner.
    * @default ["tl","tr"]
    * @type Array
    */
    oConfig.addProperty(
        SUBMENU_ALIGNMENT_CONFIG.key,
        {
            value: SUBMENU_ALIGNMENT_CONFIG.value,
            suppressEvent: SUBMENU_ALIGNMENT_CONFIG.suppressEvent
        }
    );


    /**
    * @config autosubmenudisplay
    * @description Boolean indicating if submenus are automatically made
    * visible when the user mouses over the menu's items.
    * @default true
    * @type Boolean
    */
	oConfig.addProperty(
	   AUTO_SUBMENU_DISPLAY_CONFIG.key,
	   {
	       value: AUTO_SUBMENU_DISPLAY_CONFIG.value,
	       validator: AUTO_SUBMENU_DISPLAY_CONFIG.validator,
	       suppressEvent: AUTO_SUBMENU_DISPLAY_CONFIG.suppressEvent
       }
    );


    /**
    * @config showdelay
    * @description Number indicating the time (in milliseconds) that should
    * expire before a submenu is made visible when the user mouses over
    * the menu's items.  This property is only applied when the "position"
    * configuration property is set to dynamic and is automatically applied
    * to all submenus.
    * @default 250
    * @type Number
    */
	oConfig.addProperty(
	   SHOW_DELAY_CONFIG.key,
	   {
	       value: SHOW_DELAY_CONFIG.value,
	       validator: SHOW_DELAY_CONFIG.validator,
	       suppressEvent: SHOW_DELAY_CONFIG.suppressEvent
       }
    );


    /**
    * @config hidedelay
    * @description Number indicating the time (in milliseconds) that should
    * expire before the menu is hidden.  This property is only applied when
    * the "position" configuration property is set to dynamic and is
    * automatically applied to all submenus.
    * @default 0
    * @type Number
    */
	oConfig.addProperty(
	   HIDE_DELAY_CONFIG.key,
	   {
	       handler: this.configHideDelay,
	       value: HIDE_DELAY_CONFIG.value,
	       validator: HIDE_DELAY_CONFIG.validator,
	       suppressEvent: HIDE_DELAY_CONFIG.suppressEvent
       }
    );


    /**
    * @config submenuhidedelay
    * @description Number indicating the time (in milliseconds) that should
    * expire before a submenu is hidden when the user mouses out of a menu item
    * heading in the direction of a submenu.  The value must be greater than or
    * equal to the value specified for the "showdelay" configuration property.
    * This property is only applied when the "position" configuration property
    * is set to dynamic and is automatically applied to all submenus.
    * @default 250
    * @type Number
    */
	oConfig.addProperty(
	   SUBMENU_HIDE_DELAY_CONFIG.key,
	   {
	       value: SUBMENU_HIDE_DELAY_CONFIG.value,
	       validator: SUBMENU_HIDE_DELAY_CONFIG.validator,
	       suppressEvent: SUBMENU_HIDE_DELAY_CONFIG.suppressEvent
       }
    );


    /**
    * @config clicktohide
    * @description Boolean indicating if the menu will automatically be
    * hidden if the user clicks outside of it.  This property is only
    * applied when the "position" configuration property is set to dynamic
    * and is automatically applied to all submenus.
    * @default true
    * @type Boolean
    */
    oConfig.addProperty(
        CLICK_TO_HIDE_CONFIG.key,
        {
            value: CLICK_TO_HIDE_CONFIG.value,
            validator: CLICK_TO_HIDE_CONFIG.validator,
            suppressEvent: CLICK_TO_HIDE_CONFIG.suppressEvent
        }
    );


	/**
	* @config container
	* @description HTML element reference or string specifying the id
	* attribute of the HTML element that the menu's markup should be
	* rendered into.
	* @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
	* level-one-html.html#ID-58190037">HTMLElement</a>|String
	* @default document.body
	*/
	oConfig.addProperty(
	   CONTAINER_CONFIG.key,
	   {
	       handler: this.configContainer,
	       value: document.body,
           suppressEvent: CONTAINER_CONFIG.suppressEvent
       }
   );


    /**
    * @config scrollincrement
    * @description Number used to control the scroll speed of a menu.  Used to
    * increment the "scrollTop" property of the menu's body by when a menu's
    * content is scrolling.  When set this property is automatically applied
    * to all submenus.
    * @default 1
    * @type Number
    */
    oConfig.addProperty(
        SCROLL_INCREMENT_CONFIG.key,
        {
            value: SCROLL_INCREMENT_CONFIG.value,
            validator: SCROLL_INCREMENT_CONFIG.validator,
            supercedes: SCROLL_INCREMENT_CONFIG.supercedes,
            suppressEvent: SCROLL_INCREMENT_CONFIG.suppressEvent
        }
    );


    /**
    * @config minscrollheight
    * @description Number defining the minimum threshold for the "maxheight"
    * configuration property.  When set this property is automatically applied
    * to all submenus.
    * @default 90
    * @type Number
    */
    oConfig.addProperty(
        MIN_SCROLL_HEIGHT_CONFIG.key,
        {
            value: MIN_SCROLL_HEIGHT_CONFIG.value,
            validator: MIN_SCROLL_HEIGHT_CONFIG.validator,
            supercedes: MIN_SCROLL_HEIGHT_CONFIG.supercedes,
            suppressEvent: MIN_SCROLL_HEIGHT_CONFIG.suppressEvent
        }
    );


    /**
    * @config maxheight
    * @description Number defining the maximum height (in pixels) for a menu's
    * body element (<code>&#60;div class="bd"&#62;</code>).  Once a menu's body
    * exceeds this height, the contents of the body are scrolled to maintain
    * this value.  This value cannot be set lower than the value of the
    * "minscrollheight" configuration property.
    * @default 0
    * @type Number
    */
    oConfig.addProperty(
       MAX_HEIGHT_CONFIG.key,
       {
            handler: this.configMaxHeight,
            value: MAX_HEIGHT_CONFIG.value,
            validator: MAX_HEIGHT_CONFIG.validator,
            suppressEvent: MAX_HEIGHT_CONFIG.suppressEvent,
            supercedes: MAX_HEIGHT_CONFIG.supercedes
       }
    );


    /**
    * @config classname
    * @description String representing the CSS class to be applied to the
    * menu's root <code>&#60;div&#62;</code> element.  The specified class(es)
    * are appended in addition to the default class as specified by the menu's
    * CSS_CLASS_NAME constant. When set this property is automatically
    * applied to all submenus.
    * @default null
    * @type String
    */
    oConfig.addProperty(
        CLASS_NAME_CONFIG.key,
        {
            handler: this.configClassName,
            value: CLASS_NAME_CONFIG.value,
            validator: CLASS_NAME_CONFIG.validator,
            supercedes: CLASS_NAME_CONFIG.supercedes
        }
    );


    /**
    * @config disabled
    * @description Boolean indicating if the menu should be disabled.
    * Disabling a menu disables each of its items.  (Disabled menu items are
    * dimmed and will not respond to user input or fire events.)  Disabled
    * menus have a corresponding "disabled" CSS class applied to their root
    * <code>&#60;div&#62;</code> element.
    * @default false
    * @type Boolean
    */
    oConfig.addProperty(
        DISABLED_CONFIG.key,
        {
            handler: this.configDisabled,
            value: DISABLED_CONFIG.value,
            validator: DISABLED_CONFIG.validator,
            suppressEvent: DISABLED_CONFIG.suppressEvent
        }
    );


    /**
    * @config shadow
    * @description Boolean indicating if the menu should have a shadow.
    * @default true
    * @type Boolean
    */
    oConfig.addProperty(
        SHADOW_CONFIG.key,
        {
            handler: this.configShadow,
            value: SHADOW_CONFIG.value,
            validator: SHADOW_CONFIG.validator
        }
    );


    /**
    * @config keepopen
    * @description Boolean indicating if the menu should remain open when clicked.
    * @default false
    * @type Boolean
    */
    oConfig.addProperty(
        KEEP_OPEN_CONFIG.key,
        {
            value: KEEP_OPEN_CONFIG.value,
            validator: KEEP_OPEN_CONFIG.validator
        }
    );

}

}); // END YAHOO.lang.extend

})();



(function () {

/**
* Creates an item for a menu.
*
* @param {String} p_oObject String specifying the text of the menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object specifying
* the <code>&#60;li&#62;</code> element of the menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject Object
* specifying the <code>&#60;optgroup&#62;</code> element of the menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject Object
* specifying the <code>&#60;option&#62;</code> element of the menu item.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu item. See configuration class documentation
* for more details.
* @class MenuItem
* @constructor
*/
YAHOO.widget.MenuItem = function (p_oObject, p_oConfig) {

    if (p_oObject) {

        if (p_oConfig) {

            this.parent = p_oConfig.parent;
            this.value = p_oConfig.value;
            this.id = p_oConfig.id;

        }

        this.init(p_oObject, p_oConfig);

    }

};


var Dom = YAHOO.util.Dom,
    Module = YAHOO.widget.Module,
    Menu = YAHOO.widget.Menu,
    MenuItem = YAHOO.widget.MenuItem,
    CustomEvent = YAHOO.util.CustomEvent,
    UA = YAHOO.env.ua,
    Lang = YAHOO.lang,


	_TEXT = "text",
	_HASH = "#",
	_HYPHEN = "-",
	_HELP_TEXT = "helptext",
	_URL = "url",
	_TARGET = "target",
	_EMPHASIS = "emphasis",
	_STRONG_EMPHASIS = "strongemphasis",
	_CHECKED = "checked",
	_SUBMENU = "submenu",
	_DISABLED = "disabled",
	_SELECTED = "selected",
	_HAS_SUBMENU = "hassubmenu",
	_CHECKED_DISABLED = "checked-disabled",
	_HAS_SUBMENU_DISABLED = "hassubmenu-disabled",
	_HAS_SUBMENU_SELECTED = "hassubmenu-selected",
	_CHECKED_SELECTED = "checked-selected",
	_ONCLICK = "onclick",
	_CLASSNAME = "classname",
	_EMPTY_STRING = "",
	_OPTION = "OPTION",
	_OPTGROUP = "OPTGROUP",
	_LI_UPPERCASE = "LI",
	_HREF = "href",
	_SELECT = "SELECT",
	_DIV = "DIV",
	_START_HELP_TEXT = "<em class=\"helptext\">",
	_START_EM = "<em>",
	_END_EM = "</em>",
	_START_STRONG = "<strong>",
	_END_STRONG = "</strong>",
	_PREVENT_CONTEXT_OVERLAP = "preventcontextoverlap",
	_OBJ = "obj",
	_SCOPE = "scope",
	_NONE = "none",
	_VISIBLE = "visible",
	_SPACE = " ",
	_MENUITEM = "MenuItem",
	_CLICK = "click",
	_SHOW = "show",
	_HIDE = "hide",
	_LI_LOWERCASE = "li",
	_ANCHOR_TEMPLATE = "<a href=\"#\"></a>",

    EVENT_TYPES = [

        ["mouseOverEvent", "mouseover"],
        ["mouseOutEvent", "mouseout"],
        ["mouseDownEvent", "mousedown"],
        ["mouseUpEvent", "mouseup"],
        ["clickEvent", _CLICK],
        ["keyPressEvent", "keypress"],
        ["keyDownEvent", "keydown"],
        ["keyUpEvent", "keyup"],
        ["focusEvent", "focus"],
        ["blurEvent", "blur"],
        ["destroyEvent", "destroy"]

    ],

	TEXT_CONFIG = {
		key: _TEXT,
		value: _EMPTY_STRING,
		validator: Lang.isString,
		suppressEvent: true
	},

	HELP_TEXT_CONFIG = {
		key: _HELP_TEXT,
		supercedes: [_TEXT],
		suppressEvent: true
	},

	URL_CONFIG = {
		key: _URL,
		value: _HASH,
		suppressEvent: true
	},

	TARGET_CONFIG = {
		key: _TARGET,
		suppressEvent: true
	},

	EMPHASIS_CONFIG = {
		key: _EMPHASIS,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true,
		supercedes: [_TEXT]
	},

	STRONG_EMPHASIS_CONFIG = {
		key: _STRONG_EMPHASIS,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true,
		supercedes: [_TEXT]
	},

	CHECKED_CONFIG = {
		key: _CHECKED,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true,
		supercedes: [_DISABLED, _SELECTED]
	},

	SUBMENU_CONFIG = {
		key: _SUBMENU,
		suppressEvent: true,
		supercedes: [_DISABLED, _SELECTED]
	},

	DISABLED_CONFIG = {
		key: _DISABLED,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true,
		supercedes: [_TEXT, _SELECTED]
	},

	SELECTED_CONFIG = {
		key: _SELECTED,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true
	},

	ONCLICK_CONFIG = {
		key: _ONCLICK,
		suppressEvent: true
	},

	CLASS_NAME_CONFIG = {
		key: _CLASSNAME,
		value: null,
		validator: Lang.isString,
		suppressEvent: true
	},

	KEY_LISTENER_CONFIG = {
		key: "keylistener",
		value: null,
		suppressEvent: true
	},

	m_oMenuItemTemplate = null,

    CLASS_NAMES = {};


/**
* @method getClassNameForState
* @description Returns a class name for the specified prefix and state.  If the class name does not
* yet exist, it is created and stored in the CLASS_NAMES object to increase performance.
* @private
* @param {String} prefix String representing the prefix for the class name
* @param {String} state String representing a state - "disabled," "checked," etc.
*/
var getClassNameForState = function (prefix, state) {

	var oClassNames = CLASS_NAMES[prefix];

	if (!oClassNames) {
		CLASS_NAMES[prefix] = {};
		oClassNames = CLASS_NAMES[prefix];
	}


	var sClassName = oClassNames[state];

	if (!sClassName) {
		sClassName = prefix + _HYPHEN + state;
		oClassNames[state] = sClassName;
	}

	return sClassName;

};


/**
* @method addClassNameForState
* @description Applies a class name to a MenuItem instance's &#60;LI&#62; and &#60;A&#62; elements
* that represents a MenuItem's state - "disabled," "checked," etc.
* @private
* @param {String} state String representing a state - "disabled," "checked," etc.
*/
var addClassNameForState = function (state) {

	Dom.addClass(this.element, getClassNameForState(this.CSS_CLASS_NAME, state));
	Dom.addClass(this._oAnchor, getClassNameForState(this.CSS_LABEL_CLASS_NAME, state));

};

/**
* @method removeClassNameForState
* @description Removes a class name from a MenuItem instance's &#60;LI&#62; and &#60;A&#62; elements
* that represents a MenuItem's state - "disabled," "checked," etc.
* @private
* @param {String} state String representing a state - "disabled," "checked," etc.
*/
var removeClassNameForState = function (state) {

	Dom.removeClass(this.element, getClassNameForState(this.CSS_CLASS_NAME, state));
	Dom.removeClass(this._oAnchor, getClassNameForState(this.CSS_LABEL_CLASS_NAME, state));

};


MenuItem.prototype = {

    /**
    * @property CSS_CLASS_NAME
    * @description String representing the CSS class(es) to be applied to the
    * <code>&#60;li&#62;</code> element of the menu item.
    * @default "yuimenuitem"
    * @final
    * @type String
    */
    CSS_CLASS_NAME: "yuimenuitem",


    /**
    * @property CSS_LABEL_CLASS_NAME
    * @description String representing the CSS class(es) to be applied to the
    * menu item's <code>&#60;a&#62;</code> element.
    * @default "yuimenuitemlabel"
    * @final
    * @type String
    */
    CSS_LABEL_CLASS_NAME: "yuimenuitemlabel",


    /**
    * @property SUBMENU_TYPE
    * @description Object representing the type of menu to instantiate and
    * add when parsing the child nodes of the menu item's source HTML element.
    * @final
    * @type YAHOO.widget.Menu
    */
    SUBMENU_TYPE: null,





    /**
    * @property _oAnchor
    * @description Object reference to the menu item's
    * <code>&#60;a&#62;</code> element.
    * @default null
    * @private
    * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-48250443">HTMLAnchorElement</a>
    */
    _oAnchor: null,


    /**
    * @property _oHelpTextEM
    * @description Object reference to the menu item's help text
    * <code>&#60;em&#62;</code> element.
    * @default null
    * @private
    * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-58190037">HTMLElement</a>
    */
    _oHelpTextEM: null,


    /**
    * @property _oSubmenu
    * @description Object reference to the menu item's submenu.
    * @default null
    * @private
    * @type YAHOO.widget.Menu
    */
    _oSubmenu: null,


    /**
    * @property _oOnclickAttributeValue
    * @description Object reference to the menu item's current value for the
    * "onclick" configuration attribute.
    * @default null
    * @private
    * @type Object
    */
    _oOnclickAttributeValue: null,


    /**
    * @property _sClassName
    * @description The current value of the "classname" configuration attribute.
    * @default null
    * @private
    * @type String
    */
    _sClassName: null,





	/**
    * @property constructor
	* @description Object reference to the menu item's constructor function.
    * @default YAHOO.widget.MenuItem
	* @type YAHOO.widget.MenuItem
	*/
	constructor: MenuItem,


    /**
    * @property index
    * @description Number indicating the ordinal position of the menu item in
    * its group.
    * @default null
    * @type Number
    */
    index: null,


    /**
    * @property groupIndex
    * @description Number indicating the index of the group to which the menu
    * item belongs.
    * @default null
    * @type Number
    */
    groupIndex: null,


    /**
    * @property parent
    * @description Object reference to the menu item's parent menu.
    * @default null
    * @type YAHOO.widget.Menu
    */
    parent: null,


    /**
    * @property element
    * @description Object reference to the menu item's
    * <code>&#60;li&#62;</code> element.
    * @default <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level
    * -one-html.html#ID-74680021">HTMLLIElement</a>
    * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-74680021">HTMLLIElement</a>
    */
    element: null,


    /**
    * @property srcElement
    * @description Object reference to the HTML element (either
    * <code>&#60;li&#62;</code>, <code>&#60;optgroup&#62;</code> or
    * <code>&#60;option&#62;</code>) used create the menu item.
    * @default <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
    * level-one-html.html#ID-74680021">HTMLLIElement</a>|<a href="http://www.
    * w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-38450247"
    * >HTMLOptGroupElement</a>|<a href="http://www.w3.org/TR/2000/WD-DOM-
    * Level-1-20000929/level-one-html.html#ID-70901257">HTMLOptionElement</a>
    * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-74680021">HTMLLIElement</a>|<a href="http://www.w3.
    * org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-38450247">
    * HTMLOptGroupElement</a>|<a href="http://www.w3.org/TR/2000/WD-DOM-
    * Level-1-20000929/level-one-html.html#ID-70901257">HTMLOptionElement</a>
    */
    srcElement: null,


    /**
    * @property value
    * @description Object reference to the menu item's value.
    * @default null
    * @type Object
    */
    value: null,


	/**
    * @property browser
    * @deprecated Use YAHOO.env.ua
	* @description String representing the browser.
	* @type String
	*/
	browser: Module.prototype.browser,


    /**
    * @property id
    * @description Id of the menu item's root <code>&#60;li&#62;</code>
    * element.  This property should be set via the constructor using the
    * configuration object literal.  If an id is not specified, then one will
    * be created using the "generateId" method of the Dom utility.
    * @default null
    * @type String
    */
    id: null,





    /**
    * @event destroyEvent
    * @description Fires when the menu item's <code>&#60;li&#62;</code>
    * element is removed from its parent <code>&#60;ul&#62;</code> element.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event mouseOverEvent
    * @description Fires when the mouse has entered the menu item.  Passes
    * back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event mouseOutEvent
    * @description Fires when the mouse has left the menu item.  Passes back
    * the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event mouseDownEvent
    * @description Fires when the user mouses down on the menu item.  Passes
    * back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event mouseUpEvent
    * @description Fires when the user releases a mouse button while the mouse
    * is over the menu item.  Passes back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event clickEvent
    * @description Fires when the user clicks the on the menu item.  Passes
    * back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event keyPressEvent
    * @description Fires when the user presses an alphanumeric key when the
    * menu item has focus.  Passes back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event keyDownEvent
    * @description Fires when the user presses a key when the menu item has
    * focus.  Passes back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event keyUpEvent
    * @description Fires when the user releases a key when the menu item has
    * focus.  Passes back the DOM Event object as an argument.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event focusEvent
    * @description Fires when the menu item receives focus.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event blurEvent
    * @description Fires when the menu item loses the input focus.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @method init
    * @description The MenuItem class's initialization method. This method is
    * automatically called by the constructor, and sets up all DOM references
    * for pre-existing markup, and creates required markup if it is not
    * already present.
    * @param {String} p_oObject String specifying the text of the menu item.
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object specifying
    * the <code>&#60;li&#62;</code> element of the menu item.
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject Object
    * specifying the <code>&#60;optgroup&#62;</code> element of the menu item.
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject Object
    * specifying the <code>&#60;option&#62;</code> element of the menu item.
    * @param {Object} p_oConfig Optional. Object literal specifying the
    * configuration for the menu item. See configuration class documentation
    * for more details.
    */
    init: function (p_oObject, p_oConfig) {


        if (!this.SUBMENU_TYPE) {

            this.SUBMENU_TYPE = Menu;

        }



        this.cfg = new YAHOO.util.Config(this);

        this.initDefaultConfig();

        var oConfig = this.cfg,
            sURL = _HASH,
            oCustomEvent,
			aEventData,
            oAnchor,
            sTarget,
            sText,
            sId,
            i;


        if (Lang.isString(p_oObject)) {

            this._createRootNodeStructure();

            oConfig.queueProperty(_TEXT, p_oObject);

        }
        else if (p_oObject && p_oObject.tagName) {

            switch(p_oObject.tagName.toUpperCase()) {

                case _OPTION:

                    this._createRootNodeStructure();

                    oConfig.queueProperty(_TEXT, p_oObject.text);
                    oConfig.queueProperty(_DISABLED, p_oObject.disabled);

                    this.value = p_oObject.value;

                    this.srcElement = p_oObject;

                break;

                case _OPTGROUP:

                    this._createRootNodeStructure();

                    oConfig.queueProperty(_TEXT, p_oObject.label);
                    oConfig.queueProperty(_DISABLED, p_oObject.disabled);

                    this.srcElement = p_oObject;

                    this._initSubTree();

                break;

                case _LI_UPPERCASE:


                    oAnchor = Dom.getFirstChild(p_oObject);



                    if (oAnchor) {

                        sURL = oAnchor.getAttribute(_HREF, 2);
                        sTarget = oAnchor.getAttribute(_TARGET);

                        sText = oAnchor.innerHTML;

                    }

                    this.srcElement = p_oObject;
                    this.element = p_oObject;
                    this._oAnchor = oAnchor;

                    /*
                        Set these properties silently to sync up the
                        configuration object without making changes to the
                        element's DOM
                    */

                    oConfig.setProperty(_TEXT, sText, true);
                    oConfig.setProperty(_URL, sURL, true);
                    oConfig.setProperty(_TARGET, sTarget, true);

                    this._initSubTree();

                break;

            }

        }


        if (this.element) {

            sId = (this.srcElement || this.element).id;

            if (!sId) {

                sId = this.id || Dom.generateId();

                this.element.id = sId;

            }

            this.id = sId;


            Dom.addClass(this.element, this.CSS_CLASS_NAME);
            Dom.addClass(this._oAnchor, this.CSS_LABEL_CLASS_NAME);


			i = EVENT_TYPES.length - 1;

			do {

				aEventData = EVENT_TYPES[i];

				oCustomEvent = this.createEvent(aEventData[1]);
				oCustomEvent.signature = CustomEvent.LIST;

				this[aEventData[0]] = oCustomEvent;

			}
			while (i--);


            if (p_oConfig) {

                oConfig.applyConfig(p_oConfig);

            }

            oConfig.fireQueue();

        }

    },




    /**
    * @method _createRootNodeStructure
    * @description Creates the core DOM structure for the menu item.
    * @private
    */
    _createRootNodeStructure: function () {

        var oElement,
            oAnchor;

        if (!m_oMenuItemTemplate) {

            m_oMenuItemTemplate = document.createElement(_LI_LOWERCASE);
            m_oMenuItemTemplate.innerHTML = _ANCHOR_TEMPLATE;

        }

        oElement = m_oMenuItemTemplate.cloneNode(true);
        oElement.className = this.CSS_CLASS_NAME;

        oAnchor = oElement.firstChild;
        oAnchor.className = this.CSS_LABEL_CLASS_NAME;

        this.element = oElement;
        this._oAnchor = oAnchor;

    },


    /**
    * @method _initSubTree
    * @description Iterates the source element's childNodes collection and uses
    * the child nodes to instantiate other menus.
    * @private
    */
    _initSubTree: function () {

        var oSrcEl = this.srcElement,
            oConfig = this.cfg,
            oNode,
            aOptions,
            nOptions,
            oMenu,
            n;


        if (oSrcEl.childNodes.length > 0) {

            if (this.parent.lazyLoad && this.parent.srcElement &&
                this.parent.srcElement.tagName.toUpperCase() == _SELECT) {

                oConfig.setProperty(
                        _SUBMENU,
                        { id: Dom.generateId(), itemdata: oSrcEl.childNodes }
                    );

            }
            else {

                oNode = oSrcEl.firstChild;
                aOptions = [];

                do {

                    if (oNode && oNode.tagName) {

                        switch(oNode.tagName.toUpperCase()) {

                            case _DIV:

                                oConfig.setProperty(_SUBMENU, oNode);

                            break;

                            case _OPTION:

                                aOptions[aOptions.length] = oNode;

                            break;

                        }

                    }

                }
                while((oNode = oNode.nextSibling));


                nOptions = aOptions.length;

                if (nOptions > 0) {

                    oMenu = new this.SUBMENU_TYPE(Dom.generateId());

                    oConfig.setProperty(_SUBMENU, oMenu);

                    for(n=0; n<nOptions; n++) {

                        oMenu.addItem((new oMenu.ITEM_TYPE(aOptions[n])));

                    }

                }

            }

        }

    },





    /**
    * @method configText
    * @description Event handler for when the "text" configuration property of
    * the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configText: function (p_sType, p_aArgs, p_oItem) {

        var sText = p_aArgs[0],
            oConfig = this.cfg,
            oAnchor = this._oAnchor,
            sHelpText = oConfig.getProperty(_HELP_TEXT),
            sHelpTextHTML = _EMPTY_STRING,
            sEmphasisStartTag = _EMPTY_STRING,
            sEmphasisEndTag = _EMPTY_STRING;


        if (sText) {


            if (sHelpText) {

                sHelpTextHTML = _START_HELP_TEXT + sHelpText + _END_EM;

            }


            if (oConfig.getProperty(_EMPHASIS)) {

                sEmphasisStartTag = _START_EM;
                sEmphasisEndTag = _END_EM;

            }


            if (oConfig.getProperty(_STRONG_EMPHASIS)) {

                sEmphasisStartTag = _START_STRONG;
                sEmphasisEndTag = _END_STRONG;

            }


            oAnchor.innerHTML = (sEmphasisStartTag + sText + sEmphasisEndTag + sHelpTextHTML);

        }

    },


    /**
    * @method configHelpText
    * @description Event handler for when the "helptext" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configHelpText: function (p_sType, p_aArgs, p_oItem) {

        this.cfg.refireEvent(_TEXT);

    },


    /**
    * @method configURL
    * @description Event handler for when the "url" configuration property of
    * the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configURL: function (p_sType, p_aArgs, p_oItem) {

        var sURL = p_aArgs[0];

        if (!sURL) {

            sURL = _HASH;

        }

        var oAnchor = this._oAnchor;

        if (UA.opera) {

            oAnchor.removeAttribute(_HREF);

        }

        oAnchor.setAttribute(_HREF, sURL);

    },


    /**
    * @method configTarget
    * @description Event handler for when the "target" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configTarget: function (p_sType, p_aArgs, p_oItem) {

        var sTarget = p_aArgs[0],
            oAnchor = this._oAnchor;

        if (sTarget && sTarget.length > 0) {

            oAnchor.setAttribute(_TARGET, sTarget);

        }
        else {

            oAnchor.removeAttribute(_TARGET);

        }

    },


    /**
    * @method configEmphasis
    * @description Event handler for when the "emphasis" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configEmphasis: function (p_sType, p_aArgs, p_oItem) {

        var bEmphasis = p_aArgs[0],
            oConfig = this.cfg;


        if (bEmphasis && oConfig.getProperty(_STRONG_EMPHASIS)) {

            oConfig.setProperty(_STRONG_EMPHASIS, false);

        }


        oConfig.refireEvent(_TEXT);

    },


    /**
    * @method configStrongEmphasis
    * @description Event handler for when the "strongemphasis" configuration
    * property of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configStrongEmphasis: function (p_sType, p_aArgs, p_oItem) {

        var bStrongEmphasis = p_aArgs[0],
            oConfig = this.cfg;


        if (bStrongEmphasis && oConfig.getProperty(_EMPHASIS)) {

            oConfig.setProperty(_EMPHASIS, false);

        }

        oConfig.refireEvent(_TEXT);

    },


    /**
    * @method configChecked
    * @description Event handler for when the "checked" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configChecked: function (p_sType, p_aArgs, p_oItem) {

        var bChecked = p_aArgs[0],
            oConfig = this.cfg;


        if (bChecked) {

            addClassNameForState.call(this, _CHECKED);

        }
        else {

            removeClassNameForState.call(this, _CHECKED);
        }


        oConfig.refireEvent(_TEXT);


        if (oConfig.getProperty(_DISABLED)) {

            oConfig.refireEvent(_DISABLED);

        }


        if (oConfig.getProperty(_SELECTED)) {

            oConfig.refireEvent(_SELECTED);

        }

    },



    /**
    * @method configDisabled
    * @description Event handler for when the "disabled" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configDisabled: function (p_sType, p_aArgs, p_oItem) {

        var bDisabled = p_aArgs[0],
            oConfig = this.cfg,
            oSubmenu = oConfig.getProperty(_SUBMENU),
            bChecked = oConfig.getProperty(_CHECKED);


        if (bDisabled) {

            if (oConfig.getProperty(_SELECTED)) {

                oConfig.setProperty(_SELECTED, false);

            }


			addClassNameForState.call(this, _DISABLED);


            if (oSubmenu) {

				addClassNameForState.call(this, _HAS_SUBMENU_DISABLED);

            }


            if (bChecked) {

				addClassNameForState.call(this, _CHECKED_DISABLED);

            }

        }
        else {

			removeClassNameForState.call(this, _DISABLED);


            if (oSubmenu) {

				removeClassNameForState.call(this, _HAS_SUBMENU_DISABLED);

            }


            if (bChecked) {

				removeClassNameForState.call(this, _CHECKED_DISABLED);

            }

        }

    },


    /**
    * @method configSelected
    * @description Event handler for when the "selected" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configSelected: function (p_sType, p_aArgs, p_oItem) {

        var oConfig = this.cfg,
        	oAnchor = this._oAnchor,

            bSelected = p_aArgs[0],
            bChecked = oConfig.getProperty(_CHECKED),
            oSubmenu = oConfig.getProperty(_SUBMENU);


        if (UA.opera) {

            oAnchor.blur();

        }


        if (bSelected && !oConfig.getProperty(_DISABLED)) {

			addClassNameForState.call(this, _SELECTED);


            if (oSubmenu) {

				addClassNameForState.call(this, _HAS_SUBMENU_SELECTED);

            }


            if (bChecked) {

				addClassNameForState.call(this, _CHECKED_SELECTED);

            }

        }
        else {

			removeClassNameForState.call(this, _SELECTED);


            if (oSubmenu) {

				removeClassNameForState.call(this, _HAS_SUBMENU_SELECTED);

            }


            if (bChecked) {

				removeClassNameForState.call(this, _CHECKED_SELECTED);

            }

        }


        if (this.hasFocus() && UA.opera) {

            oAnchor.focus();

        }

    },


    /**
    * @method _onSubmenuBeforeHide
    * @description "beforehide" Custom Event handler for a submenu.
    * @private
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    */
    _onSubmenuBeforeHide: function (p_sType, p_aArgs) {

        var oItem = this.parent,
            oMenu;

        function onHide() {

            oItem._oAnchor.blur();
            oMenu.beforeHideEvent.unsubscribe(onHide);

        }


        if (oItem.hasFocus()) {

            oMenu = oItem.parent;

            oMenu.beforeHideEvent.subscribe(onHide);

        }

    },


    /**
    * @method configSubmenu
    * @description Event handler for when the "submenu" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configSubmenu: function (p_sType, p_aArgs, p_oItem) {

        var oSubmenu = p_aArgs[0],
            oConfig = this.cfg,
            bLazyLoad = this.parent && this.parent.lazyLoad,
            oMenu,
            sSubmenuId,
            oSubmenuConfig;


        if (oSubmenu) {

            if (oSubmenu instanceof Menu) {

                oMenu = oSubmenu;
                oMenu.parent = this;
                oMenu.lazyLoad = bLazyLoad;

            }
            else if (Lang.isObject(oSubmenu) && oSubmenu.id && !oSubmenu.nodeType) {

                sSubmenuId = oSubmenu.id;
                oSubmenuConfig = oSubmenu;

                oSubmenuConfig.lazyload = bLazyLoad;
                oSubmenuConfig.parent = this;

                oMenu = new this.SUBMENU_TYPE(sSubmenuId, oSubmenuConfig);



                oConfig.setProperty(_SUBMENU, oMenu, true);

            }
            else {

                oMenu = new this.SUBMENU_TYPE(oSubmenu, { lazyload: bLazyLoad, parent: this });



                oConfig.setProperty(_SUBMENU, oMenu, true);

            }


            if (oMenu) {

				oMenu.cfg.setProperty(_PREVENT_CONTEXT_OVERLAP, true);

                addClassNameForState.call(this, _HAS_SUBMENU);


				if (oConfig.getProperty(_URL) === _HASH) {

					oConfig.setProperty(_URL, (_HASH + oMenu.id));

				}


                this._oSubmenu = oMenu;


                if (UA.opera) {

                    oMenu.beforeHideEvent.subscribe(this._onSubmenuBeforeHide);

                }

            }

        }
        else {

			removeClassNameForState.call(this, _HAS_SUBMENU);

            if (this._oSubmenu) {

                this._oSubmenu.destroy();

            }

        }


        if (oConfig.getProperty(_DISABLED)) {

            oConfig.refireEvent(_DISABLED);

        }


        if (oConfig.getProperty(_SELECTED)) {

            oConfig.refireEvent(_SELECTED);

        }

    },


    /**
    * @method configOnClick
    * @description Event handler for when the "onclick" configuration property
    * of the menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configOnClick: function (p_sType, p_aArgs, p_oItem) {

        var oObject = p_aArgs[0];

        /*
            Remove any existing listeners if a "click" event handler has
            already been specified.
        */

        if (this._oOnclickAttributeValue && (this._oOnclickAttributeValue != oObject)) {

            this.clickEvent.unsubscribe(this._oOnclickAttributeValue.fn,
                                this._oOnclickAttributeValue.obj);

            this._oOnclickAttributeValue = null;

        }


        if (!this._oOnclickAttributeValue && Lang.isObject(oObject) &&
            Lang.isFunction(oObject.fn)) {

            this.clickEvent.subscribe(oObject.fn,
                ((_OBJ in oObject) ? oObject.obj : this),
                ((_SCOPE in oObject) ? oObject.scope : null) );

            this._oOnclickAttributeValue = oObject;

        }

    },


    /**
    * @method configClassName
    * @description Event handler for when the "classname" configuration
    * property of a menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    * @param {YAHOO.widget.MenuItem} p_oItem Object representing the menu item
    * that fired the event.
    */
    configClassName: function (p_sType, p_aArgs, p_oItem) {

        var sClassName = p_aArgs[0];

        if (this._sClassName) {

            Dom.removeClass(this.element, this._sClassName);

        }

        Dom.addClass(this.element, sClassName);
        this._sClassName = sClassName;

    },


    /**
    * @method _dispatchClickEvent
    * @description Dispatches a DOM "click" event to the anchor element of a
	* MenuItem instance.
	* @private
    */
	_dispatchClickEvent: function () {

		var oMenuItem = this,
			oAnchor,
			oEvent;

		if (!oMenuItem.cfg.getProperty(_DISABLED)) {

			oAnchor = Dom.getFirstChild(oMenuItem.element);


			if (UA.ie) {
				oAnchor.fireEvent(_ONCLICK);
			}
			else {

				if ((UA.gecko && UA.gecko >= 1.9) || UA.opera || UA.webkit) {

					oEvent = document.createEvent("HTMLEvents");
					oEvent.initEvent(_CLICK, true, true);

				}
				else {

					oEvent = document.createEvent("MouseEvents");
					oEvent.initMouseEvent(_CLICK, true, true, window, 0, 0, 0,
						0, 0, false, false, false, false, 0, null);

				}

				oAnchor.dispatchEvent(oEvent);

			}

		}

	},


    /**
    * @method _createKeyListener
    * @description "show" event handler for a Menu instance - responsible for
	* setting up the KeyListener instance for a MenuItem.
	* @private
    * @param {String} type String representing the name of the event that
    * was fired.
    * @param {Array} args Array of arguments sent when the event was fired.
    * @param {Array} keyData Array of arguments sent when the event was fired.
    */
	_createKeyListener: function (type, args, keyData) {

		var oMenuItem = this,
			oMenu = oMenuItem.parent;

		var oKeyListener = new YAHOO.util.KeyListener(
										oMenu.element.ownerDocument,
										keyData,
										{
											fn: oMenuItem._dispatchClickEvent,
											scope: oMenuItem,
											correctScope: true });


		if (oMenu.cfg.getProperty(_VISIBLE)) {
			oKeyListener.enable();
		}


		oMenu.subscribe(_SHOW, oKeyListener.enable, null, oKeyListener);
		oMenu.subscribe(_HIDE, oKeyListener.disable, null, oKeyListener);

		oMenuItem._keyListener = oKeyListener;

		oMenu.unsubscribe(_SHOW, oMenuItem._createKeyListener, keyData);

	},


    /**
    * @method configKeyListener
    * @description Event handler for when the "keylistener" configuration
    * property of a menu item changes.
    * @param {String} p_sType String representing the name of the event that
    * was fired.
    * @param {Array} p_aArgs Array of arguments sent when the event was fired.
    */
    configKeyListener: function (p_sType, p_aArgs) {

		var oKeyData = p_aArgs[0],
			oMenuItem = this,
			oMenu = oMenuItem.parent;

		if (oMenuItem._keyData) {


			oMenu.unsubscribe(_SHOW,
					oMenuItem._createKeyListener, oMenuItem._keyData);

			oMenuItem._keyData = null;

		}



		if (oMenuItem._keyListener) {

			oMenu.unsubscribe(_SHOW, oMenuItem._keyListener.enable);
			oMenu.unsubscribe(_HIDE, oMenuItem._keyListener.disable);

			oMenuItem._keyListener.disable();
			oMenuItem._keyListener = null;

		}


    	if (oKeyData) {

			oMenuItem._keyData = oKeyData;


			oMenu.subscribe(_SHOW, oMenuItem._createKeyListener,
				oKeyData, oMenuItem);
		}

    },




	/**
    * @method initDefaultConfig
	* @description Initializes an item's configurable properties.
	*/
	initDefaultConfig : function () {

        var oConfig = this.cfg;



        /**
        * @config text
        * @description String specifying the text label for the menu item.
        * When building a menu from existing HTML the value of this property
        * will be interpreted from the menu's markup.
        * @default ""
        * @type String
        */
        oConfig.addProperty(
            TEXT_CONFIG.key,
            {
                handler: this.configText,
                value: TEXT_CONFIG.value,
                validator: TEXT_CONFIG.validator,
                suppressEvent: TEXT_CONFIG.suppressEvent
            }
        );


        /**
        * @config helptext
        * @description String specifying additional instructional text to
        * accompany the text for the menu item.
        * @deprecated Use "text" configuration property to add help text markup.
        * For example: <code>oMenuItem.cfg.setProperty("text", "Copy &#60;em
        * class=\"helptext\"&#62;Ctrl + C&#60;/em&#62;");</code>
        * @default null
        * @type String|<a href="http://www.w3.org/TR/
        * 2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-58190037">
        * HTMLElement</a>
        */
        oConfig.addProperty(
            HELP_TEXT_CONFIG.key,
            {
                handler: this.configHelpText,
                supercedes: HELP_TEXT_CONFIG.supercedes,
                suppressEvent: HELP_TEXT_CONFIG.suppressEvent
            }
        );


        /**
        * @config url
        * @description String specifying the URL for the menu item's anchor's
        * "href" attribute.  When building a menu from existing HTML the value
        * of this property will be interpreted from the menu's markup.
        * @default "#"
        * @type String
        */
        oConfig.addProperty(
            URL_CONFIG.key,
            {
                handler: this.configURL,
                value: URL_CONFIG.value,
                suppressEvent: URL_CONFIG.suppressEvent
            }
        );


        /**
        * @config target
        * @description String specifying the value for the "target" attribute
        * of the menu item's anchor element. <strong>Specifying a target will
        * require the user to click directly on the menu item's anchor node in
        * order to cause the browser to navigate to the specified URL.</strong>
        * When building a menu from existing HTML the value of this property
        * will be interpreted from the menu's markup.
        * @default null
        * @type String
        */
        oConfig.addProperty(
            TARGET_CONFIG.key,
            {
                handler: this.configTarget,
                suppressEvent: TARGET_CONFIG.suppressEvent
            }
        );


        /**
        * @config emphasis
        * @description Boolean indicating if the text of the menu item will be
        * rendered with emphasis.
        * @deprecated Use the "text" configuration property to add emphasis.
        * For example: <code>oMenuItem.cfg.setProperty("text", "&#60;em&#62;Some
        * Text&#60;/em&#62;");</code>
        * @default false
        * @type Boolean
        */
        oConfig.addProperty(
            EMPHASIS_CONFIG.key,
            {
                handler: this.configEmphasis,
                value: EMPHASIS_CONFIG.value,
                validator: EMPHASIS_CONFIG.validator,
                suppressEvent: EMPHASIS_CONFIG.suppressEvent,
                supercedes: EMPHASIS_CONFIG.supercedes
            }
        );


        /**
        * @config strongemphasis
        * @description Boolean indicating if the text of the menu item will be
        * rendered with strong emphasis.
        * @deprecated Use the "text" configuration property to add strong emphasis.
        * For example: <code>oMenuItem.cfg.setProperty("text", "&#60;strong&#62;
        * Some Text&#60;/strong&#62;");</code>
        * @default false
        * @type Boolean
        */
        oConfig.addProperty(
            STRONG_EMPHASIS_CONFIG.key,
            {
                handler: this.configStrongEmphasis,
                value: STRONG_EMPHASIS_CONFIG.value,
                validator: STRONG_EMPHASIS_CONFIG.validator,
                suppressEvent: STRONG_EMPHASIS_CONFIG.suppressEvent,
                supercedes: STRONG_EMPHASIS_CONFIG.supercedes
            }
        );


        /**
        * @config checked
        * @description Boolean indicating if the menu item should be rendered
        * with a checkmark.
        * @default false
        * @type Boolean
        */
        oConfig.addProperty(
            CHECKED_CONFIG.key,
            {
                handler: this.configChecked,
                value: CHECKED_CONFIG.value,
                validator: CHECKED_CONFIG.validator,
                suppressEvent: CHECKED_CONFIG.suppressEvent,
                supercedes: CHECKED_CONFIG.supercedes
            }
        );


        /**
        * @config disabled
        * @description Boolean indicating if the menu item should be disabled.
        * (Disabled menu items are  dimmed and will not respond to user input
        * or fire events.)
        * @default false
        * @type Boolean
        */
        oConfig.addProperty(
            DISABLED_CONFIG.key,
            {
                handler: this.configDisabled,
                value: DISABLED_CONFIG.value,
                validator: DISABLED_CONFIG.validator,
                suppressEvent: DISABLED_CONFIG.suppressEvent
            }
        );


        /**
        * @config selected
        * @description Boolean indicating if the menu item should
        * be highlighted.
        * @default false
        * @type Boolean
        */
        oConfig.addProperty(
            SELECTED_CONFIG.key,
            {
                handler: this.configSelected,
                value: SELECTED_CONFIG.value,
                validator: SELECTED_CONFIG.validator,
                suppressEvent: SELECTED_CONFIG.suppressEvent
            }
        );


        /**
        * @config submenu
        * @description Object specifying the submenu to be appended to the
        * menu item.  The value can be one of the following: <ul><li>Object
        * specifying a Menu instance.</li><li>Object literal specifying the
        * menu to be created.  Format: <code>{ id: [menu id], itemdata:
        * [<a href="YAHOO.widget.Menu.html#itemData">array of values for
        * items</a>] }</code>.</li><li>String specifying the id attribute
        * of the <code>&#60;div&#62;</code> element of the menu.</li><li>
        * Object specifying the <code>&#60;div&#62;</code> element of the
        * menu.</li></ul>
        * @default null
        * @type Menu|String|Object|<a href="http://www.w3.org/TR/2000/
        * WD-DOM-Level-1-20000929/level-one-html.html#ID-58190037">
        * HTMLElement</a>
        */
        oConfig.addProperty(
            SUBMENU_CONFIG.key,
            {
                handler: this.configSubmenu,
                supercedes: SUBMENU_CONFIG.supercedes,
                suppressEvent: SUBMENU_CONFIG.suppressEvent
            }
        );


        /**
        * @config onclick
        * @description Object literal representing the code to be executed when
        * the item is clicked.  Format:<br> <code> {<br>
        * <strong>fn:</strong> Function,   &#47;&#47; The handler to call when
        * the event fires.<br> <strong>obj:</strong> Object, &#47;&#47; An
        * object to  pass back to the handler.<br> <strong>scope:</strong>
        * Object &#47;&#47; The object to use for the scope of the handler.
        * <br> } </code>
        * @type Object
        * @default null
        */
        oConfig.addProperty(
            ONCLICK_CONFIG.key,
            {
                handler: this.configOnClick,
                suppressEvent: ONCLICK_CONFIG.suppressEvent
            }
        );


        /**
        * @config classname
        * @description CSS class to be applied to the menu item's root
        * <code>&#60;li&#62;</code> element.  The specified class(es) are
        * appended in addition to the default class as specified by the menu
        * item's CSS_CLASS_NAME constant.
        * @default null
        * @type String
        */
        oConfig.addProperty(
            CLASS_NAME_CONFIG.key,
            {
                handler: this.configClassName,
                value: CLASS_NAME_CONFIG.value,
                validator: CLASS_NAME_CONFIG.validator,
                suppressEvent: CLASS_NAME_CONFIG.suppressEvent
            }
        );


        /**
        * @config keylistener
        * @description Object literal representing the key(s) that can be used
 		* to trigger the MenuItem's "click" event.  Possible attributes are
		* shift (boolean), alt (boolean), ctrl (boolean) and keys (either an int
		* or an array of ints representing keycodes).
        * @default null
        * @type Object
        */
        oConfig.addProperty(
            KEY_LISTENER_CONFIG.key,
            {
                handler: this.configKeyListener,
                value: KEY_LISTENER_CONFIG.value,
                suppressEvent: KEY_LISTENER_CONFIG.suppressEvent
            }
        );

	},

    /**
    * @method getNextSibling
    * @description Finds the menu item's next sibling.
    * @return YAHOO.widget.MenuItem
    */
	getNextSibling: function () {

		var isUL = function (el) {
				return (el.nodeName.toLowerCase() === "ul");
			},

			menuitemEl = this.element,
			next = Dom.getNextSibling(menuitemEl),
			parent,
			sibling,
			list;

		if (!next) {

			parent = menuitemEl.parentNode;
			sibling = Dom.getNextSiblingBy(parent, isUL);

			if (sibling) {
				list = sibling;
			}
			else {
				list = Dom.getFirstChildBy(parent.parentNode, isUL);
			}

			next = Dom.getFirstChild(list);

		}

		return YAHOO.widget.MenuManager.getMenuItem(next.id);

	},

    /**
    * @method getNextEnabledSibling
    * @description Finds the menu item's next enabled sibling.
    * @return YAHOO.widget.MenuItem
    */
	getNextEnabledSibling: function () {

		var next = this.getNextSibling();

        return (next.cfg.getProperty(_DISABLED) || next.element.style.display == _NONE) ? next.getNextEnabledSibling() : next;

	},


    /**
    * @method getPreviousSibling
    * @description Finds the menu item's previous sibling.
    * @return {YAHOO.widget.MenuItem}
    */
	getPreviousSibling: function () {

		var isUL = function (el) {
				return (el.nodeName.toLowerCase() === "ul");
			},

			menuitemEl = this.element,
			next = Dom.getPreviousSibling(menuitemEl),
			parent,
			sibling,
			list;

		if (!next) {

			parent = menuitemEl.parentNode;
			sibling = Dom.getPreviousSiblingBy(parent, isUL);

			if (sibling) {
				list = sibling;
			}
			else {
				list = Dom.getLastChildBy(parent.parentNode, isUL);
			}

			next = Dom.getLastChild(list);

		}

		return YAHOO.widget.MenuManager.getMenuItem(next.id);

	},


    /**
    * @method getPreviousEnabledSibling
    * @description Finds the menu item's previous enabled sibling.
    * @return {YAHOO.widget.MenuItem}
    */
	getPreviousEnabledSibling: function () {

		var next = this.getPreviousSibling();

        return (next.cfg.getProperty(_DISABLED) || next.element.style.display == _NONE) ? next.getPreviousEnabledSibling() : next;

	},


    /**
    * @method focus
    * @description Causes the menu item to receive the focus and fires the
    * focus event.
    */
    focus: function () {

        var oParent = this.parent,
            oAnchor = this._oAnchor,
            oActiveItem = oParent.activeItem;


        function setFocus() {

            try {

                if (!(UA.ie && !document.hasFocus())) {

					if (oActiveItem) {

						oActiveItem.blurEvent.fire();

					}

					oAnchor.focus();

					this.focusEvent.fire();

                }

            }
            catch(e) {

            }

        }


        if (!this.cfg.getProperty(_DISABLED) && oParent && oParent.cfg.getProperty(_VISIBLE) &&
            this.element.style.display != _NONE) {


            /*
                Setting focus via a timer fixes a race condition in Firefox, IE
                and Opera where the browser viewport jumps as it trys to
                position and focus the menu.
            */

            Lang.later(0, this, setFocus);

        }

    },


    /**
    * @method blur
    * @description Causes the menu item to lose focus and fires the
    * blur event.
    */
    blur: function () {

        var oParent = this.parent;

        if (!this.cfg.getProperty(_DISABLED) && oParent && oParent.cfg.getProperty(_VISIBLE)) {

            Lang.later(0, this, function () {

                try {

                    this._oAnchor.blur();
                    this.blurEvent.fire();

                }
                catch (e) {

                }

            }, 0);

        }

    },


    /**
    * @method hasFocus
    * @description Returns a boolean indicating whether or not the menu item
    * has focus.
    * @return {Boolean}
    */
    hasFocus: function () {

        return (YAHOO.widget.MenuManager.getFocusedMenuItem() == this);

    },


	/**
    * @method destroy
	* @description Removes the menu item's <code>&#60;li&#62;</code> element
	* from its parent <code>&#60;ul&#62;</code> element.
	*/
    destroy: function () {

        var oEl = this.element,
            oSubmenu,
            oParentNode,
            aEventData,
            i;


        if (oEl) {



            oSubmenu = this.cfg.getProperty(_SUBMENU);

            if (oSubmenu) {

                oSubmenu.destroy();

            }



            oParentNode = oEl.parentNode;

            if (oParentNode) {

                oParentNode.removeChild(oEl);

                this.destroyEvent.fire();

            }



			i = EVENT_TYPES.length - 1;

			do {

				aEventData = EVENT_TYPES[i];

				this[aEventData[0]].unsubscribeAll();

			}
			while (i--);


            this.cfg.configChangedEvent.unsubscribeAll();

        }

    },


    /**
    * @method toString
    * @description Returns a string representing the menu item.
    * @return {String}
    */
    toString: function () {

        var sReturnVal = _MENUITEM,
            sId = this.id;

        if (sId) {

            sReturnVal += (_SPACE + sId);

        }

        return sReturnVal;

    }

};

Lang.augmentProto(MenuItem, YAHOO.util.EventProvider);

})();
(function () {

	var _XY = "xy",
		_MOUSEDOWN = "mousedown",
		_CONTEXTMENU = "ContextMenu",
		_SPACE = " ";

/**
* Creates a list of options or commands which are made visible in response to
* an HTML element's "contextmenu" event ("mousedown" for Opera).
*
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the context menu.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source for the
* context menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
* html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object specifying the
* <code>&#60;div&#62;</code> element of the context menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
* html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object specifying
* the <code>&#60;select&#62;</code> element to be used as the data source for
* the context menu.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the context menu. See configuration class documentation
* for more details.
* @class ContextMenu
* @constructor
* @extends YAHOO.widget.Menu
* @namespace YAHOO.widget
*/
YAHOO.widget.ContextMenu = function(p_oElement, p_oConfig) {

    YAHOO.widget.ContextMenu.superclass.constructor.call(this, p_oElement, p_oConfig);

};


var Event = YAHOO.util.Event,
	UA = YAHOO.env.ua,
    ContextMenu = YAHOO.widget.ContextMenu,



    /**
    * Constant representing the name of the ContextMenu's events
    * @property EVENT_TYPES
    * @private
    * @final
    * @type Object
    */
    EVENT_TYPES = {

        "TRIGGER_CONTEXT_MENU": "triggerContextMenu",
        "CONTEXT_MENU": (UA.opera ? _MOUSEDOWN : "contextmenu"),
        "CLICK": "click"

    },


    /**
    * Constant representing the ContextMenu's configuration properties
    * @property DEFAULT_CONFIG
    * @private
    * @final
    * @type Object
    */
    TRIGGER_CONFIG = {
		key: "trigger",
		suppressEvent: true
    };


/**
* @method position
* @description "beforeShow" event handler used to position the contextmenu.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {Array} p_aPos Array representing the xy position for the context menu.
*/
function position(p_sType, p_aArgs, p_aPos) {

    this.cfg.setProperty(_XY, p_aPos);

    this.beforeShowEvent.unsubscribe(position, p_aPos);

}


YAHOO.lang.extend(ContextMenu, YAHOO.widget.Menu, {





/**
* @property _oTrigger
* @description Object reference to the current value of the "trigger"
* configuration property.
* @default null
* @private
* @type String|<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/leve
* l-one-html.html#ID-58190037">HTMLElement</a>|Array
*/
_oTrigger: null,


/**
* @property _bCancelled
* @description Boolean indicating if the display of the context menu should
* be cancelled.
* @default false
* @private
* @type Boolean
*/
_bCancelled: false,





/**
* @property contextEventTarget
* @description Object reference for the HTML element that was the target of the
* "contextmenu" DOM event ("mousedown" for Opera) that triggered the display of
* the context menu.
* @default null
* @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
* html.html#ID-58190037">HTMLElement</a>
*/
contextEventTarget: null,





/**
* @event triggerContextMenuEvent
* @description Custom Event wrapper for the "contextmenu" DOM event
* ("mousedown" for Opera) fired by the element(s) that trigger the display of
* the context menu.
*/
triggerContextMenuEvent: null,



/**
* @method init
* @description The ContextMenu class's initialization method. This method is
* automatically called by the constructor, and sets up all DOM references for
* pre-existing markup, and creates required markup if it is not already present.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the context menu.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source for
* the context menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
* html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object specifying the
* <code>&#60;div&#62;</code> element of the context menu.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
* html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object specifying
* the <code>&#60;select&#62;</code> element to be used as the data source for
* the context menu.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the context menu. See configuration class documentation
* for more details.
*/
init: function(p_oElement, p_oConfig) {



    ContextMenu.superclass.init.call(this, p_oElement);


    this.beforeInitEvent.fire(ContextMenu);


    if (p_oConfig) {

        this.cfg.applyConfig(p_oConfig, true);

    }

    this.initEvent.fire(ContextMenu);

},


/**
* @method initEvents
* @description Initializes the custom events for the context menu.
*/
initEvents: function() {

	ContextMenu.superclass.initEvents.call(this);


    this.triggerContextMenuEvent = this.createEvent(EVENT_TYPES.TRIGGER_CONTEXT_MENU);

    this.triggerContextMenuEvent.signature = YAHOO.util.CustomEvent.LIST;

},


/**
* @method cancel
* @description Cancels the display of the context menu.
*/
cancel: function() {

    this._bCancelled = true;

},





/**
* @method _removeEventHandlers
* @description Removes all of the DOM event handlers from the HTML element(s)
* whose "context menu" event ("click" for Opera) trigger the display of
* the context menu.
* @private
*/
_removeEventHandlers: function() {

    var oTrigger = this._oTrigger;



    if (oTrigger) {

        Event.removeListener(oTrigger, EVENT_TYPES.CONTEXT_MENU, this._onTriggerContextMenu);

        if (UA.opera) {

            Event.removeListener(oTrigger, EVENT_TYPES.CLICK, this._onTriggerClick);

        }

    }

},






/**
* @method _onTriggerClick
* @description "click" event handler for the HTML element(s) identified as the
* "trigger" for the context menu.  Used to cancel default behaviors in Opera.
* @private
* @param {Event} p_oEvent Object representing the DOM event object passed back
* by the event utility (YAHOO.util.Event).
* @param {YAHOO.widget.ContextMenu} p_oMenu Object representing the context
* menu that is handling the event.
*/
_onTriggerClick: function(p_oEvent, p_oMenu) {

    if (p_oEvent.ctrlKey) {

        Event.stopEvent(p_oEvent);

    }

},


/**
* @method _onTriggerContextMenu
* @description "contextmenu" event handler ("mousedown" for Opera) for the HTML
* element(s) that trigger the display of the context menu.
* @private
* @param {Event} p_oEvent Object representing the DOM event object passed back
* by the event utility (YAHOO.util.Event).
* @param {YAHOO.widget.ContextMenu} p_oMenu Object representing the context
* menu that is handling the event.
*/
_onTriggerContextMenu: function(p_oEvent, p_oMenu) {

    var aXY;

    if (!(p_oEvent.type == _MOUSEDOWN && !p_oEvent.ctrlKey)) {

		this.contextEventTarget = Event.getTarget(p_oEvent);

		this.triggerContextMenuEvent.fire(p_oEvent);


		if (!this._bCancelled) {

			/*
				Prevent the browser's default context menu from appearing and
				stop the propagation of the "contextmenu" event so that
				other ContextMenu instances are not displayed.
			*/

			Event.stopEvent(p_oEvent);



			YAHOO.widget.MenuManager.hideVisible();




			aXY = Event.getXY(p_oEvent);


			if (!YAHOO.util.Dom.inDocument(this.element)) {

				this.beforeShowEvent.subscribe(position, aXY);

			}
			else {

				this.cfg.setProperty(_XY, aXY);

			}


			this.show();

		}

		this._bCancelled = false;

    }

},





/**
* @method toString
* @description Returns a string representing the context menu.
* @return {String}
*/
toString: function() {

    var sReturnVal = _CONTEXTMENU,
        sId = this.id;

    if (sId) {

        sReturnVal += (_SPACE + sId);

    }

    return sReturnVal;

},


/**
* @method initDefaultConfig
* @description Initializes the class's configurable properties which can be
* changed using the context menu's Config object ("cfg").
*/
initDefaultConfig: function() {

    ContextMenu.superclass.initDefaultConfig.call(this);

    /**
    * @config trigger
    * @description The HTML element(s) whose "contextmenu" event ("mousedown"
    * for Opera) trigger the display of the context menu.  Can be a string
    * representing the id attribute of the HTML element, an object reference
    * for the HTML element, or an array of strings or HTML element references.
    * @default null
    * @type String|<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
    * level-one-html.html#ID-58190037">HTMLElement</a>|Array
    */
    this.cfg.addProperty(TRIGGER_CONFIG.key,
        {
            handler: this.configTrigger,
            suppressEvent: TRIGGER_CONFIG.suppressEvent
        }
    );

},


/**
* @method destroy
* @description Removes the context menu's <code>&#60;div&#62;</code> element
* (and accompanying child nodes) from the document.
*/
destroy: function() {


    this._removeEventHandlers();



    ContextMenu.superclass.destroy.call(this);

},





/**
* @method configTrigger
* @description Event handler for when the value of the "trigger" configuration
* property changes.
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.ContextMenu} p_oMenu Object representing the context
* menu that fired the event.
*/
configTrigger: function(p_sType, p_aArgs, p_oMenu) {

    var oTrigger = p_aArgs[0];

    if (oTrigger) {

        /*
            If there is a current "trigger" - remove the event handlers
            from that element(s) before assigning new ones
        */

        if (this._oTrigger) {

            this._removeEventHandlers();

        }

        this._oTrigger = oTrigger;


        /*
            Listen for the "mousedown" event in Opera b/c it does not
            support the "contextmenu" event
        */

        Event.on(oTrigger, EVENT_TYPES.CONTEXT_MENU, this._onTriggerContextMenu, this, true);


        /*
            Assign a "click" event handler to the trigger element(s) for
            Opera to prevent default browser behaviors.
        */

        if (UA.opera) {

            Event.on(oTrigger, EVENT_TYPES.CLICK, this._onTriggerClick, this, true);

        }

    }
    else {

        this._removeEventHandlers();

    }

}

}); // END YAHOO.lang.extend

}());



/**
* Creates an item for a context menu.
*
* @param {String} p_oObject String specifying the text of the context menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object specifying the
* <code>&#60;li&#62;</code> element of the context menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject Object
* specifying the <code>&#60;optgroup&#62;</code> element of the context
* menu item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject Object specifying
* the <code>&#60;option&#62;</code> element of the context menu item.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the context menu item. See configuration class
* documentation for more details.
* @class ContextMenuItem
* @constructor
* @extends YAHOO.widget.MenuItem
* @deprecated As of version 2.4.0 items for YAHOO.widget.ContextMenu instances
* are of type YAHOO.widget.MenuItem.
*/
YAHOO.widget.ContextMenuItem = YAHOO.widget.MenuItem;
(function () {

	var Lang = YAHOO.lang,


		_STATIC = "static",
		_DYNAMIC_STATIC = "dynamic," + _STATIC,
		_DISABLED = "disabled",
		_SELECTED = "selected",
		_AUTO_SUBMENU_DISPLAY = "autosubmenudisplay",
		_SUBMENU = "submenu",
		_VISIBLE = "visible",
		_SPACE = " ",
		_SUBMENU_TOGGLE_REGION = "submenutoggleregion",
		_MENUBAR = "MenuBar";

/**
* Horizontal collection of items, each of which can contain a submenu.
*
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the menu bar.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source for the
* menu bar.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object specifying
* the <code>&#60;div&#62;</code> element of the menu bar.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object
* specifying the <code>&#60;select&#62;</code> element to be used as the data
* source for the menu bar.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu bar. See configuration class documentation for
* more details.
* @class MenuBar
* @constructor
* @extends YAHOO.widget.Menu
* @namespace YAHOO.widget
*/
YAHOO.widget.MenuBar = function(p_oElement, p_oConfig) {

    YAHOO.widget.MenuBar.superclass.constructor.call(this, p_oElement, p_oConfig);

};


/**
* @method checkPosition
* @description Checks to make sure that the value of the "position" property
* is one of the supported strings. Returns true if the position is supported.
* @private
* @param {Object} p_sPosition String specifying the position of the menu.
* @return {Boolean}
*/
function checkPosition(p_sPosition) {

	var returnVal = false;

    if (Lang.isString(p_sPosition)) {

        returnVal = (_DYNAMIC_STATIC.indexOf((p_sPosition.toLowerCase())) != -1);

    }

    return returnVal;

}


var Event = YAHOO.util.Event,
    MenuBar = YAHOO.widget.MenuBar,

    POSITION_CONFIG =  {
		key: "position",
		value: _STATIC,
		validator: checkPosition,
		supercedes: [_VISIBLE]
	},

	SUBMENU_ALIGNMENT_CONFIG =  {
		key: "submenualignment",
		value: ["tl","bl"]
	},

	AUTO_SUBMENU_DISPLAY_CONFIG =  {
		key: _AUTO_SUBMENU_DISPLAY,
		value: false,
		validator: Lang.isBoolean,
		suppressEvent: true
	},

	SUBMENU_TOGGLE_REGION_CONFIG = {
		key: _SUBMENU_TOGGLE_REGION,
		value: false,
		validator: Lang.isBoolean
	};



Lang.extend(MenuBar, YAHOO.widget.Menu, {

/**
* @method init
* @description The MenuBar class's initialization method. This method is
* automatically called by the constructor, and sets up all DOM references for
* pre-existing markup, and creates required markup if it is not already present.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;div&#62;</code> element of the menu bar.
* @param {String} p_oElement String specifying the id attribute of the
* <code>&#60;select&#62;</code> element to be used as the data source for the
* menu bar.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object specifying
* the <code>&#60;div&#62;</code> element of the menu bar.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object
* specifying the <code>&#60;select&#62;</code> element to be used as the data
* source for the menu bar.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu bar. See configuration class documentation for
* more details.
*/
init: function(p_oElement, p_oConfig) {

    if(!this.ITEM_TYPE) {

        this.ITEM_TYPE = YAHOO.widget.MenuBarItem;

    }



    MenuBar.superclass.init.call(this, p_oElement);


    this.beforeInitEvent.fire(MenuBar);


    if(p_oConfig) {

        this.cfg.applyConfig(p_oConfig, true);

    }

    this.initEvent.fire(MenuBar);

},





/**
* @property CSS_CLASS_NAME
* @description String representing the CSS class(es) to be applied to the menu
* bar's <code>&#60;div&#62;</code> element.
* @default "yuimenubar"
* @final
* @type String
*/
CSS_CLASS_NAME: "yuimenubar",


/**
* @property SUBMENU_TOGGLE_REGION_WIDTH
* @description Width (in pixels) of the area of a MenuBarItem that, when pressed, will toggle the
* display of the MenuBarItem's submenu.
* @default 20
* @final
* @type Number
*/
SUBMENU_TOGGLE_REGION_WIDTH: 20,




/**
* @method _onKeyDown
* @description "keydown" Custom Event handler for the menu bar.
* @private
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.MenuBar} p_oMenuBar Object representing the menu bar
* that fired the event.
*/
_onKeyDown: function(p_sType, p_aArgs, p_oMenuBar) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oSubmenu,
        oItemCfg,
        oNextItem;


    if(oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oItemCfg = oItem.cfg;

        switch(oEvent.keyCode) {

            case 37:    // Left arrow
            case 39:    // Right arrow

                if(oItem == this.activeItem && !oItemCfg.getProperty(_SELECTED)) {

                    oItemCfg.setProperty(_SELECTED, true);

                }
                else {

                    oNextItem = (oEvent.keyCode == 37) ?
                        oItem.getPreviousEnabledSibling() :
                        oItem.getNextEnabledSibling();

                    if(oNextItem) {

                        this.clearActiveItem();

                        oNextItem.cfg.setProperty(_SELECTED, true);

						oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);

						if(oSubmenu) {

							oSubmenu.show();
							oSubmenu.setInitialFocus();

						}
						else {
							oNextItem.focus();
						}

                    }

                }

                Event.preventDefault(oEvent);

            break;

            case 40:    // Down arrow

                if(this.activeItem != oItem) {

                    this.clearActiveItem();

                    oItemCfg.setProperty(_SELECTED, true);
                    oItem.focus();

                }

                oSubmenu = oItemCfg.getProperty(_SUBMENU);

                if(oSubmenu) {

                    if(oSubmenu.cfg.getProperty(_VISIBLE)) {

                        oSubmenu.setInitialSelection();
                        oSubmenu.setInitialFocus();

                    }
                    else {

                        oSubmenu.show();
                        oSubmenu.setInitialFocus();

                    }

                }

                Event.preventDefault(oEvent);

            break;

        }

    }


    if(oEvent.keyCode == 27 && this.activeItem) { // Esc key

        oSubmenu = this.activeItem.cfg.getProperty(_SUBMENU);

        if(oSubmenu && oSubmenu.cfg.getProperty(_VISIBLE)) {

            oSubmenu.hide();
            this.activeItem.focus();

        }
        else {

            this.activeItem.cfg.setProperty(_SELECTED, false);
            this.activeItem.blur();

        }

        Event.preventDefault(oEvent);

    }

},


/**
* @method _onClick
* @description "click" event handler for the menu bar.
* @protected
* @param {String} p_sType String representing the name of the event that
* was fired.
* @param {Array} p_aArgs Array of arguments sent when the event was fired.
* @param {YAHOO.widget.MenuBar} p_oMenuBar Object representing the menu bar
* that fired the event.
*/
_onClick: function(p_sType, p_aArgs, p_oMenuBar) {

    MenuBar.superclass._onClick.call(this, p_sType, p_aArgs, p_oMenuBar);

    var oItem = p_aArgs[1],
        bReturnVal = true,
    	oItemEl,
        oEvent,
        oTarget,
        oActiveItem,
        oConfig,
        oSubmenu,
        nMenuItemX,
        nToggleRegion;


	var toggleSubmenuDisplay = function () {

		if(oSubmenu.cfg.getProperty(_VISIBLE)) {

			oSubmenu.hide();

		}
		else {

			oSubmenu.show();

		}

	};


    if(oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oEvent = p_aArgs[0];
        oTarget = Event.getTarget(oEvent);
        oActiveItem = this.activeItem;
        oConfig = this.cfg;



        if(oActiveItem && oActiveItem != oItem) {

            this.clearActiveItem();

        }


        oItem.cfg.setProperty(_SELECTED, true);



        oSubmenu = oItem.cfg.getProperty(_SUBMENU);


        if(oSubmenu) {

			oItemEl = oItem.element;
			nMenuItemX = YAHOO.util.Dom.getX(oItemEl);
			nToggleRegion = nMenuItemX + (oItemEl.offsetWidth - this.SUBMENU_TOGGLE_REGION_WIDTH);

			if (oConfig.getProperty(_SUBMENU_TOGGLE_REGION)) {

				if (Event.getPageX(oEvent) > nToggleRegion) {

					toggleSubmenuDisplay();

					Event.preventDefault(oEvent);

					/*
						 Return false so that other click event handlers are not called when the
						 user clicks inside the toggle region.
					*/
					bReturnVal = false;

				}

        	}
			else {

				toggleSubmenuDisplay();

            }

        }

    }


	return bReturnVal;

},




/**
* @method configSubmenuToggle
* @description Event handler for when the "submenutoggleregion" configuration property of
* a MenuBar changes.
* @param {String} p_sType The name of the event that was fired.
* @param {Array} p_aArgs Collection of arguments sent when the event was fired.
*/
configSubmenuToggle: function (p_sType, p_aArgs) {

	var bSubmenuToggle = p_aArgs[0];

	if (bSubmenuToggle) {

		this.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, false);

	}

},


/**
* @method toString
* @description Returns a string representing the menu bar.
* @return {String}
*/
toString: function() {

    var sReturnVal = _MENUBAR,
        sId = this.id;

    if(sId) {

        sReturnVal += (_SPACE + sId);

    }

    return sReturnVal;

},


/**
* @description Initializes the class's configurable properties which can be
* changed using the menu bar's Config object ("cfg").
* @method initDefaultConfig
*/
initDefaultConfig: function() {

    MenuBar.superclass.initDefaultConfig.call(this);

    var oConfig = this.cfg;



    /*
        Set the default value for the "position" configuration property
        to "static" by re-adding the property.
    */


    /**
    * @config position
    * @description String indicating how a menu bar should be positioned on the
    * screen.  Possible values are "static" and "dynamic."  Static menu bars
    * are visible by default and reside in the normal flow of the document
    * (CSS position: static).  Dynamic menu bars are hidden by default, reside
    * out of the normal flow of the document (CSS position: absolute), and can
    * overlay other elements on the screen.
    * @default static
    * @type String
    */
    oConfig.addProperty(
        POSITION_CONFIG.key,
        {
            handler: this.configPosition,
            value: POSITION_CONFIG.value,
            validator: POSITION_CONFIG.validator,
            supercedes: POSITION_CONFIG.supercedes
        }
    );


    /*
        Set the default value for the "submenualignment" configuration property
        to ["tl","bl"] by re-adding the property.
    */

    /**
    * @config submenualignment
    * @description Array defining how submenus should be aligned to their
    * parent menu bar item. The format is: [itemCorner, submenuCorner].
    * @default ["tl","bl"]
    * @type Array
    */
    oConfig.addProperty(
        SUBMENU_ALIGNMENT_CONFIG.key,
        {
            value: SUBMENU_ALIGNMENT_CONFIG.value,
            suppressEvent: SUBMENU_ALIGNMENT_CONFIG.suppressEvent
        }
    );


    /*
        Change the default value for the "autosubmenudisplay" configuration
        property to "false" by re-adding the property.
    */

    /**
    * @config autosubmenudisplay
    * @description Boolean indicating if submenus are automatically made
    * visible when the user mouses over the menu bar's items.
    * @default false
    * @type Boolean
    */
	oConfig.addProperty(
	   AUTO_SUBMENU_DISPLAY_CONFIG.key,
	   {
	       value: AUTO_SUBMENU_DISPLAY_CONFIG.value,
	       validator: AUTO_SUBMENU_DISPLAY_CONFIG.validator,
	       suppressEvent: AUTO_SUBMENU_DISPLAY_CONFIG.suppressEvent
       }
    );


    /**
    * @config submenutoggleregion
    * @description Boolean indicating if only a specific region of a MenuBarItem should toggle the
    * display of a submenu.  The default width of the region is determined by the value of the
    * SUBMENU_TOGGLE_REGION_WIDTH property.  If set to true, the autosubmenudisplay
    * configuration property will be set to false, and any click event listeners will not be
    * called when the user clicks inside the submenu toggle region of a MenuBarItem.  If the
    * user clicks outside of the submenu toggle region, the MenuBarItem will maintain its
    * standard behavior.
    * @default false
    * @type Boolean
    */
	oConfig.addProperty(
	   SUBMENU_TOGGLE_REGION_CONFIG.key,
	   {
	       value: SUBMENU_TOGGLE_REGION_CONFIG.value,
	       validator: SUBMENU_TOGGLE_REGION_CONFIG.validator,
	       handler: this.configSubmenuToggle
       }
    );

}

}); // END YAHOO.lang.extend

}());



/**
* Creates an item for a menu bar.
*
* @param {String} p_oObject String specifying the text of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object specifying the
* <code>&#60;li&#62;</code> element of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject Object
* specifying the <code>&#60;optgroup&#62;</code> element of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject Object specifying
* the <code>&#60;option&#62;</code> element of the menu bar item.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu bar item. See configuration class documentation
* for more details.
* @class MenuBarItem
* @constructor
* @extends YAHOO.widget.MenuItem
*/
YAHOO.widget.MenuBarItem = function(p_oObject, p_oConfig) {

    YAHOO.widget.MenuBarItem.superclass.constructor.call(this, p_oObject, p_oConfig);

};

YAHOO.lang.extend(YAHOO.widget.MenuBarItem, YAHOO.widget.MenuItem, {



/**
* @method init
* @description The MenuBarItem class's initialization method. This method is
* automatically called by the constructor, and sets up all DOM references for
* pre-existing markup, and creates required markup if it is not already present.
* @param {String} p_oObject String specifying the text of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object specifying the
* <code>&#60;li&#62;</code> element of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject Object
* specifying the <code>&#60;optgroup&#62;</code> element of the menu bar item.
* @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
* one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject Object specifying
* the <code>&#60;option&#62;</code> element of the menu bar item.
* @param {Object} p_oConfig Optional. Object literal specifying the
* configuration for the menu bar item. See configuration class documentation
* for more details.
*/
init: function(p_oObject, p_oConfig) {

    if(!this.SUBMENU_TYPE) {

        this.SUBMENU_TYPE = YAHOO.widget.Menu;

    }


    /*
        Call the init of the superclass (YAHOO.widget.MenuItem)
        Note: We don't pass the user config in here yet
        because we only want it executed once, at the lowest
        subclass level.
    */

    YAHOO.widget.MenuBarItem.superclass.init.call(this, p_oObject);


    var oConfig = this.cfg;

    if(p_oConfig) {

        oConfig.applyConfig(p_oConfig, true);

    }

    oConfig.fireQueue();

},





/**
* @property CSS_CLASS_NAME
* @description String representing the CSS class(es) to be applied to the
* <code>&#60;li&#62;</code> element of the menu bar item.
* @default "yuimenubaritem"
* @final
* @type String
*/
CSS_CLASS_NAME: "yuimenubaritem",


/**
* @property CSS_LABEL_CLASS_NAME
* @description String representing the CSS class(es) to be applied to the
* menu bar item's <code>&#60;a&#62;</code> element.
* @default "yuimenubaritemlabel"
* @final
* @type String
*/
CSS_LABEL_CLASS_NAME: "yuimenubaritemlabel",





/**
* @method toString
* @description Returns a string representing the menu bar item.
* @return {String}
*/
toString: function() {

    var sReturnVal = "MenuBarItem";

    if(this.cfg && this.cfg.getProperty("text")) {

        sReturnVal += (": " + this.cfg.getProperty("text"));

    }

    return sReturnVal;

}

}); // END YAHOO.lang.extend
YAHOO.register("menu", YAHOO.widget.Menu, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
* @module button
* @description <p>The Button Control enables the creation of rich, graphical
* buttons that function like traditional HTML form buttons.  <em>Unlike</em>
* traditional HTML form buttons, buttons created with the Button Control can have
* a label that is different from its value.  With the inclusion of the optional
* <a href="module_menu.html">Menu Control</a>, the Button Control can also be
* used to create menu buttons and split buttons, controls that are not
* available natively in HTML.  The Button Control can also be thought of as a
* way to create more visually engaging implementations of the browser's
* default radio-button and check-box controls.</p>
* <p>The Button Control supports the following types:</p>
* <dl>
* <dt>push</dt>
* <dd>Basic push button that can execute a user-specified command when
* pressed.</dd>
* <dt>link</dt>
* <dd>Navigates to a specified url when pressed.</dd>
* <dt>submit</dt>
* <dd>Submits the parent form when pressed.</dd>
* <dt>reset</dt>
* <dd>Resets the parent form when pressed.</dd>
* <dt>checkbox</dt>
* <dd>Maintains a "checked" state that can be toggled on and off.</dd>
* <dt>radio</dt>
* <dd>Maintains a "checked" state that can be toggled on and off.  Use with
* the ButtonGroup class to create a set of controls that are mutually
* exclusive; checking one button in the set will uncheck all others in
* the group.</dd>
* <dt>menu</dt>
* <dd>When pressed will show/hide a menu.</dd>
* <dt>split</dt>
* <dd>Can execute a user-specified command or display a menu when pressed.</dd>
* </dl>
* @title Button
* @namespace YAHOO.widget
* @requires yahoo, dom, element, event
* @optional container, menu
*/


(function () {


    /**
    * The Button class creates a rich, graphical button.
    * @param {String} p_oElement String specifying the id attribute of the
    * <code>&#60;input&#62;</code>, <code>&#60;button&#62;</code>,
    * <code>&#60;a&#62;</code>, or <code>&#60;span&#62;</code> element to
    * be used to create the button.
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-6043025">HTMLInputElement</a>|<a href="http://www.w3.org
    * /TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-34812697">
    * HTMLButtonElement</a>|<a href="
    * http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#
    * ID-33759296">HTMLElement</a>} p_oElement Object reference for the
    * <code>&#60;input&#62;</code>, <code>&#60;button&#62;</code>,
    * <code>&#60;a&#62;</code>, or <code>&#60;span&#62;</code> element to be
    * used to create the button.
    * @param {Object} p_oElement Object literal specifying a set of
    * configuration attributes used to create the button.
    * @param {Object} p_oAttributes Optional. Object literal specifying a set
    * of configuration attributes used to create the button.
    * @namespace YAHOO.widget
    * @class Button
    * @constructor
    * @extends YAHOO.util.Element
    */




    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        UA = YAHOO.env.ua,
        Overlay = YAHOO.widget.Overlay,
        Menu = YAHOO.widget.Menu,



        m_oButtons = {},    // Collection of all Button instances
        m_oOverlayManager = null,   // YAHOO.widget.OverlayManager instance
        m_oSubmitTrigger = null,    // The button that submitted the form
        m_oFocusedButton = null;    // The button that has focus






    /**
    * @method createInputElement
    * @description Creates an <code>&#60;input&#62;</code> element of the
    * specified type.
    * @private
    * @param {String} p_sType String specifying the type of
    * <code>&#60;input&#62;</code> element to create.
    * @param {String} p_sName String specifying the name of
    * <code>&#60;input&#62;</code> element to create.
    * @param {String} p_sValue String specifying the value of
    * <code>&#60;input&#62;</code> element to create.
    * @param {String} p_bChecked Boolean specifying if the
    * <code>&#60;input&#62;</code> element is to be checked.
    * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-6043025">HTMLInputElement</a>}
    */
    function createInputElement(p_sType, p_sName, p_sValue, p_bChecked) {

        var oInput,
            sInput;

        if (Lang.isString(p_sType) && Lang.isString(p_sName)) {

            if (UA.ie) {

                /*
                    For IE it is necessary to create the element with the
                    "type," "name," "value," and "checked" properties set all
                    at once.
                */

                sInput = "<input type=\"" + p_sType + "\" name=\"" +
                    p_sName + "\"";

                if (p_bChecked) {

                    sInput += " checked";

                }

                sInput += ">";

                oInput = document.createElement(sInput);

            }
            else {

                oInput = document.createElement("input");
                oInput.name = p_sName;
                oInput.type = p_sType;

                if (p_bChecked) {

                    oInput.checked = true;

                }

            }

            oInput.value = p_sValue;

        }

		return oInput;

    }


    /**
    * @method setAttributesFromSrcElement
    * @description Gets the values for all the attributes of the source element
    * (either <code>&#60;input&#62;</code> or <code>&#60;a&#62;</code>) that
    * map to Button configuration attributes and sets them into a collection
    * that is passed to the Button constructor.
    * @private
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-6043025">HTMLInputElement</a>|<a href="http://www.w3.org/
    * TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-
    * 48250443">HTMLAnchorElement</a>} p_oElement Object reference to the HTML
    * element (either <code>&#60;input&#62;</code> or <code>&#60;span&#62;
    * </code>) used to create the button.
    * @param {Object} p_oAttributes Object reference for the collection of
    * configuration attributes used to create the button.
    */
    function setAttributesFromSrcElement(p_oElement, p_oAttributes) {

        var sSrcElementNodeName = p_oElement.nodeName.toUpperCase(),
			sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME),
            me = this,
            oAttribute,
            oRootNode,
            sText;


        /**
        * @method setAttributeFromDOMAttribute
        * @description Gets the value of the specified DOM attribute and sets it
        * into the collection of configuration attributes used to configure
        * the button.
        * @private
        * @param {String} p_sAttribute String representing the name of the
        * attribute to retrieve from the DOM element.
        */
        function setAttributeFromDOMAttribute(p_sAttribute) {

            if (!(p_sAttribute in p_oAttributes)) {

                /*
                    Need to use "getAttributeNode" instead of "getAttribute"
                    because using "getAttribute," IE will return the innerText
                    of a <code>&#60;button&#62;</code> for the value attribute
                    rather than the value of the "value" attribute.
                */

                oAttribute = p_oElement.getAttributeNode(p_sAttribute);


                if (oAttribute && ("value" in oAttribute)) {


                    p_oAttributes[p_sAttribute] = oAttribute.value;

                }

            }

        }


        /**
        * @method setFormElementProperties
        * @description Gets the value of the attributes from the form element
        * and sets them into the collection of configuration attributes used to
        * configure the button.
        * @private
        */
        function setFormElementProperties() {

            setAttributeFromDOMAttribute("type");

            if (p_oAttributes.type == "button") {

                p_oAttributes.type = "push";

            }

            if (!("disabled" in p_oAttributes)) {

                p_oAttributes.disabled = p_oElement.disabled;

            }

            setAttributeFromDOMAttribute("name");
            setAttributeFromDOMAttribute("value");
            setAttributeFromDOMAttribute("title");

        }


        switch (sSrcElementNodeName) {

        case "A":

            p_oAttributes.type = "link";

            setAttributeFromDOMAttribute("href");
            setAttributeFromDOMAttribute("target");

            break;

        case "INPUT":

            setFormElementProperties();

            if (!("checked" in p_oAttributes)) {

                p_oAttributes.checked = p_oElement.checked;

            }

            break;

        case "BUTTON":

            setFormElementProperties();

            oRootNode = p_oElement.parentNode.parentNode;

            if (Dom.hasClass(oRootNode, sClass + "-checked")) {

                p_oAttributes.checked = true;

            }

            if (Dom.hasClass(oRootNode, sClass + "-disabled")) {

                p_oAttributes.disabled = true;

            }

            p_oElement.removeAttribute("value");

            p_oElement.setAttribute("type", "button");

            break;

        }

        p_oElement.removeAttribute("id");
        p_oElement.removeAttribute("name");

        if (!("tabindex" in p_oAttributes)) {

            p_oAttributes.tabindex = p_oElement.tabIndex;

        }

        if (!("label" in p_oAttributes)) {


            sText = sSrcElementNodeName == "INPUT" ?
                            p_oElement.value : p_oElement.innerHTML;


            if (sText && sText.length > 0) {

                p_oAttributes.label = sText;

            }

        }

    }


    /**
    * @method initConfig
    * @description Initializes the set of configuration attributes that are
    * used to instantiate the button.
    * @private
    * @param {Object} Object representing the button's set of
    * configuration attributes.
    */
    function initConfig(p_oConfig) {

        var oAttributes = p_oConfig.attributes,
            oSrcElement = oAttributes.srcelement,
            sSrcElementNodeName = oSrcElement.nodeName.toUpperCase(),
            me = this;


        if (sSrcElementNodeName == this.NODE_NAME) {

            p_oConfig.element = oSrcElement;
            p_oConfig.id = oSrcElement.id;

            Dom.getElementsBy(function (p_oElement) {

                switch (p_oElement.nodeName.toUpperCase()) {

                case "BUTTON":
                case "A":
                case "INPUT":

                    setAttributesFromSrcElement.call(me, p_oElement,
                        oAttributes);

                    break;

                }

            }, "*", oSrcElement);

        }
        else {

            switch (sSrcElementNodeName) {

            case "BUTTON":
            case "A":
            case "INPUT":

                setAttributesFromSrcElement.call(this, oSrcElement,
                    oAttributes);

                break;

            }

        }

    }




    YAHOO.widget.Button = function (p_oElement, p_oAttributes) {

		if (!Overlay && YAHOO.widget.Overlay) {

			Overlay = YAHOO.widget.Overlay;

		}


		if (!Menu && YAHOO.widget.Menu) {

			Menu = YAHOO.widget.Menu;

		}


        var fnSuperClass = YAHOO.widget.Button.superclass.constructor,
            oConfig,
            oElement;


        if (arguments.length == 1 && !Lang.isString(p_oElement) && !p_oElement.nodeName) {

            if (!p_oElement.id) {

                p_oElement.id = Dom.generateId();


            }


            fnSuperClass.call(this, (this.createButtonElement(p_oElement.type)), p_oElement);

        }
        else {

            oConfig = { element: null, attributes: (p_oAttributes || {}) };


            if (Lang.isString(p_oElement)) {

                oElement = Dom.get(p_oElement);

                if (oElement) {

                    if (!oConfig.attributes.id) {

                        oConfig.attributes.id = p_oElement;

                    }



                    oConfig.attributes.srcelement = oElement;

                    initConfig.call(this, oConfig);


                    if (!oConfig.element) {


                        oConfig.element = this.createButtonElement(oConfig.attributes.type);

                    }

                    fnSuperClass.call(this, oConfig.element, oConfig.attributes);

                }

            }
            else if (p_oElement.nodeName) {

                if (!oConfig.attributes.id) {

                    if (p_oElement.id) {

                        oConfig.attributes.id = p_oElement.id;

                    }
                    else {

                        oConfig.attributes.id = Dom.generateId();


                    }

                }



                oConfig.attributes.srcelement = p_oElement;

                initConfig.call(this, oConfig);


                if (!oConfig.element) {


                    oConfig.element = this.createButtonElement(oConfig.attributes.type);

                }

                fnSuperClass.call(this, oConfig.element, oConfig.attributes);

            }

        }

    };



    YAHOO.extend(YAHOO.widget.Button, YAHOO.util.Element, {




        /**
        * @property _button
        * @description Object reference to the button's internal
        * <code>&#60;a&#62;</code> or <code>&#60;button&#62;</code> element.
        * @default null
        * @protected
        * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-48250443">HTMLAnchorElement</a>|<a href="
        * http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html
        * #ID-34812697">HTMLButtonElement</a>
        */
        _button: null,


        /**
        * @property _menu
        * @description Object reference to the button's menu.
        * @default null
        * @protected
        * @type {<a href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>|
        * <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>}
        */
        _menu: null,


        /**
        * @property _hiddenFields
        * @description Object reference to the <code>&#60;input&#62;</code>
        * element, or array of HTML form elements used to represent the button
        *  when its parent form is submitted.
        * @default null
        * @protected
        * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-6043025">HTMLInputElement</a>|Array
        */
        _hiddenFields: null,


        /**
        * @property _onclickAttributeValue
        * @description Object reference to the button's current value for the
        * "onclick" configuration attribute.
        * @default null
        * @protected
        * @type Object
        */
        _onclickAttributeValue: null,


        /**
        * @property _activationKeyPressed
        * @description Boolean indicating if the key(s) that toggle the button's
        * "active" state have been pressed.
        * @default false
        * @protected
        * @type Boolean
        */
        _activationKeyPressed: false,


        /**
        * @property _activationButtonPressed
        * @description Boolean indicating if the mouse button that toggles
        * the button's "active" state has been pressed.
        * @default false
        * @protected
        * @type Boolean
        */
        _activationButtonPressed: false,


        /**
        * @property _hasKeyEventHandlers
        * @description Boolean indicating if the button's "blur", "keydown" and
        * "keyup" event handlers are assigned
        * @default false
        * @protected
        * @type Boolean
        */
        _hasKeyEventHandlers: false,


        /**
        * @property _hasMouseEventHandlers
        * @description Boolean indicating if the button's "mouseout,"
        * "mousedown," and "mouseup" event handlers are assigned
        * @default false
        * @protected
        * @type Boolean
        */
        _hasMouseEventHandlers: false,


        /**
        * @property _nOptionRegionX
        * @description Number representing the X coordinate of the leftmost edge of the Button's
        * option region.  Applies only to Buttons of type "split".
        * @default 0
        * @protected
        * @type Number
        */
        _nOptionRegionX: 0,




        /**
        * @property CLASS_NAME_PREFIX
        * @description Prefix used for all class names applied to a Button.
        * @default "yui-"
        * @final
        * @type String
        */
        CLASS_NAME_PREFIX: "yui-",


        /**
        * @property NODE_NAME
        * @description The name of the node to be used for the button's
        * root element.
        * @default "SPAN"
        * @final
        * @type String
        */
        NODE_NAME: "SPAN",


        /**
        * @property CHECK_ACTIVATION_KEYS
        * @description Array of numbers representing keys that (when pressed)
        * toggle the button's "checked" attribute.
        * @default [32]
        * @final
        * @type Array
        */
        CHECK_ACTIVATION_KEYS: [32],


        /**
        * @property ACTIVATION_KEYS
        * @description Array of numbers representing keys that (when presed)
        * toggle the button's "active" state.
        * @default [13, 32]
        * @final
        * @type Array
        */
        ACTIVATION_KEYS: [13, 32],


        /**
        * @property OPTION_AREA_WIDTH
        * @description Width (in pixels) of the area of a split button that
        * when pressed will display a menu.
        * @default 20
        * @final
        * @type Number
        */
        OPTION_AREA_WIDTH: 20,


        /**
        * @property CSS_CLASS_NAME
        * @description String representing the CSS class(es) to be applied to
        * the button's root element.
        * @default "button"
        * @final
        * @type String
        */
        CSS_CLASS_NAME: "button",





        /**
        * @method _setType
        * @description Sets the value of the button's "type" attribute.
        * @protected
        * @param {String} p_sType String indicating the value for the button's
        * "type" attribute.
        */
        _setType: function (p_sType) {

            if (p_sType == "split") {

                this.on("option", this._onOption);

            }

        },


        /**
        * @method _setLabel
        * @description Sets the value of the button's "label" attribute.
        * @protected
        * @param {String} p_sLabel String indicating the value for the button's
        * "label" attribute.
        */
        _setLabel: function (p_sLabel) {

            this._button.innerHTML = p_sLabel;


            /*
                Remove and add the default class name from the root element
                for Gecko to ensure that the button shrinkwraps to the label.
                Without this the button will not be rendered at the correct
                width when the label changes.  The most likely cause for this
                bug is button's use of the Gecko-specific CSS display type of
                "-moz-inline-box" to simulate "inline-block" supported by IE,
                Safari and Opera.
            */

            var sClass,
                nGeckoVersion = UA.gecko;


            if (nGeckoVersion && nGeckoVersion < 1.9 && Dom.inDocument(this.get("element"))) {

                sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);

                this.removeClass(sClass);

                Lang.later(0, this, this.addClass, sClass);

            }

        },


        /**
        * @method _setTabIndex
        * @description Sets the value of the button's "tabindex" attribute.
        * @protected
        * @param {Number} p_nTabIndex Number indicating the value for the
        * button's "tabindex" attribute.
        */
        _setTabIndex: function (p_nTabIndex) {

            this._button.tabIndex = p_nTabIndex;

        },


        /**
        * @method _setTitle
        * @description Sets the value of the button's "title" attribute.
        * @protected
        * @param {String} p_nTabIndex Number indicating the value for
        * the button's "title" attribute.
        */
        _setTitle: function (p_sTitle) {

            if (this.get("type") != "link") {

                this._button.title = p_sTitle;

            }

        },


        /**
        * @method _setDisabled
        * @description Sets the value of the button's "disabled" attribute.
        * @protected
        * @param {Boolean} p_bDisabled Boolean indicating the value for
        * the button's "disabled" attribute.
        */
        _setDisabled: function (p_bDisabled) {

            if (this.get("type") != "link") {

                if (p_bDisabled) {

                    if (this._menu) {

                        this._menu.hide();

                    }

                    if (this.hasFocus()) {

                        this.blur();

                    }

                    this._button.setAttribute("disabled", "disabled");

                    this.addStateCSSClasses("disabled");

                    this.removeStateCSSClasses("hover");
                    this.removeStateCSSClasses("active");
                    this.removeStateCSSClasses("focus");

                }
                else {

                    this._button.removeAttribute("disabled");

                    this.removeStateCSSClasses("disabled");

                }

            }

        },


        /**
        * @method _setHref
        * @description Sets the value of the button's "href" attribute.
        * @protected
        * @param {String} p_sHref String indicating the value for the button's
        * "href" attribute.
        */
        _setHref: function (p_sHref) {

            if (this.get("type") == "link") {

                this._button.href = p_sHref;

            }

        },


        /**
        * @method _setTarget
        * @description Sets the value of the button's "target" attribute.
        * @protected
        * @param {String} p_sTarget String indicating the value for the button's
        * "target" attribute.
        */
        _setTarget: function (p_sTarget) {

            if (this.get("type") == "link") {

                this._button.setAttribute("target", p_sTarget);

            }

        },


        /**
        * @method _setChecked
        * @description Sets the value of the button's "target" attribute.
        * @protected
        * @param {Boolean} p_bChecked Boolean indicating the value for
        * the button's "checked" attribute.
        */
        _setChecked: function (p_bChecked) {

            var sType = this.get("type");

            if (sType == "checkbox" || sType == "radio") {

                if (p_bChecked) {
                    this.addStateCSSClasses("checked");
                }
                else {
                    this.removeStateCSSClasses("checked");
                }

            }

        },


        /**
        * @method _setMenu
        * @description Sets the value of the button's "menu" attribute.
        * @protected
        * @param {Object} p_oMenu Object indicating the value for the button's
        * "menu" attribute.
        */
        _setMenu: function (p_oMenu) {

            var bLazyLoad = this.get("lazyloadmenu"),
                oButtonElement = this.get("element"),
                sMenuCSSClassName,

                /*
                    Boolean indicating if the value of p_oMenu is an instance
                    of YAHOO.widget.Menu or YAHOO.widget.Overlay.
                */

                bInstance = false,
                oMenu,
                oMenuElement,
                oSrcElement;


			function onAppendTo() {

				oMenu.render(oButtonElement.parentNode);

				this.removeListener("appendTo", onAppendTo);

			}


			function setMenuContainer() {

				oMenu.cfg.queueProperty("container", oButtonElement.parentNode);

				this.removeListener("appendTo", setMenuContainer);

			}


			function initMenu() {

				var oContainer;

				if (oMenu) {

					Dom.addClass(oMenu.element, this.get("menuclassname"));
					Dom.addClass(oMenu.element, this.CLASS_NAME_PREFIX + this.get("type") + "-button-menu");

					oMenu.showEvent.subscribe(this._onMenuShow, null, this);
					oMenu.hideEvent.subscribe(this._onMenuHide, null, this);
					oMenu.renderEvent.subscribe(this._onMenuRender, null, this);


					if (Menu && oMenu instanceof Menu) {

						if (bLazyLoad) {

							oContainer = this.get("container");

							if (oContainer) {

								oMenu.cfg.queueProperty("container", oContainer);

							}
							else {

								this.on("appendTo", setMenuContainer);

							}

						}

						oMenu.cfg.queueProperty("clicktohide", false);

						oMenu.keyDownEvent.subscribe(this._onMenuKeyDown, this, true);
						oMenu.subscribe("click", this._onMenuClick, this, true);

						this.on("selectedMenuItemChange", this._onSelectedMenuItemChange);

						oSrcElement = oMenu.srcElement;

						if (oSrcElement && oSrcElement.nodeName.toUpperCase() == "SELECT") {

							oSrcElement.style.display = "none";
							oSrcElement.parentNode.removeChild(oSrcElement);

						}

					}
					else if (Overlay && oMenu instanceof Overlay) {

						if (!m_oOverlayManager) {

							m_oOverlayManager = new YAHOO.widget.OverlayManager();

						}

						m_oOverlayManager.register(oMenu);

					}


					this._menu = oMenu;


					if (!bInstance && !bLazyLoad) {

						if (Dom.inDocument(oButtonElement)) {

							oMenu.render(oButtonElement.parentNode);

						}
						else {

							this.on("appendTo", onAppendTo);

						}

					}

				}

			}


            if (Overlay) {

				if (Menu) {

					sMenuCSSClassName = Menu.prototype.CSS_CLASS_NAME;

				}

				if (p_oMenu && Menu && (p_oMenu instanceof Menu)) {

					oMenu = p_oMenu;
					bInstance = true;

					initMenu.call(this);

				}
				else if (Overlay && p_oMenu && (p_oMenu instanceof Overlay)) {

					oMenu = p_oMenu;
					bInstance = true;

					oMenu.cfg.queueProperty("visible", false);

					initMenu.call(this);

				}
				else if (Menu && Lang.isArray(p_oMenu)) {

					oMenu = new Menu(Dom.generateId(), { lazyload: bLazyLoad, itemdata: p_oMenu });

					this._menu = oMenu;

					this.on("appendTo", initMenu);

				}
				else if (Lang.isString(p_oMenu)) {

					oMenuElement = Dom.get(p_oMenu);

					if (oMenuElement) {

						if (Menu && Dom.hasClass(oMenuElement, sMenuCSSClassName) ||
							oMenuElement.nodeName.toUpperCase() == "SELECT") {

							oMenu = new Menu(p_oMenu, { lazyload: bLazyLoad });

							initMenu.call(this);

						}
						else if (Overlay) {

							oMenu = new Overlay(p_oMenu, { visible: false });

							initMenu.call(this);

						}

					}

				}
				else if (p_oMenu && p_oMenu.nodeName) {

					if (Menu && Dom.hasClass(p_oMenu, sMenuCSSClassName) ||
							p_oMenu.nodeName.toUpperCase() == "SELECT") {

						oMenu = new Menu(p_oMenu, { lazyload: bLazyLoad });

						initMenu.call(this);

					}
					else if (Overlay) {

						if (!p_oMenu.id) {

							Dom.generateId(p_oMenu);

						}

						oMenu = new Overlay(p_oMenu, { visible: false });

						initMenu.call(this);

					}

				}

            }

        },


        /**
        * @method _setOnClick
        * @description Sets the value of the button's "onclick" attribute.
        * @protected
        * @param {Object} p_oObject Object indicating the value for the button's
        * "onclick" attribute.
        */
        _setOnClick: function (p_oObject) {

            /*
                Remove any existing listeners if a "click" event handler
                has already been specified.
            */

            if (this._onclickAttributeValue &&
                (this._onclickAttributeValue != p_oObject)) {

                this.removeListener("click", this._onclickAttributeValue.fn);

                this._onclickAttributeValue = null;

            }


            if (!this._onclickAttributeValue &&
                Lang.isObject(p_oObject) &&
                Lang.isFunction(p_oObject.fn)) {

                this.on("click", p_oObject.fn, p_oObject.obj, p_oObject.scope);

                this._onclickAttributeValue = p_oObject;

            }

        },






        /**
        * @method _isActivationKey
        * @description Determines if the specified keycode is one that toggles
        * the button's "active" state.
        * @protected
        * @param {Number} p_nKeyCode Number representing the keycode to
        * be evaluated.
        * @return {Boolean}
        */
        _isActivationKey: function (p_nKeyCode) {

            var sType = this.get("type"),
                aKeyCodes = (sType == "checkbox" || sType == "radio") ?
                    this.CHECK_ACTIVATION_KEYS : this.ACTIVATION_KEYS,

                nKeyCodes = aKeyCodes.length,
                bReturnVal = false,
                i;


            if (nKeyCodes > 0) {

                i = nKeyCodes - 1;

                do {

                    if (p_nKeyCode == aKeyCodes[i]) {

                        bReturnVal = true;
                        break;

                    }

                }
                while (i--);

            }

            return bReturnVal;

        },


        /**
        * @method _isSplitButtonOptionKey
        * @description Determines if the specified keycode is one that toggles
        * the display of the split button's menu.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        * @return {Boolean}
        */
        _isSplitButtonOptionKey: function (p_oEvent) {

			var bShowMenu = (Event.getCharCode(p_oEvent) == 40);


			var onKeyPress = function (p_oEvent) {

				Event.preventDefault(p_oEvent);

				this.removeListener("keypress", onKeyPress);

			};


			if (bShowMenu) {

				if (UA.opera) {

					this.on("keypress", onKeyPress);

				}

				Event.preventDefault(p_oEvent);
			}

            return bShowMenu;

        },


        /**
        * @method _addListenersToForm
        * @description Adds event handlers to the button's form.
        * @protected
        */
        _addListenersToForm: function () {

            var oForm = this.getForm(),
                onFormKeyPress = YAHOO.widget.Button.onFormKeyPress,
                bHasKeyPressListener,
                oSrcElement,
                aListeners,
                nListeners,
                i;


            if (oForm) {

                Event.on(oForm, "reset", this._onFormReset, null, this);
                Event.on(oForm, "submit", this._onFormSubmit, null, this);

                oSrcElement = this.get("srcelement");


                if (this.get("type") == "submit" ||
                    (oSrcElement && oSrcElement.type == "submit"))
                {

                    aListeners = Event.getListeners(oForm, "keypress");
                    bHasKeyPressListener = false;

                    if (aListeners) {

                        nListeners = aListeners.length;

                        if (nListeners > 0) {

                            i = nListeners - 1;

                            do {

                                if (aListeners[i].fn == onFormKeyPress) {

                                    bHasKeyPressListener = true;
                                    break;

                                }

                            }
                            while (i--);

                        }

                    }


                    if (!bHasKeyPressListener) {

                        Event.on(oForm, "keypress", onFormKeyPress);

                    }

                }

            }

        },



        /**
        * @method _showMenu
        * @description Shows the button's menu.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event) that triggered
        * the display of the menu.
        */
        _showMenu: function (p_oEvent) {

            if (YAHOO.widget.MenuManager) {
                YAHOO.widget.MenuManager.hideVisible();
            }


            if (m_oOverlayManager) {
                m_oOverlayManager.hideAll();
            }


            var oMenu = this._menu,
            	aMenuAlignment = this.get("menualignment"),
            	bFocusMenu = this.get("focusmenu"),
				fnFocusMethod;


			if (this._renderedMenu) {

				oMenu.cfg.setProperty("context",
								[this.get("element"), aMenuAlignment[0], aMenuAlignment[1]]);

				oMenu.cfg.setProperty("preventcontextoverlap", true);
				oMenu.cfg.setProperty("constraintoviewport", true);

			}
			else {

				oMenu.cfg.queueProperty("context",
								[this.get("element"), aMenuAlignment[0], aMenuAlignment[1]]);

				oMenu.cfg.queueProperty("preventcontextoverlap", true);
				oMenu.cfg.queueProperty("constraintoviewport", true);

			}


			/*
				 Refocus the Button before showing its Menu in case the call to
				 YAHOO.widget.MenuManager.hideVisible() resulted in another element in the
				 DOM being focused after another Menu was hidden.
			*/

			this.focus();


            if (Menu && oMenu && (oMenu instanceof Menu)) {


				fnFocusMethod = oMenu.focus;

				oMenu.focus = function () {};

				if (this._renderedMenu) {

					oMenu.cfg.setProperty("minscrollheight", this.get("menuminscrollheight"));
					oMenu.cfg.setProperty("maxheight", this.get("menumaxheight"));

				}
				else {

					oMenu.cfg.queueProperty("minscrollheight", this.get("menuminscrollheight"));
					oMenu.cfg.queueProperty("maxheight", this.get("menumaxheight"));

				}


                oMenu.show();

        		oMenu.focus = fnFocusMethod;

				oMenu.align();


                /*
                    Stop the propagation of the event so that the MenuManager
                    doesn't blur the menu after it gets focus.
                */

                if (p_oEvent.type == "mousedown") {
                    Event.stopPropagation(p_oEvent);
                }


                if (bFocusMenu) {
                    oMenu.focus();
                }

            }
            else if (Overlay && oMenu && (oMenu instanceof Overlay)) {

				if (!this._renderedMenu) {
		            oMenu.render(this.get("element").parentNode);
				}

                oMenu.show();
				oMenu.align();

            }

        },


        /**
        * @method _hideMenu
        * @description Hides the button's menu.
        * @protected
        */
        _hideMenu: function () {

            var oMenu = this._menu;

            if (oMenu) {

                oMenu.hide();

            }

        },






        /**
        * @method _onMouseOver
        * @description "mouseover" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onMouseOver: function (p_oEvent) {

        	var sType = this.get("type"),
        		oElement,
				nOptionRegionX;


			if (sType === "split") {

				oElement = this.get("element");
				nOptionRegionX =
					(Dom.getX(oElement) + (oElement.offsetWidth - this.OPTION_AREA_WIDTH));

				this._nOptionRegionX = nOptionRegionX;

			}


            if (!this._hasMouseEventHandlers) {

				if (sType === "split") {

	        		this.on("mousemove", this._onMouseMove);

        		}

                this.on("mouseout", this._onMouseOut);

                this._hasMouseEventHandlers = true;

            }


            this.addStateCSSClasses("hover");


			if (sType === "split" && (Event.getPageX(p_oEvent) > nOptionRegionX)) {

				this.addStateCSSClasses("hoveroption");

			}


            if (this._activationButtonPressed) {

                this.addStateCSSClasses("active");

            }


            if (this._bOptionPressed) {

                this.addStateCSSClasses("activeoption");

            }


            if (this._activationButtonPressed || this._bOptionPressed) {

                Event.removeListener(document, "mouseup", this._onDocumentMouseUp);

            }

        },


        /**
        * @method _onMouseMove
        * @description "mousemove" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onMouseMove: function (p_oEvent) {

        	var nOptionRegionX = this._nOptionRegionX;

        	if (nOptionRegionX) {

				if (Event.getPageX(p_oEvent) > nOptionRegionX) {

					this.addStateCSSClasses("hoveroption");

				}
				else {

					this.removeStateCSSClasses("hoveroption");

				}

        	}

        },

        /**
        * @method _onMouseOut
        * @description "mouseout" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onMouseOut: function (p_oEvent) {

			var sType = this.get("type");

            this.removeStateCSSClasses("hover");


            if (sType != "menu") {

                this.removeStateCSSClasses("active");

            }


            if (this._activationButtonPressed || this._bOptionPressed) {

                Event.on(document, "mouseup", this._onDocumentMouseUp, null, this);

            }


			if (sType === "split" && (Event.getPageX(p_oEvent) > this._nOptionRegionX)) {

				this.removeStateCSSClasses("hoveroption");

			}

        },


        /**
        * @method _onDocumentMouseUp
        * @description "mouseup" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onDocumentMouseUp: function (p_oEvent) {

            this._activationButtonPressed = false;
            this._bOptionPressed = false;

            var sType = this.get("type"),
                oTarget,
                oMenuElement;

            if (sType == "menu" || sType == "split") {

                oTarget = Event.getTarget(p_oEvent);
                oMenuElement = this._menu.element;

                if (oTarget != oMenuElement &&
                    !Dom.isAncestor(oMenuElement, oTarget)) {

                    this.removeStateCSSClasses((sType == "menu" ?
                        "active" : "activeoption"));

                    this._hideMenu();

                }

            }

            Event.removeListener(document, "mouseup", this._onDocumentMouseUp);

        },


        /**
        * @method _onMouseDown
        * @description "mousedown" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onMouseDown: function (p_oEvent) {

            var sType,
            	bReturnVal = true;


            function onMouseUp() {

                this._hideMenu();
                this.removeListener("mouseup", onMouseUp);

            }


            if ((p_oEvent.which || p_oEvent.button) == 1) {


                if (!this.hasFocus()) {

                    this.focus();

                }


                sType = this.get("type");


                if (sType == "split") {

                    if (Event.getPageX(p_oEvent) > this._nOptionRegionX) {

                        this.fireEvent("option", p_oEvent);
						bReturnVal = false;

                    }
                    else {

                        this.addStateCSSClasses("active");

                        this._activationButtonPressed = true;

                    }

                }
                else if (sType == "menu") {

                    if (this.isActive()) {

                        this._hideMenu();

                        this._activationButtonPressed = false;

                    }
                    else {

                        this._showMenu(p_oEvent);

                        this._activationButtonPressed = true;

                    }

                }
                else {

                    this.addStateCSSClasses("active");

                    this._activationButtonPressed = true;

                }



                if (sType == "split" || sType == "menu") {

                    this._hideMenuTimer = Lang.later(250, this, this.on, ["mouseup", onMouseUp]);

                }

            }

            return bReturnVal;

        },


        /**
        * @method _onMouseUp
        * @description "mouseup" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onMouseUp: function (p_oEvent) {

            var sType = this.get("type"),
            	oHideMenuTimer = this._hideMenuTimer,
            	bReturnVal = true;


            if (oHideMenuTimer) {

  				oHideMenuTimer.cancel();

            }


            if (sType == "checkbox" || sType == "radio") {

                this.set("checked", !(this.get("checked")));

            }


            this._activationButtonPressed = false;


            if (sType != "menu") {

                this.removeStateCSSClasses("active");

            }


			if (sType == "split" && Event.getPageX(p_oEvent) > this._nOptionRegionX) {

				bReturnVal = false;

			}

			return bReturnVal;

        },


        /**
        * @method _onFocus
        * @description "focus" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onFocus: function (p_oEvent) {

            var oElement;

            this.addStateCSSClasses("focus");

            if (this._activationKeyPressed) {

                this.addStateCSSClasses("active");

            }

            m_oFocusedButton = this;


            if (!this._hasKeyEventHandlers) {

                oElement = this._button;

                Event.on(oElement, "blur", this._onBlur, null, this);
                Event.on(oElement, "keydown", this._onKeyDown, null, this);
                Event.on(oElement, "keyup", this._onKeyUp, null, this);

                this._hasKeyEventHandlers = true;

            }


            this.fireEvent("focus", p_oEvent);

        },


        /**
        * @method _onBlur
        * @description "blur" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onBlur: function (p_oEvent) {

            this.removeStateCSSClasses("focus");

            if (this.get("type") != "menu") {

                this.removeStateCSSClasses("active");

            }

            if (this._activationKeyPressed) {

                Event.on(document, "keyup", this._onDocumentKeyUp, null, this);

            }


            m_oFocusedButton = null;

            this.fireEvent("blur", p_oEvent);

        },


        /**
        * @method _onDocumentKeyUp
        * @description "keyup" event handler for the document.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onDocumentKeyUp: function (p_oEvent) {

            if (this._isActivationKey(Event.getCharCode(p_oEvent))) {

                this._activationKeyPressed = false;

                Event.removeListener(document, "keyup", this._onDocumentKeyUp);

            }

        },


        /**
        * @method _onKeyDown
        * @description "keydown" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onKeyDown: function (p_oEvent) {

            var oMenu = this._menu;


            if (this.get("type") == "split" &&
                this._isSplitButtonOptionKey(p_oEvent)) {

                this.fireEvent("option", p_oEvent);

            }
            else if (this._isActivationKey(Event.getCharCode(p_oEvent))) {

                if (this.get("type") == "menu") {

                    this._showMenu(p_oEvent);

                }
                else {

                    this._activationKeyPressed = true;

                    this.addStateCSSClasses("active");

                }

            }


            if (oMenu && oMenu.cfg.getProperty("visible") &&
                Event.getCharCode(p_oEvent) == 27) {

                oMenu.hide();
                this.focus();

            }

        },


        /**
        * @method _onKeyUp
        * @description "keyup" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onKeyUp: function (p_oEvent) {

            var sType;

            if (this._isActivationKey(Event.getCharCode(p_oEvent))) {

                sType = this.get("type");

                if (sType == "checkbox" || sType == "radio") {

                    this.set("checked", !(this.get("checked")));

                }

                this._activationKeyPressed = false;

                if (this.get("type") != "menu") {

                    this.removeStateCSSClasses("active");

                }

            }

        },


        /**
        * @method _onClick
        * @description "click" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onClick: function (p_oEvent) {

            var sType = this.get("type"),
                oForm,
                oSrcElement,
                bReturnVal;


			switch (sType) {

			case "submit":

				if (p_oEvent.returnValue !== false) {

					this.submitForm();

				}

				break;

			case "reset":

				oForm = this.getForm();

				if (oForm) {

					oForm.reset();

				}

				break;


			case "split":

				if (this._nOptionRegionX > 0 &&
						(Event.getPageX(p_oEvent) > this._nOptionRegionX)) {

					bReturnVal = false;

				}
				else {

					this._hideMenu();

					oSrcElement = this.get("srcelement");

					if (oSrcElement && oSrcElement.type == "submit" &&
							p_oEvent.returnValue !== false) {

						this.submitForm();

					}

				}

				break;

			}

			return bReturnVal;

        },


        /**
        * @method _onDblClick
        * @description "dblclick" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onDblClick: function (p_oEvent) {

            var bReturnVal = true;

			if (this.get("type") == "split" && Event.getPageX(p_oEvent) > this._nOptionRegionX) {

				bReturnVal = false;

			}

        	return bReturnVal;

        },


        /**
        * @method _onAppendTo
        * @description "appendTo" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onAppendTo: function (p_oEvent) {

            /*
                It is necessary to call "_addListenersToForm" using
                "setTimeout" to make sure that the button's "form" property
                returns a node reference.  Sometimes, if you try to get the
                reference immediately after appending the field, it is null.
            */

            Lang.later(0, this, this._addListenersToForm);

        },


        /**
        * @method _onFormReset
        * @description "reset" event handler for the button's form.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event
        * object passed back by the event utility (YAHOO.util.Event).
        */
        _onFormReset: function (p_oEvent) {

            var sType = this.get("type"),
                oMenu = this._menu;

            if (sType == "checkbox" || sType == "radio") {

                this.resetValue("checked");

            }


            if (Menu && oMenu && (oMenu instanceof Menu)) {

                this.resetValue("selectedMenuItem");

            }

        },


        /**
        * @method _onFormSubmit
        * @description "submit" event handler for the button's form.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event
        * object passed back by the event utility (YAHOO.util.Event).
        */
        _onFormSubmit: function (p_oEvent) {

        	this.createHiddenFields();

        },


        /**
        * @method _onDocumentMouseDown
        * @description "mousedown" event handler for the document.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onDocumentMouseDown: function (p_oEvent) {

            var oTarget = Event.getTarget(p_oEvent),
                oButtonElement = this.get("element"),
                oMenuElement = this._menu.element;


            if (oTarget != oButtonElement &&
                !Dom.isAncestor(oButtonElement, oTarget) &&
                oTarget != oMenuElement &&
                !Dom.isAncestor(oMenuElement, oTarget)) {

                this._hideMenu();


				if (UA.ie && oTarget.focus) {
					oTarget.setActive();
				}

                Event.removeListener(document, "mousedown",
                    this._onDocumentMouseDown);

            }

        },


        /**
        * @method _onOption
        * @description "option" event handler for the button.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onOption: function (p_oEvent) {

            if (this.hasClass(this.CLASS_NAME_PREFIX + "split-button-activeoption")) {

                this._hideMenu();

                this._bOptionPressed = false;

            }
            else {

                this._showMenu(p_oEvent);

                this._bOptionPressed = true;

            }

        },


        /**
        * @method _onMenuShow
        * @description "show" event handler for the button's menu.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        */
        _onMenuShow: function (p_sType) {

            Event.on(document, "mousedown", this._onDocumentMouseDown,
                null, this);

            var sState = (this.get("type") == "split") ? "activeoption" : "active";

            this.addStateCSSClasses(sState);

        },


        /**
        * @method _onMenuHide
        * @description "hide" event handler for the button's menu.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        */
        _onMenuHide: function (p_sType) {

            var sState = (this.get("type") == "split") ? "activeoption" : "active";

            this.removeStateCSSClasses(sState);


            if (this.get("type") == "split") {

                this._bOptionPressed = false;

            }

        },


        /**
        * @method _onMenuKeyDown
        * @description "keydown" event handler for the button's menu.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        _onMenuKeyDown: function (p_sType, p_aArgs) {

            var oEvent = p_aArgs[0];

            if (Event.getCharCode(oEvent) == 27) {

                this.focus();

                if (this.get("type") == "split") {

                    this._bOptionPressed = false;

                }

            }

        },


        /**
        * @method _onMenuRender
        * @description "render" event handler for the button's menu.
        * @private
        * @param {String} p_sType String representing the name of the
        * event thatwas fired.
        */
        _onMenuRender: function (p_sType) {

            var oButtonElement = this.get("element"),
                oButtonParent = oButtonElement.parentNode,
				oMenu = this._menu,
                oMenuElement = oMenu.element,
				oSrcElement = oMenu.srcElement,
				oItem;


            if (oButtonParent != oMenuElement.parentNode) {

                oButtonParent.appendChild(oMenuElement);

            }

			this._renderedMenu = true;


			if (oSrcElement &&
					oSrcElement.nodeName.toLowerCase() === "select" &&
					oSrcElement.value) {


				oItem = oMenu.getItem(oSrcElement.selectedIndex);


				this.set("selectedMenuItem", oItem, true);


				this._onSelectedMenuItemChange({ newValue: oItem });

			}

        },



        /**
        * @method _onMenuClick
        * @description "click" event handler for the button's menu.
        * @private
        * @param {String} p_sType String representing the name of the event
        * that was fired.
        * @param {Array} p_aArgs Array of arguments sent when the event
        * was fired.
        */
        _onMenuClick: function (p_sType, p_aArgs) {

            var oItem = p_aArgs[1],
                oSrcElement;

            if (oItem) {

				this.set("selectedMenuItem", oItem);

                oSrcElement = this.get("srcelement");

                if (oSrcElement && oSrcElement.type == "submit") {

                    this.submitForm();

                }

                this._hideMenu();

            }

        },


        /**
        * @method _onSelectedMenuItemChange
        * @description "selectedMenuItemChange" event handler for the Button's
		* "selectedMenuItem" attribute.
        * @param {Event} event Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
		_onSelectedMenuItemChange: function (event) {

			var oSelected = event.prevValue,
				oItem = event.newValue,
				sPrefix = this.CLASS_NAME_PREFIX;

			if (oSelected) {
				Dom.removeClass(oSelected.element, (sPrefix + "button-selectedmenuitem"));
			}

			if (oItem) {
				Dom.addClass(oItem.element, (sPrefix + "button-selectedmenuitem"));
			}

		},


        /**
        * @method _onLabelClick
        * @description "click" event handler for the Button's
		* <code>&#60;label&#62;</code> element.
        * @param {Event} event Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
		_onLabelClick: function (event) {

			this.focus();

			var sType = this.get("type");

			if (sType == "radio" || sType == "checkbox") {
				this.set("checked", (!this.get("checked")));
			}

		},




        /**
        * @method createButtonElement
        * @description Creates the button's HTML elements.
        * @param {String} p_sType String indicating the type of element
        * to create.
        * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-58190037">HTMLElement</a>}
        */
        createButtonElement: function (p_sType) {

            var sNodeName = this.NODE_NAME,
                oElement = document.createElement(sNodeName);

            oElement.innerHTML =  "<" + sNodeName + " class=\"first-child\">" +
                (p_sType == "link" ? "<a></a>" :
                "<button type=\"button\"></button>") + "</" + sNodeName + ">";

            return oElement;

        },


        /**
        * @method addStateCSSClasses
        * @description Appends state-specific CSS classes to the button's root
        * DOM element.
        */
        addStateCSSClasses: function (p_sState) {

            var sType = this.get("type"),
				sPrefix = this.CLASS_NAME_PREFIX;

            if (Lang.isString(p_sState)) {

                if (p_sState != "activeoption" && p_sState != "hoveroption") {

                    this.addClass(sPrefix + this.CSS_CLASS_NAME + ("-" + p_sState));

                }

                this.addClass(sPrefix + sType + ("-button-" + p_sState));

            }

        },


        /**
        * @method removeStateCSSClasses
        * @description Removes state-specific CSS classes to the button's root
        * DOM element.
        */
        removeStateCSSClasses: function (p_sState) {

            var sType = this.get("type"),
				sPrefix = this.CLASS_NAME_PREFIX;

            if (Lang.isString(p_sState)) {

                this.removeClass(sPrefix + this.CSS_CLASS_NAME + ("-" + p_sState));
                this.removeClass(sPrefix + sType + ("-button-" + p_sState));

            }

        },


        /**
        * @method createHiddenFields
        * @description Creates the button's hidden form field and appends it
        * to its parent form.
        * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-6043025">HTMLInputElement</a>|Array}
        */
        createHiddenFields: function () {

            this.removeHiddenFields();

            var oForm = this.getForm(),
                oButtonField,
                sType,
                bCheckable,
                oMenu,
                oMenuItem,
                sButtonName,
                oValue,
                oMenuField,
                oReturnVal,
				sMenuFieldName,
				oMenuSrcElement,
				bMenuSrcElementIsSelect = false;


            if (oForm && !this.get("disabled")) {

                sType = this.get("type");
                bCheckable = (sType == "checkbox" || sType == "radio");


                if ((bCheckable && this.get("checked")) || (m_oSubmitTrigger == this)) {


                    oButtonField = createInputElement((bCheckable ? sType : "hidden"),
                                    this.get("name"), this.get("value"), this.get("checked"));


                    if (oButtonField) {

                        if (bCheckable) {

                            oButtonField.style.display = "none";

                        }

                        oForm.appendChild(oButtonField);

                    }

                }


                oMenu = this._menu;


                if (Menu && oMenu && (oMenu instanceof Menu)) {


                    oMenuItem = this.get("selectedMenuItem");
					oMenuSrcElement = oMenu.srcElement;
					bMenuSrcElementIsSelect = (oMenuSrcElement &&
												oMenuSrcElement.nodeName.toUpperCase() == "SELECT");

                    if (oMenuItem) {

						oValue = (oMenuItem.value === null || oMenuItem.value === "") ?
									oMenuItem.cfg.getProperty("text") : oMenuItem.value;

						sButtonName = this.get("name");


						if (bMenuSrcElementIsSelect) {

							sMenuFieldName = oMenuSrcElement.name;

						}
						else if (sButtonName) {

							sMenuFieldName = (sButtonName + "_options");

						}


						if (oValue && sMenuFieldName) {

							oMenuField = createInputElement("hidden", sMenuFieldName, oValue);
							oForm.appendChild(oMenuField);

						}

                    }
                    else if (bMenuSrcElementIsSelect) {

						oMenuField = oForm.appendChild(oMenuSrcElement);

                    }

                }


                if (oButtonField && oMenuField) {

                    this._hiddenFields = [oButtonField, oMenuField];

                }
                else if (!oButtonField && oMenuField) {

                    this._hiddenFields = oMenuField;

                }
                else if (oButtonField && !oMenuField) {

                    this._hiddenFields = oButtonField;

                }

        		oReturnVal = this._hiddenFields;

            }

			return oReturnVal;

        },


        /**
        * @method removeHiddenFields
        * @description Removes the button's hidden form field(s) from its
        * parent form.
        */
        removeHiddenFields: function () {

            var oField = this._hiddenFields,
                nFields,
                i;

            function removeChild(p_oElement) {

                if (Dom.inDocument(p_oElement)) {

                    p_oElement.parentNode.removeChild(p_oElement);

                }

            }


            if (oField) {

                if (Lang.isArray(oField)) {

                    nFields = oField.length;

                    if (nFields > 0) {

                        i = nFields - 1;

                        do {

                            removeChild(oField[i]);

                        }
                        while (i--);

                    }

                }
                else {

                    removeChild(oField);

                }

                this._hiddenFields = null;

            }

        },


        /**
        * @method submitForm
        * @description Submits the form to which the button belongs.  Returns
        * true if the form was submitted successfully, false if the submission
        * was cancelled.
        * @protected
        * @return {Boolean}
        */
        submitForm: function () {

            var oForm = this.getForm(),

                oSrcElement = this.get("srcelement"),

                /*
                    Boolean indicating if the event fired successfully
                    (was not cancelled by any handlers)
                */

                bSubmitForm = false,

                oEvent;


            if (oForm) {

                if (this.get("type") == "submit" || (oSrcElement && oSrcElement.type == "submit")) {

                    m_oSubmitTrigger = this;

                }


                if (UA.ie) {

                    bSubmitForm = oForm.fireEvent("onsubmit");

                }
                else {  // Gecko, Opera, and Safari

                    oEvent = document.createEvent("HTMLEvents");
                    oEvent.initEvent("submit", true, true);

                    bSubmitForm = oForm.dispatchEvent(oEvent);

                }


                /*
                    In IE and Safari, dispatching a "submit" event to a form
                    WILL cause the form's "submit" event to fire, but WILL NOT
                    submit the form.  Therefore, we need to call the "submit"
                    method as well.
                */

                if ((UA.ie || UA.webkit) && bSubmitForm) {

                    oForm.submit();

                }

            }

            return bSubmitForm;

        },


        /**
        * @method init
        * @description The Button class's initialization method.
        * @param {String} p_oElement String specifying the id attribute of the
        * <code>&#60;input&#62;</code>, <code>&#60;button&#62;</code>,
        * <code>&#60;a&#62;</code>, or <code>&#60;span&#62;</code> element to
        * be used to create the button.
        * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-6043025">HTMLInputElement</a>|<a href="http://
        * www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html
        * #ID-34812697">HTMLButtonElement</a>|<a href="http://www.w3.org/TR
        * /2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-33759296">
        * HTMLElement</a>} p_oElement Object reference for the
        * <code>&#60;input&#62;</code>, <code>&#60;button&#62;</code>,
        * <code>&#60;a&#62;</code>, or <code>&#60;span&#62;</code> element to be
        * used to create the button.
        * @param {Object} p_oElement Object literal specifying a set of
        * configuration attributes used to create the button.
        * @param {Object} p_oAttributes Optional. Object literal specifying a
        * set of configuration attributes used to create the button.
        */
        init: function (p_oElement, p_oAttributes) {

            var sNodeName = p_oAttributes.type == "link" ? "a" : "button",
                oSrcElement = p_oAttributes.srcelement,
                oButton = p_oElement.getElementsByTagName(sNodeName)[0],
                oInput;


            if (!oButton) {

                oInput = p_oElement.getElementsByTagName("input")[0];


                if (oInput) {

                    oButton = document.createElement("button");
                    oButton.setAttribute("type", "button");

                    oInput.parentNode.replaceChild(oButton, oInput);

                }

            }

            this._button = oButton;


            YAHOO.widget.Button.superclass.init.call(this, p_oElement, p_oAttributes);


			var sId = this.get("id"),
				sButtonId = sId + "-button";


        	oButton.id = sButtonId;


			var aLabels,
				oLabel;


        	var hasLabel = function (element) {

				return (element.htmlFor === sId);

        	};


			var setLabel = function () {

				oLabel.setAttribute((UA.ie ? "htmlFor" : "for"), sButtonId);

			};


			if (oSrcElement && this.get("type") != "link") {

				aLabels = Dom.getElementsBy(hasLabel, "label");

				if (Lang.isArray(aLabels) && aLabels.length > 0) {

					oLabel = aLabels[0];

				}

			}


            m_oButtons[sId] = this;

        	var sPrefix = this.CLASS_NAME_PREFIX;

            this.addClass(sPrefix + this.CSS_CLASS_NAME);
            this.addClass(sPrefix + this.get("type") + "-button");

            Event.on(this._button, "focus", this._onFocus, null, this);
            this.on("mouseover", this._onMouseOver);
			this.on("mousedown", this._onMouseDown);
			this.on("mouseup", this._onMouseUp);
            this.on("click", this._onClick);


			var fnOnClick = this.get("onclick");

			this.set("onclick", null);
			this.set("onclick", fnOnClick);

            this.on("dblclick", this._onDblClick);


			var oParentNode;

            if (oLabel) {

				if (this.get("replaceLabel")) {

					this.set("label", oLabel.innerHTML);

					oParentNode = oLabel.parentNode;

					oParentNode.removeChild(oLabel);

				}
				else {

					this.on("appendTo", setLabel);

					Event.on(oLabel, "click", this._onLabelClick, null, this);

					this._label = oLabel;

				}

            }

            this.on("appendTo", this._onAppendTo);



            var oContainer = this.get("container"),
                oElement = this.get("element"),
                bElInDoc = Dom.inDocument(oElement);


            if (oContainer) {

                if (oSrcElement && oSrcElement != oElement) {

                    oParentNode = oSrcElement.parentNode;

                    if (oParentNode) {

                        oParentNode.removeChild(oSrcElement);

                    }

                }

                if (Lang.isString(oContainer)) {

                    Event.onContentReady(oContainer, this.appendTo, oContainer, this);

                }
                else {

        			this.on("init", function () {

        				Lang.later(0, this, this.appendTo, oContainer);

        			});

                }

            }
            else if (!bElInDoc && oSrcElement && oSrcElement != oElement) {

                oParentNode = oSrcElement.parentNode;

                if (oParentNode) {

                    this.fireEvent("beforeAppendTo", {
                        type: "beforeAppendTo",
                        target: oParentNode
                    });

                    oParentNode.replaceChild(oElement, oSrcElement);

                    this.fireEvent("appendTo", {
                        type: "appendTo",
                        target: oParentNode
                    });

                }

            }
            else if (this.get("type") != "link" && bElInDoc && oSrcElement &&
                oSrcElement == oElement) {

                this._addListenersToForm();

            }



			this.fireEvent("init", {
				type: "init",
				target: this
			});

        },


        /**
        * @method initAttributes
        * @description Initializes all of the configuration attributes used to
        * create the button.
        * @param {Object} p_oAttributes Object literal specifying a set of
        * configuration attributes used to create the button.
        */
        initAttributes: function (p_oAttributes) {

            var oAttributes = p_oAttributes || {};

            YAHOO.widget.Button.superclass.initAttributes.call(this,
                oAttributes);


            /**
            * @attribute type
            * @description String specifying the button's type.  Possible
            * values are: "push," "link," "submit," "reset," "checkbox,"
            * "radio," "menu," and "split."
            * @default "push"
            * @type String
			* @writeonce
            */
            this.setAttributeConfig("type", {

                value: (oAttributes.type || "push"),
                validator: Lang.isString,
                writeOnce: true,
                method: this._setType

            });


            /**
            * @attribute label
            * @description String specifying the button's text label
            * or innerHTML.
            * @default null
            * @type String
            */
            this.setAttributeConfig("label", {

                value: oAttributes.label,
                validator: Lang.isString,
                method: this._setLabel

            });


            /**
            * @attribute value
            * @description Object specifying the value for the button.
            * @default null
            * @type Object
            */
            this.setAttributeConfig("value", {

                value: oAttributes.value

            });


            /**
            * @attribute name
            * @description String specifying the name for the button.
            * @default null
            * @type String
            */
            this.setAttributeConfig("name", {

                value: oAttributes.name,
                validator: Lang.isString

            });


            /**
            * @attribute tabindex
            * @description Number specifying the tabindex for the button.
            * @default null
            * @type Number
            */
            this.setAttributeConfig("tabindex", {

                value: oAttributes.tabindex,
                validator: Lang.isNumber,
                method: this._setTabIndex

            });


            /**
            * @attribute title
            * @description String specifying the title for the button.
            * @default null
            * @type String
            */
            this.configureAttribute("title", {

                value: oAttributes.title,
                validator: Lang.isString,
                method: this._setTitle

            });


            /**
            * @attribute disabled
            * @description Boolean indicating if the button should be disabled.
            * (Disabled buttons are dimmed and will not respond to user input
            * or fire events.  Does not apply to button's of type "link.")
            * @default false
            * @type Boolean
            */
            this.setAttributeConfig("disabled", {

                value: (oAttributes.disabled || false),
                validator: Lang.isBoolean,
                method: this._setDisabled

            });


            /**
            * @attribute href
            * @description String specifying the href for the button.  Applies
            * only to buttons of type "link."
            * @type String
            */
            this.setAttributeConfig("href", {

                value: oAttributes.href,
                validator: Lang.isString,
                method: this._setHref

            });


            /**
            * @attribute target
            * @description String specifying the target for the button.
            * Applies only to buttons of type "link."
            * @type String
            */
            this.setAttributeConfig("target", {

                value: oAttributes.target,
                validator: Lang.isString,
                method: this._setTarget

            });


            /**
            * @attribute checked
            * @description Boolean indicating if the button is checked.
            * Applies only to buttons of type "radio" and "checkbox."
            * @default false
            * @type Boolean
            */
            this.setAttributeConfig("checked", {

                value: (oAttributes.checked || false),
                validator: Lang.isBoolean,
                method: this._setChecked

            });


            /**
            * @attribute container
            * @description HTML element reference or string specifying the id
            * attribute of the HTML element that the button's markup should be
            * rendered into.
            * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
            * level-one-html.html#ID-58190037">HTMLElement</a>|String
            * @default null
			* @writeonce
            */
            this.setAttributeConfig("container", {

                value: oAttributes.container,
                writeOnce: true

            });


            /**
            * @attribute srcelement
            * @description Object reference to the HTML element (either
            * <code>&#60;input&#62;</code> or <code>&#60;span&#62;</code>)
            * used to create the button.
            * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
            * level-one-html.html#ID-58190037">HTMLElement</a>|String
            * @default null
			* @writeonce
            */
            this.setAttributeConfig("srcelement", {

                value: oAttributes.srcelement,
                writeOnce: true

            });


            /**
            * @attribute menu
            * @description Object specifying the menu for the button.
            * The value can be one of the following:
            * <ul>
            * <li>Object specifying a rendered <a href="YAHOO.widget.Menu.html">
            * YAHOO.widget.Menu</a> instance.</li>
            * <li>Object specifying a rendered <a href="YAHOO.widget.Overlay.html">
            * YAHOO.widget.Overlay</a> instance.</li>
            * <li>String specifying the id attribute of the <code>&#60;div&#62;
            * </code> element used to create the menu.  By default the menu
            * will be created as an instance of
            * <a href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>.
            * If the <a href="YAHOO.widget.Menu.html#CSS_CLASS_NAME">
            * default CSS class name for YAHOO.widget.Menu</a> is applied to
            * the <code>&#60;div&#62;</code> element, it will be created as an
            * instance of <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu
            * </a>.</li><li>String specifying the id attribute of the
            * <code>&#60;select&#62;</code> element used to create the menu.
            * </li><li>Object specifying the <code>&#60;div&#62;</code> element
            * used to create the menu.</li>
            * <li>Object specifying the <code>&#60;select&#62;</code> element
            * used to create the menu.</li>
            * <li>Array of object literals, each representing a set of
            * <a href="YAHOO.widget.MenuItem.html">YAHOO.widget.MenuItem</a>
            * configuration attributes.</li>
            * <li>Array of strings representing the text labels for each menu
            * item in the menu.</li>
            * </ul>
            * @type <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>|<a
            * href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>|<a
            * href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
            * one-html.html#ID-58190037">HTMLElement</a>|String|Array
            * @default null
			* @writeonce
            */
            this.setAttributeConfig("menu", {

                value: null,
                method: this._setMenu,
                writeOnce: true

            });


            /**
            * @attribute lazyloadmenu
            * @description Boolean indicating the value to set for the
            * <a href="YAHOO.widget.Menu.html#lazyLoad">"lazyload"</a>
            * configuration property of the button's menu.  Setting
            * "lazyloadmenu" to <code>true </code> will defer rendering of
            * the button's menu until the first time it is made visible.
            * If "lazyloadmenu" is set to <code>false</code>, the button's
            * menu will be rendered immediately if the button is in the
            * document, or in response to the button's "appendTo" event if
            * the button is not yet in the document.  In either case, the
            * menu is rendered into the button's parent HTML element.
            * <em>This attribute does not apply if a
            * <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a> or
            * <a href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>
            * instance is passed as the value of the button's "menu"
            * configuration attribute. <a href="YAHOO.widget.Menu.html">
            * YAHOO.widget.Menu</a> or <a href="YAHOO.widget.Overlay.html">
            * YAHOO.widget.Overlay</a> instances should be rendered before
            * being set as the value for the "menu" configuration
            * attribute.</em>
            * @default true
            * @type Boolean
			* @writeonce
            */
            this.setAttributeConfig("lazyloadmenu", {

                value: (oAttributes.lazyloadmenu === false ? false : true),
                validator: Lang.isBoolean,
                writeOnce: true

            });


            /**
            * @attribute menuclassname
            * @description String representing the CSS class name to be
            * applied to the root element of the button's menu.
            * @type String
            * @default "yui-button-menu"
			* @writeonce
            */
            this.setAttributeConfig("menuclassname", {

                value: (oAttributes.menuclassname || (this.CLASS_NAME_PREFIX + "button-menu")),
                validator: Lang.isString,
                method: this._setMenuClassName,
                writeOnce: true

            });


			/**
			* @attribute menuminscrollheight
			* @description Number defining the minimum threshold for the "menumaxheight"
			* configuration attribute.  When set this attribute is automatically applied
			* to all submenus.
			* @default 90
			* @type Number
			*/
            this.setAttributeConfig("menuminscrollheight", {

                value: (oAttributes.menuminscrollheight || 90),
                validator: Lang.isNumber

            });


            /**
            * @attribute menumaxheight
			* @description Number defining the maximum height (in pixels) for a menu's
			* body element (<code>&#60;div class="bd"&#60;</code>).  Once a menu's body
			* exceeds this height, the contents of the body are scrolled to maintain
			* this value.  This value cannot be set lower than the value of the
			* "minscrollheight" configuration property.
            * @type Number
            * @default 0
            */
            this.setAttributeConfig("menumaxheight", {

                value: (oAttributes.menumaxheight || 0),
                validator: Lang.isNumber

            });


            /**
            * @attribute menualignment
			* @description Array defining how the Button's Menu is aligned to the Button.
            * The default value of ["tl", "bl"] aligns the Menu's top left corner to the Button's
            * bottom left corner.
            * @type Array
            * @default ["tl", "bl"]
            */
            this.setAttributeConfig("menualignment", {

                value: (oAttributes.menualignment || ["tl", "bl"]),
                validator: Lang.isArray

            });


            /**
            * @attribute selectedMenuItem
            * @description Object representing the item in the button's menu
            * that is currently selected.
            * @type YAHOO.widget.MenuItem
            * @default null
            */
            this.setAttributeConfig("selectedMenuItem", {

                value: null

            });


            /**
            * @attribute onclick
            * @description Object literal representing the code to be executed
            * when the button is clicked.  Format:<br> <code> {<br>
            * <strong>fn:</strong> Function,   &#47;&#47; The handler to call
            * when the event fires.<br> <strong>obj:</strong> Object,
            * &#47;&#47; An object to pass back to the handler.<br>
            * <strong>scope:</strong> Object &#47;&#47;  The object to use
            * for the scope of the handler.<br> } </code>
            * @type Object
            * @default null
            */
            this.setAttributeConfig("onclick", {

                value: oAttributes.onclick,
                method: this._setOnClick

            });


            /**
            * @attribute focusmenu
            * @description Boolean indicating whether or not the button's menu
            * should be focused when it is made visible.
            * @type Boolean
            * @default true
            */
            this.setAttributeConfig("focusmenu", {

                value: (oAttributes.focusmenu === false ? false : true),
                validator: Lang.isBoolean

            });


            /**
            * @attribute replaceLabel
            * @description Boolean indicating whether or not the text of the
			* button's <code>&#60;label&#62;</code> element should be used as
			* the source for the button's label configuration attribute and
			* removed from the DOM.
            * @type Boolean
            * @default false
            */
            this.setAttributeConfig("replaceLabel", {

                value: false,
                validator: Lang.isBoolean,
                writeOnce: true

            });

        },


        /**
        * @method focus
        * @description Causes the button to receive the focus and fires the
        * button's "focus" event.
        */
        focus: function () {

            if (!this.get("disabled")) {

                this._button.focus();

            }

        },


        /**
        * @method blur
        * @description Causes the button to lose focus and fires the button's
        * "blur" event.
        */
        blur: function () {

            if (!this.get("disabled")) {

                this._button.blur();

            }

        },


        /**
        * @method hasFocus
        * @description Returns a boolean indicating whether or not the button
        * has focus.
        * @return {Boolean}
        */
        hasFocus: function () {

            return (m_oFocusedButton == this);

        },


        /**
        * @method isActive
        * @description Returns a boolean indicating whether or not the button
        * is active.
        * @return {Boolean}
        */
        isActive: function () {

            return this.hasClass(this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME + "-active");

        },


        /**
        * @method getMenu
        * @description Returns a reference to the button's menu.
        * @return {<a href="YAHOO.widget.Overlay.html">
        * YAHOO.widget.Overlay</a>|<a
        * href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>}
        */
        getMenu: function () {

            return this._menu;

        },


        /**
        * @method getForm
        * @description Returns a reference to the button's parent form.
        * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-
        * 20000929/level-one-html.html#ID-40002357">HTMLFormElement</a>}
        */
        getForm: function () {

        	var oButton = this._button,
        		oForm;

            if (oButton) {

            	oForm = oButton.form;

            }

        	return oForm;

        },


        /**
        * @method getHiddenFields
        * @description Returns an <code>&#60;input&#62;</code> element or
        * array of form elements used to represent the button when its parent
        * form is submitted.
        * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-6043025">HTMLInputElement</a>|Array}
        */
        getHiddenFields: function () {

            return this._hiddenFields;

        },


        /**
        * @method destroy
        * @description Removes the button's element from its parent element and
        * removes all event handlers.
        */
        destroy: function () {


            var oElement = this.get("element"),
                oMenu = this._menu,
				oLabel = this._label,
                oParentNode,
                aButtons;

            if (oMenu) {


                if (m_oOverlayManager && m_oOverlayManager.find(oMenu)) {

                    m_oOverlayManager.remove(oMenu);

                }

                oMenu.destroy();

            }


            Event.purgeElement(oElement);
            Event.purgeElement(this._button);
            Event.removeListener(document, "mouseup", this._onDocumentMouseUp);
            Event.removeListener(document, "keyup", this._onDocumentKeyUp);
            Event.removeListener(document, "mousedown", this._onDocumentMouseDown);


			if (oLabel) {

            	Event.removeListener(oLabel, "click", this._onLabelClick);

				oParentNode = oLabel.parentNode;
				oParentNode.removeChild(oLabel);

			}


            var oForm = this.getForm();

            if (oForm) {

                Event.removeListener(oForm, "reset", this._onFormReset);
                Event.removeListener(oForm, "submit", this._onFormSubmit);

            }


            this.unsubscribeAll();

			oParentNode = oElement.parentNode;

            if (oParentNode) {

                oParentNode.removeChild(oElement);

            }


            delete m_oButtons[this.get("id")];

			var sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);

            aButtons = Dom.getElementsByClassName(sClass,
                                this.NODE_NAME, oForm);

            if (Lang.isArray(aButtons) && aButtons.length === 0) {

                Event.removeListener(oForm, "keypress",
                        YAHOO.widget.Button.onFormKeyPress);

            }


        },


        fireEvent: function (p_sType , p_aArgs) {

			var sType = arguments[0];


			if (this.DOM_EVENTS[sType] && this.get("disabled")) {

				return false;

			}

			return YAHOO.widget.Button.superclass.fireEvent.apply(this, arguments);

        },


        /**
        * @method toString
        * @description Returns a string representing the button.
        * @return {String}
        */
        toString: function () {

            return ("Button " + this.get("id"));

        }

    });


    /**
    * @method YAHOO.widget.Button.onFormKeyPress
    * @description "keypress" event handler for the button's form.
    * @param {Event} p_oEvent Object representing the DOM event object passed
    * back by the event utility (YAHOO.util.Event).
    */
    YAHOO.widget.Button.onFormKeyPress = function (p_oEvent) {

        var oTarget = Event.getTarget(p_oEvent),
            nCharCode = Event.getCharCode(p_oEvent),
            sNodeName = oTarget.nodeName && oTarget.nodeName.toUpperCase(),
            sType = oTarget.type,

            /*
                Boolean indicating if the form contains any enabled or
                disabled YUI submit buttons
            */

            bFormContainsYUIButtons = false,

            oButton,

            oYUISubmitButton,   // The form's first, enabled YUI submit button

            /*
                 The form's first, enabled HTML submit button that precedes any
                 YUI submit button
            */

            oPrecedingSubmitButton,

            oEvent;


        function isSubmitButton(p_oElement) {

            var sId,
                oSrcElement;

            switch (p_oElement.nodeName.toUpperCase()) {

            case "INPUT":
            case "BUTTON":

                if (p_oElement.type == "submit" && !p_oElement.disabled) {

                    if (!bFormContainsYUIButtons && !oPrecedingSubmitButton) {

                        oPrecedingSubmitButton = p_oElement;

                    }

                }

                break;


            default:

                sId = p_oElement.id;

                if (sId) {

                    oButton = m_oButtons[sId];

                    if (oButton) {

                        bFormContainsYUIButtons = true;

                        if (!oButton.get("disabled")) {

                            oSrcElement = oButton.get("srcelement");

                            if (!oYUISubmitButton && (oButton.get("type") == "submit" ||
                                (oSrcElement && oSrcElement.type == "submit"))) {

                                oYUISubmitButton = oButton;

                            }

                        }

                    }

                }

                break;

            }

        }


        if (nCharCode == 13 && ((sNodeName == "INPUT" && (sType == "text" ||
            sType == "password" || sType == "checkbox" || sType == "radio" ||
            sType == "file")) || sNodeName == "SELECT")) {

            Dom.getElementsBy(isSubmitButton, "*", this);


            if (oPrecedingSubmitButton) {

                /*
                     Need to set focus to the first enabled submit button
                     to make sure that IE includes its name and value
                     in the form's data set.
                */

                oPrecedingSubmitButton.focus();

            }
            else if (!oPrecedingSubmitButton && oYUISubmitButton) {

				/*
					Need to call "preventDefault" to ensure that the form doesn't end up getting
					submitted twice.
				*/

    			Event.preventDefault(p_oEvent);


				if (UA.ie) {

					oYUISubmitButton.get("element").fireEvent("onclick");

				}
				else {

					oEvent = document.createEvent("HTMLEvents");
					oEvent.initEvent("click", true, true);


					if (UA.gecko < 1.9) {

						oYUISubmitButton.fireEvent("click", oEvent);

					}
					else {

						oYUISubmitButton.get("element").dispatchEvent(oEvent);

					}

                }

            }

        }

    };


    /**
    * @method YAHOO.widget.Button.addHiddenFieldsToForm
    * @description Searches the specified form and adds hidden fields for
    * instances of YAHOO.widget.Button that are of type "radio," "checkbox,"
    * "menu," and "split."
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
    * one-html.html#ID-40002357">HTMLFormElement</a>} p_oForm Object reference
    * for the form to search.
    */
    YAHOO.widget.Button.addHiddenFieldsToForm = function (p_oForm) {

        var proto = YAHOO.widget.Button.prototype,
			aButtons = Dom.getElementsByClassName(
							(proto.CLASS_NAME_PREFIX + proto.CSS_CLASS_NAME),
                            "*",
                            p_oForm),

            nButtons = aButtons.length,
            oButton,
            sId,
            i;

        if (nButtons > 0) {


            for (i = 0; i < nButtons; i++) {

                sId = aButtons[i].id;

                if (sId) {

                    oButton = m_oButtons[sId];

                    if (oButton) {

                        oButton.createHiddenFields();

                    }

                }

            }

        }

    };


    /**
    * @method YAHOO.widget.Button.getButton
    * @description Returns a button with the specified id.
    * @param {String} p_sId String specifying the id of the root node of the
    * HTML element representing the button to be retrieved.
    * @return {YAHOO.widget.Button}
    */
    YAHOO.widget.Button.getButton = function (p_sId) {

		return m_oButtons[p_sId];

    };




    /**
    * @event focus
    * @description Fires when the menu item receives focus.  Passes back a
    * single object representing the original DOM event object passed back by
    * the event utility (YAHOO.util.Event) when the event was fired.  See
    * <a href="YAHOO.util.Element.html#addListener">Element.addListener</a>
    * for more information on listening for this event.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event blur
    * @description Fires when the menu item loses the input focus.  Passes back
    * a single object representing the original DOM event object passed back by
    * the event utility (YAHOO.util.Event) when the event was fired.  See
    * <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
    * more information on listening for this event.
    * @type YAHOO.util.CustomEvent
    */


    /**
    * @event option
    * @description Fires when the user invokes the button's option.  Passes
    * back a single object representing the original DOM event (either
    * "mousedown" or "keydown") that caused the "option" event to fire.  See
    * <a href="YAHOO.util.Element.html#addListener">Element.addListener</a>
    * for more information on listening for this event.
    * @type YAHOO.util.CustomEvent
    */

})();
(function () {


    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Button = YAHOO.widget.Button,


        m_oButtons = {};



    /**
    * The ButtonGroup class creates a set of buttons that are mutually
    * exclusive; checking one button in the set will uncheck all others in the
    * button group.
    * @param {String} p_oElement String specifying the id attribute of the
    * <code>&#60;div&#62;</code> element of the button group.
    * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
    * level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
    * specifying the <code>&#60;div&#62;</code> element of the button group.
    * @param {Object} p_oElement Object literal specifying a set of
    * configuration attributes used to create the button group.
    * @param {Object} p_oAttributes Optional. Object literal specifying a set
    * of configuration attributes used to create the button group.
    * @namespace YAHOO.widget
    * @class ButtonGroup
    * @constructor
    * @extends YAHOO.util.Element
    */
    YAHOO.widget.ButtonGroup = function (p_oElement, p_oAttributes) {

        var fnSuperClass = YAHOO.widget.ButtonGroup.superclass.constructor,
            sNodeName,
            oElement,
            sId;

        if (arguments.length == 1 && !Lang.isString(p_oElement) &&
            !p_oElement.nodeName) {

            if (!p_oElement.id) {

                sId = Dom.generateId();

                p_oElement.id = sId;


            }



            fnSuperClass.call(this, (this._createGroupElement()), p_oElement);

        }
        else if (Lang.isString(p_oElement)) {

            oElement = Dom.get(p_oElement);

            if (oElement) {

                if (oElement.nodeName.toUpperCase() == this.NODE_NAME) {


                    fnSuperClass.call(this, oElement, p_oAttributes);

                }

            }

        }
        else {

            sNodeName = p_oElement.nodeName.toUpperCase();

            if (sNodeName && sNodeName == this.NODE_NAME) {

                if (!p_oElement.id) {

                    p_oElement.id = Dom.generateId();


                }


                fnSuperClass.call(this, p_oElement, p_oAttributes);

            }

        }

    };


    YAHOO.extend(YAHOO.widget.ButtonGroup, YAHOO.util.Element, {




        /**
        * @property _buttons
        * @description Array of buttons in the button group.
        * @default null
        * @protected
        * @type Array
        */
        _buttons: null,





        /**
        * @property NODE_NAME
        * @description The name of the tag to be used for the button
        * group's element.
        * @default "DIV"
        * @final
        * @type String
        */
        NODE_NAME: "DIV",


        /**
        * @property CLASS_NAME_PREFIX
        * @description Prefix used for all class names applied to a ButtonGroup.
        * @default "yui-"
        * @final
        * @type String
        */
        CLASS_NAME_PREFIX: "yui-",


        /**
        * @property CSS_CLASS_NAME
        * @description String representing the CSS class(es) to be applied
        * to the button group's element.
        * @default "buttongroup"
        * @final
        * @type String
        */
        CSS_CLASS_NAME: "buttongroup",





        /**
        * @method _createGroupElement
        * @description Creates the button group's element.
        * @protected
        * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-22445964">HTMLDivElement</a>}
        */
        _createGroupElement: function () {

            var oElement = document.createElement(this.NODE_NAME);

            return oElement;

        },





        /**
        * @method _setDisabled
        * @description Sets the value of the button groups's
        * "disabled" attribute.
        * @protected
        * @param {Boolean} p_bDisabled Boolean indicating the value for
        * the button group's "disabled" attribute.
        */
        _setDisabled: function (p_bDisabled) {

            var nButtons = this.getCount(),
                i;

            if (nButtons > 0) {

                i = nButtons - 1;

                do {

                    this._buttons[i].set("disabled", p_bDisabled);

                }
                while (i--);

            }

        },





        /**
        * @method _onKeyDown
        * @description "keydown" event handler for the button group.
        * @protected
        * @param {Event} p_oEvent Object representing the DOM event object
        * passed back by the event utility (YAHOO.util.Event).
        */
        _onKeyDown: function (p_oEvent) {

            var oTarget = Event.getTarget(p_oEvent),
                nCharCode = Event.getCharCode(p_oEvent),
                sId = oTarget.parentNode.parentNode.id,
                oButton = m_oButtons[sId],
                nIndex = -1;


            if (nCharCode == 37 || nCharCode == 38) {

                nIndex = (oButton.index === 0) ?
                            (this._buttons.length - 1) : (oButton.index - 1);

            }
            else if (nCharCode == 39 || nCharCode == 40) {

                nIndex = (oButton.index === (this._buttons.length - 1)) ?
                            0 : (oButton.index + 1);

            }


            if (nIndex > -1) {

                this.check(nIndex);
                this.getButton(nIndex).focus();

            }

        },


        /**
        * @method _onAppendTo
        * @description "appendTo" event handler for the button group.
        * @protected
        * @param {Event} p_oEvent Object representing the event that was fired.
        */
        _onAppendTo: function (p_oEvent) {

            var aButtons = this._buttons,
                nButtons = aButtons.length,
                i;

            for (i = 0; i < nButtons; i++) {

                aButtons[i].appendTo(this.get("element"));

            }

        },


        /**
        * @method _onButtonCheckedChange
        * @description "checkedChange" event handler for each button in the
        * button group.
        * @protected
        * @param {Event} p_oEvent Object representing the event that was fired.
        * @param {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
        * p_oButton Object representing the button that fired the event.
        */
        _onButtonCheckedChange: function (p_oEvent, p_oButton) {

            var bChecked = p_oEvent.newValue,
                oCheckedButton = this.get("checkedButton");

            if (bChecked && oCheckedButton != p_oButton) {

                if (oCheckedButton) {

                    oCheckedButton.set("checked", false, true);

                }

                this.set("checkedButton", p_oButton);
                this.set("value", p_oButton.get("value"));

            }
            else if (oCheckedButton && !oCheckedButton.set("checked")) {

                oCheckedButton.set("checked", true, true);

            }

        },





        /**
        * @method init
        * @description The ButtonGroup class's initialization method.
        * @param {String} p_oElement String specifying the id attribute of the
        * <code>&#60;div&#62;</code> element of the button group.
        * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
        * specifying the <code>&#60;div&#62;</code> element of the button group.
        * @param {Object} p_oElement Object literal specifying a set of
        * configuration attributes used to create the button group.
        * @param {Object} p_oAttributes Optional. Object literal specifying a
        * set of configuration attributes used to create the button group.
        */
        init: function (p_oElement, p_oAttributes) {

            this._buttons = [];

            YAHOO.widget.ButtonGroup.superclass.init.call(this, p_oElement,
                    p_oAttributes);

            this.addClass(this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);


            var sClass = (YAHOO.widget.Button.prototype.CLASS_NAME_PREFIX + "radio-button"),
				aButtons = this.getElementsByClassName(sClass);



            if (aButtons.length > 0) {


                this.addButtons(aButtons);

            }



            function isRadioButton(p_oElement) {

                return (p_oElement.type == "radio");

            }

            aButtons =
                Dom.getElementsBy(isRadioButton, "input", this.get("element"));


            if (aButtons.length > 0) {


                this.addButtons(aButtons);

            }

            this.on("keydown", this._onKeyDown);
            this.on("appendTo", this._onAppendTo);


            var oContainer = this.get("container");

            if (oContainer) {

                if (Lang.isString(oContainer)) {

                    Event.onContentReady(oContainer, function () {

                        this.appendTo(oContainer);

                    }, null, this);

                }
                else {

                    this.appendTo(oContainer);

                }

            }



        },


        /**
        * @method initAttributes
        * @description Initializes all of the configuration attributes used to
        * create the button group.
        * @param {Object} p_oAttributes Object literal specifying a set of
        * configuration attributes used to create the button group.
        */
        initAttributes: function (p_oAttributes) {

            var oAttributes = p_oAttributes || {};

            YAHOO.widget.ButtonGroup.superclass.initAttributes.call(
                this, oAttributes);


            /**
            * @attribute name
            * @description String specifying the name for the button group.
            * This name will be applied to each button in the button group.
            * @default null
            * @type String
            */
            this.setAttributeConfig("name", {

                value: oAttributes.name,
                validator: Lang.isString

            });


            /**
            * @attribute disabled
            * @description Boolean indicating if the button group should be
            * disabled.  Disabling the button group will disable each button
            * in the button group.  Disabled buttons are dimmed and will not
            * respond to user input or fire events.
            * @default false
            * @type Boolean
            */
            this.setAttributeConfig("disabled", {

                value: (oAttributes.disabled || false),
                validator: Lang.isBoolean,
                method: this._setDisabled

            });


            /**
            * @attribute value
            * @description Object specifying the value for the button group.
            * @default null
            * @type Object
            */
            this.setAttributeConfig("value", {

                value: oAttributes.value

            });


            /**
            * @attribute container
            * @description HTML element reference or string specifying the id
            * attribute of the HTML element that the button group's markup
            * should be rendered into.
            * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
            * level-one-html.html#ID-58190037">HTMLElement</a>|String
            * @default null
			* @writeonce
            */
            this.setAttributeConfig("container", {

                value: oAttributes.container,
                writeOnce: true

            });


            /**
            * @attribute checkedButton
            * @description Reference for the button in the button group that
            * is checked.
            * @type {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
            * @default null
            */
            this.setAttributeConfig("checkedButton", {

                value: null

            });

        },


        /**
        * @method addButton
        * @description Adds the button to the button group.
        * @param {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
        * p_oButton Object reference for the <a href="YAHOO.widget.Button.html">
        * YAHOO.widget.Button</a> instance to be added to the button group.
        * @param {String} p_oButton String specifying the id attribute of the
        * <code>&#60;input&#62;</code> or <code>&#60;span&#62;</code> element
        * to be used to create the button to be added to the button group.
        * @param {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
        * level-one-html.html#ID-6043025">HTMLInputElement</a>|<a href="
        * http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#
        * ID-33759296">HTMLElement</a>} p_oButton Object reference for the
        * <code>&#60;input&#62;</code> or <code>&#60;span&#62;</code> element
        * to be used to create the button to be added to the button group.
        * @param {Object} p_oButton Object literal specifying a set of
        * <a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>
        * configuration attributes used to configure the button to be added to
        * the button group.
        * @return {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
        */
        addButton: function (p_oButton) {

            var oButton,
                oButtonElement,
                oGroupElement,
                nIndex,
                sButtonName,
                sGroupName;


            if (p_oButton instanceof Button &&
                p_oButton.get("type") == "radio") {

                oButton = p_oButton;

            }
            else if (!Lang.isString(p_oButton) && !p_oButton.nodeName) {

                p_oButton.type = "radio";

                oButton = new Button(p_oButton);

            }
            else {

                oButton = new Button(p_oButton, { type: "radio" });

            }


            if (oButton) {

                nIndex = this._buttons.length;
                sButtonName = oButton.get("name");
                sGroupName = this.get("name");

                oButton.index = nIndex;

                this._buttons[nIndex] = oButton;
                m_oButtons[oButton.get("id")] = oButton;


                if (sButtonName != sGroupName) {

                    oButton.set("name", sGroupName);

                }


                if (this.get("disabled")) {

                    oButton.set("disabled", true);

                }


                if (oButton.get("checked")) {

                    this.set("checkedButton", oButton);

                }


                oButtonElement = oButton.get("element");
                oGroupElement = this.get("element");

                if (oButtonElement.parentNode != oGroupElement) {

                    oGroupElement.appendChild(oButtonElement);

                }


                oButton.on("checkedChange",
                    this._onButtonCheckedChange, oButton, this);


            }

			return oButton;

        },


        /**
        * @method addButtons
        * @description Adds the array of buttons to the button group.
        * @param {Array} p_aButtons Array of <a href="YAHOO.widget.Button.html">
        * YAHOO.widget.Button</a> instances to be added
        * to the button group.
        * @param {Array} p_aButtons Array of strings specifying the id
        * attribute of the <code>&#60;input&#62;</code> or <code>&#60;span&#62;
        * </code> elements to be used to create the buttons to be added to the
        * button group.
        * @param {Array} p_aButtons Array of object references for the
        * <code>&#60;input&#62;</code> or <code>&#60;span&#62;</code> elements
        * to be used to create the buttons to be added to the button group.
        * @param {Array} p_aButtons Array of object literals, each containing
        * a set of <a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>
        * configuration attributes used to configure each button to be added
        * to the button group.
        * @return {Array}
        */
        addButtons: function (p_aButtons) {

            var nButtons,
                oButton,
                aButtons,
                i;

            if (Lang.isArray(p_aButtons)) {

                nButtons = p_aButtons.length;
                aButtons = [];

                if (nButtons > 0) {

                    for (i = 0; i < nButtons; i++) {

                        oButton = this.addButton(p_aButtons[i]);

                        if (oButton) {

                            aButtons[aButtons.length] = oButton;

                        }

                    }

                }

            }

			return aButtons;

        },


        /**
        * @method removeButton
        * @description Removes the button at the specified index from the
        * button group.
        * @param {Number} p_nIndex Number specifying the index of the button
        * to be removed from the button group.
        */
        removeButton: function (p_nIndex) {

            var oButton = this.getButton(p_nIndex),
                nButtons,
                i;

            if (oButton) {


                this._buttons.splice(p_nIndex, 1);
                delete m_oButtons[oButton.get("id")];

                oButton.removeListener("checkedChange",
                    this._onButtonCheckedChange);

                oButton.destroy();


                nButtons = this._buttons.length;

                if (nButtons > 0) {

                    i = this._buttons.length - 1;

                    do {

                        this._buttons[i].index = i;

                    }
                    while (i--);

                }


            }

        },


        /**
        * @method getButton
        * @description Returns the button at the specified index.
        * @param {Number} p_nIndex The index of the button to retrieve from the
        * button group.
        * @return {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
        */
        getButton: function (p_nIndex) {

            return this._buttons[p_nIndex];

        },


        /**
        * @method getButtons
        * @description Returns an array of the buttons in the button group.
        * @return {Array}
        */
        getButtons: function () {

            return this._buttons;

        },


        /**
        * @method getCount
        * @description Returns the number of buttons in the button group.
        * @return {Number}
        */
        getCount: function () {

            return this._buttons.length;

        },


        /**
        * @method focus
        * @description Sets focus to the button at the specified index.
        * @param {Number} p_nIndex Number indicating the index of the button
        * to focus.
        */
        focus: function (p_nIndex) {

            var oButton,
                nButtons,
                i;

            if (Lang.isNumber(p_nIndex)) {

                oButton = this._buttons[p_nIndex];

                if (oButton) {

                    oButton.focus();

                }

            }
            else {

                nButtons = this.getCount();

                for (i = 0; i < nButtons; i++) {

                    oButton = this._buttons[i];

                    if (!oButton.get("disabled")) {

                        oButton.focus();
                        break;

                    }

                }

            }

        },


        /**
        * @method check
        * @description Checks the button at the specified index.
        * @param {Number} p_nIndex Number indicating the index of the button
        * to check.
        */
        check: function (p_nIndex) {

            var oButton = this.getButton(p_nIndex);

            if (oButton) {

                oButton.set("checked", true);

            }

        },


        /**
        * @method destroy
        * @description Removes the button group's element from its parent
        * element and removes all event handlers.
        */
        destroy: function () {


            var nButtons = this._buttons.length,
                oElement = this.get("element"),
                oParentNode = oElement.parentNode,
                i;

            if (nButtons > 0) {

                i = this._buttons.length - 1;

                do {

                    this._buttons[i].destroy();

                }
                while (i--);

            }


            Event.purgeElement(oElement);


            oParentNode.removeChild(oElement);

        },


        /**
        * @method toString
        * @description Returns a string representing the button group.
        * @return {String}
        */
        toString: function () {

            return ("ButtonGroup " + this.get("id"));

        }

    });

})();
YAHOO.register("button", YAHOO.widget.Button, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 * @module dragdrop
 * @title Drag and Drop
 * @requires yahoo,dom,event
 * @namespace YAHOO.util
 */

if (!YAHOO.util.DragDropMgr) {

/**
 * DragDropMgr is a singleton that tracks the element interaction for
 * all DragDrop items in the window.  Generally, you will not call
 * this class directly, but it does have helper methods that could
 * be useful in your DragDrop implementations.
 * @class DragDropMgr
 * @static
 */
YAHOO.util.DragDropMgr = function() {

    var Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom;

    return {
        /**
        * This property is used to turn on global use of the shim element on all DragDrop instances, defaults to false for backcompat. (Use: YAHOO.util.DDM.useShim = true)
        * @property useShim
        * @type Boolean
        * @static
        */
        useShim: false,
        /**
        * This property is used to determine if the shim is active over the screen, default false.
        * @private
        * @property _shimActive
        * @type Boolean
        * @static
        */
        _shimActive: false,
        /**
        * This property is used when useShim is set on a DragDrop object to store the current state of DDM.useShim so it can be reset when a drag operation is done.
        * @private
        * @property _shimState
        * @type Boolean
        * @static
        */
        _shimState: false,
        /**
        * This property is used when useShim is set to true, it will set the opacity on the shim to .5 for debugging. Use: (YAHOO.util.DDM._debugShim = true;)
        * @private
        * @property _debugShim
        * @type Boolean
        * @static
        */
        _debugShim: false,
        /**
        * This method will create a shim element (giving it the id of yui-ddm-shim), it also attaches the mousemove and mouseup listeners to it and attaches a scroll listener on the window
        * @private
        * @method _sizeShim
        * @static
        */
        _createShim: function() {
            var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            Dom.setStyle(s, 'opacity', '0');
            this._shim = s;
            Event.on(s, "mouseup",   this.handleMouseUp, this, true);
            Event.on(s, "mousemove", this.handleMouseMove, this, true);
            Event.on(window, 'scroll', this._sizeShim, this, true);
        },
        /**
        * This method will size the shim, called from activate and on window scroll event
        * @private
        * @method _sizeShim
        * @static
        */
        _sizeShim: function() {
            if (this._shimActive) {
                var s = this._shim;
                s.style.height = Dom.getDocumentHeight() + 'px';
                s.style.width = Dom.getDocumentWidth() + 'px';
                s.style.top = '0';
                s.style.left = '0';
            }
        },
        /**
        * This method will create the shim element if needed, then show the shim element, size the element and set the _shimActive property to true
        * @private
        * @method _activateShim
        * @static
        */
        _activateShim: function() {
            if (this.useShim) {
                if (!this._shim) {
                    this._createShim();
                }
                this._shimActive = true;
                var s = this._shim,
                    o = '0';
                if (this._debugShim) {
                    o = '.5';
                }
                Dom.setStyle(s, 'opacity', o);
                this._sizeShim();
                s.style.display = 'block';
            }
        },
        /**
        * This method will hide the shim element and set the _shimActive property to false
        * @private
        * @method _deactivateShim
        * @static
        */
        _deactivateShim: function() {
            this._shim.style.display = 'none';
            this._shimActive = false;
        },
        /**
        * The HTML element created to use as a shim over the document to track mouse movements
        * @private
        * @property _shim
        * @type HTMLElement
        * @static
        */
        _shim: null,
        /**
         * Two dimensional Array of registered DragDrop objects.  The first
         * dimension is the DragDrop item group, the second the DragDrop
         * object.
         * @property ids
         * @type {string: string}
         * @private
         * @static
         */
        ids: {},

        /**
         * Array of element ids defined as drag handles.  Used to determine
         * if the element that generated the mousedown event is actually the
         * handle and not the html element itself.
         * @property handleIds
         * @type {string: string}
         * @private
         * @static
         */
        handleIds: {},

        dragCurrent: null,

        /**
         * the DragDrop object(s) that are being hovered over
         * @property dragOvers
         * @type Array
         * @private
         * @static
         */
        dragOvers: {},

        /**
         * the X distance between the cursor and the object being dragged
         * @property deltaX
         * @type int
         * @private
         * @static
         */
        deltaX: 0,

        /**
         * the Y distance between the cursor and the object being dragged
         * @property deltaY
         * @type int
         * @private
         * @static
         */
        deltaY: 0,

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to
         * false if you need the default behavior (not recommended)
         * @property preventDefault
         * @type boolean
         * @static
         */
        preventDefault: true,

        /**
         * Flag to determine if we should stop the propagation of the events
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         * @property stopPropagation
         * @type boolean
         * @static
         */
        stopPropagation: true,

        /**
         * Internal flag that is set to true when drag and drop has been
         * initialized
         * @property initialized
         * @private
         * @static
         */
        initialized: false,

        /**
         * All drag and drop can be disabled.
         * @property locked
         * @private
         * @static
         */
        locked: false,

        /**
         * Provides additional information about the the current set of
         * interactions.  Can be accessed from the event handlers. It
         * contains the following properties:
         *
         *       out:       onDragOut interactions
         *       enter:     onDragEnter interactions
         *       over:      onDragOver interactions
         *       drop:      onDragDrop interactions
         *       point:     The location of the cursor
         *       draggedRegion: The location of dragged element at the time
         *                      of the interaction
         *       sourceRegion: The location of the source elemtn at the time
         *                     of the interaction
         *       validDrop: boolean
         * @property interactionInfo
         * @type object
         * @static
         */
        interactionInfo: null,

        /**
         * Called the first time an element is registered.
         * @method init
         * @private
         * @static
         */
        init: function() {
            this.initialized = true;
        },

        /**
         * In point mode, drag and drop interaction is defined by the
         * location of the cursor during the drag/drop
         * @property POINT
         * @type int
         * @static
         * @final
         */
        POINT: 0,

        /**
         * In intersect mode, drag and drop interaction is defined by the
         * cursor position or the amount of overlap of two or more drag and
         * drop objects.
         * @property INTERSECT
         * @type int
         * @static
         * @final
         */
        INTERSECT: 1,

        /**
         * In intersect mode, drag and drop interaction is defined only by the
         * overlap of two or more drag and drop objects.
         * @property STRICT_INTERSECT
         * @type int
         * @static
         * @final
         */
        STRICT_INTERSECT: 2,

        /**
         * The current drag and drop mode.  Default: POINT
         * @property mode
         * @type int
         * @static
         */
        mode: 0,

        /**
         * Runs method on all drag and drop objects
         * @method _execOnAll
         * @private
         * @static
         */
        _execOnAll: function(sMethod, args) {
            for (var i in this.ids) {
                for (var j in this.ids[i]) {
                    var oDD = this.ids[i][j];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }
                    oDD[sMethod].apply(oDD, args);
                }
            }
        },

        /**
         * Drag and drop initialization.  Sets up the global event handlers
         * @method _onLoad
         * @private
         * @static
         */
        _onLoad: function() {

            this.init();

            Event.on(document, "mouseup",   this.handleMouseUp, this, true);
            Event.on(document, "mousemove", this.handleMouseMove, this, true);
            Event.on(window,   "unload",    this._onUnload, this, true);
            Event.on(window,   "resize",    this._onResize, this, true);

        },

        /**
         * Reset constraints on all drag and drop objs
         * @method _onResize
         * @private
         * @static
         */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
         * Lock all drag and drop functionality
         * @method lock
         * @static
         */
        lock: function() { this.locked = true; },

        /**
         * Unlock all drag and drop functionality
         * @method unlock
         * @static
         */
        unlock: function() { this.locked = false; },

        /**
         * Is drag and drop locked?
         * @method isLocked
         * @return {boolean} True if drag and drop is locked, false otherwise.
         * @static
         */
        isLocked: function() { return this.locked; },

        /**
         * Location cache that is set for all drag drop objects when a drag is
         * initiated, cleared when the drag is finished.
         * @property locationCache
         * @private
         * @static
         */
        locationCache: {},

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * @property useCache
         * @type boolean
         * @static
         */
        useCache: true,

        /**
         * The number of pixels that the mouse needs to move after the
         * mousedown before the drag is initiated.  Default=3;
         * @property clickPixelThresh
         * @type int
         * @static
         */
        clickPixelThresh: 3,

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * @property clickTimeThresh
         * @type int
         * @static
         */
        clickTimeThresh: 1000,

        /**
         * Flag that indicates that either the drag pixel threshold or the
         * mousdown time threshold has been met
         * @property dragThreshMet
         * @type boolean
         * @private
         * @static
         */
        dragThreshMet: false,

        /**
         * Timeout used for the click time threshold
         * @property clickTimeout
         * @type Object
         * @private
         * @static
         */
        clickTimeout: null,

        /**
         * The X position of the mousedown event stored for later use when a
         * drag threshold is met.
         * @property startX
         * @type int
         * @private
         * @static
         */
        startX: 0,

        /**
         * The Y position of the mousedown event stored for later use when a
         * drag threshold is met.
         * @property startY
         * @type int
         * @private
         * @static
         */
        startY: 0,

        /**
         * Flag to determine if the drag event was fired from the click timeout and
         * not the mouse move threshold.
         * @property fromTimeout
         * @type boolean
         * @private
         * @static
         */
        fromTimeout: false,

        /**
         * Each DragDrop instance must be registered with the DragDropMgr.
         * This is executed in DragDrop.init()
         * @method regDragDrop
         * @param {DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         * @static
         */
        regDragDrop: function(oDD, sGroup) {
            if (!this.initialized) { this.init(); }

            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }
            this.ids[sGroup][oDD.id] = oDD;
        },

        /**
         * Removes the supplied dd instance from the supplied group. Executed
         * by DragDrop.removeFromGroup, so don't call this function directly.
         * @method removeDDFromGroup
         * @private
         * @static
         */
        removeDDFromGroup: function(oDD, sGroup) {
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }

            var obj = this.ids[sGroup];
            if (obj && obj[oDD.id]) {
                delete obj[oDD.id];
            }
        },

        /**
         * Unregisters a drag and drop item.  This is executed in
         * DragDrop.unreg, use that method instead of calling this directly.
         * @method _remove
         * @private
         * @static
         */
        _remove: function(oDD) {
            for (var g in oDD.groups) {
                if (g) {
                    var item = this.ids[g];
                    if (item && item[oDD.id]) {
                        delete item[oDD.id];
                    }
                }

            }
            delete this.handleIds[oDD.id];
        },

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @method regHandle
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag
         * handle
         * @static
         */
        regHandle: function(sDDId, sHandleId) {
            if (!this.handleIds[sDDId]) {
                this.handleIds[sDDId] = {};
            }
            this.handleIds[sDDId][sHandleId] = sHandleId;
        },

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop item.
         * @method isDragDrop
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop item,
         * false otherwise
         * @static
         */
        isDragDrop: function(id) {
            return ( this.getDDById(id) ) ? true : false;
        },

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @method getRelated
         * @param {DragDrop} p_oDD the obj to get related data for
         * @param {boolean} bTargetsOnly if true, only return targetable objs
         * @return {DragDrop[]} the related instances
         * @static
         */
        getRelated: function(p_oDD, bTargetsOnly) {
            var oDDs = [];
            for (var i in p_oDD.groups) {
                for (var j in this.ids[i]) {
                    var dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            return oDDs;
        },

        /**
         * Returns true if the specified dd target is a legal target for
         * the specifice drag obj
         * @method isLegalTarget
         * @param {DragDrop} the drag obj
         * @param {DragDrop} the target
         * @return {boolean} true if the target is a legal target for the
         * dd obj
         * @static
         */
        isLegalTarget: function (oDD, oTargetDD) {
            var targets = this.getRelated(oDD, true);
            for (var i=0, len=targets.length;i<len;++i) {
                if (targets[i].id == oTargetDD.id) {
                    return true;
                }
            }

            return false;
        },

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @method isTypeOfDD
         * @param {Object} the object to evaluate
         * @return {boolean} true if typeof oDD = DragDrop
         * @static
         */
        isTypeOfDD: function (oDD) {
            return (oDD && oDD.__ygDragDrop);
        },

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop handle for the given Drag Drop object.
         * @method isHandle
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop handle, false
         * otherwise
         * @static
         */
        isHandle: function(sDDId, sHandleId) {
            return ( this.handleIds[sDDId] &&
                            this.handleIds[sDDId][sHandleId] );
        },

        /**
         * Returns the DragDrop instance for a given id
         * @method getDDById
         * @param {String} id the id of the DragDrop object
         * @return {DragDrop} the drag drop object, null if it is not found
         * @static
         */
        getDDById: function(id) {
            for (var i in this.ids) {
                if (this.ids[i][id]) {
                    return this.ids[i][id];
                }
            }
            return null;
        },

        /**
         * Fired after a registered DragDrop object gets the mousedown event.
         * Sets up the events required to track the object being dragged
         * @method handleMouseDown
         * @param {Event} e the event
         * @param oDD the DragDrop object being dragged
         * @private
         * @static
         */
        handleMouseDown: function(e, oDD) {

            this.currentTarget = YAHOO.util.Event.getTarget(e);

            this.dragCurrent = oDD;

            var el = oDD.getEl();

            this.startX = YAHOO.util.Event.getPageX(e);
            this.startY = YAHOO.util.Event.getPageY(e);

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout(
                    function() {
                        var DDM = YAHOO.util.DDM;
                        DDM.startDrag(DDM.startX, DDM.startY);
                        DDM.fromTimeout = true;
                    },
                    this.clickTimeThresh );
        },

        /**
         * Fired when either the drag pixel threshold or the mousedown hold
         * time threshold has been met.
         * @method startDrag
         * @param x {int} the X position of the original mousedown
         * @param y {int} the Y position of the original mousedown
         * @static
         */
        startDrag: function(x, y) {
            if (this.dragCurrent && this.dragCurrent.useShim) {
                this._shimState = this.useShim;
                this.useShim = true;
            }
            this._activateShim();
            clearTimeout(this.clickTimeout);
            var dc = this.dragCurrent;
            if (dc && dc.events.b4StartDrag) {
                dc.b4StartDrag(x, y);
                dc.fireEvent('b4StartDragEvent', { x: x, y: y });
            }
            if (dc && dc.events.startDrag) {
                dc.startDrag(x, y);
                dc.fireEvent('startDragEvent', { x: x, y: y });
            }
            this.dragThreshMet = true;
        },

        /**
         * Internal function to handle the mouseup event.  Will be invoked
         * from the context of the document.
         * @method handleMouseUp
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseUp: function(e) {
            if (this.dragCurrent) {
                clearTimeout(this.clickTimeout);

                if (this.dragThreshMet) {
                    if (this.fromTimeout) {
                        this.fromTimeout = false;
                        this.handleMouseMove(e);
                    }
                    this.fromTimeout = false;
                    this.fireEvents(e, true);
                } else {
                }

                this.stopDrag(e);

                this.stopEvent(e);
            }
        },

        /**
         * Utility to stop event propagation and event default, if these
         * features are turned on.
         * @method stopEvent
         * @param {Event} e the event as returned by this.getEvent()
         * @static
         */
        stopEvent: function(e) {
            if (this.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            if (this.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        },

        /**
         * Ends the current drag, cleans up the state, and fires the endDrag
         * and mouseUp events.  Called internally when a mouseup is detected
         * during the drag.  Can be fired manually during the drag by passing
         * either another event (such as the mousemove event received in onDrag)
         * or a fake event with pageX and pageY defined (so that endDrag and
         * onMouseUp have usable position data.).  Alternatively, pass true
         * for the silent parameter so that the endDrag and onMouseUp events
         * are skipped (so no event data is needed.)
         *
         * @method stopDrag
         * @param {Event} e the mouseup event, another event (or a fake event)
         *                  with pageX and pageY defined, or nothing if the
         *                  silent parameter is true
         * @param {boolean} silent skips the enddrag and mouseup events if true
         * @static
         */
        stopDrag: function(e, silent) {
            var dc = this.dragCurrent;
            if (dc && !silent) {
                if (this.dragThreshMet) {
                    if (dc.events.b4EndDrag) {
                        dc.b4EndDrag(e);
                        dc.fireEvent('b4EndDragEvent', { e: e });
                    }
                    if (dc.events.endDrag) {
                        dc.endDrag(e);
                        dc.fireEvent('endDragEvent', { e: e });
                    }
                }
                if (dc.events.mouseUp) {
                    dc.onMouseUp(e);
                    dc.fireEvent('mouseUpEvent', { e: e });
                }
            }

            if (this._shimActive) {
                this._deactivateShim();
                if (this.dragCurrent && this.dragCurrent.useShim) {
                    this.useShim = this._shimState;
                    this._shimState = false;
                }
            }

            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /**
         * Internal function to handle the mousemove event.  Will be invoked
         * from the context of the html element.
         *
         * @TODO figure out what we can do about mouse events lost when the
         * user drags objects beyond the window boundary.  Currently we can
         * detect this in internet explorer by verifying that the mouse is
         * down during the mousemove event.  Firefox doesn't give us the
         * button state on the mousemove event.
         * @method handleMouseMove
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseMove: function(e) {

            var dc = this.dragCurrent;
            if (dc) {


                if (YAHOO.util.Event.isIE && !e.button) {
                    this.stopEvent(e);
                    return this.handleMouseUp(e);
                } else {
                    if (e.clientX < 0 || e.clientY < 0) {
                    }
                }

                if (!this.dragThreshMet) {
                    var diffX = Math.abs(this.startX - YAHOO.util.Event.getPageX(e));
                    var diffY = Math.abs(this.startY - YAHOO.util.Event.getPageY(e));
                    if (diffX > this.clickPixelThresh ||
                                diffY > this.clickPixelThresh) {
                        this.startDrag(this.startX, this.startY);
                    }
                }

                if (this.dragThreshMet) {
                    if (dc && dc.events.b4Drag) {
                        dc.b4Drag(e);
                        dc.fireEvent('b4DragEvent', { e: e});
                    }
                    if (dc && dc.events.drag) {
                        dc.onDrag(e);
                        dc.fireEvent('dragEvent', { e: e});
                    }
                    if (dc) {
                        this.fireEvents(e, false);
                    }
                }

                this.stopEvent(e);
            }
        },

        /**
         * Iterates over all of the DragDrop elements to find ones we are
         * hovering over or dropping on
         * @method fireEvents
         * @param {Event} e the event
         * @param {boolean} isDrop is this a drop op or a mouseover op?
         * @private
         * @static
         */
        fireEvents: function(e, isDrop) {
            var dc = this.dragCurrent;

            if (!dc || dc.isLocked() || dc.dragOnly) {
                return;
            }

            var x = YAHOO.util.Event.getPageX(e),
                y = YAHOO.util.Event.getPageY(e),
                pt = new YAHOO.util.Point(x,y),
                pos = dc.getTargetCoord(pt.x, pt.y),
                el = dc.getDragEl(),
                events = ['out', 'over', 'drop', 'enter'],
                curRegion = new YAHOO.util.Region( pos.y,
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight,
                                               pos.x ),

                oldOvers = [], // cache the previous dragOver array
                inGroupsObj  = {},
                inGroups  = [],
                data = {
                    outEvts: [],
                    overEvts: [],
                    dropEvts: [],
                    enterEvts: []
                };


            for (var i in this.dragOvers) {

                var ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }
                if (! this.isOverTarget(pt, ddo, this.mode, curRegion)) {
                    data.outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete this.dragOvers[i];
            }

            for (var sGroup in dc.groups) {

                if ("string" != typeof sGroup) {
                    continue;
                }

                for (i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }

                    if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
                        if (this.isOverTarget(pt, oDD, this.mode, curRegion)) {
                            inGroupsObj[sGroup] = true;
                            if (isDrop) {
                                data.dropEvts.push( oDD );
                            } else {

                                if (!oldOvers[oDD.id]) {
                                    data.enterEvts.push( oDD );
                                } else {
                                    data.overEvts.push( oDD );
                                }

                                this.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            this.interactionInfo = {
                out:       data.outEvts,
                enter:     data.enterEvts,
                over:      data.overEvts,
                drop:      data.dropEvts,
                point:     pt,
                draggedRegion:    curRegion,
                sourceRegion: this.locationCache[dc.id],
                validDrop: isDrop
            };


            for (var inG in inGroupsObj) {
                inGroups.push(inG);
            }

            if (isDrop && !data.dropEvts.length) {
                this.interactionInfo.validDrop = false;
                if (dc.events.invalidDrop) {
                    dc.onInvalidDrop(e);
                    dc.fireEvent('invalidDropEvent', { e: e });
                }
            }
            for (i = 0; i < events.length; i++) {
                var tmp = null;
                if (data[events[i] + 'Evts']) {
                    tmp = data[events[i] + 'Evts'];
                }
                if (tmp && tmp.length) {
                    var type = events[i].charAt(0).toUpperCase() + events[i].substr(1),
                        ev = 'onDrag' + type,
                        b4 = 'b4Drag' + type,
                        cev = 'drag' + type + 'Event',
                        check = 'drag' + type;
                    if (this.mode) {
                        if (dc.events[b4]) {
                            dc[b4](e, tmp, inGroups);
                            dc.fireEvent(b4 + 'Event', { event: e, info: tmp, group: inGroups });

                        }
                        if (dc.events[check]) {
                            dc[ev](e, tmp, inGroups);
                            dc.fireEvent(cev, { event: e, info: tmp, group: inGroups });
                        }
                    } else {
                        for (var b = 0, len = tmp.length; b < len; ++b) {
                            if (dc.events[b4]) {
                                dc[b4](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(b4 + 'Event', { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                            if (dc.events[check]) {
                                dc[ev](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(cev, { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                        }
                    }
                }
            }
        },

        /**
         * Helper function for getting the best match from the list of drag
         * and drop objects returned by the drag and drop events when we are
         * in INTERSECT mode.  It returns either the first object that the
         * cursor is over, or the object that has the greatest overlap with
         * the dragged element.
         * @method getBestMatch
         * @param  {DragDrop[]} dds The array of drag and drop objects
         * targeted
         * @return {DragDrop}       The best single match
         * @static
         */
        getBestMatch: function(dds) {
            var winner = null;

            var len = dds.length;

            if (len == 1) {
                winner = dds[0];
            } else {
                for (var i=0; i<len; ++i) {
                    var dd = dds[i];
                    if (this.mode == this.INTERSECT && dd.cursorIsOver) {
                        winner = dd;
                        break;
                    } else {
                        if (!winner || !winner.overlap || (dd.overlap &&
                            winner.overlap.getArea() < dd.overlap.getArea())) {
                            winner = dd;
                        }
                    }
                }
            }

            return winner;
        },

        /**
         * Refreshes the cache of the top-left and bottom-right points of the
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical
         * usage is:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
         * Alternatively:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
         * @TODO this really should be an indexed array.  Alternatively this
         * method could accept both.
         * @method refreshCache
         * @param {Object} groups an associative array of groups to refresh
         * @static
         */
        refreshCache: function(groups) {

            var g = groups || this.ids;

            for (var sGroup in g) {
                if ("string" != typeof sGroup) {
                    continue;
                }
                for (var i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];

                    if (this.isTypeOfDD(oDD)) {
                        var loc = this.getLocation(oDD);
                        if (loc) {
                            this.locationCache[oDD.id] = loc;
                        } else {
                            delete this.locationCache[oDD.id];
                        }
                    }
                }
            }
        },

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @method verifyEl
         * @param {HTMLElement} el the element to check
         * @return {boolean} true if the element looks usable
         * @static
         */
        verifyEl: function(el) {
            try {
                if (el) {
                    var parent = el.offsetParent;
                    if (parent) {
                        return true;
                    }
                }
            } catch(e) {
            }

            return false;
        },

        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @method getLocation
         * @param {DragDrop} oDD the drag and drop object to get the
         *                       location for
         * @return {YAHOO.util.Region} a Region object representing the total area
         *                             the element occupies, including any padding
         *                             the instance is configured for.
         * @static
         */
        getLocation: function(oDD) {
            if (! this.isTypeOfDD(oDD)) {
                return null;
            }

            var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

            try {
                pos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            if (!pos) {
                return null;
            }

            x1 = pos[0];
            x2 = x1 + el.offsetWidth;
            y1 = pos[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - oDD.padding[0];
            r = x2 + oDD.padding[1];
            b = y2 + oDD.padding[2];
            l = x1 - oDD.padding[3];

            return new YAHOO.util.Region( t, r, b, l );
        },

        /**
         * Checks the cursor location to see if it over the target
         * @method isOverTarget
         * @param {YAHOO.util.Point} pt The point to evaluate
         * @param {DragDrop} oTarget the DragDrop object we are inspecting
         * @param {boolean} intersect true if we are in intersect mode
         * @param {YAHOO.util.Region} pre-cached location of the dragged element
         * @return {boolean} true if the mouse is over the target
         * @private
         * @static
         */
        isOverTarget: function(pt, oTarget, intersect, curRegion) {
            var loc = this.locationCache[oTarget.id];
            if (!loc || !this.useCache) {
                loc = this.getLocation(oTarget);
                this.locationCache[oTarget.id] = loc;

            }

            if (!loc) {
                return false;
            }

            oTarget.cursorIsOver = loc.contains( pt );


            var dc = this.dragCurrent;
            if (!dc || (!intersect && !dc.constrainX && !dc.constrainY)) {

                return oTarget.cursorIsOver;
            }

            oTarget.overlap = null;



            if (!curRegion) {
                var pos = dc.getTargetCoord(pt.x, pt.y);
                var el = dc.getDragEl();
                curRegion = new YAHOO.util.Region( pos.y,
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight,
                                                   pos.x );
            }

            var overlap = curRegion.intersect(loc);

            if (overlap) {
                oTarget.overlap = overlap;
                return (intersect) ? true : oTarget.cursorIsOver;
            } else {
                return false;
            }
        },

        /**
         * unload event handler
         * @method _onUnload
         * @private
         * @static
         */
        _onUnload: function(e, me) {
            this.unregAll();
        },

        /**
         * Cleans up the drag and drop events and objects.
         * @method unregAll
         * @private
         * @static
         */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }

            this._execOnAll("unreg", []);


            this.ids = {};
        },

        /**
         * A cache of DOM elements
         * @property elementCache
         * @private
         * @static
         * @deprecated elements are not cached now
         */
        elementCache: {},

        /**
         * Get the wrapper for the DOM element specified
         * @method getElWrapper
         * @param {String} id the id of the element to get
         * @return {YAHOO.util.DDM.ElementWrapper} the wrapped element
         * @private
         * @deprecated This wrapper isn't that useful
         * @static
         */
        getElWrapper: function(id) {
            var oWrapper = this.elementCache[id];
            if (!oWrapper || !oWrapper.el) {
                oWrapper = this.elementCache[id] =
                    new this.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            return oWrapper;
        },

        /**
         * Returns the actual DOM element
         * @method getElement
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use YAHOO.util.Dom.get instead
         * @static
         */
        getElement: function(id) {
            return YAHOO.util.Dom.get(id);
        },

        /**
         * Returns the style property for the DOM element (i.e.,
         * document.getElById(id).style)
         * @method getCss
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         * @deprecated use YAHOO.util.Dom instead
         * @static
         */
        getCss: function(id) {
            var el = YAHOO.util.Dom.get(id);
            return (el) ? el.style : null;
        },

        /**
         * Inner class for cached elements
         * @class DragDropMgr.ElementWrapper
         * @for DragDropMgr
         * @private
         * @deprecated
         */
        ElementWrapper: function(el) {
                /**
                 * The element
                 * @property el
                 */
                this.el = el || null;
                /**
                 * The element id
                 * @property id
                 */
                this.id = this.el && el.id;
                /**
                 * A reference to the style property
                 * @property css
                 */
                this.css = this.el && el.style;
            },

        /**
         * Returns the X position of an html element
         * @method getPosX
         * @param el the element for which to get the position
         * @return {int} the X coordinate
         * @for DragDropMgr
         * @deprecated use YAHOO.util.Dom.getX instead
         * @static
         */
        getPosX: function(el) {
            return YAHOO.util.Dom.getX(el);
        },

        /**
         * Returns the Y position of an html element
         * @method getPosY
         * @param el the element for which to get the position
         * @return {int} the Y coordinate
         * @deprecated use YAHOO.util.Dom.getY instead
         * @static
         */
        getPosY: function(el) {
            return YAHOO.util.Dom.getY(el);
        },

        /**
         * Swap two nodes.  In IE, we use the native method, for others we
         * emulate the IE behavior
         * @method swapNode
         * @param n1 the first node to swap
         * @param n2 the other node to swap
         * @static
         */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else {
                var p = n2.parentNode;
                var s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
         * Returns the current scroll position
         * @method getScroll
         * @private
         * @static
         */
        getScroll: function () {
            var t, l, dde=document.documentElement, db=document.body;
            if (dde && (dde.scrollTop || dde.scrollLeft)) {
                t = dde.scrollTop;
                l = dde.scrollLeft;
            } else if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else {
            }
            return { top: t, left: l };
        },

        /**
         * Returns the specified element style property
         * @method getStyle
         * @param {HTMLElement} el          the element
         * @param {string}      styleProp   the style property
         * @return {string} The value of the style property
         * @deprecated use YAHOO.util.Dom.getStyle
         * @static
         */
        getStyle: function(el, styleProp) {
            return YAHOO.util.Dom.getStyle(el, styleProp);
        },

        /**
         * Gets the scrollTop
         * @method getScrollTop
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollTop: function () { return this.getScroll().top; },

        /**
         * Gets the scrollLeft
         * @method getScrollLeft
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollLeft: function () { return this.getScroll().left; },

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @method moveToEl
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         * @static
         */
        moveToEl: function (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        },

        /**
         * Gets the client height
         * @method getClientHeight
         * @return {int} client height in px
         * @deprecated use YAHOO.util.Dom.getViewportHeight instead
         * @static
         */
        getClientHeight: function() {
            return YAHOO.util.Dom.getViewportHeight();
        },

        /**
         * Gets the client width
         * @method getClientWidth
         * @return {int} client width in px
         * @deprecated use YAHOO.util.Dom.getViewportWidth instead
         * @static
         */
        getClientWidth: function() {
            return YAHOO.util.Dom.getViewportWidth();
        },

        /**
         * Numeric array sort function
         * @method numericSort
         * @static
         */
        numericSort: function(a, b) { return (a - b); },

        /**
         * Internal counter
         * @property _timeoutCount
         * @private
         * @static
         */
        _timeoutCount: 0,

        /**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * @method _addListeners
         * @private
         * @static
         */
        _addListeners: function() {
            var DDM = YAHOO.util.DDM;
            if ( YAHOO.util.Event && document ) {
                DDM._onLoad();
            } else {
                if (DDM._timeoutCount > 2000) {
                } else {
                    setTimeout(DDM._addListeners, 10);
                    if (document && document.body) {
                        DDM._timeoutCount += 1;
                    }
                }
            }
        },

        /**
         * Recursively searches the immediate parent and all child nodes for
         * the handle element in order to determine wheter or not it was
         * clicked.
         * @method handleWasClicked
         * @param node the html element to inspect
         * @static
         */
        handleWasClicked: function(node, id) {
            if (this.isHandle(id, node.id)) {
                return true;
            } else {
                var p = node.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return true;
                    } else {
                        p = p.parentNode;
                    }
                }
            }

            return false;
        }

    };

}();

YAHOO.util.DDM = YAHOO.util.DragDropMgr;
YAHOO.util.DDM._addListeners();

}

(function() {

var Event=YAHOO.util.Event;
var Dom=YAHOO.util.Dom;

/**
 * Defines the interface and base operation of items that that can be
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver, onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with
 * other DragDrop objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that
 * was clicked matches a handle element.  By default this is the linked
 * element, but there are times that you will want only a portion of the
 * linked element to initiate the drag operation, and the setHandleElId()
 * method provides a way to define this.</li>
 * <li>drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in {@link YAHOO.util.DD}.  setDragElId() lets you define
 * a separate element that would be moved, as in {@link YAHOO.util.DDProxy}
 * </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any
 * other DragDrop obj in the "group1" group:
 * <pre>
 *  dd = new YAHOO.util.DragDrop("div1", "group1");
 * </pre>
 * Since none of the event handlers have been implemented, nothing would
 * actually happen if you were to run the code above.  Normally you would
 * override this class or one of the default implementations, but you can
 * also override the methods you want on an instance of the class...
 * <pre>
 *  dd.onDragDrop = function(e, id) {
 *  &nbsp;&nbsp;alert("dd was dropped on " + id);
 *  }
 * </pre>
 * @namespace YAHOO.util
 * @class DragDrop
 * @constructor
 * @param {String} id of the element that is linked to this instance
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DragDrop:
 *                    padding, isTarget, maintainOffset, primaryButtonOnly,
 */
YAHOO.util.DragDrop = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.util.DragDrop.prototype = {
    /**
     * An Object Literal containing the events that we will be using: mouseDown, b4MouseDown, mouseUp, b4StartDrag, startDrag, b4EndDrag, endDrag, mouseUp, drag, b4Drag, invalidDrop, b4DragOut, dragOut, dragEnter, b4DragOver, dragOver, b4DragDrop, dragDrop
     * By setting any of these to false, then event will not be fired.
     * @property events
     * @type object
     */
    events: null,
    /**
    * @method on
    * @description Shortcut for EventProvider.subscribe, see <a href="YAHOO.util.EventProvider.html#subscribe">YAHOO.util.EventProvider.subscribe</a>
    */
    on: function() {
        this.subscribe.apply(this, arguments);
    },
    /**
     * The id of the element associated with this object.  This is what we
     * refer to as the "linked element" because the size and position of
     * this element is used to determine when the drag and drop objects have
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same
     * as the linked element , but could be changed to another element. Ex:
     * YAHOO.util.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null,

    /**
     * the id of the element that initiates the drag operation.  By default
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null,

    /**
     * An associative array of HTML tags that will be ignored if clicked.
     * @property invalidHandleTypes
     * @type {string: string}
     */
    invalidHandleTypes: null,

    /**
     * An associative array of ids for elements that will be ignored if clicked
     * @property invalidHandleIds
     * @type {string: string}
     */
    invalidHandleIds: null,

    /**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * @property invalidHandleClasses
     * @type string[]
     */
    invalidHandleClasses: null,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are
     * related.  Instances only get events when interacting with other
     * DragDrop object in the same group.  This lets us define multiple
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type {string: string}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function() { this.locked = true; },

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function() { this.locked = false; },

    /**
     * By default, all instances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @property isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @property padding
     * @type int[]
     */
    padding: null,
    /**
     * If this flag is true, do not fire drop events. The element is a drag only element (for movement not dropping)
     * @property dragOnly
     * @type Boolean
     */
    dragOnly: false,

    /**
     * If this flag is true, a shim will be placed over the screen/viewable area to track mouse events. Should help with dragging elements over iframes and other controls.
     * @property useShim
     * @type Boolean
     */
    useShim: false,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaX
     * @type int
     * @private
     */
    deltaX: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaY
     * @type int
     * @private
     */
    deltaY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * vertical graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This property
     * can be used in intersect mode to help determine the focus of
     * the mouse interaction.  DDM.getBestMatch uses this property first to
     * determine the closest match in INTERSECT mode when multiple targets
     * are part of the same interaction.
     * @property cursorIsOver
     * @type boolean
     */
    cursorIsOver: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This is a region
     * that represents the area the draggable element overlaps this target.
     * DDM.getBestMatch uses this property to compare the size of the overlap
     * to that of other targets in order to determine the closest match in
     * INTERSECT mode when multiple targets are part of the same interaction.
     * @property overlap
     * @type YAHOO.util.Region
     */
    overlap: null,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function(x, y) { },

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function(x, y) { /* override this */ },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function(e) { },

    /**
     * Abstract method called during the onMouseMove event while dragging an
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function(e) { /* override this */ },

    /**
     * Abstract method called when this element fist begins hovering over
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more
     * dragdrop items being hovered over.
     */
    onDragEnter: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function(e) { },

    /**
     * Abstract method called when this element is hovering over another
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items
     * being hovered over.
     */
    onDragOver: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function(e) { },

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items
     * that the mouse is no longer over.
     */
    onDragOut: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function(e) { },

    /**
     * Abstract method called when this item is dropped on another DragDrop
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this
     * was dropped on.
     */
    onDragDrop: function(e, id) { /* override this */ },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function(e) { /* override this */ },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function(e) { },

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function(e) { /* override this */ },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function(e) {  },

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function(e) { /* override this */ },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function(e) { /* override this */ },

    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () {
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element
     */
    getEl: function() {
        if (!this._domRef) {
            this._domRef = Dom.get(this.id);
        }

        return this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another
     * element. An example of this can be found in YAHOO.util.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element
     */
    getDragEl: function() {
        return Dom.get(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * YAHOO.util.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function(id, sGroup, config) {
        this.initTarget(id, sGroup, config);
        Event.on(this._domRef || this.id, "mousedown",
                        this.handleMouseDown, this, true);

        for (var i in this.events) {
            this.createEvent(i + 'Event');
        }

    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function(id, sGroup, config) {

        this.config = config || {};

        this.events = {};

        this.DDM = YAHOO.util.DDM;

        this.groups = {};

        if (typeof id !== "string") {
            this._domRef = id;
            id = Dom.generateId(id);
        }

        this.id = id;

        this.addToGroup((sGroup) ? sGroup : "default");

        this.handleElId = id;

        Event.onAvailable(id, this.handleOnAvailable, this, true);


        this.setDragElId(id);

        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function() {
        this.events = {
            mouseDown: true,
            b4MouseDown: true,
            mouseUp: true,
            b4StartDrag: true,
            startDrag: true,
            b4EndDrag: true,
            endDrag: true,
            drag: true,
            b4Drag: true,
            invalidDrop: true,
            b4DragOut: true,
            dragOut: true,
            dragEnter: true,
            b4DragOver: true,
            dragOver: true,
            b4DragDrop: true,
            dragDrop: true
        };

        if (this.config.events) {
            for (var i in this.config.events) {
                if (this.config.events[i] === false) {
                    this.events[i] = false;
                }
            }
        }


        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
        this.dragOnly = ((this.config.dragOnly === true) ? true : false);
        this.useShim = ((this.config.useShim === true) ? true : false);
    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function(iTop, iRight, iBot, iLeft) {
        if (!iRight && 0 !== iRight) {
            this.padding = [iTop, iTop, iTop, iTop];
        } else if (!iBot && 0 !== iBot) {
            this.padding = [iTop, iRight, iTop, iRight];
        } else {
            this.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitialPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     * @private
     */
    setInitPosition: function(diffX, diffY) {
        var el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            if (el && el.style && (el.style.display == 'none')) {
            } else {
            }
            return;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = Dom.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];



        this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function(pos) {
        var p = pos || Dom.getXY(this.getEl());

        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All
     * instances belong to at least one group, and can belong to as many
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function(sGroup) {
        this.groups[sGroup] = true;
        this.DDM.regDragDrop(this, sGroup);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function(sGroup) {
        if (this.groups[sGroup]) {
            delete this.groups[sGroup];
        }

        this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
     * Allows you to specify that an element other than the linked element
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be
     * used to initiate the drag operation.  An example of this would be if
     * you have a content div with text and links.  Clicking anywhere in the
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to
     * initiate the drag.
     */
    setHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        Event.on(id, "mousedown",
                this.handleMouseDown, this, true);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function() {
        Event.removeListener(this.id, "mousedown",
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else
     * false
     */
    isLocked: function() {
        return (this.DDM.isLocked() || this.locked);
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e
     * @param {YAHOO.util.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function(e, oDD) {

        var button = e.which || e.button;

        if (this.primaryButtonOnly && button > 1) {
            return;
        }

        if (this.isLocked()) {
            return;
        }



        var b4Return = this.b4MouseDown(e),
        b4Return2 = true;

        if (this.events.b4MouseDown) {
            b4Return2 = this.fireEvent('b4MouseDownEvent', e);
        }
        var mDownReturn = this.onMouseDown(e),
            mDownReturn2 = true;
        if (this.events.mouseDown) {
            mDownReturn2 = this.fireEvent('mouseDownEvent', e);
        }

        if ((b4Return === false) || (mDownReturn === false) || (b4Return2 === false) || (mDownReturn2 === false)) {
            return;
        }

        this.DDM.refreshCache(this.groups);

        var pt = new YAHOO.util.Point(Event.getPageX(e), Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else {
            if (this.clickValidator(e)) {


                this.setStartPosition();

                this.DDM.handleMouseDown(e, this);

                this.DDM.stopEvent(e);
            } else {


            }
        }
    },

    /**
     * @method clickValidator
     * @description Method validates that the clicked element
     * was indeed the handle or a valid child of the handle
     * @param {Event} e
     */
    clickValidator: function(e) {
        var target = YAHOO.util.Event.getTarget(e);
        return ( this.isValidHandleChild(target) &&
                    (this.id == this.handleElId ||
                        this.DDM.handleWasClicked(target, this.id)) );
    },

    /**
     * Finds the location the element should be placed if we want to move
     * it to where the mouse location less the click offset would place us.
     * @method getTargetCoord
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     * @return an object that contains the coordinates (Object.x and Object.y)
     * @private
     */
    getTargetCoord: function(iPageX, iPageY) {


        var x = iPageX - this.deltaX;
        var y = iPageY - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }

        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return {x:x, y:y};
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        this.invalidHandleTypes[type] = type;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.invalidHandleIds[id] = id;
    },


    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function(cssClass) {
        this.invalidHandleClasses.push(cssClass);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        delete this.invalidHandleTypes[type];
    },

    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        delete this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to
     * re-enable
     */
    removeInvalidHandleClass: function(cssClass) {
        for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == cssClass) {
                delete this.invalidHandleClasses[i];
            }
        }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function(node) {

        var valid = true;
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid && !this.invalidHandleTypes[nodeName];
        valid = valid && !this.invalidHandleIds[node.id];

        for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
            valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);
        }


        return valid;

    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function(iStartX, iTickSize) {
        this.xTicks = [];
        this.xTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function(iStartY, iTickSize) {
        this.yTicks = [];
        this.yTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use
     * this method to limit the horizontal travel of the element.  Pass in
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the
     * right
     * @param {int} iTickSize optional parameter for specifying that the
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = parseInt(iLeft, 10);
        this.rightConstraint = parseInt(iRight, 10);

        this.minX = this.initPageX - this.leftConstraint;
        this.maxX = this.initPageX + this.rightConstraint;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = parseInt(iUp, 10);
        this.bottomConstraint = parseInt(iDown, 10);

        this.minY = this.initPageY - this.topConstraint;
        this.maxY = this.initPageY + this.bottomConstraint;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;

    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     */
    resetConstraints: function() {


        if (this.initPageX || this.initPageX === 0) {
            var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        } else {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint,
                                 this.rightConstraint,
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint,
                                 this.bottomConstraint,
                                 this.yTickSize         );
        }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify
     * that it move a number of pixels at a time.  This method resolves the
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function(val, tickArray) {

        if (!tickArray) {
            return val;
        } else if (tickArray[0] >= val) {
            return tickArray[0];
        } else {
            for (var i=0, len=tickArray.length; i<len; ++i) {
                var next = i + 1;
                if (tickArray[next] && tickArray[next] >= val) {
                    var diff1 = val - tickArray[i];
                    var diff2 = tickArray[next] - val;
                    return (diff2 > diff1) ? tickArray[i] : tickArray[next];
                }
            }

            return tickArray[tickArray.length - 1];
        }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function() {
        return ("DragDrop " + this.id);
    }

};
YAHOO.augment(YAHOO.util.DragDrop, YAHOO.util.EventProvider);

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
})();
/**
 * A DragDrop implementation where the linked element follows the
 * mouse cursor during a drag.
 * @class DD
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String} id the id of the linked element
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD:
 *                    scroll
 */
YAHOO.util.DD = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DD, YAHOO.util.DragDrop, {

    /**
     * When set to true, the utility automatically tries to scroll the browser
     * window when a drag and drop element is dragged near the viewport boundary.
     * Defaults to true.
     * @property scroll
     * @type boolean
     */
    scroll: true,

    /**
     * Sets the pointer offset to the distance between the linked element's top
     * left corner and the location the element was clicked
     * @method autoOffset
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     */
    autoOffset: function(iPageX, iPageY) {
        var x = iPageX - this.startPageX;
        var y = iPageY - this.startPageY;
        this.setDelta(x, y);
    },

    /**
     * Sets the pointer offset.  You can call this directly to force the
     * offset to be in a particular location (e.g., pass in 0,0 to set it
     * to the center of the object, as done in YAHOO.widget.Slider)
     * @method setDelta
     * @param {int} iDeltaX the distance from the left
     * @param {int} iDeltaY the distance from the top
     */
    setDelta: function(iDeltaX, iDeltaY) {
        this.deltaX = iDeltaX;
        this.deltaY = iDeltaY;
    },

    /**
     * Sets the drag element to the location of the mousedown or click event,
     * maintaining the cursor location relative to the location on the element
     * that was clicked.  Override this if you want to place the element in a
     * location other than where the cursor is.
     * @method setDragElPos
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    setDragElPos: function(iPageX, iPageY) {

        var el = this.getDragEl();
        this.alignElWithMouse(el, iPageX, iPageY);
    },

    /**
     * Sets the element to the location of the mousedown or click event,
     * maintaining the cursor location relative to the location on the element
     * that was clicked.  Override this if you want to place the element in a
     * location other than where the cursor is.
     * @method alignElWithMouse
     * @param {HTMLElement} el the element to move
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var oCoord = this.getTargetCoord(iPageX, iPageY);

        if (!this.deltaSetXY) {
            var aCoord = [oCoord.x, oCoord.y];
            YAHOO.util.Dom.setXY(el, aCoord);

            var newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            var newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            this.deltaSetXY = [ newLeft - oCoord.x, newTop - oCoord.y ];
        } else {
            YAHOO.util.Dom.setStyle(el, "left", (oCoord.x + this.deltaSetXY[0]) + "px");
            YAHOO.util.Dom.setStyle(el, "top",  (oCoord.y + this.deltaSetXY[1]) + "px");
        }

        this.cachePosition(oCoord.x, oCoord.y);
        var self = this;
        setTimeout(function() {
            self.autoScroll.call(self, oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
        }, 0);
    },

    /**
     * Saves the most recent position so that we can reset the constraints and
     * tick marks on-demand.  We need to know this so that we can calculate the
     * number of pixels the element is offset from its original position.
     * @method cachePosition
     * @param iPageX the current x position (optional, this just makes it so we
     * don't have to look it up again)
     * @param iPageY the current y position (optional, this just makes it so we
     * don't have to look it up again)
     */
    cachePosition: function(iPageX, iPageY) {
        if (iPageX) {
            this.lastPageX = iPageX;
            this.lastPageY = iPageY;
        } else {
            var aCoord = YAHOO.util.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
     * Auto-scroll the window if the dragged object has been moved beyond the
     * visible window boundary.
     * @method autoScroll
     * @param {int} x the drag element's x position
     * @param {int} y the drag element's y position
     * @param {int} h the height of the drag element
     * @param {int} w the width of the drag element
     * @private
     */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            var clientH = this.DDM.getClientHeight();

            var clientW = this.DDM.getClientWidth();

            var st = this.DDM.getScrollTop();

            var sl = this.DDM.getScrollLeft();

            var bot = h + y;

            var right = w + x;

            var toBot = (clientH + st - y - this.deltaY);

            var toRight = (clientW + sl - x - this.deltaX);


            var thresh = 40;

            var scrAmt = (document.all) ? 80 : 30;

            if ( bot > clientH && toBot < thresh ) {
                window.scrollTo(sl, st + scrAmt);
            }

            if ( y < st && st > 0 && y - st < thresh ) {
                window.scrollTo(sl, st - scrAmt);
            }

            if ( right > clientW && toRight < thresh ) {
                window.scrollTo(sl + scrAmt, st);
            }

            if ( x < sl && sl > 0 && x - sl < thresh ) {
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /*
     * Sets up config options specific to this class. Overrides
     * YAHOO.util.DragDrop, but all versions of this method through the
     * inheritance chain are called
     */
    applyConfig: function() {
        YAHOO.util.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
     * Event that fires prior to the onMouseDown event.  Overrides
     * YAHOO.util.DragDrop.
     */
    b4MouseDown: function(e) {
        this.setStartPosition();
        this.autoOffset(YAHOO.util.Event.getPageX(e),
                            YAHOO.util.Event.getPageY(e));
    },

    /*
     * Event that fires prior to the onDrag event.  Overrides
     * YAHOO.util.DragDrop.
     */
    b4Drag: function(e) {
        this.setDragElPos(YAHOO.util.Event.getPageX(e),
                            YAHOO.util.Event.getPageY(e));
    },

    toString: function() {
        return ("DD " + this.id);
    }

    /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
});
/**
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @class DDProxy
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop:
 *                   resizeFrame, centerFrame, dragElId
 */
YAHOO.util.DDProxy = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
        this.initFrame();
    }
};

/**
 * The default drag frame div id
 * @property YAHOO.util.DDProxy.dragElId
 * @type String
 * @static
 */
YAHOO.util.DDProxy.dragElId = "ygddfdiv";

YAHOO.extend(YAHOO.util.DDProxy, YAHOO.util.DD, {

    /**
     * By default we resize the drag frame to be the same size as the element
     * we want to drag (this is to get the frame effect).  We can turn it off
     * if we want a different behavior.
     * @property resizeFrame
     * @type boolean
     */
    resizeFrame: true,

    /**
     * By default the frame is positioned exactly where the drag element is, so
     * we use the cursor offset provided by YAHOO.util.DD.  Another option that works only if
     * you do not have constraints on the obj is to have the drag frame centered
     * around the cursor.  Set centerFrame to true for this effect.
     * @property centerFrame
     * @type boolean
     */
    centerFrame: false,

    /**
     * Creates the proxy element if it does not yet exist
     * @method createFrame
     */
    createFrame: function() {
        var self=this, body=document.body;

        if (!body || !body.firstChild) {
            setTimeout( function() { self.createFrame(); }, 50 );
            return;
        }

        var div=this.getDragEl(), Dom=YAHOO.util.Dom;

        if (!div) {
            div    = document.createElement("div");
            div.id = this.dragElId;
            var s  = div.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;
            s.height     = "25px";
            s.width      = "25px";

            var _data = document.createElement('div');
            Dom.setStyle(_data, 'height', '100%');
            Dom.setStyle(_data, 'width', '100%');
            /**
            * If the proxy element has no background-color, then it is considered to the "transparent" by Internet Explorer.
            * Since it is "transparent" then the events pass through it to the iframe below.
            * So creating a "fake" div inside the proxy element and giving it a background-color, then setting it to an
            * opacity of 0, it appears to not be there, however IE still thinks that it is so the events never pass through.
            */
            Dom.setStyle(_data, 'background-color', '#ccc');
            Dom.setStyle(_data, 'opacity', '0');
            div.appendChild(_data);

            body.insertBefore(div, body.firstChild);
        }
    },

    /**
     * Initialization for the drag frame element.  Must be called in the
     * constructor of all subclasses
     * @method initFrame
     */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        YAHOO.util.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || YAHOO.util.DDProxy.dragElId);
    },

    /**
     * Resizes the drag frame to the dimensions of the clicked object, positions
     * it over the object, and finally displays it
     * @method showFrame
     * @param {int} iPageX X click position
     * @param {int} iPageY Y click position
     * @private
     */
    showFrame: function(iPageX, iPageY) {
        var el = this.getEl();
        var dragEl = this.getDragEl();
        var s = dragEl.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2),
                           Math.round(parseInt(s.height, 10)/2) );
        }

        this.setDragElPos(iPageX, iPageY);

        YAHOO.util.Dom.setStyle(dragEl, "visibility", "visible");
    },

    /**
     * The proxy is automatically resized to the dimensions of the linked
     * element when a drag is initiated, unless resizeFrame is set to false
     * @method _resizeProxy
     * @private
     */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var DOM    = YAHOO.util.Dom;
            var el     = this.getEl();
            var dragEl = this.getDragEl();

            var bt = parseInt( DOM.getStyle(dragEl, "borderTopWidth"    ), 10);
            var br = parseInt( DOM.getStyle(dragEl, "borderRightWidth"  ), 10);
            var bb = parseInt( DOM.getStyle(dragEl, "borderBottomWidth" ), 10);
            var bl = parseInt( DOM.getStyle(dragEl, "borderLeftWidth"   ), 10);

            if (isNaN(bt)) { bt = 0; }
            if (isNaN(br)) { br = 0; }
            if (isNaN(bb)) { bb = 0; }
            if (isNaN(bl)) { bl = 0; }


            var newWidth  = Math.max(0, el.offsetWidth  - br - bl);
            var newHeight = Math.max(0, el.offsetHeight - bt - bb);


            DOM.setStyle( dragEl, "width",  newWidth  + "px" );
            DOM.setStyle( dragEl, "height", newHeight + "px" );
        }
    },

    b4MouseDown: function(e) {
        this.setStartPosition();
        var x = YAHOO.util.Event.getPageX(e);
        var y = YAHOO.util.Event.getPageY(e);
        this.autoOffset(x, y);

    },

    b4StartDrag: function(x, y) {
        this.showFrame(x, y);
    },

    b4EndDrag: function(e) {
        YAHOO.util.Dom.setStyle(this.getDragEl(), "visibility", "hidden");
    },

    endDrag: function(e) {
        var DOM = YAHOO.util.Dom;
        var lel = this.getEl();
        var del = this.getDragEl();

        DOM.setStyle(del, "visibility", "");

        DOM.setStyle(lel, "visibility", "hidden");
        YAHOO.util.DDM.moveToEl(lel, del);
        DOM.setStyle(del, "visibility", "hidden");
        DOM.setStyle(lel, "visibility", "");
    },

    toString: function() {
        return ("DDProxy " + this.id);
    }
/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

});
/**
 * A DragDrop implementation that does not move, but can be a drop
 * target.  You would get the same result by simply omitting implementation
 * for the event callbacks, but this way we reduce the processing cost of the
 * event listener and the callbacks.
 * @class DDTarget
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in
 *                 DragDrop:
 *                    none
 */
YAHOO.util.DDTarget = function(id, sGroup, config) {
    if (id) {
        this.initTarget(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
    toString: function() {
        return ("DDTarget " + this.id);
    }
});
YAHOO.register("dragdrop", YAHOO.util.DragDropMgr, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * The Slider component is a UI control that enables the user to adjust
 * values in a finite range along one or two axes. Typically, the Slider
 * control is used in a web application as a rich, visual replacement
 * for an input box that takes a number as input. The Slider control can
 * also easily accommodate a second dimension, providing x,y output for
 * a selection point chosen from a rectangular region.
 *
 * @module    slider
 * @title     Slider Widget
 * @namespace YAHOO.widget
 * @requires  yahoo,dom,dragdrop,event
 * @optional  animation
 */
 (function () {

var getXY = YAHOO.util.Dom.getXY,
    Event = YAHOO.util.Event,
    _AS   = Array.prototype.slice;

/**
 * A DragDrop implementation that can be used as a background for a
 * slider.  It takes a reference to the thumb instance
 * so it can delegate some of the events to it.  The goal is to make the
 * thumb jump to the location on the background when the background is
 * clicked.
 *
 * @class Slider
 * @extends YAHOO.util.DragDrop
 * @uses YAHOO.util.EventProvider
 * @constructor
 * @param {String}      id     The id of the element linked to this instance
 * @param {String}      sGroup The group of related DragDrop items
 * @param {SliderThumb} oThumb The thumb for this slider
 * @param {String}      sType  The type of slider (horiz, vert, region)
 */
function Slider(sElementId, sGroup, oThumb, sType) {

    Slider.ANIM_AVAIL = (!YAHOO.lang.isUndefined(YAHOO.util.Anim));

    if (sElementId) {
        this.init(sElementId, sGroup, true);
        this.initSlider(sType);
        this.initThumb(oThumb);
    }
}

YAHOO.lang.augmentObject(Slider,{
    /**
     * Factory method for creating a horizontal slider
     * @method YAHOO.widget.Slider.getHorizSlider
     * @static
     * @param {String} sBGElId the id of the slider's background element
     * @param {String} sHandleElId the id of the thumb element
     * @param {int} iLeft the number of pixels the element can move left
     * @param {int} iRight the number of pixels the element can move right
     * @param {int} iTickSize optional parameter for specifying that the element
     * should move a certain number pixels at a time.
     * @return {Slider} a horizontal slider control
     */
    getHorizSlider :
        function (sBGElId, sHandleElId, iLeft, iRight, iTickSize) {
            return new Slider(sBGElId, sBGElId,
                new YAHOO.widget.SliderThumb(sHandleElId, sBGElId,
                                   iLeft, iRight, 0, 0, iTickSize), "horiz");
    },

    /**
     * Factory method for creating a vertical slider
     * @method YAHOO.widget.Slider.getVertSlider
     * @static
     * @param {String} sBGElId the id of the slider's background element
     * @param {String} sHandleElId the id of the thumb element
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the element
     * should move a certain number pixels at a time.
     * @return {Slider} a vertical slider control
     */
    getVertSlider :
        function (sBGElId, sHandleElId, iUp, iDown, iTickSize) {
            return new Slider(sBGElId, sBGElId,
                new YAHOO.widget.SliderThumb(sHandleElId, sBGElId, 0, 0,
                                   iUp, iDown, iTickSize), "vert");
    },

    /**
     * Factory method for creating a slider region like the one in the color
     * picker example
     * @method YAHOO.widget.Slider.getSliderRegion
     * @static
     * @param {String} sBGElId the id of the slider's background element
     * @param {String} sHandleElId the id of the thumb element
     * @param {int} iLeft the number of pixels the element can move left
     * @param {int} iRight the number of pixels the element can move right
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the element
     * should move a certain number pixels at a time.
     * @return {Slider} a slider region control
     */
    getSliderRegion :
        function (sBGElId, sHandleElId, iLeft, iRight, iUp, iDown, iTickSize) {
            return new Slider(sBGElId, sBGElId,
                new YAHOO.widget.SliderThumb(sHandleElId, sBGElId, iLeft, iRight,
                                   iUp, iDown, iTickSize), "region");
    },

    /**
     * Constant for valueChangeSource, indicating that the user clicked or
     * dragged the slider to change the value.
     * @property Slider.SOURCE_UI_EVENT
     * @final
     * @static
     * @default 1
     */
    SOURCE_UI_EVENT : 1,

    /**
     * Constant for valueChangeSource, indicating that the value was altered
     * by a programmatic call to setValue/setRegionValue.
     * @property Slider.SOURCE_SET_VALUE
     * @final
     * @static
     * @default 2
     */
    SOURCE_SET_VALUE : 2,

    /**
     * Constant for valueChangeSource, indicating that the value was altered
     * by hitting any of the supported keyboard characters.
     * @property Slider.SOURCE_KEY_EVENT
     * @final
     * @static
     * @default 2
     */
    SOURCE_KEY_EVENT : 3,

    /**
     * By default, animation is available if the animation utility is detected.
     * @property Slider.ANIM_AVAIL
     * @static
     * @type boolean
     */
    ANIM_AVAIL : false
},true);

YAHOO.extend(Slider, YAHOO.util.DragDrop, {

    /**
     * Tracks the state of the mouse button to aid in when events are fired.
     *
     * @property _mouseDown
     * @type boolean
     * @default false
     * @private
     */
    _mouseDown : false,

    /**
     * Override the default setting of dragOnly to true.
     * @property dragOnly
     * @type boolean
     * @default true
     */
    dragOnly : true,

    /**
     * Initializes the slider.  Executed in the constructor
     * @method initSlider
     * @param {string} sType the type of slider (horiz, vert, region)
     */
    initSlider: function(sType) {

        /**
         * The type of the slider (horiz, vert, region)
         * @property type
         * @type string
         */
        this.type = sType;



        /**
         * Event the fires when the value of the control changes.  If
         * the control is animated the event will fire every point
         * along the way.
         * @event change
         * @param {int} newOffset|x the new offset for normal sliders, or the new
         *                          x offset for region sliders
         * @param {int} y the number of pixels the thumb has moved on the y axis
         *                (region sliders only)
         */
        this.createEvent("change", this);

        /**
         * Event that fires at the beginning of a slider thumb move.
         * @event slideStart
         */
        this.createEvent("slideStart", this);

        /**
         * Event that fires at the end of a slider thumb move
         * @event slideEnd
         */
        this.createEvent("slideEnd", this);

        /**
         * Overrides the isTarget property in YAHOO.util.DragDrop
         * @property isTarget
         * @private
         */
        this.isTarget = false;

        /**
         * Flag that determines if the thumb will animate when moved
         * @property animate
         * @type boolean
         */
        this.animate = Slider.ANIM_AVAIL;

        /**
         * Set to false to disable a background click thumb move
         * @property backgroundEnabled
         * @type boolean
         */
        this.backgroundEnabled = true;

        /**
         * Adjustment factor for tick animation, the more ticks, the
         * faster the animation (by default)
         * @property tickPause
         * @type int
         */
        this.tickPause = 40;

        /**
         * Enables the arrow, home and end keys, defaults to true.
         * @property enableKeys
         * @type boolean
         */
        this.enableKeys = true;

        /**
         * Specifies the number of pixels the arrow keys will move the slider.
         * Default is 20.
         * @property keyIncrement
         * @type int
         */
        this.keyIncrement = 20;

        /**
         * moveComplete is set to true when the slider has moved to its final
         * destination.  For animated slider, this value can be checked in
         * the onChange handler to make it possible to execute logic only
         * when the move is complete rather than at all points along the way.
         * Deprecated because this flag is only useful when the background is
         * clicked and the slider is animated.  If the user drags the thumb,
         * the flag is updated when the drag is over ... the final onDrag event
         * fires before the mouseup the ends the drag, so the implementer will
         * never see it.
         *
         * @property moveComplete
         * @type Boolean
         * @deprecated use the slideEnd event instead
         */
        this.moveComplete = true;

        /**
         * If animation is configured, specifies the length of the animation
         * in seconds.
         * @property animationDuration
         * @type int
         * @default 0.2
         */
        this.animationDuration = 0.2;

        /**
         * Constant for valueChangeSource, indicating that the user clicked or
         * dragged the slider to change the value.
         * @property SOURCE_UI_EVENT
         * @final
         * @default 1
         * @deprecated use static Slider.SOURCE_UI_EVENT
         */
        this.SOURCE_UI_EVENT = 1;

        /**
         * Constant for valueChangeSource, indicating that the value was altered
         * by a programmatic call to setValue/setRegionValue.
         * @property SOURCE_SET_VALUE
         * @final
         * @default 2
         * @deprecated use static Slider.SOURCE_SET_VALUE
         */
        this.SOURCE_SET_VALUE = 2;

        /**
         * When the slider value changes, this property is set to identify where
         * the update came from.  This will be either 1, meaning the slider was
         * clicked or dragged, or 2, meaning that it was set via a setValue() call.
         * This can be used within event handlers to apply some of the logic only
         * when dealing with one source or another.
         * @property valueChangeSource
         * @type int
         * @since 2.3.0
         */
        this.valueChangeSource = 0;

        /**
         * Indicates whether or not events will be supressed for the current
         * slide operation
         * @property _silent
         * @type boolean
         * @private
         */
        this._silent = false;

        /**
         * Saved offset used to protect against NaN problems when slider is
         * set to display:none
         * @property lastOffset
         * @type [int, int]
         */
        this.lastOffset = [0,0];
    },

    /**
     * Initializes the slider's thumb. Executed in the constructor.
     * @method initThumb
     * @param {YAHOO.widget.SliderThumb} t the slider thumb
     */
    initThumb: function(t) {

        var self = this;

        /**
         * A YAHOO.widget.SliderThumb instance that we will use to
         * reposition the thumb when the background is clicked
         * @property thumb
         * @type YAHOO.widget.SliderThumb
         */
        this.thumb = t;

        t.cacheBetweenDrags = true;

        if (t._isHoriz && t.xTicks && t.xTicks.length) {
            this.tickPause = Math.round(360 / t.xTicks.length);
        } else if (t.yTicks && t.yTicks.length) {
            this.tickPause = Math.round(360 / t.yTicks.length);
        }


        t.onAvailable = function() {
                return self.setStartSliderState();
            };
        t.onMouseDown = function () {
                self._mouseDown = true;
                return self.focus();
            };
        t.startDrag = function() {
                self._slideStart();
            };
        t.onDrag = function() {
                self.fireEvents(true);
            };
        t.onMouseUp = function() {
                self.thumbMouseUp();
            };

    },

    /**
     * Executed when the slider element is available
     * @method onAvailable
     */
    onAvailable: function() {
        this._bindKeyEvents();
    },

    /**
     * Sets up the listeners for keydown and key press events.
     *
     * @method _bindKeyEvents
     * @protected
     */
    _bindKeyEvents : function () {
        Event.on(this.id, "keydown",  this.handleKeyDown,  this, true);
        Event.on(this.id, "keypress", this.handleKeyPress, this, true);
    },

    /**
     * Executed when a keypress event happens with the control focused.
     * Prevents the default behavior for navigation keys.  The actual
     * logic for moving the slider thumb in response to a key event
     * happens in handleKeyDown.
     * @param {Event} e the keypress event
     */
    handleKeyPress: function(e) {
        if (this.enableKeys) {
            var kc = Event.getCharCode(e);

            switch (kc) {
                case 0x25: // left
                case 0x26: // up
                case 0x27: // right
                case 0x28: // down
                case 0x24: // home
                case 0x23: // end
                    Event.preventDefault(e);
                    break;
                default:
            }
        }
    },

    /**
     * Executed when a keydown event happens with the control focused.
     * Updates the slider value and display when the keypress is an
     * arrow key, home, or end as long as enableKeys is set to true.
     * @param {Event} e the keydown event
     */
    handleKeyDown: function(e) {
        if (this.enableKeys) {
            var kc = Event.getCharCode(e),
                t  = this.thumb,
                h  = this.getXValue(),
                v  = this.getYValue(),
                changeValue = true;

            switch (kc) {

                case 0x25: h -= this.keyIncrement; break;

                case 0x26: v -= this.keyIncrement; break;

                case 0x27: h += this.keyIncrement; break;

                case 0x28: v += this.keyIncrement; break;

                case 0x24: h = t.leftConstraint;
                           v = t.topConstraint;
                           break;

                case 0x23: h = t.rightConstraint;
                           v = t.bottomConstraint;
                           break;

                default:   changeValue = false;
            }

            if (changeValue) {
                if (t._isRegion) {
                    this._setRegionValue(Slider.SOURCE_KEY_EVENT, h, v, true);
                } else {
                    this._setValue(Slider.SOURCE_KEY_EVENT,
                        (t._isHoriz ? h : v), true);
                }
                Event.stopEvent(e);
            }

        }
    },

    /**
     * Initialization that sets up the value offsets once the elements are ready
     * @method setStartSliderState
     */
    setStartSliderState: function() {


        this.setThumbCenterPoint();

        /**
         * The basline position of the background element, used
         * to determine if the background has moved since the last
         * operation.
         * @property baselinePos
         * @type [int, int]
         */
        this.baselinePos = getXY(this.getEl());

        this.thumb.startOffset = this.thumb.getOffsetFromParent(this.baselinePos);

        if (this.thumb._isRegion) {
            if (this.deferredSetRegionValue) {
                this._setRegionValue.apply(this, this.deferredSetRegionValue);
                this.deferredSetRegionValue = null;
            } else {
                this.setRegionValue(0, 0, true, true, true);
            }
        } else {
            if (this.deferredSetValue) {
                this._setValue.apply(this, this.deferredSetValue);
                this.deferredSetValue = null;
            } else {
                this.setValue(0, true, true, true);
            }
        }
    },

    /**
     * When the thumb is available, we cache the centerpoint of the element so
     * we can position the element correctly when the background is clicked
     * @method setThumbCenterPoint
     */
    setThumbCenterPoint: function() {

        var el = this.thumb.getEl();

        if (el) {
            /**
             * The center of the slider element is stored so we can
             * place it in the correct position when the background is clicked.
             * @property thumbCenterPoint
             * @type {"x": int, "y": int}
             */
            this.thumbCenterPoint = {
                    x: parseInt(el.offsetWidth/2, 10),
                    y: parseInt(el.offsetHeight/2, 10)
            };
        }

    },

    /**
     * Locks the slider, overrides YAHOO.util.DragDrop
     * @method lock
     */
    lock: function() {
        this.thumb.lock();
        this.locked = true;
    },

    /**
     * Unlocks the slider, overrides YAHOO.util.DragDrop
     * @method unlock
     */
    unlock: function() {
        this.thumb.unlock();
        this.locked = false;
    },

    /**
     * Handles mouseup event on the thumb
     * @method thumbMouseUp
     * @private
     */
    thumbMouseUp: function() {
        this._mouseDown = false;
        if (!this.isLocked()) {
            this.endMove();
        }

    },

    onMouseUp: function() {
        this._mouseDown = false;
        if (this.backgroundEnabled && !this.isLocked()) {
            this.endMove();
        }
    },

    /**
     * Returns a reference to this slider's thumb
     * @method getThumb
     * @return {SliderThumb} this slider's thumb
     */
    getThumb: function() {
        return this.thumb;
    },

    /**
     * Try to focus the element when clicked so we can add
     * accessibility features
     * @method focus
     * @private
     */
    focus: function() {
        this.valueChangeSource = Slider.SOURCE_UI_EVENT;

        var el = this.getEl();

        if (el.focus) {
            try {
                el.focus();
            } catch(e) {
            }
        }

        this.verifyOffset();

        return !this.isLocked();
    },

    /**
     * Event that fires when the value of the slider has changed
     * @method onChange
     * @param {int} firstOffset the number of pixels the thumb has moved
     * from its start position. Normal horizontal and vertical sliders will only
     * have the firstOffset.  Regions will have both, the first is the horizontal
     * offset, the second the vertical.
     * @param {int} secondOffset the y offset for region sliders
     * @deprecated use instance.subscribe("change") instead
     */
    onChange: function (firstOffset, secondOffset) {
        /* override me */
    },

    /**
     * Event that fires when the at the beginning of the slider thumb move
     * @method onSlideStart
     * @deprecated use instance.subscribe("slideStart") instead
     */
    onSlideStart: function () {
        /* override me */
    },

    /**
     * Event that fires at the end of a slider thumb move
     * @method onSliderEnd
     * @deprecated use instance.subscribe("slideEnd") instead
     */
    onSlideEnd: function () {
        /* override me */
    },

    /**
     * Returns the slider's thumb offset from the start position
     * @method getValue
     * @return {int} the current value
     */
    getValue: function () {
        return this.thumb.getValue();
    },

    /**
     * Returns the slider's thumb X offset from the start position
     * @method getXValue
     * @return {int} the current horizontal offset
     */
    getXValue: function () {
        return this.thumb.getXValue();
    },

    /**
     * Returns the slider's thumb Y offset from the start position
     * @method getYValue
     * @return {int} the current vertical offset
     */
    getYValue: function () {
        return this.thumb.getYValue();
    },

    /**
     * Provides a way to set the value of the slider in code.
     *
     * @method setValue
     * @param {int} newOffset the number of pixels the thumb should be
     * positioned away from the initial start point
     * @param {boolean} skipAnim set to true to disable the animation
     * for this move action (but not others).
     * @param {boolean} force ignore the locked setting and set value anyway
     * @param {boolean} silent when true, do not fire events
     * @return {boolean} true if the move was performed, false if it failed
     */
    setValue: function() {
        var args = _AS.call(arguments);
        args.unshift(Slider.SOURCE_SET_VALUE);
        return this._setValue.apply(this,args);
    },

    /**
     * Worker function to execute the value set operation.  Accepts type of
     * set operation in addition to the usual setValue params.
     *
     * @method _setValue
     * @param source {int} what triggered the set (e.g. Slider.SOURCE_SET_VALUE)
     * @param {int} newOffset the number of pixels the thumb should be
     * positioned away from the initial start point
     * @param {boolean} skipAnim set to true to disable the animation
     * for this move action (but not others).
     * @param {boolean} force ignore the locked setting and set value anyway
     * @param {boolean} silent when true, do not fire events
     * @return {boolean} true if the move was performed, false if it failed
     * @protected
     */
    _setValue: function(source, newOffset, skipAnim, force, silent) {
        var t = this.thumb, newX, newY;

        if (!t.available) {
            this.deferredSetValue = arguments;
            return false;
        }

        if (this.isLocked() && !force) {
            return false;
        }

        if ( isNaN(newOffset) ) {
            return false;
        }

        if (t._isRegion) {
            return false;
        }


        this._silent = silent;
        this.valueChangeSource = source || Slider.SOURCE_SET_VALUE;

        t.lastOffset = [newOffset, newOffset];
        this.verifyOffset();

        this._slideStart();

        if (t._isHoriz) {
            newX = t.initPageX + newOffset + this.thumbCenterPoint.x;
            this.moveThumb(newX, t.initPageY, skipAnim);
        } else {
            newY = t.initPageY + newOffset + this.thumbCenterPoint.y;
            this.moveThumb(t.initPageX, newY, skipAnim);
        }

        return true;
    },

    /**
     * Provides a way to set the value of the region slider in code.
     * @method setRegionValue
     * @param {int} newOffset the number of pixels the thumb should be
     * positioned away from the initial start point (x axis for region)
     * @param {int} newOffset2 the number of pixels the thumb should be
     * positioned away from the initial start point (y axis for region)
     * @param {boolean} skipAnim set to true to disable the animation
     * for this move action (but not others).
     * @param {boolean} force ignore the locked setting and set value anyway
     * @param {boolean} silent when true, do not fire events
     * @return {boolean} true if the move was performed, false if it failed
     */
    setRegionValue : function () {
        var args = _AS.call(arguments);
        args.unshift(Slider.SOURCE_SET_VALUE);
        return this._setRegionValue.apply(this,args);
    },

    /**
     * Worker function to execute the value set operation.  Accepts type of
     * set operation in addition to the usual setValue params.
     *
     * @method _setRegionValue
     * @param source {int} what triggered the set (e.g. Slider.SOURCE_SET_VALUE)
     * @param {int} newOffset the number of pixels the thumb should be
     * positioned away from the initial start point (x axis for region)
     * @param {int} newOffset2 the number of pixels the thumb should be
     * positioned away from the initial start point (y axis for region)
     * @param {boolean} skipAnim set to true to disable the animation
     * for this move action (but not others).
     * @param {boolean} force ignore the locked setting and set value anyway
     * @param {boolean} silent when true, do not fire events
     * @return {boolean} true if the move was performed, false if it failed
     * @protected
     */
    _setRegionValue: function(source, newOffset, newOffset2, skipAnim, force, silent) {
        var t = this.thumb, newX, newY;

        if (!t.available) {
            this.deferredSetRegionValue = arguments;
            return false;
        }

        if (this.isLocked() && !force) {
            return false;
        }

        if ( isNaN(newOffset) ) {
            return false;
        }

        if (!t._isRegion) {
            return false;
        }

        this._silent = silent;

        this.valueChangeSource = source || Slider.SOURCE_SET_VALUE;

        t.lastOffset = [newOffset, newOffset2];
        this.verifyOffset();

        this._slideStart();

        newX = t.initPageX + newOffset + this.thumbCenterPoint.x;
        newY = t.initPageY + newOffset2 + this.thumbCenterPoint.y;
        this.moveThumb(newX, newY, skipAnim);

        return true;
    },

    /**
     * Checks the background position element position.  If it has moved from the
     * baseline position, the constraints for the thumb are reset
     * @method verifyOffset
     * @return {boolean} True if the offset is the same as the baseline.
     */
    verifyOffset: function() {

        var xy = getXY(this.getEl()),
            t  = this.thumb;

        if (!this.thumbCenterPoint || !this.thumbCenterPoint.x) {
            this.setThumbCenterPoint();
        }

        if (xy) {


            if (xy[0] != this.baselinePos[0] || xy[1] != this.baselinePos[1]) {

                this.setInitPosition();
                this.baselinePos = xy;

                t.initPageX = this.initPageX + t.startOffset[0];
                t.initPageY = this.initPageY + t.startOffset[1];
                t.deltaSetXY = null;
                this.resetThumbConstraints();

                return false;
            }
        }

        return true;
    },

    /**
     * Move the associated slider moved to a timeout to try to get around the
     * mousedown stealing moz does when I move the slider element between the
     * cursor and the background during the mouseup event
     * @method moveThumb
     * @param {int} x the X coordinate of the click
     * @param {int} y the Y coordinate of the click
     * @param {boolean} skipAnim don't animate if the move happend onDrag
     * @param {boolean} midMove set to true if this is not terminating
     * the slider movement
     * @private
     */
    moveThumb: function(x, y, skipAnim, midMove) {

        var t = this.thumb,
            self = this,
            p,_p,anim;

        if (!t.available) {
            return;
        }


        t.setDelta(this.thumbCenterPoint.x, this.thumbCenterPoint.y);

        _p = t.getTargetCoord(x, y);
        p = [Math.round(_p.x), Math.round(_p.y)];

        if (this.animate && t._graduated && !skipAnim) {
            this.lock();

            this.curCoord = getXY(this.thumb.getEl());
            this.curCoord = [Math.round(this.curCoord[0]), Math.round(this.curCoord[1])];

            setTimeout( function() { self.moveOneTick(p); }, this.tickPause );

        } else if (this.animate && Slider.ANIM_AVAIL && !skipAnim) {

            this.lock();

            anim = new YAHOO.util.Motion(
                    t.id, { points: { to: p } },
                    this.animationDuration,
                    YAHOO.util.Easing.easeOut );

            anim.onComplete.subscribe( function() {
                    self.unlock();
                    if (!self._mouseDown) {
                        self.endMove();
                    }
                });
            anim.animate();

        } else {
            t.setDragElPos(x, y);
            if (!midMove && !this._mouseDown) {
                this.endMove();
            }
        }
    },

    _slideStart: function() {
        if (!this._sliding) {
            if (!this._silent) {
                this.onSlideStart();
                this.fireEvent("slideStart");
            }
            this._sliding = true;
            this.moveComplete = false; // for backward compatibility. Deprecated
        }
    },

    _slideEnd: function() {
        if (this._sliding) {
            var silent = this._silent;
            this._sliding = false;
            this.moveComplete = true; // for backward compatibility. Deprecated
            this._silent = false;
            if (!silent) {
                this.onSlideEnd();
                this.fireEvent("slideEnd");
            }
        }
    },

    /**
     * Move the slider one tick mark towards its final coordinate.  Used
     * for the animation when tick marks are defined
     * @method moveOneTick
     * @param {int[]} the destination coordinate
     * @private
     */
    moveOneTick: function(finalCoord) {

        var t = this.thumb,
            self = this,
            nextCoord = null,
            tmpX, tmpY;

        if (t._isRegion) {
            nextCoord = this._getNextX(this.curCoord, finalCoord);
            tmpX = (nextCoord !== null) ? nextCoord[0] : this.curCoord[0];
            nextCoord = this._getNextY(this.curCoord, finalCoord);
            tmpY = (nextCoord !== null) ? nextCoord[1] : this.curCoord[1];

            nextCoord = tmpX !== this.curCoord[0] || tmpY !== this.curCoord[1] ?
                [ tmpX, tmpY ] : null;
        } else if (t._isHoriz) {
            nextCoord = this._getNextX(this.curCoord, finalCoord);
        } else {
            nextCoord = this._getNextY(this.curCoord, finalCoord);
        }


        if (nextCoord) {

            this.curCoord = nextCoord;

            this.thumb.alignElWithMouse(t.getEl(), nextCoord[0] + this.thumbCenterPoint.x, nextCoord[1] + this.thumbCenterPoint.y);

            if (!(nextCoord[0] == finalCoord[0] && nextCoord[1] == finalCoord[1])) {
                setTimeout(function() { self.moveOneTick(finalCoord); },
                        this.tickPause);
            } else {
                this.unlock();
                if (!this._mouseDown) {
                    this.endMove();
                }
            }
        } else {
            this.unlock();
            if (!this._mouseDown) {
                this.endMove();
            }
        }
    },

    /**
     * Returns the next X tick value based on the current coord and the target coord.
     * @method _getNextX
     * @private
     */
    _getNextX: function(curCoord, finalCoord) {
        var t = this.thumb,
            thresh,
            tmp = [],
            nextCoord = null;

        if (curCoord[0] > finalCoord[0]) {
            thresh = t.tickSize - this.thumbCenterPoint.x;
            tmp = t.getTargetCoord( curCoord[0] - thresh, curCoord[1] );
            nextCoord = [tmp.x, tmp.y];
        } else if (curCoord[0] < finalCoord[0]) {
            thresh = t.tickSize + this.thumbCenterPoint.x;
            tmp = t.getTargetCoord( curCoord[0] + thresh, curCoord[1] );
            nextCoord = [tmp.x, tmp.y];
        } else {
        }

        return nextCoord;
    },

    /**
     * Returns the next Y tick value based on the current coord and the target coord.
     * @method _getNextY
     * @private
     */
    _getNextY: function(curCoord, finalCoord) {
        var t = this.thumb,
            thresh,
            tmp = [],
            nextCoord = null;

        if (curCoord[1] > finalCoord[1]) {
            thresh = t.tickSize - this.thumbCenterPoint.y;
            tmp = t.getTargetCoord( curCoord[0], curCoord[1] - thresh );
            nextCoord = [tmp.x, tmp.y];
        } else if (curCoord[1] < finalCoord[1]) {
            thresh = t.tickSize + this.thumbCenterPoint.y;
            tmp = t.getTargetCoord( curCoord[0], curCoord[1] + thresh );
            nextCoord = [tmp.x, tmp.y];
        } else {
        }

        return nextCoord;
    },

    /**
     * Resets the constraints before moving the thumb.
     * @method b4MouseDown
     * @private
     */
    b4MouseDown: function(e) {
        if (!this.backgroundEnabled) {
            return false;
        }

        this.thumb.autoOffset();
        this.baselinePos = [];
    },

    /**
     * Handles the mousedown event for the slider background
     * @method onMouseDown
     * @private
     */
    onMouseDown: function(e) {
        if (!this.backgroundEnabled || this.isLocked()) {
            return false;
        }

        this._mouseDown = true;

        var x = Event.getPageX(e),
            y = Event.getPageY(e);


        this.focus();
        this._slideStart();
        this.moveThumb(x, y);
    },

    /**
     * Handles the onDrag event for the slider background
     * @method onDrag
     * @private
     */
    onDrag: function(e) {
        if (this.backgroundEnabled && !this.isLocked()) {
            var x = Event.getPageX(e),
                y = Event.getPageY(e);
            this.moveThumb(x, y, true, true);
            this.fireEvents();
        }
    },

    /**
     * Fired when the slider movement ends
     * @method endMove
     * @private
     */
    endMove: function () {
        this.unlock();
        this.fireEvents();
        this._slideEnd();
    },

    /**
     * Resets the X and Y contraints for the thumb.  Used in lieu of the thumb
     * instance's inherited resetConstraints because some logic was not
     * applicable.
     * @method resetThumbConstraints
     * @protected
     */
    resetThumbConstraints: function () {
        var t = this.thumb;

        t.setXConstraint(t.leftConstraint, t.rightConstraint, t.xTickSize);
        t.setYConstraint(t.topConstraint, t.bottomConstraint, t.xTickSize);
    },

    /**
     * Fires the change event if the value has been changed.  Ignored if we are in
     * the middle of an animation as the event will fire when the animation is
     * complete
     * @method fireEvents
     * @param {boolean} thumbEvent set to true if this event is fired from an event
     *                  that occurred on the thumb.  If it is, the state of the
     *                  thumb dd object should be correct.  Otherwise, the event
     *                  originated on the background, so the thumb state needs to
     *                  be refreshed before proceeding.
     * @private
     */
    fireEvents: function (thumbEvent) {

        var t = this.thumb, newX, newY, newVal;

        if (!thumbEvent) {
            t.cachePosition();
        }

        if (! this.isLocked()) {
            if (t._isRegion) {
                newX = t.getXValue();
                newY = t.getYValue();

                if (newX != this.previousX || newY != this.previousY) {
                    if (!this._silent) {
                        this.onChange(newX, newY);
                        this.fireEvent("change", { x: newX, y: newY });
                    }
                }

                this.previousX = newX;
                this.previousY = newY;

            } else {
                newVal = t.getValue();
                if (newVal != this.previousVal) {
                    if (!this._silent) {
                        this.onChange( newVal );
                        this.fireEvent("change", newVal);
                    }
                }
                this.previousVal = newVal;
            }

        }
    },

    /**
     * Slider toString
     * @method toString
     * @return {string} string representation of the instance
     */
    toString: function () {
        return ("Slider (" + this.type +") " + this.id);
    }

});

YAHOO.lang.augmentProto(Slider, YAHOO.util.EventProvider);

YAHOO.widget.Slider = Slider;
})();
/**
 * A drag and drop implementation to be used as the thumb of a slider.
 * @class SliderThumb
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String} id the id of the slider html element
 * @param {String} sGroup the group of related DragDrop items
 * @param {int} iLeft the number of pixels the element can move left
 * @param {int} iRight the number of pixels the element can move right
 * @param {int} iUp the number of pixels the element can move up
 * @param {int} iDown the number of pixels the element can move down
 * @param {int} iTickSize optional parameter for specifying that the element
 * should move a certain number pixels at a time.
 */
YAHOO.widget.SliderThumb = function(id, sGroup, iLeft, iRight, iUp, iDown, iTickSize) {

    if (id) {
        YAHOO.widget.SliderThumb.superclass.constructor.call(this, id, sGroup);

        /**
         * The id of the thumbs parent HTML element (the slider background
         * element).
         * @property parentElId
         * @type string
         */
        this.parentElId = sGroup;
    }



    /**
     * Overrides the isTarget property in YAHOO.util.DragDrop
     * @property isTarget
     * @private
     */
    this.isTarget = false;

    /**
     * The tick size for this slider
     * @property tickSize
     * @type int
     * @private
     */
    this.tickSize = iTickSize;

    /**
     * Informs the drag and drop util that the offsets should remain when
     * resetting the constraints.  This preserves the slider value when
     * the constraints are reset
     * @property maintainOffset
     * @type boolean
     * @private
     */
    this.maintainOffset = true;

    this.initSlider(iLeft, iRight, iUp, iDown, iTickSize);

    /**
     * Turns off the autoscroll feature in drag and drop
     * @property scroll
     * @private
     */
    this.scroll = false;

};

YAHOO.extend(YAHOO.widget.SliderThumb, YAHOO.util.DD, {

    /**
     * The (X and Y) difference between the thumb location and its parent
     * (the slider background) when the control is instantiated.
     * @property startOffset
     * @type [int, int]
     */
    startOffset: null,

    /**
     * Override the default setting of dragOnly to true.
     * @property dragOnly
     * @type boolean
     * @default true
     */
    dragOnly : true,

    /**
     * Flag used to figure out if this is a horizontal or vertical slider
     * @property _isHoriz
     * @type boolean
     * @private
     */
    _isHoriz: false,

    /**
     * Cache the last value so we can check for change
     * @property _prevVal
     * @type int
     * @private
     */
    _prevVal: 0,

    /**
     * The slider is _graduated if there is a tick interval defined
     * @property _graduated
     * @type boolean
     * @private
     */
    _graduated: false,


    /**
     * Returns the difference between the location of the thumb and its parent.
     * @method getOffsetFromParent
     * @param {[int, int]} parentPos Optionally accepts the position of the parent
     * @type [int, int]
     */
    getOffsetFromParent0: function(parentPos) {
        var myPos = YAHOO.util.Dom.getXY(this.getEl()),
            ppos  = parentPos || YAHOO.util.Dom.getXY(this.parentElId);

        return [ (myPos[0] - ppos[0]), (myPos[1] - ppos[1]) ];
    },

    getOffsetFromParent: function(parentPos) {

        var el = this.getEl(), newOffset,
            myPos,ppos,l,t,deltaX,deltaY,newLeft,newTop;

        if (!this.deltaOffset) {

            myPos = YAHOO.util.Dom.getXY(el);
            ppos  = parentPos || YAHOO.util.Dom.getXY(this.parentElId);

            newOffset = [ (myPos[0] - ppos[0]), (myPos[1] - ppos[1]) ];

            l = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            t = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            deltaX = l - newOffset[0];
            deltaY = t - newOffset[1];

            if (isNaN(deltaX) || isNaN(deltaY)) {
            } else {
                this.deltaOffset = [deltaX, deltaY];
            }

        } else {
            newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            newOffset  = [newLeft + this.deltaOffset[0], newTop + this.deltaOffset[1]];
        }

        return newOffset;
    },

    /**
     * Set up the slider, must be called in the constructor of all subclasses
     * @method initSlider
     * @param {int} iLeft the number of pixels the element can move left
     * @param {int} iRight the number of pixels the element can move right
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize the width of the tick interval.
     */
    initSlider: function (iLeft, iRight, iUp, iDown, iTickSize) {
        this.initLeft = iLeft;
        this.initRight = iRight;
        this.initUp = iUp;
        this.initDown = iDown;

        this.setXConstraint(iLeft, iRight, iTickSize);
        this.setYConstraint(iUp, iDown, iTickSize);

        if (iTickSize && iTickSize > 1) {
            this._graduated = true;
        }

        this._isHoriz  = (iLeft || iRight);
        this._isVert   = (iUp   || iDown);
        this._isRegion = (this._isHoriz && this._isVert);

    },

    /**
     * Clear's the slider's ticks
     * @method clearTicks
     */
    clearTicks: function () {
        YAHOO.widget.SliderThumb.superclass.clearTicks.call(this);
        this.tickSize = 0;
        this._graduated = false;
    },


    /**
     * Gets the current offset from the element's start position in
     * pixels.
     * @method getValue
     * @return {int} the number of pixels (positive or negative) the
     * slider has moved from the start position.
     */
    getValue: function () {
        return (this._isHoriz) ? this.getXValue() : this.getYValue();
    },

    /**
     * Gets the current X offset from the element's start position in
     * pixels.
     * @method getXValue
     * @return {int} the number of pixels (positive or negative) the
     * slider has moved horizontally from the start position.
     */
    getXValue: function () {
        if (!this.available) {
            return 0;
        }
        var newOffset = this.getOffsetFromParent();
        if (YAHOO.lang.isNumber(newOffset[0])) {
            this.lastOffset = newOffset;
            return (newOffset[0] - this.startOffset[0]);
        } else {
            return (this.lastOffset[0] - this.startOffset[0]);
        }
    },

    /**
     * Gets the current Y offset from the element's start position in
     * pixels.
     * @method getYValue
     * @return {int} the number of pixels (positive or negative) the
     * slider has moved vertically from the start position.
     */
    getYValue: function () {
        if (!this.available) {
            return 0;
        }
        var newOffset = this.getOffsetFromParent();
        if (YAHOO.lang.isNumber(newOffset[1])) {
            this.lastOffset = newOffset;
            return (newOffset[1] - this.startOffset[1]);
        } else {
            return (this.lastOffset[1] - this.startOffset[1]);
        }
    },

    /**
     * Thumb toString
     * @method toString
     * @return {string} string representation of the instance
     */
    toString: function () {
        return "SliderThumb " + this.id;
    },

    /**
     * The onchange event for the handle/thumb is delegated to the YAHOO.widget.Slider
     * instance it belongs to.
     * @method onChange
     * @private
     */
    onChange: function (x, y) {
    }

});
/**
 * A slider with two thumbs, one that represents the min value and
 * the other the max.  Actually a composition of two sliders, both with
 * the same background.  The constraints for each slider are adjusted
 * dynamically so that the min value of the max slider is equal or greater
 * to the current value of the min slider, and the max value of the min
 * slider is the current value of the max slider.
 * Constructor assumes both thumbs are positioned absolutely at the 0 mark on
 * the background.
 *
 * @namespace YAHOO.widget
 * @class DualSlider
 * @uses YAHOO.util.EventProvider
 * @constructor
 * @param {Slider} minSlider The Slider instance used for the min value thumb
 * @param {Slider} maxSlider The Slider instance used for the max value thumb
 * @param {int}    range The number of pixels the thumbs may move within
 * @param {Array}  initVals (optional) [min,max] Initial thumb placement
 */
(function () {

var Event = YAHOO.util.Event,
    YW = YAHOO.widget;

function DualSlider(minSlider, maxSlider, range, initVals) {

    var self  = this,
        ready = { min : false, max : false },
        minThumbOnMouseDown, maxThumbOnMouseDown;

    /**
     * A slider instance that keeps track of the lower value of the range.
     * <strong>read only</strong>
     * @property minSlider
     * @type Slider
     */
    this.minSlider = minSlider;

    /**
     * A slider instance that keeps track of the upper value of the range.
     * <strong>read only</strong>
     * @property maxSlider
     * @type Slider
     */
    this.maxSlider = maxSlider;

    /**
     * The currently active slider (min or max). <strong>read only</strong>
     * @property activeSlider
     * @type Slider
     */
    this.activeSlider = minSlider;

    /**
     * Is the DualSlider oriented horizontally or vertically?
     * <strong>read only</strong>
     * @property isHoriz
     * @type boolean
     */
    this.isHoriz = minSlider.thumb._isHoriz;

    minThumbOnMouseDown = this.minSlider.thumb.onMouseDown;
    maxThumbOnMouseDown = this.maxSlider.thumb.onMouseDown;
    this.minSlider.thumb.onMouseDown = function() {
        self.activeSlider = self.minSlider;
        minThumbOnMouseDown.apply(this,arguments);
    };
    this.maxSlider.thumb.onMouseDown = function () {
        self.activeSlider = self.maxSlider;
        maxThumbOnMouseDown.apply(this,arguments);
    };

    this.minSlider.thumb.onAvailable = function () {
        minSlider.setStartSliderState();
        ready.min = true;
        if (ready.max) {
            self.fireEvent('ready',self);
        }
    };
    this.maxSlider.thumb.onAvailable = function () {
        maxSlider.setStartSliderState();
        ready.max = true;
        if (ready.min) {
            self.fireEvent('ready',self);
        }
    };

    minSlider.onMouseDown =
    maxSlider.onMouseDown = function(e) {
        return this.backgroundEnabled && self._handleMouseDown(e);
    };

    minSlider.onDrag =
    maxSlider.onDrag = function(e) {
        self._handleDrag(e);
    };

    minSlider.onMouseUp =
    maxSlider.onMouseUp = function (e) {
        self._handleMouseUp(e);
    };

    minSlider._bindKeyEvents = function () {
        self._bindKeyEvents(this);
    };
    maxSlider._bindKeyEvents = function () {};

    minSlider.subscribe("change", this._handleMinChange, minSlider, this);
    minSlider.subscribe("slideStart", this._handleSlideStart, minSlider, this);
    minSlider.subscribe("slideEnd", this._handleSlideEnd, minSlider, this);

    maxSlider.subscribe("change", this._handleMaxChange, maxSlider, this);
    maxSlider.subscribe("slideStart", this._handleSlideStart, maxSlider, this);
    maxSlider.subscribe("slideEnd", this._handleSlideEnd, maxSlider, this);

    /**
     * Event that fires when the slider is finished setting up
     * @event ready
     * @param {DualSlider} dualslider the DualSlider instance
     */
    this.createEvent("ready", this);

    /**
     * Event that fires when either the min or max value changes
     * @event change
     * @param {DualSlider} dualslider the DualSlider instance
     */
    this.createEvent("change", this);

    /**
     * Event that fires when one of the thumbs begins to move
     * @event slideStart
     * @param {Slider} activeSlider the moving slider
     */
    this.createEvent("slideStart", this);

    /**
     * Event that fires when one of the thumbs finishes moving
     * @event slideEnd
     * @param {Slider} activeSlider the moving slider
     */
    this.createEvent("slideEnd", this);

    initVals = YAHOO.lang.isArray(initVals) ? initVals : [0,range];
    initVals[0] = Math.min(Math.max(parseInt(initVals[0],10)|0,0),range);
    initVals[1] = Math.max(Math.min(parseInt(initVals[1],10)|0,range),0);
    if (initVals[0] > initVals[1]) {
        initVals.splice(0,2,initVals[1],initVals[0]);
    }
    this.minVal = initVals[0];
    this.maxVal = initVals[1];

    this.minSlider.setValue(this.minVal,true,true,true);
    this.maxSlider.setValue(this.maxVal,true,true,true);

}

DualSlider.prototype = {

    /**
     * The current value of the min thumb. <strong>read only</strong>.
     * @property minVal
     * @type int
     */
    minVal : -1,

    /**
     * The current value of the max thumb. <strong>read only</strong>.
     * @property maxVal
     * @type int
     */
    maxVal : -1,

    /**
     * Pixel distance to maintain between thumbs.
     * @property minRange
     * @type int
     * @default 0
     */
    minRange : 0,

    /**
     * Executed when one of the sliders fires the slideStart event
     * @method _handleSlideStart
     * @private
     */
    _handleSlideStart: function(data, slider) {
        this.fireEvent("slideStart", slider);
    },

    /**
     * Executed when one of the sliders fires the slideEnd event
     * @method _handleSlideEnd
     * @private
     */
    _handleSlideEnd: function(data, slider) {
        this.fireEvent("slideEnd", slider);
    },

    /**
     * Overrides the onDrag method for both sliders
     * @method _handleDrag
     * @private
     */
    _handleDrag: function(e) {
        YW.Slider.prototype.onDrag.call(this.activeSlider, e);
    },

    /**
     * Executed when the min slider fires the change event
     * @method _handleMinChange
     * @private
     */
    _handleMinChange: function() {
        this.activeSlider = this.minSlider;
        this.updateValue();
    },

    /**
     * Executed when the max slider fires the change event
     * @method _handleMaxChange
     * @private
     */
    _handleMaxChange: function() {
        this.activeSlider = this.maxSlider;
        this.updateValue();
    },

    /**
     * Set up the listeners for the keydown and keypress events.
     *
     * @method _bindKeyEvents
     * @protected
     */
    _bindKeyEvents : function (slider) {
        Event.on(slider.id,'keydown', this._handleKeyDown, this,true);
        Event.on(slider.id,'keypress',this._handleKeyPress,this,true);
    },

    /**
     * Delegate event handling to the active Slider.  See Slider.handleKeyDown.
     *
     * @method _handleKeyDown
     * @param e {Event} the mousedown DOM event
     * @protected
     */
    _handleKeyDown : function (e) {
        this.activeSlider.handleKeyDown.apply(this.activeSlider,arguments);
    },

    /**
     * Delegate event handling to the active Slider.  See Slider.handleKeyPress.
     *
     * @method _handleKeyPress
     * @param e {Event} the mousedown DOM event
     * @protected
     */
    _handleKeyPress : function (e) {
        this.activeSlider.handleKeyPress.apply(this.activeSlider,arguments);
    },

    /**
     * Sets the min and max thumbs to new values.
     * @method setValues
     * @param min {int} Pixel offset to assign to the min thumb
     * @param max {int} Pixel offset to assign to the max thumb
     * @param skipAnim {boolean} (optional) Set to true to skip thumb animation.
     * Default false
     * @param force {boolean} (optional) ignore the locked setting and set
     * value anyway. Default false
     * @param silent {boolean} (optional) Set to true to skip firing change
     * events.  Default false
     */
    setValues : function (min, max, skipAnim, force, silent) {
        var mins = this.minSlider,
            maxs = this.maxSlider,
            mint = mins.thumb,
            maxt = maxs.thumb,
            self = this,
            done = { min : false, max : false };

        if (mint._isHoriz) {
            mint.setXConstraint(mint.leftConstraint,maxt.rightConstraint,mint.tickSize);
            maxt.setXConstraint(mint.leftConstraint,maxt.rightConstraint,maxt.tickSize);
        } else {
            mint.setYConstraint(mint.topConstraint,maxt.bottomConstraint,mint.tickSize);
            maxt.setYConstraint(mint.topConstraint,maxt.bottomConstraint,maxt.tickSize);
        }

        this._oneTimeCallback(mins,'slideEnd',function () {
            done.min = true;
            if (done.max) {
                self.updateValue(silent);
                setTimeout(function () {
                    self._cleanEvent(mins,'slideEnd');
                    self._cleanEvent(maxs,'slideEnd');
                },0);
            }
        });

        this._oneTimeCallback(maxs,'slideEnd',function () {
            done.max = true;
            if (done.min) {
                self.updateValue(silent);
                setTimeout(function () {
                    self._cleanEvent(mins,'slideEnd');
                    self._cleanEvent(maxs,'slideEnd');
                },0);
            }
        });

        mins.setValue(min,skipAnim,force,false);
        maxs.setValue(max,skipAnim,force,false);
    },

    /**
     * Set the min thumb position to a new value.
     * @method setMinValue
     * @param min {int} Pixel offset for min thumb
     * @param skipAnim {boolean} (optional) Set to true to skip thumb animation.
     * Default false
     * @param force {boolean} (optional) ignore the locked setting and set
     * value anyway. Default false
     * @param silent {boolean} (optional) Set to true to skip firing change
     * events.  Default false
     */
    setMinValue : function (min, skipAnim, force, silent) {
        var mins = this.minSlider,
            self = this;

        this.activeSlider = mins;

        self = this;
        this._oneTimeCallback(mins,'slideEnd',function () {
            self.updateValue(silent);
            setTimeout(function () { self._cleanEvent(mins,'slideEnd'); }, 0);
        });

        mins.setValue(min, skipAnim, force);
    },

    /**
     * Set the max thumb position to a new value.
     * @method setMaxValue
     * @param max {int} Pixel offset for max thumb
     * @param skipAnim {boolean} (optional) Set to true to skip thumb animation.
     * Default false
     * @param force {boolean} (optional) ignore the locked setting and set
     * value anyway. Default false
     * @param silent {boolean} (optional) Set to true to skip firing change
     * events.  Default false
     */
    setMaxValue : function (max, skipAnim, force, silent) {
        var maxs = this.maxSlider,
            self = this;

        this.activeSlider = maxs;

        this._oneTimeCallback(maxs,'slideEnd',function () {
            self.updateValue(silent);
            setTimeout(function () { self._cleanEvent(maxs,'slideEnd'); }, 0);
        });

        maxs.setValue(max, skipAnim, force);
    },

    /**
     * Executed when one of the sliders is moved
     * @method updateValue
     * @param silent {boolean} (optional) Set to true to skip firing change
     * events.  Default false
     * @private
     */
    updateValue: function(silent) {
        var min     = this.minSlider.getValue(),
            max     = this.maxSlider.getValue(),
            changed = false,
            mint,maxt,dim,minConstraint,maxConstraint,thumbInnerWidth;

        if (min != this.minVal || max != this.maxVal) {
            changed = true;

            mint = this.minSlider.thumb;
            maxt = this.maxSlider.thumb;
            dim  = this.isHoriz ? 'x' : 'y';

            thumbInnerWidth = this.minSlider.thumbCenterPoint[dim] +
                              this.maxSlider.thumbCenterPoint[dim];

            minConstraint = Math.max(max-thumbInnerWidth-this.minRange,0);
            maxConstraint = Math.min(-min-thumbInnerWidth-this.minRange,0);

            if (this.isHoriz) {
                minConstraint = Math.min(minConstraint,maxt.rightConstraint);

                mint.setXConstraint(mint.leftConstraint,minConstraint, mint.tickSize);

                maxt.setXConstraint(maxConstraint,maxt.rightConstraint, maxt.tickSize);
            } else {
                minConstraint = Math.min(minConstraint,maxt.bottomConstraint);
                mint.setYConstraint(mint.leftConstraint,minConstraint, mint.tickSize);

                maxt.setYConstraint(maxConstraint,maxt.bottomConstraint, maxt.tickSize);
            }
        }

        this.minVal = min;
        this.maxVal = max;

        if (changed && !silent) {
            this.fireEvent("change", this);
        }
    },

    /**
     * A background click will move the slider thumb nearest to the click.
     * Override if you need different behavior.
     * @method selectActiveSlider
     * @param e {Event} the mousedown event
     * @private
     */
    selectActiveSlider: function(e) {
        var min = this.minSlider,
            max = this.maxSlider,
            minLocked = min.isLocked() || !min.backgroundEnabled,
            maxLocked = max.isLocked() || !min.backgroundEnabled,
            Ev  = YAHOO.util.Event,
            d;

        if (minLocked || maxLocked) {
            this.activeSlider = minLocked ? max : min;
        } else {
            if (this.isHoriz) {
                d = Ev.getPageX(e)-min.thumb.initPageX-min.thumbCenterPoint.x;
            } else {
                d = Ev.getPageY(e)-min.thumb.initPageY-min.thumbCenterPoint.y;
            }

            this.activeSlider = d*2 > max.getValue()+min.getValue() ? max : min;
        }
    },

    /**
     * Delegates the onMouseDown to the appropriate Slider
     *
     * @method _handleMouseDown
     * @param e {Event} mouseup event
     * @protected
     */
    _handleMouseDown: function(e) {
        if (!e._handled && !this.minSlider._sliding && !this.maxSlider._sliding) {
            e._handled = true;
            this.selectActiveSlider(e);
            return YW.Slider.prototype.onMouseDown.call(this.activeSlider, e);
        } else {
            return false;
        }
    },

    /**
     * Delegates the onMouseUp to the active Slider
     *
     * @method _handleMouseUp
     * @param e {Event} mouseup event
     * @protected
     */
    _handleMouseUp : function (e) {
        YW.Slider.prototype.onMouseUp.apply(
            this.activeSlider, arguments);
    },

    /**
     * Schedule an event callback that will execute once, then unsubscribe
     * itself.
     * @method _oneTimeCallback
     * @param o {EventProvider} Object to attach the event to
     * @param evt {string} Name of the event
     * @param fn {Function} function to execute once
     * @private
     */
    _oneTimeCallback : function (o,evt,fn) {
        var sub = function () {
            o.unsubscribe(evt, sub);
            fn.apply({},arguments);
        };
        o.subscribe(evt,sub);
    },

    /**
     * Clean up the slideEnd event subscribers array, since each one-time
     * callback will be replaced in the event's subscribers property with
     * null.  This will cause memory bloat and loss of performance.
     * @method _cleanEvent
     * @param o {EventProvider} object housing the CustomEvent
     * @param evt {string} name of the CustomEvent
     * @private
     */
    _cleanEvent : function (o,evt) {
        var ce,i,len,j,subs,newSubs;

        if (o.__yui_events && o.events[evt]) {
            for (i = o.__yui_events.length; i >= 0; --i) {
                if (o.__yui_events[i].type === evt) {
                    ce = o.__yui_events[i];
                    break;
                }
            }
            if (ce) {
                subs    = ce.subscribers;
                newSubs = [];
                j = 0;
                for (i = 0, len = subs.length; i < len; ++i) {
                    if (subs[i]) {
                        newSubs[j++] = subs[i];
                    }
                }
                ce.subscribers = newSubs;
            }
        }
    }

};

YAHOO.lang.augmentProto(DualSlider, YAHOO.util.EventProvider);


/**
 * Factory method for creating a horizontal dual-thumb slider
 * @for YAHOO.widget.Slider
 * @method YAHOO.widget.Slider.getHorizDualSlider
 * @static
 * @param {String} bg the id of the slider's background element
 * @param {String} minthumb the id of the min thumb
 * @param {String} maxthumb the id of the thumb thumb
 * @param {int} range the number of pixels the thumbs can move within
 * @param {int} iTickSize (optional) the element should move this many pixels
 * at a time
 * @param {Array}  initVals (optional) [min,max] Initial thumb placement
 * @return {DualSlider} a horizontal dual-thumb slider control
 */
YW.Slider.getHorizDualSlider =
    function (bg, minthumb, maxthumb, range, iTickSize, initVals) {
        var mint = new YW.SliderThumb(minthumb, bg, 0, range, 0, 0, iTickSize),
            maxt = new YW.SliderThumb(maxthumb, bg, 0, range, 0, 0, iTickSize);

        return new DualSlider(
                    new YW.Slider(bg, bg, mint, "horiz"),
                    new YW.Slider(bg, bg, maxt, "horiz"),
                    range, initVals);
};

/**
 * Factory method for creating a vertical dual-thumb slider.
 * @for YAHOO.widget.Slider
 * @method YAHOO.widget.Slider.getVertDualSlider
 * @static
 * @param {String} bg the id of the slider's background element
 * @param {String} minthumb the id of the min thumb
 * @param {String} maxthumb the id of the thumb thumb
 * @param {int} range the number of pixels the thumbs can move within
 * @param {int} iTickSize (optional) the element should move this many pixels
 * at a time
 * @param {Array}  initVals (optional) [min,max] Initial thumb placement
 * @return {DualSlider} a vertical dual-thumb slider control
 */
YW.Slider.getVertDualSlider =
    function (bg, minthumb, maxthumb, range, iTickSize, initVals) {
        var mint = new YW.SliderThumb(minthumb, bg, 0, 0, 0, range, iTickSize),
            maxt = new YW.SliderThumb(maxthumb, bg, 0, 0, 0, range, iTickSize);

        return new YW.DualSlider(
                    new YW.Slider(bg, bg, mint, "vert"),
                    new YW.Slider(bg, bg, maxt, "vert"),
                    range, initVals);
};

YAHOO.widget.DualSlider = DualSlider;

})();
YAHOO.register("slider", YAHOO.widget.Slider, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/

/**
 * The LogMsg class defines a single log message.
 *
 * @class LogMsg
 * @constructor
 * @param oConfigs {Object} Object literal of configuration params.
 */
YAHOO.widget.LogMsg = function(oConfigs) {
    /**
     * Log message.
     *
     * @property msg
     * @type String
     */
    this.msg =
    /**
     * Log timestamp.
     *
     * @property time
     * @type Date
     */
    this.time =

    /**
     * Log category.
     *
     * @property category
     * @type String
     */
    this.category =

    /**
     * Log source. The first word passed in as the source argument.
     *
     * @property source
     * @type String
     */
    this.source =

    /**
     * Log source detail. The remainder of the string passed in as the source argument, not
     * including the first word (if any).
     *
     * @property sourceDetail
     * @type String
     */
    this.sourceDetail = null;

    if (oConfigs && (oConfigs.constructor == Object)) {
        for(var param in oConfigs) {
            if (oConfigs.hasOwnProperty(param)) {
                this[param] = oConfigs[param];
            }
        }
    }
};

/**
 * The LogWriter class provides a mechanism to log messages through
 * YAHOO.widget.Logger from a named source.
 *
 * @class LogWriter
 * @constructor
 * @param sSource {String} Source of LogWriter instance.
 */
YAHOO.widget.LogWriter = function(sSource) {
    if(!sSource) {
        YAHOO.log("Could not instantiate LogWriter due to invalid source.",
            "error", "LogWriter");
        return;
    }
    this._source = sSource;
 };


 /**
 * Public accessor to the unique name of the LogWriter instance.
 *
 * @method toString
 * @return {String} Unique name of the LogWriter instance.
 */
YAHOO.widget.LogWriter.prototype.toString = function() {
    return "LogWriter " + this._sSource;
};

/**
 * Logs a message attached to the source of the LogWriter.
 *
 * @method log
 * @param sMsg {String} The log message.
 * @param sCategory {String} Category name.
 */
YAHOO.widget.LogWriter.prototype.log = function(sMsg, sCategory) {
    YAHOO.widget.Logger.log(sMsg, sCategory, this._source);
};

/**
 * Public accessor to get the source name.
 *
 * @method getSource
 * @return {String} The LogWriter source.
 */
YAHOO.widget.LogWriter.prototype.getSource = function() {
    return this._source;
};

/**
 * Public accessor to set the source name.
 *
 * @method setSource
 * @param sSource {String} Source of LogWriter instance.
 */
YAHOO.widget.LogWriter.prototype.setSource = function(sSource) {
    if(!sSource) {
        YAHOO.log("Could not set source due to invalid source.", "error", this.toString());
        return;
    }
    else {
        this._source = sSource;
    }
};


/**
 * Source of the LogWriter instance.
 *
 * @property _source
 * @type String
 * @private
 */
YAHOO.widget.LogWriter.prototype._source = null;



 /**
 * The Logger widget provides a simple way to read or write log messages in
 * JavaScript code. Integration with the YUI Library's debug builds allow
 * implementers to access under-the-hood events, errors, and debugging messages.
 * Output may be read through a LogReader console and/or output to a browser
 * console.
 *
 * @module logger
 * @requires yahoo, event, dom
 * @optional dragdrop
 * @namespace YAHOO.widget
 * @title Logger Widget
 */


if(!YAHOO.widget.Logger) {
    /**
     * The singleton Logger class provides core log management functionality. Saves
     * logs written through the global YAHOO.log function or written by a LogWriter
     * instance. Provides access to logs for reading by a LogReader instance or
     * native browser console such as the Firebug extension to Firefox or Safari's
     * JavaScript console through integration with the console.log() method.
     *
     * @class Logger
     * @static
     */
    YAHOO.widget.Logger = {
        loggerEnabled: true,
        _browserConsoleEnabled: false,
        categories: ["info","warn","error","time","window"],
        sources: ["global"],
        _stack: [], // holds all log msgs
        maxStackEntries: 2500,
        _startTime: new Date().getTime(), // static start timestamp
        _lastTime: null, // timestamp of last logged message
        _windowErrorsHandled: false,
        _origOnWindowError: null
    };

    /**
     * True if Logger is enabled, false otherwise.
     *
     * @property loggerEnabled
     * @type Boolean
     * @static
     * @default true
     */

    /**
     * Array of categories.
     *
     * @property categories
     * @type String[]
     * @static
     * @default ["info","warn","error","time","window"]
     */

    /**
     * Array of sources.
     *
     * @property sources
     * @type String[]
     * @static
     * @default ["global"]
     */

    /**
     * Upper limit on size of internal stack.
     *
     * @property maxStackEntries
     * @type Number
     * @static
     * @default 2500
     */

    /**
     * Internal property to track whether output to browser console is enabled.
     *
     * @property _browserConsoleEnabled
     * @type Boolean
     * @static
     * @default false
     * @private
     */

    /**
     * Array to hold all log messages.
     *
     * @property _stack
     * @type Array
     * @static
     * @private
     */
    /**
     * Static timestamp of Logger initialization.
     *
     * @property _startTime
     * @type Date
     * @static
     * @private
     */
    /**
     * Timestamp of last logged message.
     *
     * @property _lastTime
     * @type Date
     * @static
     * @private
     */
    /**
     * Saves a log message to the stack and fires newLogEvent. If the log message is
     * assigned to an unknown category, creates a new category. If the log message is
     * from an unknown source, creates a new source.  If browser console is enabled,
     * outputs the log message to browser console.
     *
     * @method log
     * @param sMsg {String} The log message.
     * @param sCategory {String} Category of log message, or null.
     * @param sSource {String} Source of LogWriter, or null if global.
     */
    YAHOO.widget.Logger.log = function(sMsg, sCategory, sSource) {
        if(this.loggerEnabled) {
            if(!sCategory) {
                sCategory = "info"; // default category
            }
            else {
                sCategory = sCategory.toLocaleLowerCase();
                if(this._isNewCategory(sCategory)) {
                    this._createNewCategory(sCategory);
                }
            }
            var sClass = "global"; // default source
            var sDetail = null;
            if(sSource) {
                var spaceIndex = sSource.indexOf(" ");
                if(spaceIndex > 0) {
                    sClass = sSource.substring(0,spaceIndex);
                    sDetail = sSource.substring(spaceIndex,sSource.length);
                }
                else {
                    sClass = sSource;
                }
                if(this._isNewSource(sClass)) {
                    this._createNewSource(sClass);
                }
            }

            var timestamp = new Date();
            var logEntry = new YAHOO.widget.LogMsg({
                msg: sMsg,
                time: timestamp,
                category: sCategory,
                source: sClass,
                sourceDetail: sDetail
            });

            var stack = this._stack;
            var maxStackEntries = this.maxStackEntries;
            if(maxStackEntries && !isNaN(maxStackEntries) &&
                (stack.length >= maxStackEntries)) {
                stack.shift();
            }
            stack.push(logEntry);
            this.newLogEvent.fire(logEntry);

            if(this._browserConsoleEnabled) {
                this._printToBrowserConsole(logEntry);
            }
            return true;
        }
        else {
            return false;
        }
    };

    /**
     * Resets internal stack and startTime, enables Logger, and fires logResetEvent.
     *
     * @method reset
     */
    YAHOO.widget.Logger.reset = function() {
        this._stack = [];
        this._startTime = new Date().getTime();
        this.loggerEnabled = true;
        this.log("Logger reset");
        this.logResetEvent.fire();
    };

    /**
     * Public accessor to internal stack of log message objects.
     *
     * @method getStack
     * @return {Object[]} Array of log message objects.
     */
    YAHOO.widget.Logger.getStack = function() {
        return this._stack;
    };

    /**
     * Public accessor to internal start time.
     *
     * @method getStartTime
     * @return {Date} Internal date of when Logger singleton was initialized.
     */
    YAHOO.widget.Logger.getStartTime = function() {
        return this._startTime;
    };

    /**
     * Disables output to the browser's global console.log() function, which is used
     * by the Firebug extension to Firefox as well as Safari.
     *
     * @method disableBrowserConsole
     */
    YAHOO.widget.Logger.disableBrowserConsole = function() {
        YAHOO.log("Logger output to the function console.log() has been disabled.");
        this._browserConsoleEnabled = false;
    };

    /**
     * Enables output to the browser's global console.log() function, which is used
     * by the Firebug extension to Firefox as well as Safari.
     *
     * @method enableBrowserConsole
     */
    YAHOO.widget.Logger.enableBrowserConsole = function() {
        this._browserConsoleEnabled = true;
        YAHOO.log("Logger output to the function console.log() has been enabled.");
    };

    /**
     * Surpresses native JavaScript errors and outputs to console. By default,
     * Logger does not handle JavaScript window error events.
     * NB: Not all browsers support the window.onerror event.
     *
     * @method handleWindowErrors
     */
    YAHOO.widget.Logger.handleWindowErrors = function() {
        if(!YAHOO.widget.Logger._windowErrorsHandled) {
            if(window.error) {
                YAHOO.widget.Logger._origOnWindowError = window.onerror;
            }
            window.onerror = YAHOO.widget.Logger._onWindowError;
            YAHOO.widget.Logger._windowErrorsHandled = true;
            YAHOO.log("Logger handling of window.onerror has been enabled.");
        }
        else {
            YAHOO.log("Logger handling of window.onerror had already been enabled.");
        }
    };

    /**
     * Unsurpresses native JavaScript errors. By default,
     * Logger does not handle JavaScript window error events.
     * NB: Not all browsers support the window.onerror event.
     *
     * @method unhandleWindowErrors
     */
    YAHOO.widget.Logger.unhandleWindowErrors = function() {
        if(YAHOO.widget.Logger._windowErrorsHandled) {
            if(YAHOO.widget.Logger._origOnWindowError) {
                window.onerror = YAHOO.widget.Logger._origOnWindowError;
                YAHOO.widget.Logger._origOnWindowError = null;
            }
            else {
                window.onerror = null;
            }
            YAHOO.widget.Logger._windowErrorsHandled = false;
            YAHOO.log("Logger handling of window.onerror has been disabled.");
        }
        else {
            YAHOO.log("Logger handling of window.onerror had already been disabled.");
        }
    };


     /**
     * Fired when a new category has been created.
     *
     * @event categoryCreateEvent
     * @param sCategory {String} Category name.
     */
    YAHOO.widget.Logger.categoryCreateEvent =
        new YAHOO.util.CustomEvent("categoryCreate", this, true);

     /**
     * Fired when a new source has been named.
     *
     * @event sourceCreateEvent
     * @param sSource {String} Source name.
     */
    YAHOO.widget.Logger.sourceCreateEvent =
        new YAHOO.util.CustomEvent("sourceCreate", this, true);

     /**
     * Fired when a new log message has been created.
     *
     * @event newLogEvent
     * @param sMsg {String} Log message.
     */
    YAHOO.widget.Logger.newLogEvent = new YAHOO.util.CustomEvent("newLog", this, true);

    /**
     * Fired when the Logger has been reset has been created.
     *
     * @event logResetEvent
     */
    YAHOO.widget.Logger.logResetEvent = new YAHOO.util.CustomEvent("logReset", this, true);


    /**
     * Creates a new category of log messages and fires categoryCreateEvent.
     *
     * @method _createNewCategory
     * @param sCategory {String} Category name.
     * @private
     */
    YAHOO.widget.Logger._createNewCategory = function(sCategory) {
        this.categories.push(sCategory);
        this.categoryCreateEvent.fire(sCategory);
    };

    /**
     * Checks to see if a category has already been created.
     *
     * @method _isNewCategory
     * @param sCategory {String} Category name.
     * @return {Boolean} Returns true if category is unknown, else returns false.
     * @private
     */
    YAHOO.widget.Logger._isNewCategory = function(sCategory) {
        for(var i=0; i < this.categories.length; i++) {
            if(sCategory == this.categories[i]) {
                return false;
            }
        }
        return true;
    };

    /**
     * Creates a new source of log messages and fires sourceCreateEvent.
     *
     * @method _createNewSource
     * @param sSource {String} Source name.
     * @private
     */
    YAHOO.widget.Logger._createNewSource = function(sSource) {
        this.sources.push(sSource);
        this.sourceCreateEvent.fire(sSource);
    };

    /**
     * Checks to see if a source already exists.
     *
     * @method _isNewSource
     * @param sSource {String} Source name.
     * @return {Boolean} Returns true if source is unknown, else returns false.
     * @private
     */
    YAHOO.widget.Logger._isNewSource = function(sSource) {
        if(sSource) {
            for(var i=0; i < this.sources.length; i++) {
                if(sSource == this.sources[i]) {
                    return false;
                }
            }
            return true;
        }
    };

    /**
     * Outputs a log message to global console.log() function.
     *
     * @method _printToBrowserConsole
     * @param oEntry {Object} Log entry object.
     * @private
     */
    YAHOO.widget.Logger._printToBrowserConsole = function(oEntry) {
        if(window.console && console.log) {
            var category = oEntry.category;
            var label = oEntry.category.substring(0,4).toUpperCase();

            var time = oEntry.time;
            var localTime;
            if (time.toLocaleTimeString) {
                localTime  = time.toLocaleTimeString();
            }
            else {
                localTime = time.toString();
            }

            var msecs = time.getTime();
            var elapsedTime = (YAHOO.widget.Logger._lastTime) ?
                (msecs - YAHOO.widget.Logger._lastTime) : 0;
            YAHOO.widget.Logger._lastTime = msecs;

            var output =
                localTime + " (" +
                elapsedTime + "ms): " +
                oEntry.source + ": ";

            if (YAHOO.env.ua.webkit) {
                output += oEntry.msg;
            }

            console.log(output, oEntry.msg);
        }
    };


    /**
     * Handles logging of messages due to window error events.
     *
     * @method _onWindowError
     * @param sMsg {String} The error message.
     * @param sUrl {String} URL of the error.
     * @param sLine {String} Line number of the error.
     * @private
     */
    YAHOO.widget.Logger._onWindowError = function(sMsg,sUrl,sLine) {
        try {
            YAHOO.widget.Logger.log(sMsg+' ('+sUrl+', line '+sLine+')', "window");
            if(YAHOO.widget.Logger._origOnWindowError) {
                YAHOO.widget.Logger._origOnWindowError();
            }
        }
        catch(e) {
            return false;
        }
    };


    YAHOO.widget.Logger.log("Logger initialized");
}

(function () {
var Logger = YAHOO.widget.Logger,
    u      = YAHOO.util,
    Dom    = u.Dom,
    Event  = u.Event,
    d      = document;

function make(el,props) {
    el = d.createElement(el);
    if (props) {
        for (var p in props) {
            if (props.hasOwnProperty(p)) {
                el[p] = props[p];
            }
        }
    }
    return el;
}

/**
 * The LogReader class provides UI to read messages logged to YAHOO.widget.Logger.
 *
 * @class LogReader
 * @constructor
 * @param elContainer {HTMLElement} (optional) DOM element reference of an existing DIV.
 * @param elContainer {String} (optional) String ID of an existing DIV.
 * @param oConfigs {Object} (optional) Object literal of configuration params.
 */
function LogReader(elContainer, oConfigs) {
    this._sName = LogReader._index;
    LogReader._index++;

    this._init.apply(this,arguments);

    /**
     * Render the LogReader immediately upon instantiation.  If set to false,
     * you must call myLogReader.render() to generate the UI.
     *
     * @property autoRender
     * @type {Boolean}
     * @default true
     */
    if (this.autoRender !== false) {
        this.render();
    }
}

YAHOO.lang.augmentObject(LogReader, {
    /**
     * Internal class member to index multiple LogReader instances.
     *
     * @property _memberName
     * @static
     * @type Number
     * @default 0
     * @private
     */
    _index : 0,

    /**
     * Node template for the log entries
     * @property ENTRY_TEMPLATE
     * @static
     * @type {HTMLElement}
     * @default <code>pre</code> element with class yui-log-entry
     */
    ENTRY_TEMPLATE : (function () {
        return make('pre',{ className: 'yui-log-entry' });
    })(),

    /**
     * Template used for innerHTML of verbose entry output.
     * @property VERBOSE_TEMPLATE
     * @static
     * @default "&lt;p>&lt;span class='{category}'>{label}&lt;/span>{totalTime}ms (+{elapsedTime}) {localTime}:&lt;/p>&lt;p>{sourceAndDetail}&lt;/p>&lt;p>{message}&lt;/p>"
     */
    VERBOSE_TEMPLATE : "<p><span class='{category}'>{label}</span> {totalTime}ms (+{elapsedTime}) {localTime}:</p><p>{sourceAndDetail}</p><p>{message}</p>",

    /**
     * Template used for innerHTML of compact entry output.
     * @property BASIC_TEMPLATE
     * @static
     * @default "&lt;p>&lt;span class='{category}'>{label}&lt;/span>{totalTime}ms (+{elapsedTime}) {localTime}: {sourceAndDetail}: {message}&lt;/p>"
     */
    BASIC_TEMPLATE : "<p><span class='{category}'>{label}</span> {totalTime}ms (+{elapsedTime}) {localTime}: {sourceAndDetail}: {message}</p>"
});


LogReader.prototype = {
    /**
     * Whether or not LogReader is enabled to output log messages.
     *
     * @property logReaderEnabled
     * @type Boolean
     * @default true
     */
    logReaderEnabled : true,

    /**
     * Public member to access CSS width of the LogReader container.
     *
     * @property width
     * @type String
     */
    width : null,

    /**
     * Public member to access CSS height of the LogReader container.
     *
     * @property height
     * @type String
     */
    height : null,

    /**
     * Public member to access CSS top position of the LogReader container.
     *
     * @property top
     * @type String
     */
    top : null,

    /**
     * Public member to access CSS left position of the LogReader container.
     *
     * @property left
     * @type String
     */
    left : null,

    /**
     * Public member to access CSS right position of the LogReader container.
     *
     * @property right
     * @type String
     */
    right : null,

    /**
     * Public member to access CSS bottom position of the LogReader container.
     *
     * @property bottom
     * @type String
     */
    bottom : null,

    /**
     * Public member to access CSS font size of the LogReader container.
     *
     * @property fontSize
     * @type String
     */
    fontSize : null,

    /**
     * Whether or not the footer UI is enabled for the LogReader.
     *
     * @property footerEnabled
     * @type Boolean
     * @default true
     */
    footerEnabled : true,

    /**
     * Whether or not output is verbose (more readable). Setting to true will make
     * output more compact (less readable).
     *
     * @property verboseOutput
     * @type Boolean
     * @default true
     */
    verboseOutput : true,

    /**
     * Custom output format for log messages.  Defaults to null, which falls
     * back to verboseOutput param deciding between LogReader.VERBOSE_TEMPLATE
     * and LogReader.BASIC_TEMPLATE.  Use bracketed place holders to mark where
     * message info should go.  Available place holder names include:
     * <ul>
     *  <li>category</li>
     *  <li>label</li>
     *  <li>sourceAndDetail</li>
     *  <li>message</li>
     *  <li>localTime</li>
     *  <li>elapsedTime</li>
     *  <li>totalTime</li>
     * </ul>
     *
     * @property entryFormat
     * @type String
     * @default null
     */
    entryFormat : null,

    /**
     * Whether or not newest message is printed on top.
     *
     * @property newestOnTop
     * @type Boolean
     */
    newestOnTop : true,

    /**
     * Output timeout buffer in milliseconds.
     *
     * @property outputBuffer
     * @type Number
     * @default 100
     */
    outputBuffer : 100,

    /**
     * Maximum number of messages a LogReader console will display.
     *
     * @property thresholdMax
     * @type Number
     * @default 500
     */
    thresholdMax : 500,

    /**
     * When a LogReader console reaches its thresholdMax, it will clear out messages
     * and print out the latest thresholdMin number of messages.
     *
     * @property thresholdMin
     * @type Number
     * @default 100
     */
    thresholdMin : 100,

    /**
     * True when LogReader is in a collapsed state, false otherwise.
     *
     * @property isCollapsed
     * @type Boolean
     * @default false
     */
    isCollapsed : false,

    /**
     * True when LogReader is in a paused state, false otherwise.
     *
     * @property isPaused
     * @type Boolean
     * @default false
     */
    isPaused : false,

    /**
     * Enables draggable LogReader if DragDrop Utility is present.
     *
     * @property draggable
     * @type Boolean
     * @default true
     */
    draggable : true,


     /**
     * Public accessor to the unique name of the LogReader instance.
     *
     * @method toString
     * @return {String} Unique name of the LogReader instance.
     */
    toString : function() {
        return "LogReader instance" + this._sName;
    },
    /**
     * Pauses output of log messages. While paused, log messages are not lost, but
     * get saved to a buffer and then output upon resume of LogReader.
     *
     * @method pause
     */
    pause : function() {
        this.isPaused = true;
        this._timeout = null;
        this.logReaderEnabled = false;
        if (this._btnPause) {
            this._btnPause.value = "Resume";
        }
    },

    /**
     * Resumes output of log messages, including outputting any log messages that
     * have been saved to buffer while paused.
     *
     * @method resume
     */
    resume : function() {
        this.isPaused = false;
        this.logReaderEnabled = true;
        this._printBuffer();
        if (this._btnPause) {
            this._btnPause.value = "Pause";
        }
    },

    /**
     * Adds the UI to the DOM, attaches event listeners, and bootstraps initial
     * UI state.
     *
     * @method render
     */
    render : function () {
        if (this.rendered) {
            return;
        }

        this._initContainerEl();

        this._initHeaderEl();
        this._initConsoleEl();
        this._initFooterEl();

        this._initCategories();
        this._initSources();

        this._initDragDrop();

        Logger.newLogEvent.subscribe(this._onNewLog, this);
        Logger.logResetEvent.subscribe(this._onReset, this);

        Logger.categoryCreateEvent.subscribe(this._onCategoryCreate, this);
        Logger.sourceCreateEvent.subscribe(this._onSourceCreate, this);

        this.rendered = true;

        this._filterLogs();
    },

    /**
     * Removes the UI from the DOM entirely and detaches all event listeners.
     * Implementers should note that Logger will still accumulate messages.
     *
     * @method destroy
     */
    destroy : function () {
        Event.purgeElement(this._elContainer,true);
        this._elContainer.innerHTML = '';
        this._elContainer.parentNode.removeChild(this._elContainer);

        this.rendered = false;
    },

    /**
     * Hides UI of LogReader. Logging functionality is not disrupted.
     *
     * @method hide
     */
    hide : function() {
        this._elContainer.style.display = "none";
    },

    /**
     * Shows UI of LogReader. Logging functionality is not disrupted.
     *
     * @method show
     */
    show : function() {
        this._elContainer.style.display = "block";
    },

    /**
     * Collapses UI of LogReader. Logging functionality is not disrupted.
     *
     * @method collapse
     */
    collapse : function() {
        this._elConsole.style.display = "none";
        if(this._elFt) {
            this._elFt.style.display = "none";
        }
        this._btnCollapse.value = "Expand";
        this.isCollapsed = true;
    },

    /**
     * Expands UI of LogReader. Logging functionality is not disrupted.
     *
     * @method expand
     */
    expand : function() {
        this._elConsole.style.display = "block";
        if(this._elFt) {
            this._elFt.style.display = "block";
        }
        this._btnCollapse.value = "Collapse";
        this.isCollapsed = false;
    },

    /**
     * Returns related checkbox element for given filter (i.e., category or source).
     *
     * @method getCheckbox
     * @param {String} Category or source name.
     * @return {Array} Array of all filter checkboxes.
     */
    getCheckbox : function(filter) {
        return this._filterCheckboxes[filter];
    },

    /**
     * Returns array of enabled categories.
     *
     * @method getCategories
     * @return {String[]} Array of enabled categories.
     */
    getCategories : function() {
        return this._categoryFilters;
    },

    /**
     * Shows log messages associated with given category.
     *
     * @method showCategory
     * @param {String} Category name.
     */
    showCategory : function(sCategory) {
        var filtersArray = this._categoryFilters;
        if(filtersArray.indexOf) {
             if(filtersArray.indexOf(sCategory) >  -1) {
                return;
            }
        }
        else {
            for(var i=0; i<filtersArray.length; i++) {
               if(filtersArray[i] === sCategory){
                    return;
                }
            }
        }

        this._categoryFilters.push(sCategory);
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sCategory);
        if(elCheckbox) {
            elCheckbox.checked = true;
        }
    },

    /**
     * Hides log messages associated with given category.
     *
     * @method hideCategory
     * @param {String} Category name.
     */
    hideCategory : function(sCategory) {
        var filtersArray = this._categoryFilters;
        for(var i=0; i<filtersArray.length; i++) {
            if(sCategory == filtersArray[i]) {
                filtersArray.splice(i, 1);
                break;
            }
        }
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sCategory);
        if(elCheckbox) {
            elCheckbox.checked = false;
        }
    },

    /**
     * Returns array of enabled sources.
     *
     * @method getSources
     * @return {Array} Array of enabled sources.
     */
    getSources : function() {
        return this._sourceFilters;
    },

    /**
     * Shows log messages associated with given source.
     *
     * @method showSource
     * @param {String} Source name.
     */
    showSource : function(sSource) {
        var filtersArray = this._sourceFilters;
        if(filtersArray.indexOf) {
             if(filtersArray.indexOf(sSource) >  -1) {
                return;
            }
        }
        else {
            for(var i=0; i<filtersArray.length; i++) {
               if(sSource == filtersArray[i]){
                    return;
                }
            }
        }
        filtersArray.push(sSource);
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sSource);
        if(elCheckbox) {
            elCheckbox.checked = true;
        }
    },

    /**
     * Hides log messages associated with given source.
     *
     * @method hideSource
     * @param {String} Source name.
     */
    hideSource : function(sSource) {
        var filtersArray = this._sourceFilters;
        for(var i=0; i<filtersArray.length; i++) {
            if(sSource == filtersArray[i]) {
                filtersArray.splice(i, 1);
                break;
            }
        }
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sSource);
        if(elCheckbox) {
            elCheckbox.checked = false;
        }
    },

    /**
     * Does not delete any log messages, but clears all printed log messages from
     * the console. Log messages will be printed out again if user re-filters. The
     * static method YAHOO.widget.Logger.reset() should be called in order to
     * actually delete log messages.
     *
     * @method clearConsole
     */
    clearConsole : function() {
        this._timeout = null;
        this._buffer = [];
        this._consoleMsgCount = 0;

        var elConsole = this._elConsole;
        elConsole.innerHTML = '';
    },

    /**
     * Updates title to given string.
     *
     * @method setTitle
     * @param sTitle {String} New title.
     */
    setTitle : function(sTitle) {
        this._title.innerHTML = this.html2Text(sTitle);
    },

    /**
     * Gets timestamp of the last log.
     *
     * @method getLastTime
     * @return {Date} Timestamp of the last log.
     */
    getLastTime : function() {
        return this._lastTime;
    },

    formatMsg : function (entry) {
        var entryFormat = this.entryFormat || (this.verboseOutput ?
                          LogReader.VERBOSE_TEMPLATE : LogReader.BASIC_TEMPLATE),
            info        = {
                category : entry.category,

                label : entry.category.substring(0,4).toUpperCase(),

                sourceAndDetail : entry.sourceDetail ?
                                  entry.source + " " + entry.sourceDetail :
                                  entry.source,

                message : this.html2Text(entry.msg || entry.message || '')
            };

        if (entry.time && entry.time.getTime) {
            info.localTime = entry.time.toLocaleTimeString ?
                             entry.time.toLocaleTimeString() :
                             entry.time.toString();

            info.elapsedTime = entry.time.getTime() - this.getLastTime();

            info.totalTime = entry.time.getTime() - Logger.getStartTime();
        }

        var msg = LogReader.ENTRY_TEMPLATE.cloneNode(true);
        if (this.verboseOutput) {
            msg.className += ' yui-log-verbose';
        }

        msg.innerHTML = entryFormat.replace(/\{(\w+)\}/g,
            function (x, placeholder) {
                return (placeholder in info) ? info[placeholder] : '';
            });

        return msg;
    },

    /**
     * Converts input chars "<", ">", and "&" to HTML entities.
     *
     * @method html2Text
     * @param sHtml {String} String to convert.
     * @private
     */
    html2Text : function(sHtml) {
        if(sHtml) {
            sHtml += "";
            return sHtml.replace(/&/g, "&#38;").
                         replace(/</g, "&#60;").
                         replace(/>/g, "&#62;");
        }
        return "";
    },


    /**
     * Name of LogReader instance.
     *
     * @property _sName
     * @type String
     * @private
     */
    _sName : null,

    /**
     * A class member shared by all LogReaders if a container needs to be
     * created during instantiation. Will be null if a container element never needs to
     * be created on the fly, such as when the implementer passes in their own element.
     *
     * @property _elDefaultContainer
     * @type HTMLElement
     * @private
     */

    /**
     * Buffer of log message objects for batch output.
     *
     * @property _buffer
     * @type Object[]
     * @private
     */
    _buffer : null,

    /**
     * Number of log messages output to console.
     *
     * @property _consoleMsgCount
     * @type Number
     * @default 0
     * @private
     */
    _consoleMsgCount : 0,

    /**
     * Date of last output log message.
     *
     * @property _lastTime
     * @type Date
     * @private
     */
    _lastTime : null,

    /**
     * Batched output timeout ID.
     *
     * @property _timeout
     * @type Number
     * @private
     */
    _timeout : null,

    /**
     * Hash of filters and their related checkbox elements.
     *
     * @property _filterCheckboxes
     * @type Object
     * @private
     */
    _filterCheckboxes : null,

    /**
     * Array of filters for log message categories.
     *
     * @property _categoryFilters
     * @type String[]
     * @private
     */
    _categoryFilters : null,

    /**
     * Array of filters for log message sources.
     *
     * @property _sourceFilters
     * @type String[]
     * @private
     */
    _sourceFilters : null,

    /**
     * LogReader container element.
     *
     * @property _elContainer
     * @type HTMLElement
     * @private
     */
    _elContainer : null,

    /**
     * LogReader header element.
     *
     * @property _elHd
     * @type HTMLElement
     * @private
     */
    _elHd : null,

    /**
     * LogReader collapse element.
     *
     * @property _elCollapse
     * @type HTMLElement
     * @private
     */
    _elCollapse : null,

    /**
     * LogReader collapse button element.
     *
     * @property _btnCollapse
     * @type HTMLElement
     * @private
     */
    _btnCollapse : null,

    /**
     * LogReader title header element.
     *
     * @property _title
     * @type HTMLElement
     * @private
     */
    _title : null,

    /**
     * LogReader console element.
     *
     * @property _elConsole
     * @type HTMLElement
     * @private
     */
    _elConsole : null,

    /**
     * LogReader footer element.
     *
     * @property _elFt
     * @type HTMLElement
     * @private
     */
    _elFt : null,

    /**
     * LogReader buttons container element.
     *
     * @property _elBtns
     * @type HTMLElement
     * @private
     */
    _elBtns : null,

    /**
     * Container element for LogReader category filter checkboxes.
     *
     * @property _elCategoryFilters
     * @type HTMLElement
     * @private
     */
    _elCategoryFilters : null,

    /**
     * Container element for LogReader source filter checkboxes.
     *
     * @property _elSourceFilters
     * @type HTMLElement
     * @private
     */
    _elSourceFilters : null,

    /**
     * LogReader pause button element.
     *
     * @property _btnPause
     * @type HTMLElement
     * @private
     */
    _btnPause : null,

    /**
     * Clear button element.
     *
     * @property _btnClear
     * @type HTMLElement
     * @private
     */
    _btnClear : null,


    /**
     * Initializes the instance's message buffer, start time, etc
     *
     * @method _init
     * @param container {String|HTMLElement} (optional) the render target
     * @param config {Object} (optional) instance configuration
     * @protected
     */
    _init : function (container, config) {
        this._buffer = []; // output buffer
        this._filterCheckboxes = {}; // pointers to checkboxes
        this._lastTime = Logger.getStartTime(); // timestamp of last log message to console

        if (config && (config.constructor == Object)) {
            for(var param in config) {
                if (config.hasOwnProperty(param)) {
                    this[param] = config[param];
                }
            }
        }

        this._elContainer = Dom.get(container);

        YAHOO.log("LogReader initialized", null, this.toString());
    },

    /**
     * Initializes the primary container element.
     *
     * @method _initContainerEl
     * @private
     */
    _initContainerEl : function() {

        if(!this._elContainer || !/div$/i.test(this._elContainer.tagName)) {
            this._elContainer = d.body.insertBefore(make("div"),d.body.firstChild);
            Dom.addClass(this._elContainer,"yui-log-container");
        }

        Dom.addClass(this._elContainer,"yui-log");

        var style = this._elContainer.style,
            styleProps = ['width','right','top','fontSize'],
            prop,i;

        for (i = styleProps.length - 1; i >= 0; --i) {
            prop = styleProps[i];
            if (this[prop]){
                style[prop] = this[prop];
            }
        }

        if(this.left) {
            style.left  = this.left;
            style.right = "auto";
        }
        if(this.bottom) {
            style.bottom = this.bottom;
            style.top    = "auto";
        }

        if (YAHOO.env.ua.opera) {
            d.body.style += '';
        }

    },

    /**
     * Initializes the header element.
     *
     * @method _initHeaderEl
     * @private
     */
    _initHeaderEl : function() {
        if(this._elHd) {
            Event.purgeElement(this._elHd, true);

            this._elHd.innerHTML = "";
        }

        this._elHd = make("div",{
            id: 'yui-log-hd' + this._sName,
            className: "yui-log-hd"
        });

        this._elCollapse = make("div",{ className: 'yui-log-btns' });

        this._btnCollapse = make("input",{
            type: 'button',
            className: 'yui-log-button',
            value: 'Collapse'
        });
        Event.on(this._btnCollapse,'click',this._onClickCollapseBtn,this);


        this._title = make("h4",{ innerHTML : "Logger Console" });

        this._elCollapse.appendChild(this._btnCollapse);
        this._elHd.appendChild(this._elCollapse);
        this._elHd.appendChild(this._title);
        this._elContainer.appendChild(this._elHd);
    },

    /**
     * Initializes the console element.
     *
     * @method _initConsoleEl
     * @private
     */
    _initConsoleEl : function() {
        if(this._elConsole) {
            Event.purgeElement(this._elConsole, true);

            this._elConsole.innerHTML = "";
        }

        this._elConsole = make("div", { className: "yui-log-bd" });

        if(this.height) {
            this._elConsole.style.height = this.height;
        }

        this._elContainer.appendChild(this._elConsole);
    },

    /**
     * Initializes the footer element.
     *
     * @method _initFooterEl
     * @private
     */
    _initFooterEl : function() {
        if(this.footerEnabled) {
            if(this._elFt) {
                Event.purgeElement(this._elFt, true);

                this._elFt.innerHTML = "";
            }

            this._elFt = make("div",{ className: "yui-log-ft" });
            this._elBtns = make("div", { className: "yui-log-btns" });
            this._btnPause = make("input", {
                type: "button",
                className: "yui-log-button",
                value: "Pause"
            });

            Event.on(this._btnPause,'click',this._onClickPauseBtn,this);

            this._btnClear = make("input", {
                type: "button",
                className: "yui-log-button",
                value: "Clear"
            });

            Event.on(this._btnClear,'click',this._onClickClearBtn,this);

            this._elCategoryFilters = make("div", { className: "yui-log-categoryfilters" });
            this._elSourceFilters = make("div", { className: "yui-log-sourcefilters" });

            this._elBtns.appendChild(this._btnPause);
            this._elBtns.appendChild(this._btnClear);
            this._elFt.appendChild(this._elBtns);
            this._elFt.appendChild(this._elCategoryFilters);
            this._elFt.appendChild(this._elSourceFilters);
            this._elContainer.appendChild(this._elFt);
        }
    },

    /**
     * Initializes Drag and Drop on the header element.
     *
     * @method _initDragDrop
     * @private
     */
    _initDragDrop : function() {
        if(u.DD && this.draggable && this._elHd) {
            var ylog_dd = new u.DD(this._elContainer);
            ylog_dd.setHandleElId(this._elHd.id);
            this._elHd.style.cursor = "move";
        }
    },

    /**
     * Initializes category filters.
     *
     * @method _initCategories
     * @private
     */
    _initCategories : function() {
        this._categoryFilters = [];
        var aInitialCategories = Logger.categories;

        for(var j=0; j < aInitialCategories.length; j++) {
            var sCategory = aInitialCategories[j];

            this._categoryFilters.push(sCategory);

            if(this._elCategoryFilters) {
                this._createCategoryCheckbox(sCategory);
            }
        }
    },

    /**
     * Initializes source filters.
     *
     * @method _initSources
     * @private
     */
    _initSources : function() {
        this._sourceFilters = [];
        var aInitialSources = Logger.sources;

        for(var j=0; j < aInitialSources.length; j++) {
            var sSource = aInitialSources[j];

            this._sourceFilters.push(sSource);

            if(this._elSourceFilters) {
                this._createSourceCheckbox(sSource);
            }
        }
    },

    /**
     * Creates the UI for a category filter in the LogReader footer element.
     *
     * @method _createCategoryCheckbox
     * @param sCategory {String} Category name.
     * @private
     */
    _createCategoryCheckbox : function(sCategory) {
        if(this._elFt) {
            var filter = make("span",{ className: "yui-log-filtergrp" }),
                check  = make("input", {
                    id: "yui-log-filter-" + sCategory + this._sName,
                    className: "yui-log-filter-" + sCategory,
                    type: "checkbox",
                    category: sCategory
                }),
                label  = make("label", {
                    htmlFor: check.id,
                    className: sCategory,
                    innerHTML: sCategory
                });


            Event.on(check,'click',this._onCheckCategory,this);

            this._filterCheckboxes[sCategory] = check;

            filter.appendChild(check);
            filter.appendChild(label);
            this._elCategoryFilters.appendChild(filter);
            check.checked = true;
        }
    },

    /**
     * Creates a checkbox in the LogReader footer element to filter by source.
     *
     * @method _createSourceCheckbox
     * @param sSource {String} Source name.
     * @private
     */
    _createSourceCheckbox : function(sSource) {
        if(this._elFt) {
            var filter = make("span",{ className: "yui-log-filtergrp" }),
                check  = make("input", {
                    id: "yui-log-filter-" + sSource + this._sName,
                    className: "yui-log-filter-" + sSource,
                    type: "checkbox",
                    source: sSource
                }),
                label  = make("label", {
                    htmlFor: check.id,
                    className: sSource,
                    innerHTML: sSource
                });


            Event.on(check,'click',this._onCheckSource,this);

            this._filterCheckboxes[sSource] = check;

            filter.appendChild(check);
            filter.appendChild(label);
            this._elSourceFilters.appendChild(filter);
            check.checked = true;
        }
    },

    /**
     * Reprints all log messages in the stack through filters.
     *
     * @method _filterLogs
     * @private
     */
    _filterLogs : function() {
        if (this._elConsole !== null) {
            this.clearConsole();
            this._printToConsole(Logger.getStack());
        }
    },

    /**
     * Sends buffer of log messages to output and clears buffer.
     *
     * @method _printBuffer
     * @private
     */
    _printBuffer : function() {
        this._timeout = null;

        if(this._elConsole !== null) {
            var thresholdMax = this.thresholdMax;
            thresholdMax = (thresholdMax && !isNaN(thresholdMax)) ? thresholdMax : 500;
            if(this._consoleMsgCount < thresholdMax) {
                var entries = [];
                for (var i=0; i<this._buffer.length; i++) {
                    entries[i] = this._buffer[i];
                }
                this._buffer = [];
                this._printToConsole(entries);
            }
            else {
                this._filterLogs();
            }

            if(!this.newestOnTop) {
                this._elConsole.scrollTop = this._elConsole.scrollHeight;
            }
        }
    },

    /**
     * Cycles through an array of log messages, and outputs each one to the console
     * if its category has not been filtered out.
     *
     * @method _printToConsole
     * @param aEntries {Object[]} Array of LogMsg objects to output to console.
     * @private
     */
    _printToConsole : function(aEntries) {
        var entriesLen         = aEntries.length,
            df                 = d.createDocumentFragment(),
            msgHTML            = [],
            thresholdMin       = this.thresholdMin,
            sourceFiltersLen   = this._sourceFilters.length,
            categoryFiltersLen = this._categoryFilters.length,
            entriesStartIndex,
            i, j, msg, before;

        if(isNaN(thresholdMin) || (thresholdMin > this.thresholdMax)) {
            thresholdMin = 0;
        }
        entriesStartIndex = (entriesLen > thresholdMin) ? (entriesLen - thresholdMin) : 0;

        for(i=entriesStartIndex; i<entriesLen; i++) {
            var okToPrint = false,
                okToFilterCats = false,
                entry = aEntries[i],
                source = entry.source,
                category = entry.category;

            for(j=0; j<sourceFiltersLen; j++) {
                if(source == this._sourceFilters[j]) {
                    okToFilterCats = true;
                    break;
                }
            }
            if(okToFilterCats) {
                for(j=0; j<categoryFiltersLen; j++) {
                    if(category == this._categoryFilters[j]) {
                        okToPrint = true;
                        break;
                    }
                }
            }
            if(okToPrint) {
                if (this._consoleMsgCount === 0) {
                    this._lastTime = entry.time.getTime();
                }

                msg = this.formatMsg(entry);
                if (typeof msg === 'string') {
                    msgHTML[msgHTML.length] = msg;
                } else {
                    df.insertBefore(msg, this.newestOnTop ?
                        df.firstChild || null : null);
                }
                this._consoleMsgCount++;
                this._lastTime = entry.time.getTime();
            }
        }

        if (msgHTML.length) {
            msgHTML.splice(0,0,this._elConsole.innerHTML);
            this._elConsole.innerHTML = this.newestOnTop ?
                                            msgHTML.reverse().join('') :
                                            msgHTML.join('');
        } else if (df.firstChild) {
            this._elConsole.insertBefore(df, this.newestOnTop ?
                        this._elConsole.firstChild || null : null);
        }
    },


    /**
     * Handles Logger's categoryCreateEvent.
     *
     * @method _onCategoryCreate
     * @param sType {String} The event.
     * @param aArgs {Object[]} Data passed from event firer.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onCategoryCreate : function(sType, aArgs, oSelf) {
        var category = aArgs[0];

        oSelf._categoryFilters.push(category);

        if(oSelf._elFt) {
            oSelf._createCategoryCheckbox(category);
        }
    },

    /**
     * Handles Logger's sourceCreateEvent.
     *
     * @method _onSourceCreate
     * @param sType {String} The event.
     * @param aArgs {Object[]} Data passed from event firer.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onSourceCreate : function(sType, aArgs, oSelf) {
        var source = aArgs[0];

        oSelf._sourceFilters.push(source);

        if(oSelf._elFt) {
            oSelf._createSourceCheckbox(source);
        }
    },

    /**
     * Handles check events on the category filter checkboxes.
     *
     * @method _onCheckCategory
     * @param v {HTMLEvent} The click event.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onCheckCategory : function(v, oSelf) {
        var category = this.category;
        if(!this.checked) {
            oSelf.hideCategory(category);
        }
        else {
            oSelf.showCategory(category);
        }
    },

    /**
     * Handles check events on the category filter checkboxes.
     *
     * @method _onCheckSource
     * @param v {HTMLEvent} The click event.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onCheckSource : function(v, oSelf) {
        var source = this.source;
        if(!this.checked) {
            oSelf.hideSource(source);
        }
        else {
            oSelf.showSource(source);
        }
    },

    /**
     * Handles click events on the collapse button.
     *
     * @method _onClickCollapseBtn
     * @param v {HTMLEvent} The click event.
     * @param oSelf {Object} The LogReader instance
     * @private
     */
    _onClickCollapseBtn : function(v, oSelf) {
        if(!oSelf.isCollapsed) {
            oSelf.collapse();
        }
        else {
            oSelf.expand();
        }
    },

    /**
     * Handles click events on the pause button.
     *
     * @method _onClickPauseBtn
     * @param v {HTMLEvent} The click event.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onClickPauseBtn : function(v, oSelf) {
        if(!oSelf.isPaused) {
            oSelf.pause();
        }
        else {
            oSelf.resume();
        }
    },

    /**
     * Handles click events on the clear button.
     *
     * @method _onClickClearBtn
     * @param v {HTMLEvent} The click event.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onClickClearBtn : function(v, oSelf) {
        oSelf.clearConsole();
    },

    /**
     * Handles Logger's newLogEvent.
     *
     * @method _onNewLog
     * @param sType {String} The event.
     * @param aArgs {Object[]} Data passed from event firer.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onNewLog : function(sType, aArgs, oSelf) {
        var logEntry = aArgs[0];
        oSelf._buffer.push(logEntry);

        if (oSelf.logReaderEnabled === true && oSelf._timeout === null) {
            oSelf._timeout = setTimeout(function(){oSelf._printBuffer();}, oSelf.outputBuffer);
        }
    },

    /**
     * Handles Logger's resetEvent.
     *
     * @method _onReset
     * @param sType {String} The event.
     * @param aArgs {Object[]} Data passed from event firer.
     * @param oSelf {Object} The LogReader instance.
     * @private
     */
    _onReset : function(sType, aArgs, oSelf) {
        oSelf._filterLogs();
    }
};

YAHOO.widget.LogReader = LogReader;

})();
YAHOO.register("logger", YAHOO.widget.Logger, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
/**
 * Provides color conversion and validation utils
 * @class YAHOO.util.Color
 * @namespace YAHOO.util
 */
YAHOO.util.Color = function() {

    var ZERO     = "0",
        isArray  = YAHOO.lang.isArray,
        isNumber = YAHOO.lang.isNumber;

    return {

        /**
         * Converts 0-1 to 0-255
         * @method real2dec
         * @param n {float} the number to convert
         * @return {int} a number 0-255
         */
        real2dec: function(n) {
            return Math.min(255, Math.round(n*256));
        },

        /**
         * Converts HSV (h[0-360], s[0-1]), v[0-1] to RGB [255,255,255]
         * @method hsv2rgb
         * @param h {int|[int, float, float]} the hue, or an
         *        array containing all three parameters
         * @param s {float} the saturation
         * @param v {float} the value/brightness
         * @return {[int, int, int]} the red, green, blue values in
         *          decimal.
         */
        hsv2rgb: function(h, s, v) {

            if (isArray(h)) {
                return this.hsv2rgb.call(this, h[0], h[1], h[2]);
            }

            var r, g, b,
                i = Math.floor((h/60)%6),
                f = (h/60)-i,
                p = v*(1-s),
                q = v*(1-f*s),
                t = v*(1-(1-f)*s),
                fn;

            switch (i) {
                case 0: r=v; g=t; b=p; break;
                case 1: r=q; g=v; b=p; break;
                case 2: r=p; g=v; b=t; break;
                case 3: r=p; g=q; b=v; break;
                case 4: r=t; g=p; b=v; break;
                case 5: r=v; g=p; b=q; break;
            }

            fn=this.real2dec;

            return [fn(r), fn(g), fn(b)];
        },

        /**
         * Converts to RGB [255,255,255] to HSV (h[0-360], s[0-1]), v[0-1]
         * @method rgb2hsv
         * @param r {int|[int, int, int]} the red value, or an
         *        array containing all three parameters
         * @param g {int} the green value
         * @param b {int} the blue value
         * @return {[int, float, float]} the value converted to hsv
         */
        rgb2hsv: function(r, g, b) {

            if (isArray(r)) {
                return this.rgb2hsv.apply(this, r);
            }

            r /= 255;
            g /= 255;
            b /= 255;

            var h,s,
                min = Math.min(Math.min(r,g),b),
                max = Math.max(Math.max(r,g),b),
                delta = max-min,
                hsv;

            switch (max) {
                case min: h=0; break;
                case r:   h=60*(g-b)/delta;
                          if (g<b) {
                              h+=360;
                          }
                          break;
                case g:   h=(60*(b-r)/delta)+120; break;
                case b:   h=(60*(r-g)/delta)+240; break;
            }

            s = (max === 0) ? 0 : 1-(min/max);

            hsv = [Math.round(h), s, max];

            return hsv;
        },

        /**
         * Converts decimal rgb values into a hex string
         * 255,255,255 -> FFFFFF
         * @method rgb2hex
         * @param r {int|[int, int, int]} the red value, or an
         *        array containing all three parameters
         * @param g {int} the green value
         * @param b {int} the blue value
         * @return {string} the hex string
         */
        rgb2hex: function(r, g, b) {
            if (isArray(r)) {
                return this.rgb2hex.apply(this, r);
            }

            var f=this.dec2hex;
            return f(r) + f(g) + f(b);
        },

        /**
         * Converts an int 0...255 to hex pair 00...FF
         * @method dec2hex
         * @param n {int} the number to convert
         * @return {string} the hex equivalent
         */
        dec2hex: function(n) {
            n = parseInt(n,10)|0;
            n = (n > 255 || n < 0) ? 0 : n;

            return (ZERO+n.toString(16)).slice(-2).toUpperCase();
        },

        /**
         * Converts a hex pair 00...FF to an int 0...255
         * @method hex2dec
         * @param str {string} the hex pair to convert
         * @return {int} the decimal
         */
        hex2dec: function(str) {
            return parseInt(str,16);
        },

        /**
         * Converts a hex string to rgb
         * @method hex2rgb
         * @param str {string} the hex string
         * @return {[int, int, int]} an array containing the rgb values
         */
        hex2rgb: function(s) {
            var f = this.hex2dec;
            return [f(s.slice(0, 2)), f(s.slice(2, 4)), f(s.slice(4, 6))];
        },

        /**
         * Returns the closest websafe color to the supplied rgb value.
         * @method websafe
         * @param r {int|[int, int, int]} the red value, or an
         *        array containing all three parameters
         * @param g {int} the green value
         * @param b {int} the blue value
         * @return {[int, int, int]} an array containing the closes
         *                           websafe rgb colors.
         */
        websafe: function(r, g, b) {

            if (isArray(r)) {
                return this.websafe.apply(this, r);
            }

            var f = function(v) {
                if (isNumber(v)) {
                    v = Math.min(Math.max(0, v), 255);
                    var i, next;
                    for (i=0; i<256; i=i+51) {
                        next = i+51;
                        if (v >= i && v <= next) {
                            return (v-i > 25) ? next : i;
                        }
                    }
                }

                return v;
            };

            return [f(r), f(g), f(b)];
        }
    };
}();


/**
 * The colorpicker module provides a widget for selecting colors
 * @module colorpicker
 * @requires yahoo, dom, event, element, slider
 */
(function() {

    var _pickercount = 0,
        util   = YAHOO.util,
        lang   = YAHOO.lang,
        Slider = YAHOO.widget.Slider,
        Color  = util.Color,
        Dom    = util.Dom,
        Event  = util.Event,
        sub    = lang.substitute,

        b = "yui-picker";


    /**
     * A widget to select colors
     * @namespace YAHOO.widget
     * @class YAHOO.widget.ColorPicker
     * @extends YAHOO.util.Element
     * @constructor
     * @param {HTMLElement | String | Object} el(optional) The html
     * element that represents the colorpicker, or the attribute object to use.
     * An element will be created if none provided.
     * @param {Object} attr (optional) A key map of the colorpicker's
     * initial attributes.  Ignored if first arg is attributes object.
     */
    function ColorPicker(el, attr) {
        _pickercount = _pickercount + 1;
        attr = attr || {};
        if (arguments.length === 1 && !YAHOO.lang.isString(el) && !el.nodeName) {
            attr = el; // treat first arg as attr object
            el = attr.element || null;
        }

        if (!el && !attr.element) { // create if we dont have one
            el = this._createHostElement(attr);
        }

    	ColorPicker.superclass.constructor.call(this, el, attr);

        this.initPicker();
    }

    YAHOO.extend(ColorPicker, YAHOO.util.Element, {

        /**
         * The element ids used by this control
         * @property ID
         * @final
         */
        ID : {

            /**
             * The id for the "red" form field
             * @property ID.R
             * @type String
             * @final
             * @default yui-picker-r
             */
            R: b + "-r",

            /**
             * The id for the "red" hex pair output
             * @property ID.R_HEX
             * @type String
             * @final
             * @default yui-picker-rhex
             */
            R_HEX: b + "-rhex",

            /**
             * The id for the "green" form field
             * @property ID.G
             * @type String
             * @final
             * @default yui-picker-g
             */
            G: b + "-g",

            /**
             * The id for the "green" hex pair output
             * @property ID.G_HEX
             * @type String
             * @final
             * @default yui-picker-ghex
             */
            G_HEX: b + "-ghex",


            /**
             * The id for the "blue" form field
             * @property ID.B
             * @type String
             * @final
             * @default yui-picker-b
             */
            B: b + "-b",

            /**
             * The id for the "blue" hex pair output
             * @property ID.B_HEX
             * @type String
             * @final
             * @default yui-picker-bhex
             */
            B_HEX: b + "-bhex",

            /**
             * The id for the "hue" form field
             * @property ID.H
             * @type String
             * @final
             * @default yui-picker-h
             */
            H: b + "-h",

            /**
             * The id for the "saturation" form field
             * @property ID.S
             * @type String
             * @final
             * @default yui-picker-s
             */
            S: b + "-s",

            /**
             * The id for the "value" form field
             * @property ID.V
             * @type String
             * @final
             * @default yui-picker-v
             */
            V: b + "-v",

            /**
             * The id for the picker region slider
             * @property ID.PICKER_BG
             * @type String
             * @final
             * @default yui-picker-bg
             */
            PICKER_BG:      b + "-bg",

            /**
             * The id for the picker region thumb
             * @property ID.PICKER_THUMB
             * @type String
             * @final
             * @default yui-picker-thumb
             */
            PICKER_THUMB:   b + "-thumb",

            /**
             * The id for the hue slider
             * @property ID.HUE_BG
             * @type String
             * @final
             * @default yui-picker-hue-bg
             */
            HUE_BG:         b + "-hue-bg",

            /**
             * The id for the hue thumb
             * @property ID.HUE_THUMB
             * @type String
             * @final
             * @default yui-picker-hue-thumb
             */
            HUE_THUMB:      b + "-hue-thumb",

            /**
             * The id for the hex value form field
             * @property ID.HEX
             * @type String
             * @final
             * @default yui-picker-hex
             */
            HEX:            b + "-hex",

            /**
             * The id for the color swatch
             * @property ID.SWATCH
             * @type String
             * @final
             * @default yui-picker-swatch
             */
            SWATCH:         b + "-swatch",

            /**
             * The id for the websafe color swatch
             * @property ID.WEBSAFE_SWATCH
             * @type String
             * @final
             * @default yui-picker-websafe-swatch
             */
            WEBSAFE_SWATCH: b + "-websafe-swatch",

            /**
             * The id for the control details
             * @property ID.CONTROLS
             * @final
             * @default yui-picker-controls
             */
            CONTROLS: b + "-controls",

            /**
             * The id for the rgb controls
             * @property ID.RGB_CONTROLS
             * @final
             * @default yui-picker-rgb-controls
             */
            RGB_CONTROLS: b + "-rgb-controls",

            /**
             * The id for the hsv controls
             * @property ID.HSV_CONTROLS
             * @final
             * @default yui-picker-hsv-controls
             */
            HSV_CONTROLS: b + "-hsv-controls",

            /**
             * The id for the hsv controls
             * @property ID.HEX_CONTROLS
             * @final
             * @default yui-picker-hex-controls
             */
            HEX_CONTROLS: b + "-hex-controls",

            /**
             * The id for the hex summary
             * @property ID.HEX_SUMMARY
             * @final
             * @default yui-picker-hex-summary
             */
            HEX_SUMMARY: b + "-hex-summary",

            /**
             * The id for the controls section header
             * @property ID.CONTROLS_LABEL
             * @final
             * @default yui-picker-controls-label
             */
            CONTROLS_LABEL: b + "-controls-label"
        },

        /**
         * Constants for any script-generated messages.  The values here
         * are the default messages.  They can be updated by providing
         * the complete list to the constructor for the "txt" attribute.
         * @property TXT
         * @final
         */
        TXT : {
            ILLEGAL_HEX: "Illegal hex value entered",
            SHOW_CONTROLS: "Show color details",
            HIDE_CONTROLS: "Hide color details",
            CURRENT_COLOR: "Currently selected color: {rgb}",
            CLOSEST_WEBSAFE: "Closest websafe color: {rgb}. Click to select.",
            R: "R",
            G: "G",
            B: "B",
            H: "H",
            S: "S",
            V: "V",
            HEX: "#",
            DEG: "\u00B0",
            PERCENT: "%"
        },

        /**
         * Constants for the default image locations for img tags that are
         * generated by the control.  They can be modified by passing the
         * complete list to the contructor for the "images" attribute
         * @property IMAGE
         * @final
         */
        IMAGE : {
            PICKER_THUMB: "../../build/colorpicker/assets/picker_thumb.png",
            HUE_THUMB: "../../build/colorpicker/assets/hue_thumb.png"
        },

        /**
         * Constants for the control's default default values
         * @property DEFAULT
         * @final
         */
        DEFAULT : {
            PICKER_SIZE: 180
        },

        /**
         * Constants for the control's configuration attributes
         * @property OPT
         * @final
         */
        OPT : {
            HUE         : "hue",
            SATURATION  : "saturation",
            VALUE       : "value",
            RED     : "red",
            GREEN   : "green",
            BLUE    : "blue",
            HSV     : "hsv",
            RGB     : "rgb",
            WEBSAFE : "websafe",
            HEX     : "hex",
            PICKER_SIZE       : "pickersize",
            SHOW_CONTROLS     : "showcontrols",
            SHOW_RGB_CONTROLS : "showrgbcontrols",
            SHOW_HSV_CONTROLS : "showhsvcontrols",
            SHOW_HEX_CONTROLS : "showhexcontrols",
            SHOW_HEX_SUMMARY  : "showhexsummary",
            SHOW_WEBSAFE      : "showwebsafe",
            CONTAINER         : "container",
            IDS      : "ids",
            ELEMENTS : "elements",
            TXT      : "txt",
            IMAGES   : "images",
            ANIMATE  : "animate"
        },

        /**
         * Flag to allow individual UI updates to forego animation if available.
         * True during construction for initial thumb placement.  Set to false
         * after that.
         *
         * @property skipAnim
         * @type Boolean
         * @default true
         */
        skipAnim : true,

        /**
         * Creates the host element if it doesn't exist
         * @method _createHostElement
         * @protected
         */
        _createHostElement : function () {
            var el = document.createElement('div');

            if (this.CSS.BASE) {
                el.className = this.CSS.BASE;
            }

            return el;
        },

        /**
         * Moves the hue slider into the position dictated by the current state
         * of the control
         * @method _updateHueSlider
         * @protected
         */
        _updateHueSlider : function() {
            var size = this.get(this.OPT.PICKER_SIZE),
                h = this.get(this.OPT.HUE);

            h = size - Math.round(h / 360 * size);

            if (h === size) {
                h = 0;
            }

            this.hueSlider.setValue(h, this.skipAnim);
        },

        /**
         * Moves the picker slider into the position dictated by the current state
         * of the control
         * @method _updatePickerSlider
         * @protected
         */
        _updatePickerSlider : function() {
            var size = this.get(this.OPT.PICKER_SIZE),
                s = this.get(this.OPT.SATURATION),
                v = this.get(this.OPT.VALUE);

            s = Math.round(s * size / 100);
            v = Math.round(size - (v * size / 100));


            this.pickerSlider.setRegionValue(s, v, this.skipAnim);
        },

        /**
         * Moves the sliders into the position dictated by the current state
         * of the control
         * @method _updateSliders
         * @protected
         */
        _updateSliders : function() {
            this._updateHueSlider();
            this._updatePickerSlider();
        },

        /**
         * Sets the control to the specified rgb value and
         * moves the sliders to the proper positions
         * @method setValue
         * @param rgb {[int, int, int]} the rgb value
         * @param silent {boolean} whether or not to fire the change event
         */
        setValue : function(rgb, silent) {
            silent = (silent) || false;
            this.set(this.OPT.RGB, rgb, silent);
            this._updateSliders();
        },

        /**
         * The hue slider
         * @property hueSlider
         * @type YAHOO.widget.Slider
         */
        hueSlider : null,

        /**
         * The picker region
         * @property pickerSlider
         * @type YAHOO.widget.Slider
         */
        pickerSlider : null,

        /**
         * Translates the slider value into hue, int[0,359]
         * @method _getH
         * @protected
         * @return {int} the hue from 0 to 359
         */
        _getH : function() {
            var size = this.get(this.OPT.PICKER_SIZE),
                h = (size - this.hueSlider.getValue()) / size;
            h = Math.round(h*360);
            return (h === 360) ? 0 : h;
        },

        /**
         * Translates the slider value into saturation, int[0,1], left to right
         * @method _getS
         * @protected
         * @return {int} the saturation from 0 to 1
         */
        _getS : function() {
            return this.pickerSlider.getXValue() / this.get(this.OPT.PICKER_SIZE);
        },

        /**
         * Translates the slider value into value/brightness, int[0,1], top
         * to bottom
         * @method _getV
         * @protected
         * @return {int} the value from 0 to 1
         */
        _getV : function() {
            var size = this.get(this.OPT.PICKER_SIZE);
            return (size - this.pickerSlider.getYValue()) / size;
        },

        /**
         * Updates the background of the swatch with the current rbg value.
         * Also updates the websafe swatch to the closest websafe color
         * @method _updateSwatch
         * @protected
         */
        _updateSwatch : function() {
            var rgb = this.get(this.OPT.RGB),
                websafe = this.get(this.OPT.WEBSAFE),
                el = this.getElement(this.ID.SWATCH),
                color = rgb.join(","),
                txt = this.get(this.OPT.TXT);

            Dom.setStyle(el, "background-color", "rgb(" + color  + ")");
            el.title = sub(txt.CURRENT_COLOR, {
                    "rgb": "#" + this.get(this.OPT.HEX)
                });


            el = this.getElement(this.ID.WEBSAFE_SWATCH);
            color = websafe.join(",");

            Dom.setStyle(el, "background-color", "rgb(" + color + ")");
            el.title = sub(txt.CLOSEST_WEBSAFE, {
                    "rgb": "#" + Color.rgb2hex(websafe)
                });

        },

        /**
         * Reads the sliders and converts the values to RGB, updating the
         * internal state for all the individual form fields
         * @method _getValuesFromSliders
         * @protected
         */
        _getValuesFromSliders : function() {
            this.set(this.OPT.RGB, Color.hsv2rgb(this._getH(), this._getS(), this._getV()));
        },

        /**
         * Updates the form field controls with the state data contained
         * in the control.
         * @method _updateFormFields
         * @protected
         */
        _updateFormFields : function() {
            this.getElement(this.ID.H).value = this.get(this.OPT.HUE);
            this.getElement(this.ID.S).value = this.get(this.OPT.SATURATION);
            this.getElement(this.ID.V).value = this.get(this.OPT.VALUE);
            this.getElement(this.ID.R).value = this.get(this.OPT.RED);
            this.getElement(this.ID.R_HEX).innerHTML = Color.dec2hex(this.get(this.OPT.RED));
            this.getElement(this.ID.G).value = this.get(this.OPT.GREEN);
            this.getElement(this.ID.G_HEX).innerHTML = Color.dec2hex(this.get(this.OPT.GREEN));
            this.getElement(this.ID.B).value = this.get(this.OPT.BLUE);
            this.getElement(this.ID.B_HEX).innerHTML = Color.dec2hex(this.get(this.OPT.BLUE));
            this.getElement(this.ID.HEX).value = this.get(this.OPT.HEX);
        },

        /**
         * Event handler for the hue slider.
         * @method _onHueSliderChange
         * @param newOffset {int} pixels from the start position
         * @protected
         */
        _onHueSliderChange : function(newOffset) {

            var h        = this._getH(),
                rgb      = Color.hsv2rgb(h, 1, 1),
                styleDef = "rgb(" + rgb.join(",") + ")";

            this.set(this.OPT.HUE, h, true);

            Dom.setStyle(this.getElement(this.ID.PICKER_BG), "background-color", styleDef);

            if (this.hueSlider.valueChangeSource !== Slider.SOURCE_SET_VALUE) {
                this._getValuesFromSliders();
            }

            this._updateFormFields();
            this._updateSwatch();
        },

        /**
         * Event handler for the picker slider, which controls the
         * saturation and value/brightness.
         * @method _onPickerSliderChange
         * @param newOffset {{x: int, y: int}} x/y pixels from the start position
         * @protected
         */
        _onPickerSliderChange : function(newOffset) {

            var s=this._getS(), v=this._getV();
            this.set(this.OPT.SATURATION, Math.round(s*100), true);
            this.set(this.OPT.VALUE, Math.round(v*100), true);

            if (this.pickerSlider.valueChangeSource !== Slider.SOURCE_SET_VALUE) {
                this._getValuesFromSliders();
            }

            this._updateFormFields();
            this._updateSwatch();
        },


        /**
         * Key map to well-known commands for txt field input
         * @method _getCommand
         * @param e {Event} the keypress or keydown event
         * @return {int} a command code
         * <ul>
         * <li>0 = not a number, letter in range, or special key</li>
         * <li>1 = number</li>
         * <li>2 = a-fA-F</li>
         * <li>3 = increment (up arrow)</li>
         * <li>4 = decrement (down arrow)</li>
         * <li>5 = special key (tab, delete, return, escape, left, right)</li>
         * <li>6 = return</li>
         * </ul>
         * @protected
         */
        _getCommand : function(e) {
            var c = Event.getCharCode(e);


            if (c === 38) { // up arrow
                return 3;
            } else if (c === 13) { // return
                return 6;
            } else if (c === 40) { // down array
                return 4;
            } else if (c >= 48 && c<=57) { // 0-9
                return 1;
            } else if (c >= 97 && c<=102) { // a-f
                return 2;
            } else if (c >= 65 && c<=70) { // A-F
                return 2;
            } else if ("8, 9, 13, 27, 37, 39".indexOf(c) > -1 ||
                       e.ctrlKey || e.metaKey) { // special chars
                return 5;
            } else { // something we probably don't want
                return 0;
            }
        },

        /**
         * Use the value of the text field to update the control
         * @method _useFieldValue
         * @param e {Event} an event
         * @param el {HTMLElement} the field
         * @param prop {string} the key to the linked property
         * @protected
         */
        _useFieldValue : function(e, el, prop) {
            var val = el.value;

            if (prop !== this.OPT.HEX) {
                val = parseInt(val, 10);
            }

            if (val !== this.get(prop)) {
                this.set(prop, val);
            }
        },

        /**
         * Handle keypress on one of the rgb or hsv fields.
         * @method _rgbFieldKeypress
         * @param e {Event} the keypress event
         * @param el {HTMLElement} the field
         * @param prop {string} the key to the linked property
         * @protected
         */
        _rgbFieldKeypress : function(e, el, prop) {
            var command = this._getCommand(e),
                inc = (e.shiftKey) ? 10 : 1;
            switch (command) {
                case 6: // return, update the value
                    this._useFieldValue.apply(this, arguments);
                    break;

                case 3: // up arrow, increment
                    this.set(prop, Math.min(this.get(prop)+inc, 255));
                    this._updateFormFields();
                    break;
                case 4: // down arrow, decrement
                    this.set(prop, Math.max(this.get(prop)-inc, 0));
                    this._updateFormFields();
                    break;

                default:
            }

        },

        /**
         * Handle keydown on the hex field
         * @method _hexFieldKeypress
         * @param e {Event} the keypress event
         * @param el {HTMLElement} the field
         * @param prop {string} the key to the linked property
         * @protected
         */
        _hexFieldKeypress : function(e, el, prop) {
            var command = this._getCommand(e);
            if (command === 6) { // return, update the value
                this._useFieldValue.apply(this, arguments);
            }
        },

        /**
         * Allows numbers and special chars, and by default allows a-f.
         * Used for the hex field keypress handler.
         * @method _hexOnly
         * @param e {Event} the event
         * @param numbersOnly omits a-f if set to true
         * @protected
         * @return {boolean} false if we are canceling the event
         */
        _hexOnly : function(e, numbersOnly) {
            var command = this._getCommand(e);
            switch (command) {
                case 6: // return
                case 5: // special char
                case 1: // number
                    break;
                case 2: // hex char (a-f)
                    if (numbersOnly !== true) {
                        break;
                    }


                default: // prevent alpha and punctuation
                    Event.stopEvent(e);
                    return false;
            }
        },

        /**
         * Allows numbers and special chars only.  Used for the
         * rgb and hsv fields keypress handler.
         * @method _numbersOnly
         * @param e {Event} the event
         * @protected
         * @return {boolean} false if we are canceling the event
         */
        _numbersOnly : function(e) {
            return this._hexOnly(e, true);
        },

        /**
         * Returns the element reference that is saved.  The id can be either
         * the element id, or the key for this id in the "id" config attribute.
         * For instance, the host element id can be obtained by passing its
         * id (default: "yui_picker") or by its key "YUI_PICKER".
         * @param id {string} the element id, or key
         * @return {HTMLElement} a reference to the element
         */
        getElement : function(id) {
            return this.get(this.OPT.ELEMENTS)[this.get(this.OPT.IDS)[id]];
        },

        _createElements : function() {
            var el, child, img, fld, p,
                ids = this.get(this.OPT.IDS),
                txt = this.get(this.OPT.TXT),
                images = this.get(this.OPT.IMAGES),
                Elem = function(type, o) {
                    var n = document.createElement(type);
                    if (o) {
                        lang.augmentObject(n, o, true);
                    }
                    return n;
                },
                RGBElem = function(type, obj) {
                    var o = lang.merge({
                            autocomplete: "off",
                            value: "0",
                            size: 3,
                            maxlength: 3
                        }, obj);

                    o.name = o.id;
                    return new Elem(type, o);
                };

            p = this.get("element");


            el = new Elem("div", {
                id: ids[this.ID.PICKER_BG],
                className: "yui-picker-bg",
                tabIndex: -1,
                hideFocus: true
            });

            child = new Elem("div", {
                id: ids[this.ID.PICKER_THUMB],
                className: "yui-picker-thumb"
            });

            img = new Elem("img", {
                src: images.PICKER_THUMB
            });

            child.appendChild(img);
            el.appendChild(child);
            p.appendChild(el);

            el = new Elem("div", {
                id: ids[this.ID.HUE_BG],
                className: "yui-picker-hue-bg",
                tabIndex: -1,
                hideFocus: true
            });

            child = new Elem("div", {
                id: ids[this.ID.HUE_THUMB],
                className: "yui-picker-hue-thumb"
            });

            img = new Elem("img", {
                src: images.HUE_THUMB
            });

            child.appendChild(img);
            el.appendChild(child);
            p.appendChild(el);



            el = new Elem("div", {
                id: ids[this.ID.CONTROLS],
                className: "yui-picker-controls"
            });

            p.appendChild(el);
            p = el;

                el = new Elem("div", {
                    className: "hd"
                });

                child = new Elem("a", {
                    id: ids[this.ID.CONTROLS_LABEL],
                    href: "#"
                });
                el.appendChild(child);
                p.appendChild(el);

                el = new Elem("div", {
                    className: "bd"
                });

                p.appendChild(el);
                p = el;

                    el = new Elem("ul", {
                        id: ids[this.ID.RGB_CONTROLS],
                        className: "yui-picker-rgb-controls"
                    });

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.R + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.R],
                        className: "yui-picker-r"
                    });

                    child.appendChild(fld);
                    el.appendChild(child);

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.G + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.G],
                        className: "yui-picker-g"
                    });

                    child.appendChild(fld);
                    el.appendChild(child);

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.B + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.B],
                        className: "yui-picker-b"
                    });

                    child.appendChild(fld);
                    el.appendChild(child);

                    p.appendChild(el);

                    el = new Elem("ul", {
                        id: ids[this.ID.HSV_CONTROLS],
                        className: "yui-picker-hsv-controls"
                    });

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.H + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.H],
                        className: "yui-picker-h"
                    });

                    child.appendChild(fld);
                    child.appendChild(document.createTextNode(" " + txt.DEG));

                    el.appendChild(child);

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.S + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.S],
                        className: "yui-picker-s"
                    });

                    child.appendChild(fld);
                    child.appendChild(document.createTextNode(" " + txt.PERCENT));

                    el.appendChild(child);

                    child = new Elem("li");
                    child.appendChild(document.createTextNode(txt.V + " "));

                    fld = new RGBElem("input", {
                        id: ids[this.ID.V],
                        className: "yui-picker-v"
                    });

                    child.appendChild(fld);
                    child.appendChild(document.createTextNode(" " + txt.PERCENT));

                    el.appendChild(child);
                    p.appendChild(el);



                    el = new Elem("ul", {
                        id: ids[this.ID.HEX_SUMMARY],
                        className: "yui-picker-hex_summary"
                    });

                    child = new Elem("li", {
                        id: ids[this.ID.R_HEX]
                    });
                    el.appendChild(child);

                    child = new Elem("li", {
                        id: ids[this.ID.G_HEX]
                    });
                    el.appendChild(child);

                    child = new Elem("li", {
                        id: ids[this.ID.B_HEX]
                    });
                    el.appendChild(child);
                    p.appendChild(el);

                    el = new Elem("div", {
                        id: ids[this.ID.HEX_CONTROLS],
                        className: "yui-picker-hex-controls"
                    });
                    el.appendChild(document.createTextNode(txt.HEX + " "));

                    child = new RGBElem("input", {
                        id: ids[this.ID.HEX],
                        className: "yui-picker-hex",
                        size: 6,
                        maxlength: 6
                    });

                    el.appendChild(child);
                    p.appendChild(el);

                    p = this.get("element");

                    el = new Elem("div", {
                        id: ids[this.ID.SWATCH],
                        className: "yui-picker-swatch"
                    });

                    p.appendChild(el);

                    el = new Elem("div", {
                        id: ids[this.ID.WEBSAFE_SWATCH],
                        className: "yui-picker-websafe-swatch"
                    });

                    p.appendChild(el);

        },

        _attachRGBHSV : function(id, config) {
            Event.on(this.getElement(id), "keydown", function(e, me) {
                    me._rgbFieldKeypress(e, this, config);
                }, this);
            Event.on(this.getElement(id), "keypress", this._numbersOnly, this, true);
            Event.on(this.getElement(id), "blur", function(e, me) {
                    me._useFieldValue(e, this, config);
                }, this);
        },


        /**
         * Updates the rgb attribute with the current state of the r,g,b
         * fields.  This is invoked from change listeners on these
         * attributes to facilitate updating these values from the
         * individual form fields
         * @method _updateRGB
         * @protected
         */
        _updateRGB : function() {
            var rgb = [this.get(this.OPT.RED),
                       this.get(this.OPT.GREEN),
                       this.get(this.OPT.BLUE)];

            this.set(this.OPT.RGB, rgb);

            this._updateSliders();
        },

        /**
         * Creates any missing DOM structure.
         *
         * @method _initElements
         * @protected
         */
        _initElements : function () {
            var o=this.OPT,
                ids = this.get(o.IDS),
                els = this.get(o.ELEMENTS),
                      i, el, id;

            for (i in this.ID) {
                if (lang.hasOwnProperty(this.ID, i)) {
                    ids[this.ID[i]] = ids[i];
                }
            }

            el = Dom.get(ids[this.ID.PICKER_BG]);
            if (!el) {
                this._createElements();
            } else {
            }

            for (i in ids) {
                if (lang.hasOwnProperty(ids, i)) {
                    el = Dom.get(ids[i]);

                    id = Dom.generateId(el);

                    ids[i] = id; // key is WEBSAFE_SWATCH
                    ids[ids[i]] = id; // key is websafe_swatch

                    els[id] = el;
                }
            }

        },

        /**
         * Sets the initial state of the sliders
         * @method initPicker
         */
        initPicker : function () {
            this._initSliders();
            this._bindUI();
            this.syncUI(true);
        },

        /**
         * Creates the Hue and Value/Saturation Sliders.
         *
         * @method _initSliders
         * @protected
         */
        _initSliders : function () {
            var ID = this.ID,
                size = this.get(this.OPT.PICKER_SIZE);


            this.hueSlider = Slider.getVertSlider(
                this.getElement(ID.HUE_BG),
                this.getElement(ID.HUE_THUMB), 0, size);

            this.pickerSlider = Slider.getSliderRegion(
                this.getElement(ID.PICKER_BG),
                this.getElement(ID.PICKER_THUMB), 0, size, 0, size);

            this.set(this.OPT.ANIMATE, this.get(this.OPT.ANIMATE));
        },

        /**
         * Adds event listeners to Sliders and UI elements.  Wires everything
         * up.
         *
         * @method _bindUI
         * @protected
         */
        _bindUI : function () {
            var ID = this.ID,
                O  = this.OPT;

            this.hueSlider.subscribe("change",
                this._onHueSliderChange, this, true);
            this.pickerSlider.subscribe("change",
                this._onPickerSliderChange, this, true);

            Event.on(this.getElement(ID.WEBSAFE_SWATCH), "click", function(e) {
                   this.setValue(this.get(O.WEBSAFE));
               }, this, true);

            Event.on(this.getElement(ID.CONTROLS_LABEL), "click", function(e) {
                   this.set(O.SHOW_CONTROLS, !this.get(O.SHOW_CONTROLS));
                   Event.preventDefault(e);
               }, this, true);

            this._attachRGBHSV(ID.R, O.RED);
            this._attachRGBHSV(ID.G, O.GREEN);
            this._attachRGBHSV(ID.B, O.BLUE);
            this._attachRGBHSV(ID.H, O.HUE);
            this._attachRGBHSV(ID.S, O.SATURATION);
            this._attachRGBHSV(ID.V, O.VALUE);

            Event.on(this.getElement(ID.HEX), "keydown", function(e, me) {
                    me._hexFieldKeypress(e, this, O.HEX);
                }, this);

            Event.on(this.getElement(this.ID.HEX), "keypress",
                this._hexOnly, this,true);
            Event.on(this.getElement(this.ID.HEX), "blur", function(e, me) {
                    me._useFieldValue(e, this, O.HEX);
                }, this);
        },

        /**
         * Wrapper for _updateRGB, but allows setting
         *
         * @method syncUI
         * @param skipAnim {Boolean} Omit Slider animation for this action
         */
        syncUI : function (skipAnim) {
            this.skipAnim = skipAnim;
            this._updateRGB();
            this.skipAnim = false;
        },


        /**
         * Updates the RGB values from the current state of the HSV
         * values.  Executed when the one of the HSV form fields are
         * updated
         * _updateRGBFromHSV
         * @protected
         */
        _updateRGBFromHSV : function() {
            var hsv = [this.get(this.OPT.HUE),
                       this.get(this.OPT.SATURATION)/100,
                       this.get(this.OPT.VALUE)/100],
                rgb = Color.hsv2rgb(hsv);

            this.set(this.OPT.RGB, rgb);

            this._updateSliders();
        },

        /**
         * Parses the hex string to normalize shorthand values, converts
         * the hex value to rgb and updates the rgb attribute (which
         * updates the state for all of the other values)
         * method _updateHex
         * @protected
         */
        _updateHex : function() {

            var hex = this.get(this.OPT.HEX),
                l   = hex.length,
                c,i,rgb;

            if (l === 3) {
                c = hex.split("");
                for (i=0; i<l; i=i+1) {
                    c[i] = c[i] + c[i];
                }

                hex = c.join("");
            }

            if (hex.length !== 6) {
                return false;
            }

            rgb = Color.hex2rgb(hex);


            this.setValue(rgb);
        },


        /**
         * Returns the cached element reference.  If the id is not a string, it
         * is assumed that it is an element and this is returned.
         * @param id {string|HTMLElement} the element key, id, or ref
         * @param on {boolean} hide or show.  If true, show
         * @protected
         */
        _hideShowEl : function(id, on) {
            var el = (lang.isString(id) ? this.getElement(id) : id);
            Dom.setStyle(el, "display", (on) ? "" : "none");
        },


        /**
         * Sets up the config attributes and the change listeners for this
         * properties
         * @method initAttributes
         * @param attr An object containing default attribute values
         */
        initAttributes : function(attr) {

            attr = attr || {};
            ColorPicker.superclass.initAttributes.call(this, attr);

            /**
             * The size of the picker. Trying to change this is not recommended.
             * @attribute pickersize
             * @default 180
             * @type int
             */
            this.setAttributeConfig(this.OPT.PICKER_SIZE, {
                    value: attr.size || this.DEFAULT.PICKER_SIZE
                });

            /**
             * The current hue value 0-360
             * @attribute hue
             * @type int
             */
            this.setAttributeConfig(this.OPT.HUE, {
                    value: attr.hue || 0,
                    validator: lang.isNumber
                });

            /**
             * The current saturation value 0-100
             * @attribute saturation
             * @type int
             */
            this.setAttributeConfig(this.OPT.SATURATION, {
                    value: attr.saturation || 0,
                    validator: lang.isNumber
                });

            /**
             * The current value/brightness value 0-100
             * @attribute value
             * @type int
             */
            this.setAttributeConfig(this.OPT.VALUE, {
                    value: lang.isNumber(attr.value) ? attr.value : 100,
                    validator: lang.isNumber
                });

            /**
             * The current red value 0-255
             * @attribute red
             * @type int
             */
            this.setAttributeConfig(this.OPT.RED, {
                    value: lang.isNumber(attr.red) ? attr.red : 255,
                    validator: lang.isNumber
                });

            /**
             * The current green value 0-255
             * @attribute green
             * @type int
             */
            this.setAttributeConfig(this.OPT.GREEN, {
                    value: lang.isNumber(attr.green) ? attr.green : 255,
                    validator: lang.isNumber
                });

            /**
             * The current blue value 0-255
             * @attribute blue
             * @type int
             */
            this.setAttributeConfig(this.OPT.BLUE, {
                    value: lang.isNumber(attr.blue) ? attr.blue : 255,
                    validator: lang.isNumber
                });

            /**
             * The current hex value #000000-#FFFFFF, without the #
             * @attribute hex
             * @type string
             */
            this.setAttributeConfig(this.OPT.HEX, {
                    value: attr.hex || "FFFFFF",
                    validator: lang.isString
                });

            /**
             * The current rgb value.  Updates the state of all of the
             * other value fields.  Read-only: use setValue to set the
             * controls rgb value.
             * @attribute hex
             * @type [int, int, int]
             * @readonly
             */
            this.setAttributeConfig(this.OPT.RGB, {
                    value: attr.rgb || [255,255,255],
                    method: function(rgb) {

                        this.set(this.OPT.RED, rgb[0], true);
                        this.set(this.OPT.GREEN, rgb[1], true);
                        this.set(this.OPT.BLUE, rgb[2], true);

                        var websafe = Color.websafe(rgb),
                            hex = Color.rgb2hex(rgb),
                            hsv = Color.rgb2hsv(rgb);

                        this.set(this.OPT.WEBSAFE, websafe, true);
                        this.set(this.OPT.HEX, hex, true);



                        if (hsv[1]) {
                            this.set(this.OPT.HUE, hsv[0], true);
                        }
                        this.set(this.OPT.SATURATION, Math.round(hsv[1]*100), true);
                        this.set(this.OPT.VALUE, Math.round(hsv[2]*100), true);
                    },
                    readonly: true
                });

            /**
             * If the color picker will live inside of a container object,
             * set, provide a reference to it so the control can use the
             * container's events.
             * @attribute container
             * @type YAHOO.widget.Panel
             */
            this.setAttributeConfig(this.OPT.CONTAINER, {
                        value: null,
                        method: function(container) {
                            if (container) {
                                container.showEvent.subscribe(function() {
                                    this.pickerSlider.focus();
                                }, this, true);
                            }
                        }
                    });
            /**
             * The closest current websafe value
             * @attribute websafe
             * @type int
             */
            this.setAttributeConfig(this.OPT.WEBSAFE, {
                    value: attr.websafe || [255,255,255]
                });


            var ids = attr.ids || lang.merge({}, this.ID), i;

            if (!attr.ids && _pickercount > 1) {
                for (i in ids) {
                    if (lang.hasOwnProperty(ids, i)) {
                        ids[i] = ids[i] + _pickercount;
                    }
                }
            }


            /**
             * A list of element ids and/or element references used by the
             * control.  The default is the this.ID list, and can be customized
             * by passing a list in the contructor
             * @attribute ids
             * @type {referenceid: realid}
             * @writeonce
             */
            this.setAttributeConfig(this.OPT.IDS, {
                    value: ids,
                    writeonce: true
                });

            /**
             * A list of txt strings for internationalization.  Default
             * is this.TXT
             * @attribute txt
             * @type {key: txt}
             * @writeonce
             */
            this.setAttributeConfig(this.OPT.TXT, {
                    value: attr.txt || this.TXT,
                    writeonce: true
                });

            /**
             * The img src default list
             * is this.IMAGES
             * @attribute images
             * @type {key: image}
             * @writeonce
             */
            this.setAttributeConfig(this.OPT.IMAGES, {
                    value: attr.images || this.IMAGE,
                    writeonce: true
                });
            /**
             * The element refs used by this control.  Set at initialization
             * @attribute elements
             * @type {id: HTMLElement}
             * @readonly
             */
            this.setAttributeConfig(this.OPT.ELEMENTS, {
                    value: {},
                    readonly: true
                });

            /**
             * Hide/show the entire set of controls
             * @attribute showcontrols
             * @type boolean
             * @default true
             */
            this.setAttributeConfig(this.OPT.SHOW_CONTROLS, {
                    value: lang.isBoolean(attr.showcontrols) ? attr.showcontrols : true,
                    method: function(on) {

                        var el = Dom.getElementsByClassName("bd", "div",
                                this.getElement(this.ID.CONTROLS))[0];

                        this._hideShowEl(el, on);

                        this.getElement(this.ID.CONTROLS_LABEL).innerHTML =
                            (on) ? this.get(this.OPT.TXT).HIDE_CONTROLS :
                                   this.get(this.OPT.TXT).SHOW_CONTROLS;

                    }
                });

            /**
             * Hide/show the rgb controls
             * @attribute showrgbcontrols
             * @type boolean
             * @default true
             */
            this.setAttributeConfig(this.OPT.SHOW_RGB_CONTROLS, {
                    value: lang.isBoolean(attr.showrgbcontrols) ? attr.showrgbcontrols : true,
                    method: function(on) {
                        this._hideShowEl(this.ID.RGB_CONTROLS, on);
                    }
                });

            /**
             * Hide/show the hsv controls
             * @attribute showhsvcontrols
             * @type boolean
             * @default false
             */
            this.setAttributeConfig(this.OPT.SHOW_HSV_CONTROLS, {
                    value: lang.isBoolean(attr.showhsvcontrols) ?
                                          attr.showhsvcontrols : false,
                    method: function(on) {
                        this._hideShowEl(this.ID.HSV_CONTROLS, on);

                        if (on && this.get(this.OPT.SHOW_HEX_SUMMARY)) {
                            this.set(this.OPT.SHOW_HEX_SUMMARY, false);
                        }
                    }
                });

            /**
             * Hide/show the hex controls
             * @attribute showhexcontrols
             * @type boolean
             * @default true
             */
            this.setAttributeConfig(this.OPT.SHOW_HEX_CONTROLS, {
                    value: lang.isBoolean(attr.showhexcontrols) ?
                                          attr.showhexcontrols : false,
                    method: function(on) {
                        this._hideShowEl(this.ID.HEX_CONTROLS, on);
                    }
                });

            /**
             * Hide/show the websafe swatch
             * @attribute showwebsafe
             * @type boolean
             * @default true
             */
            this.setAttributeConfig(this.OPT.SHOW_WEBSAFE, {
                    value: lang.isBoolean(attr.showwebsafe) ? attr.showwebsafe : true,
                    method: function(on) {
                        this._hideShowEl(this.ID.WEBSAFE_SWATCH, on);
                    }
                });

            /**
             * Hide/show the hex summary
             * @attribute showhexsummary
             * @type boolean
             * @default true
             */
            this.setAttributeConfig(this.OPT.SHOW_HEX_SUMMARY, {
                    value: lang.isBoolean(attr.showhexsummary) ? attr.showhexsummary : true,
                    method: function(on) {
                        this._hideShowEl(this.ID.HEX_SUMMARY, on);

                        if (on && this.get(this.OPT.SHOW_HSV_CONTROLS)) {
                            this.set(this.OPT.SHOW_HSV_CONTROLS, false);
                        }
                    }
                });
            this.setAttributeConfig(this.OPT.ANIMATE, {
                    value: lang.isBoolean(attr.animate) ? attr.animate : true,
                    method: function(on) {
                        if (this.pickerSlider) {
                            this.pickerSlider.animate = on;
                            this.hueSlider.animate = on;
                        }
                    }
                });

            this.on(this.OPT.HUE + "Change", this._updateRGBFromHSV, this, true);
            this.on(this.OPT.SATURATION + "Change", this._updateRGBFromHSV, this, true);
            this.on(this.OPT.VALUE + "Change", this._updateRGBFromHSV, this, true);

            this.on(this.OPT.RED + "Change", this._updateRGB, this, true);
            this.on(this.OPT.GREEN + "Change", this._updateRGB, this, true);
            this.on(this.OPT.BLUE + "Change", this._updateRGB, this, true);

            this.on(this.OPT.HEX + "Change", this._updateHex, this, true);

            this._initElements();
        }
    });

    YAHOO.widget.ColorPicker = ColorPicker;
})();
YAHOO.register("colorpicker", YAHOO.widget.ColorPicker, {version: "2.8.2r1", build: "7"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
(function () {

    /**
    * Config is a utility used within an Object to allow the implementer to
    * maintain a list of local configuration properties and listen for changes
    * to those properties dynamically using CustomEvent. The initial values are
    * also maintained so that the configuration can be reset at any given point
    * to its initial state.
    * @namespace YAHOO.util
    * @class Config
    * @constructor
    * @param {Object} owner The owner Object to which this Config Object belongs
    */
    YAHOO.util.Config = function (owner) {

        if (owner) {
            this.init(owner);
        }


    };


    var Lang = YAHOO.lang,
        CustomEvent = YAHOO.util.CustomEvent,
        Config = YAHOO.util.Config;


    /**
     * Constant representing the CustomEvent type for the config changed event.
     * @property YAHOO.util.Config.CONFIG_CHANGED_EVENT
     * @private
     * @static
     * @final
     */
    Config.CONFIG_CHANGED_EVENT = "configChanged";

    /**
     * Constant representing the boolean type string
     * @property YAHOO.util.Config.BOOLEAN_TYPE
     * @private
     * @static
     * @final
     */
    Config.BOOLEAN_TYPE = "boolean";

    Config.prototype = {

        /**
        * Object reference to the owner of this Config Object
        * @property owner
        * @type Object
        */
        owner: null,

        /**
        * Boolean flag that specifies whether a queue is currently
        * being executed
        * @property queueInProgress
        * @type Boolean
        */
        queueInProgress: false,

        /**
        * Maintains the local collection of configuration property objects and
        * their specified values
        * @property config
        * @private
        * @type Object
        */
        config: null,

        /**
        * Maintains the local collection of configuration property objects as
        * they were initially applied.
        * This object is used when resetting a property.
        * @property initialConfig
        * @private
        * @type Object
        */
        initialConfig: null,

        /**
        * Maintains the local, normalized CustomEvent queue
        * @property eventQueue
        * @private
        * @type Object
        */
        eventQueue: null,

        /**
        * Custom Event, notifying subscribers when Config properties are set
        * (setProperty is called without the silent flag
        * @event configChangedEvent
        */
        configChangedEvent: null,

        /**
        * Initializes the configuration Object and all of its local members.
        * @method init
        * @param {Object} owner The owner Object to which this Config
        * Object belongs
        */
        init: function (owner) {

            this.owner = owner;

            this.configChangedEvent =
                this.createEvent(Config.CONFIG_CHANGED_EVENT);

            this.configChangedEvent.signature = CustomEvent.LIST;
            this.queueInProgress = false;
            this.config = {};
            this.initialConfig = {};
            this.eventQueue = [];

        },

        /**
        * Validates that the value passed in is a Boolean.
        * @method checkBoolean
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */
        checkBoolean: function (val) {
            return (typeof val == Config.BOOLEAN_TYPE);
        },

        /**
        * Validates that the value passed in is a number.
        * @method checkNumber
        * @param {Object} val The value to validate
        * @return {Boolean} true, if the value is valid
        */
        checkNumber: function (val) {
            return (!isNaN(val));
        },

        /**
        * Fires a configuration property event using the specified value.
        * @method fireEvent
        * @private
        * @param {String} key The configuration property's name
        * @param {value} Object The value of the correct type for the property
        */
        fireEvent: function ( key, value ) {
            var property = this.config[key];

            if (property && property.event) {
                property.event.fire(value);
            }
        },

        /**
        * Adds a property to the Config Object's private config hash.
        * @method addProperty
        * @param {String} key The configuration property's name
        * @param {Object} propertyObject The Object containing all of this
        * property's arguments
        */
        addProperty: function ( key, propertyObject ) {
            key = key.toLowerCase();

            this.config[key] = propertyObject;

            propertyObject.event = this.createEvent(key, { scope: this.owner });
            propertyObject.event.signature = CustomEvent.LIST;


            propertyObject.key = key;

            if (propertyObject.handler) {
                propertyObject.event.subscribe(propertyObject.handler,
                    this.owner);
            }

            this.setProperty(key, propertyObject.value, true);

            if (! propertyObject.suppressEvent) {
                this.queueProperty(key, propertyObject.value);
            }

        },

        /**
        * Returns a key-value configuration map of the values currently set in
        * the Config Object.
        * @method getConfig
        * @return {Object} The current config, represented in a key-value map
        */
        getConfig: function () {

            var cfg = {},
                currCfg = this.config,
                prop,
                property;

            for (prop in currCfg) {
                if (Lang.hasOwnProperty(currCfg, prop)) {
                    property = currCfg[prop];
                    if (property && property.event) {
                        cfg[prop] = property.value;
                    }
                }
            }

            return cfg;
        },

        /**
        * Returns the value of specified property.
        * @method getProperty
        * @param {String} key The name of the property
        * @return {Object}  The value of the specified property
        */
        getProperty: function (key) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.value;
            } else {
                return undefined;
            }
        },

        /**
        * Resets the specified property's value to its initial value.
        * @method resetProperty
        * @param {String} key The name of the property
        * @return {Boolean} True is the property was reset, false if not
        */
        resetProperty: function (key) {

            key = key.toLowerCase();

            var property = this.config[key];

            if (property && property.event) {

                if (this.initialConfig[key] &&
                    !Lang.isUndefined(this.initialConfig[key])) {

                    this.setProperty(key, this.initialConfig[key]);

                    return true;

                }

            } else {

                return false;
            }

        },

        /**
        * Sets the value of a property. If the silent property is passed as
        * true, the property's event will not be fired.
        * @method setProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @param {Boolean} silent Whether the value should be set silently,
        * without firing the property event.
        * @return {Boolean} True, if the set was successful, false if it failed.
        */
        setProperty: function (key, value, silent) {

            var property;

            key = key.toLowerCase();

            if (this.queueInProgress && ! silent) {
                this.queueProperty(key,value);
                return true;

            } else {
                property = this.config[key];
                if (property && property.event) {
                    if (property.validator && !property.validator(value)) {
                        return false;
                    } else {
                        property.value = value;
                        if (! silent) {
                            this.fireEvent(key, value);
                            this.configChangedEvent.fire([key, value]);
                        }
                        return true;
                    }
                } else {
                    return false;
                }
            }
        },

        /**
        * Sets the value of a property and queues its event to execute. If the
        * event is already scheduled to execute, it is
        * moved from its current position to the end of the queue.
        * @method queueProperty
        * @param {String} key The name of the property
        * @param {String} value The value to set the property to
        * @return {Boolean}  true, if the set was successful, false if
        * it failed.
        */
        queueProperty: function (key, value) {

            key = key.toLowerCase();

            var property = this.config[key],
                foundDuplicate = false,
                iLen,
                queueItem,
                queueItemKey,
                queueItemValue,
                sLen,
                supercedesCheck,
                qLen,
                queueItemCheck,
                queueItemCheckKey,
                queueItemCheckValue,
                i,
                s,
                q;

            if (property && property.event) {

                if (!Lang.isUndefined(value) && property.validator &&
                    !property.validator(value)) { // validator
                    return false;
                } else {

                    if (!Lang.isUndefined(value)) {
                        property.value = value;
                    } else {
                        value = property.value;
                    }

                    foundDuplicate = false;
                    iLen = this.eventQueue.length;

                    for (i = 0; i < iLen; i++) {
                        queueItem = this.eventQueue[i];

                        if (queueItem) {
                            queueItemKey = queueItem[0];
                            queueItemValue = queueItem[1];

                            if (queueItemKey == key) {

                                /*
                                    found a dupe... push to end of queue, null
                                    current item, and break
                                */

                                this.eventQueue[i] = null;

                                this.eventQueue.push(
                                    [key, (!Lang.isUndefined(value) ?
                                    value : queueItemValue)]);

                                foundDuplicate = true;
                                break;
                            }
                        }
                    }


                    if (! foundDuplicate && !Lang.isUndefined(value)) {
                        this.eventQueue.push([key, value]);
                    }
                }

                if (property.supercedes) {

                    sLen = property.supercedes.length;

                    for (s = 0; s < sLen; s++) {

                        supercedesCheck = property.supercedes[s];
                        qLen = this.eventQueue.length;

                        for (q = 0; q < qLen; q++) {
                            queueItemCheck = this.eventQueue[q];

                            if (queueItemCheck) {
                                queueItemCheckKey = queueItemCheck[0];
                                queueItemCheckValue = queueItemCheck[1];

                                if (queueItemCheckKey ==
                                    supercedesCheck.toLowerCase() ) {

                                    this.eventQueue.push([queueItemCheckKey,
                                        queueItemCheckValue]);

                                    this.eventQueue[q] = null;
                                    break;

                                }
                            }
                        }
                    }
                }


                return true;
            } else {
                return false;
            }
        },

        /**
        * Fires the event for a property using the property's current value.
        * @method refireEvent
        * @param {String} key The name of the property
        */
        refireEvent: function (key) {

            key = key.toLowerCase();

            var property = this.config[key];

            if (property && property.event &&

                !Lang.isUndefined(property.value)) {

                if (this.queueInProgress) {

                    this.queueProperty(key);

                } else {

                    this.fireEvent(key, property.value);

                }

            }
        },

        /**
        * Applies a key-value Object literal to the configuration, replacing
        * any existing values, and queueing the property events.
        * Although the values will be set, fireQueue() must be called for their
        * associated events to execute.
        * @method applyConfig
        * @param {Object} userConfig The configuration Object literal
        * @param {Boolean} init  When set to true, the initialConfig will
        * be set to the userConfig passed in, so that calling a reset will
        * reset the properties to the passed values.
        */
        applyConfig: function (userConfig, init) {

            var sKey,
                oConfig;

            if (init) {
                oConfig = {};
                for (sKey in userConfig) {
                    if (Lang.hasOwnProperty(userConfig, sKey)) {
                        oConfig[sKey.toLowerCase()] = userConfig[sKey];
                    }
                }
                this.initialConfig = oConfig;
            }

            for (sKey in userConfig) {
                if (Lang.hasOwnProperty(userConfig, sKey)) {
                    this.queueProperty(sKey, userConfig[sKey]);
                }
            }
        },

        /**
        * Refires the events for all configuration properties using their
        * current values.
        * @method refresh
        */
        refresh: function () {

            var prop;

            for (prop in this.config) {
                if (Lang.hasOwnProperty(this.config, prop)) {
                    this.refireEvent(prop);
                }
            }
        },

        /**
        * Fires the normalized list of queued property change events
        * @method fireQueue
        */
        fireQueue: function () {

            var i,
                queueItem,
                key,
                value,
                property;

            this.queueInProgress = true;
            for (i = 0;i < this.eventQueue.length; i++) {
                queueItem = this.eventQueue[i];
                if (queueItem) {

                    key = queueItem[0];
                    value = queueItem[1];
                    property = this.config[key];

                    property.value = value;

                    this.eventQueue[i] = null;

                    this.fireEvent(key,value);
                }
            }

            this.queueInProgress = false;
            this.eventQueue = [];
        },

        /**
        * Subscribes an external handler to the change event for any
        * given property.
        * @method subscribeToConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to
        * the property's event
        * @param {Object} obj The Object to use for scoping the event handler
        * (see CustomEvent documentation)
        * @param {Boolean} overrideContext Optional. If true, will override
        * "this" within the handler to map to the scope Object passed into the
        * method.
        * @return {Boolean} True, if the subscription was successful,
        * otherwise false.
        */
        subscribeToConfigEvent: function (key, handler, obj, overrideContext) {

            var property = this.config[key.toLowerCase()];

            if (property && property.event) {
                if (!Config.alreadySubscribed(property.event, handler, obj)) {
                    property.event.subscribe(handler, obj, overrideContext);
                }
                return true;
            } else {
                return false;
            }

        },

        /**
        * Unsubscribes an external handler from the change event for any
        * given property.
        * @method unsubscribeFromConfigEvent
        * @param {String} key The property name
        * @param {Function} handler The handler function to use subscribe to
        * the property's event
        * @param {Object} obj The Object to use for scoping the event
        * handler (see CustomEvent documentation)
        * @return {Boolean} True, if the unsubscription was successful,
        * otherwise false.
        */
        unsubscribeFromConfigEvent: function (key, handler, obj) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.event.unsubscribe(handler, obj);
            } else {
                return false;
            }
        },

        /**
        * Returns a string representation of the Config object
        * @method toString
        * @return {String} The Config object in string format.
        */
        toString: function () {
            var output = "Config";
            if (this.owner) {
                output += " [" + this.owner.toString() + "]";
            }
            return output;
        },

        /**
        * Returns a string representation of the Config object's current
        * CustomEvent queue
        * @method outputEventQueue
        * @return {String} The string list of CustomEvents currently queued
        * for execution
        */
        outputEventQueue: function () {

            var output = "",
                queueItem,
                q,
                nQueue = this.eventQueue.length;

            for (q = 0; q < nQueue; q++) {
                queueItem = this.eventQueue[q];
                if (queueItem) {
                    output += queueItem[0] + "=" + queueItem[1] + ", ";
                }
            }
            return output;
        },

        /**
        * Sets all properties to null, unsubscribes all listeners from each
        * property's change event and all listeners from the configChangedEvent.
        * @method destroy
        */
        destroy: function () {

            var oConfig = this.config,
                sProperty,
                oProperty;


            for (sProperty in oConfig) {

                if (Lang.hasOwnProperty(oConfig, sProperty)) {

                    oProperty = oConfig[sProperty];

                    oProperty.event.unsubscribeAll();
                    oProperty.event = null;

                }

            }

            this.configChangedEvent.unsubscribeAll();

            this.configChangedEvent = null;
            this.owner = null;
            this.config = null;
            this.initialConfig = null;
            this.eventQueue = null;

        }

    };



    /**
    * Checks to determine if a particular function/Object pair are already
    * subscribed to the specified CustomEvent
    * @method YAHOO.util.Config.alreadySubscribed
    * @static
    * @param {YAHOO.util.CustomEvent} evt The CustomEvent for which to check
    * the subscriptions
    * @param {Function} fn The function to look for in the subscribers list
    * @param {Object} obj The execution scope Object for the subscription
    * @return {Boolean} true, if the function/Object pair is already subscribed
    * to the CustomEvent passed in
    */
    Config.alreadySubscribed = function (evt, fn, obj) {

        var nSubscribers = evt.subscribers.length,
            subsc,
            i;

        if (nSubscribers > 0) {
            i = nSubscribers - 1;
            do {
                subsc = evt.subscribers[i];
                if (subsc && subsc.obj == obj && subsc.fn == fn) {
                    return true;
                }
            }
            while (i--);
        }

        return false;

    };

    YAHOO.lang.augmentProto(Config, YAHOO.util.EventProvider);

}());
/**
* The datemath module provides utility methods for basic JavaScript Date object manipulation and
* comparison.
*
* @module datemath
*/

/**
* YAHOO.widget.DateMath is used for simple date manipulation. The class is a static utility
* used for adding, subtracting, and comparing dates.
* @namespace YAHOO.widget
* @class DateMath
*/
YAHOO.widget.DateMath = {
    /**
    * Constant field representing Day
    * @property DAY
    * @static
    * @final
    * @type String
    */
    DAY : "D",

    /**
    * Constant field representing Week
    * @property WEEK
    * @static
    * @final
    * @type String
    */
    WEEK : "W",

    /**
    * Constant field representing Year
    * @property YEAR
    * @static
    * @final
    * @type String
    */
    YEAR : "Y",

    /**
    * Constant field representing Month
    * @property MONTH
    * @static
    * @final
    * @type String
    */
    MONTH : "M",

    /**
    * Constant field representing one day, in milliseconds
    * @property ONE_DAY_MS
    * @static
    * @final
    * @type Number
    */
    ONE_DAY_MS : 1000*60*60*24,

    /**
     * Constant field representing the date in first week of January
     * which identifies the first week of the year.
     * <p>
     * In the U.S, Jan 1st is normally used based on a Sunday start of week.
     * ISO 8601, used widely throughout Europe, uses Jan 4th, based on a Monday start of week.
     * </p>
     * @property WEEK_ONE_JAN_DATE
     * @static
     * @type Number
     */
    WEEK_ONE_JAN_DATE : 1,

    /**
    * Adds the specified amount of time to the this instance.
    * @method add
    * @param {Date} date The JavaScript Date object to perform addition on
    * @param {String} field The field constant to be used for performing addition.
    * @param {Number} amount The number of units (measured in the field constant) to add to the date.
    * @return {Date} The resulting Date object
    */
    add : function(date, field, amount) {
        var d = new Date(date.getTime());
        switch (field) {
            case this.MONTH:
                var newMonth = date.getMonth() + amount;
                var years = 0;

                if (newMonth < 0) {
                    while (newMonth < 0) {
                        newMonth += 12;
                        years -= 1;
                    }
                } else if (newMonth > 11) {
                    while (newMonth > 11) {
                        newMonth -= 12;
                        years += 1;
                    }
                }

                d.setMonth(newMonth);
                d.setFullYear(date.getFullYear() + years);
                break;
            case this.DAY:
                this._addDays(d, amount);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + amount);
                break;
            case this.WEEK:
                this._addDays(d, (amount * 7));
                break;
        }
        return d;
    },

    /**
     * Private helper method to account for bug in Safari 2 (webkit < 420)
     * when Date.setDate(n) is called with n less than -128 or greater than 127.
     * <p>
     * Fix approach and original findings are available here:
     * http://brianary.blogspot.com/2006/03/safari-date-bug.html
     * </p>
     * @method _addDays
     * @param {Date} d JavaScript date object
     * @param {Number} nDays The number of days to add to the date object (can be negative)
     * @private
     */
    _addDays : function(d, nDays) {
        if (YAHOO.env.ua.webkit && YAHOO.env.ua.webkit < 420) {
            if (nDays < 0) {
                for(var min = -128; nDays < min; nDays -= min) {
                    d.setDate(d.getDate() + min);
                }
            } else {
                for(var max = 96; nDays > max; nDays -= max) {
                    d.setDate(d.getDate() + max);
                }
            }
        }
        d.setDate(d.getDate() + nDays);
    },

    /**
    * Subtracts the specified amount of time from the this instance.
    * @method subtract
    * @param {Date} date The JavaScript Date object to perform subtraction on
    * @param {Number} field The this field constant to be used for performing subtraction.
    * @param {Number} amount The number of units (measured in the field constant) to subtract from the date.
    * @return {Date} The resulting Date object
    */
    subtract : function(date, field, amount) {
        return this.add(date, field, (amount*-1));
    },

    /**
    * Determines whether a given date is before another date on the calendar.
    * @method before
    * @param {Date} date  The Date object to compare with the compare argument
    * @param {Date} compareTo The Date object to use for the comparison
    * @return {Boolean} true if the date occurs before the compared date; false if not.
    */
    before : function(date, compareTo) {
        var ms = compareTo.getTime();
        if (date.getTime() < ms) {
            return true;
        } else {
            return false;
        }
    },

    /**
    * Determines whether a given date is after another date on the calendar.
    * @method after
    * @param {Date} date  The Date object to compare with the compare argument
    * @param {Date} compareTo The Date object to use for the comparison
    * @return {Boolean} true if the date occurs after the compared date; false if not.
    */
    after : function(date, compareTo) {
        var ms = compareTo.getTime();
        if (date.getTime() > ms) {
            return true;
        } else {
            return false;
        }
    },

    /**
    * Determines whether a given date is between two other dates on the calendar.
    * @method between
    * @param {Date} date  The date to check for
    * @param {Date} dateBegin The start of the range
    * @param {Date} dateEnd  The end of the range
    * @return {Boolean} true if the date occurs between the compared dates; false if not.
    */
    between : function(date, dateBegin, dateEnd) {
        if (this.after(date, dateBegin) && this.before(date, dateEnd)) {
            return true;
        } else {
            return false;
        }
    },

    /**
    * Retrieves a JavaScript Date object representing January 1 of any given year.
    * @method getJan1
    * @param {Number} calendarYear  The calendar year for which to retrieve January 1
    * @return {Date} January 1 of the calendar year specified.
    */
    getJan1 : function(calendarYear) {
        return this.getDate(calendarYear,0,1);
    },

    /**
    * Calculates the number of days the specified date is from January 1 of the specified calendar year.
    * Passing January 1 to this function would return an offset value of zero.
    * @method getDayOffset
    * @param {Date} date The JavaScript date for which to find the offset
    * @param {Number} calendarYear The calendar year to use for determining the offset
    * @return {Number} The number of days since January 1 of the given year
    */
    getDayOffset : function(date, calendarYear) {
        var beginYear = this.getJan1(calendarYear); // Find the start of the year. This will be in week 1.

        var dayOffset = Math.ceil((date.getTime()-beginYear.getTime()) / this.ONE_DAY_MS);
        return dayOffset;
    },

    /**
    * Calculates the week number for the given date. Can currently support standard
    * U.S. week numbers, based on Jan 1st defining the 1st week of the year, and
    * ISO8601 week numbers, based on Jan 4th defining the 1st week of the year.
    *
    * @method getWeekNumber
    * @param {Date} date The JavaScript date for which to find the week number
    * @param {Number} firstDayOfWeek The index of the first day of the week (0 = Sun, 1 = Mon ... 6 = Sat).
    * Defaults to 0
    * @param {Number} janDate The date in the first week of January which defines week one for the year
    * Defaults to the value of YAHOO.widget.DateMath.WEEK_ONE_JAN_DATE, which is 1 (Jan 1st).
    * For the U.S, this is normally Jan 1st. ISO8601 uses Jan 4th to define the first week of the year.
    *
    * @return {Number} The number of the week containing the given date.
    */
    getWeekNumber : function(date, firstDayOfWeek, janDate) {

        firstDayOfWeek = firstDayOfWeek || 0;
        janDate = janDate || this.WEEK_ONE_JAN_DATE;

        var targetDate = this.clearTime(date),
            startOfWeek,
            endOfWeek;

        if (targetDate.getDay() === firstDayOfWeek) {
            startOfWeek = targetDate;
        } else {
            startOfWeek = this.getFirstDayOfWeek(targetDate, firstDayOfWeek);
        }

        var startYear = startOfWeek.getFullYear();

        endOfWeek = new Date(startOfWeek.getTime() + 6*this.ONE_DAY_MS);

        var weekNum;
        if (startYear !== endOfWeek.getFullYear() && endOfWeek.getDate() >= janDate) {
            weekNum = 1;
        } else {
            var weekOne = this.clearTime(this.getDate(startYear, 0, janDate)),
                weekOneDayOne = this.getFirstDayOfWeek(weekOne, firstDayOfWeek);

            var daysDiff  = Math.round((targetDate.getTime() - weekOneDayOne.getTime())/this.ONE_DAY_MS);

            var rem = daysDiff % 7;
            var weeksDiff = (daysDiff - rem)/7;
            weekNum = weeksDiff + 1;
        }
        return weekNum;
    },

    /**
     * Get the first day of the week, for the give date.
     * @param {Date} dt The date in the week for which the first day is required.
     * @param {Number} startOfWeek The index for the first day of the week, 0 = Sun, 1 = Mon ... 6 = Sat (defaults to 0)
     * @return {Date} The first day of the week
     */
    getFirstDayOfWeek : function (dt, startOfWeek) {
        startOfWeek = startOfWeek || 0;
        var dayOfWeekIndex = dt.getDay(),
            dayOfWeek = (dayOfWeekIndex - startOfWeek + 7) % 7;

        return this.subtract(dt, this.DAY, dayOfWeek);
    },

    /**
    * Determines if a given week overlaps two different years.
    * @method isYearOverlapWeek
    * @param {Date} weekBeginDate The JavaScript Date representing the first day of the week.
    * @return {Boolean} true if the date overlaps two different years.
    */
    isYearOverlapWeek : function(weekBeginDate) {
        var overlaps = false;
        var nextWeek = this.add(weekBeginDate, this.DAY, 6);
        if (nextWeek.getFullYear() != weekBeginDate.getFullYear()) {
            overlaps = true;
        }
        return overlaps;
    },

    /**
    * Determines if a given week overlaps two different months.
    * @method isMonthOverlapWeek
    * @param {Date} weekBeginDate The JavaScript Date representing the first day of the week.
    * @return {Boolean} true if the date overlaps two different months.
    */
    isMonthOverlapWeek : function(weekBeginDate) {
        var overlaps = false;
        var nextWeek = this.add(weekBeginDate, this.DAY, 6);
        if (nextWeek.getMonth() != weekBeginDate.getMonth()) {
            overlaps = true;
        }
        return overlaps;
    },

    /**
    * Gets the first day of a month containing a given date.
    * @method findMonthStart
    * @param {Date} date The JavaScript Date used to calculate the month start
    * @return {Date}  The JavaScript Date representing the first day of the month
    */
    findMonthStart : function(date) {
        var start = this.getDate(date.getFullYear(), date.getMonth(), 1);
        return start;
    },

    /**
    * Gets the last day of a month containing a given date.
    * @method findMonthEnd
    * @param {Date} date The JavaScript Date used to calculate the month end
    * @return {Date}  The JavaScript Date representing the last day of the month
    */
    findMonthEnd : function(date) {
        var start = this.findMonthStart(date);
        var nextMonth = this.add(start, this.MONTH, 1);
        var end = this.subtract(nextMonth, this.DAY, 1);
        return end;
    },

    /**
    * Clears the time fields from a given date, effectively setting the time to 12 noon.
    * @method clearTime
    * @param {Date} date The JavaScript Date for which the time fields will be cleared
    * @return {Date}  The JavaScript Date cleared of all time fields
    */
    clearTime : function(date) {
        date.setHours(12,0,0,0);
        return date;
    },

    /**
     * Returns a new JavaScript Date object, representing the given year, month and date. Time fields (hr, min, sec, ms) on the new Date object
     * are set to 0. The method allows Date instances to be created with the a year less than 100. "new Date(year, month, date)" implementations
     * set the year to 19xx if a year (xx) which is less than 100 is provided.
     * <p>
     * <em>NOTE:</em>Validation on argument values is not performed. It is the caller's responsibility to ensure
     * arguments are valid as per the ECMAScript-262 Date object specification for the new Date(year, month[, date]) constructor.
     * </p>
     * @method getDate
     * @param {Number} y Year.
     * @param {Number} m Month index from 0 (Jan) to 11 (Dec).
     * @param {Number} d (optional) Date from 1 to 31. If not provided, defaults to 1.
     * @return {Date} The JavaScript date object with year, month, date set as provided.
     */
    getDate : function(y, m, d) {
        var dt = null;
        if (YAHOO.lang.isUndefined(d)) {
            d = 1;
        }
        if (y >= 100) {
            dt = new Date(y, m, d);
        } else {
            dt = new Date();
            dt.setFullYear(y);
            dt.setMonth(m);
            dt.setDate(d);
            dt.setHours(0,0,0,0);
        }
        return dt;
    }
};
/**
* The Calendar component is a UI control that enables users to choose one or more dates from a graphical calendar presented in a one-month or
* multi-month interface. Calendars are generated entirely via script and can be navigated without any page refreshes.
* @module    calendar
* @title    Calendar
* @namespace  YAHOO.widget
* @requires  yahoo,dom,event
*/
(function(){

    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        DateMath = YAHOO.widget.DateMath;

/**
* Calendar is the base class for the Calendar widget. In its most basic
* implementation, it has the ability to render a calendar widget on the page
* that can be manipulated to select a single date, move back and forth between
* months and years.
* <p>To construct the placeholder for the calendar widget, the code is as
* follows:
*   <xmp>
*       <div id="calContainer"></div>
*   </xmp>
* </p>
* <p>
* <strong>NOTE: As of 2.4.0, the constructor's ID argument is optional.</strong>
* The Calendar can be constructed by simply providing a container ID string,
* or a reference to a container DIV HTMLElement (the element needs to exist
* in the document).
*
* E.g.:
*   <xmp>
*       var c = new YAHOO.widget.Calendar("calContainer", configOptions);
*   </xmp>
* or:
*   <xmp>
*       var containerDiv = YAHOO.util.Dom.get("calContainer");
*       var c = new YAHOO.widget.Calendar(containerDiv, configOptions);
*   </xmp>
* </p>
* <p>
* If not provided, the ID will be generated from the container DIV ID by adding an "_t" suffix.
* For example if an ID is not provided, and the container's ID is "calContainer", the Calendar's ID will be set to "calContainer_t".
* </p>
*
* @namespace YAHOO.widget
* @class Calendar
* @constructor
* @param {String} id optional The id of the table element that will represent the Calendar widget. As of 2.4.0, this argument is optional.
* @param {String | HTMLElement} container The id of the container div element that will wrap the Calendar table, or a reference to a DIV element which exists in the document.
* @param {Object} config optional The configuration object containing the initial configuration values for the Calendar.
*/
function Calendar(id, containerId, config) {
    this.init.apply(this, arguments);
}

/**
* The path to be used for images loaded for the Calendar
* @property YAHOO.widget.Calendar.IMG_ROOT
* @static
* @deprecated   You can now customize images by overriding the calclose, calnavleft and calnavright default CSS classes for the close icon, left arrow and right arrow respectively
* @type String
*/
Calendar.IMG_ROOT = null;

/**
* Type constant used for renderers to represent an individual date (M/D/Y)
* @property YAHOO.widget.Calendar.DATE
* @static
* @final
* @type String
*/
Calendar.DATE = "D";

/**
* Type constant used for renderers to represent an individual date across any year (M/D)
* @property YAHOO.widget.Calendar.MONTH_DAY
* @static
* @final
* @type String
*/
Calendar.MONTH_DAY = "MD";

/**
* Type constant used for renderers to represent a weekday
* @property YAHOO.widget.Calendar.WEEKDAY
* @static
* @final
* @type String
*/
Calendar.WEEKDAY = "WD";

/**
* Type constant used for renderers to represent a range of individual dates (M/D/Y-M/D/Y)
* @property YAHOO.widget.Calendar.RANGE
* @static
* @final
* @type String
*/
Calendar.RANGE = "R";

/**
* Type constant used for renderers to represent a month across any year
* @property YAHOO.widget.Calendar.MONTH
* @static
* @final
* @type String
*/
Calendar.MONTH = "M";

/**
* Constant that represents the total number of date cells that are displayed in a given month
* @property YAHOO.widget.Calendar.DISPLAY_DAYS
* @static
* @final
* @type Number
*/
Calendar.DISPLAY_DAYS = 42;

/**
* Constant used for halting the execution of the remainder of the render stack
* @property YAHOO.widget.Calendar.STOP_RENDER
* @static
* @final
* @type String
*/
Calendar.STOP_RENDER = "S";

/**
* Constant used to represent short date field string formats (e.g. Tu or Feb)
* @property YAHOO.widget.Calendar.SHORT
* @static
* @final
* @type String
*/
Calendar.SHORT = "short";

/**
* Constant used to represent long date field string formats (e.g. Monday or February)
* @property YAHOO.widget.Calendar.LONG
* @static
* @final
* @type String
*/
Calendar.LONG = "long";

/**
* Constant used to represent medium date field string formats (e.g. Mon)
* @property YAHOO.widget.Calendar.MEDIUM
* @static
* @final
* @type String
*/
Calendar.MEDIUM = "medium";

/**
* Constant used to represent single character date field string formats (e.g. M, T, W)
* @property YAHOO.widget.Calendar.ONE_CHAR
* @static
* @final
* @type String
*/
Calendar.ONE_CHAR = "1char";

/**
* The set of default Config property keys and values for the Calendar.
*
* <p>
* NOTE: This property is made public in order to allow users to change
* the default values of configuration properties. Users should not
* modify the key string, unless they are overriding the Calendar implementation
* </p>
*
* <p>
* The property is an object with key/value pairs, the key being the
* uppercase configuration property name and the value being an object
* literal with a key string property, and a value property, specifying the
* default value of the property. To override a default value, you can set
* the value property, for example, <code>YAHOO.widget.Calendar.DEFAULT_CONFIG.MULTI_SELECT.value = true;</code>
*
* @property YAHOO.widget.Calendar.DEFAULT_CONFIG
* @static
* @type Object
*/

Calendar.DEFAULT_CONFIG = {
    YEAR_OFFSET : {key:"year_offset", value:0, supercedes:["pagedate", "selected", "mindate","maxdate"]},
    TODAY : {key:"today", value:new Date(), supercedes:["pagedate"]},
    PAGEDATE : {key:"pagedate", value:null},
    SELECTED : {key:"selected", value:[]},
    TITLE : {key:"title", value:""},
    CLOSE : {key:"close", value:false},
    IFRAME : {key:"iframe", value:(YAHOO.env.ua.ie && YAHOO.env.ua.ie <= 6) ? true : false},
    MINDATE : {key:"mindate", value:null},
    MAXDATE : {key:"maxdate", value:null},
    MULTI_SELECT : {key:"multi_select", value:false},
    START_WEEKDAY : {key:"start_weekday", value:0},
    SHOW_WEEKDAYS : {key:"show_weekdays", value:true},
    SHOW_WEEK_HEADER : {key:"show_week_header", value:false},
    SHOW_WEEK_FOOTER : {key:"show_week_footer", value:false},
    HIDE_BLANK_WEEKS : {key:"hide_blank_weeks", value:false},
    NAV_ARROW_LEFT: {key:"nav_arrow_left", value:null} ,
    NAV_ARROW_RIGHT : {key:"nav_arrow_right", value:null} ,
    MONTHS_SHORT : {key:"months_short", value:["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]},
    MONTHS_LONG: {key:"months_long", value:["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]},
    WEEKDAYS_1CHAR: {key:"weekdays_1char", value:["S", "M", "T", "W", "T", "F", "S"]},
    WEEKDAYS_SHORT: {key:"weekdays_short", value:["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]},
    WEEKDAYS_MEDIUM: {key:"weekdays_medium", value:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]},
    WEEKDAYS_LONG: {key:"weekdays_long", value:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]},
    LOCALE_MONTHS:{key:"locale_months", value:"long"},
    LOCALE_WEEKDAYS:{key:"locale_weekdays", value:"short"},
    DATE_DELIMITER:{key:"date_delimiter", value:","},
    DATE_FIELD_DELIMITER:{key:"date_field_delimiter", value:"/"},
    DATE_RANGE_DELIMITER:{key:"date_range_delimiter", value:"-"},
    MY_MONTH_POSITION:{key:"my_month_position", value:1},
    MY_YEAR_POSITION:{key:"my_year_position", value:2},
    MD_MONTH_POSITION:{key:"md_month_position", value:1},
    MD_DAY_POSITION:{key:"md_day_position", value:2},
    MDY_MONTH_POSITION:{key:"mdy_month_position", value:1},
    MDY_DAY_POSITION:{key:"mdy_day_position", value:2},
    MDY_YEAR_POSITION:{key:"mdy_year_position", value:3},
    MY_LABEL_MONTH_POSITION:{key:"my_label_month_position", value:1},
    MY_LABEL_YEAR_POSITION:{key:"my_label_year_position", value:2},
    MY_LABEL_MONTH_SUFFIX:{key:"my_label_month_suffix", value:" "},
    MY_LABEL_YEAR_SUFFIX:{key:"my_label_year_suffix", value:""},
    NAV: {key:"navigator", value: null},
    STRINGS : {
        key:"strings",
        value: {
            previousMonth : "Previous Month",
            nextMonth : "Next Month",
            close: "Close"
        },
        supercedes : ["close", "title"]
    }
};

/**
* The set of default Config property keys and values for the Calendar
* @property YAHOO.widget.Calendar._DEFAULT_CONFIG
* @deprecated Made public. See the public DEFAULT_CONFIG property for details
* @final
* @static
* @private
* @type Object
*/
Calendar._DEFAULT_CONFIG = Calendar.DEFAULT_CONFIG;

var DEF_CFG = Calendar.DEFAULT_CONFIG;

/**
* The set of Custom Event types supported by the Calendar
* @property YAHOO.widget.Calendar._EVENT_TYPES
* @final
* @static
* @private
* @type Object
*/
Calendar._EVENT_TYPES = {
    BEFORE_SELECT : "beforeSelect",
    SELECT : "select",
    BEFORE_DESELECT : "beforeDeselect",
    DESELECT : "deselect",
    CHANGE_PAGE : "changePage",
    BEFORE_RENDER : "beforeRender",
    RENDER : "render",
    BEFORE_DESTROY : "beforeDestroy",
    DESTROY : "destroy",
    RESET : "reset",
    CLEAR : "clear",
    BEFORE_HIDE : "beforeHide",
    HIDE : "hide",
    BEFORE_SHOW : "beforeShow",
    SHOW : "show",
    BEFORE_HIDE_NAV : "beforeHideNav",
    HIDE_NAV : "hideNav",
    BEFORE_SHOW_NAV : "beforeShowNav",
    SHOW_NAV : "showNav",
    BEFORE_RENDER_NAV : "beforeRenderNav",
    RENDER_NAV : "renderNav"
};

/**
* The set of default style constants for the Calendar
* @property YAHOO.widget.Calendar.STYLES
* @static
* @type Object An object with name/value pairs for the class name identifier/value.
*/
Calendar.STYLES = {
    CSS_ROW_HEADER: "calrowhead",
    CSS_ROW_FOOTER: "calrowfoot",
    CSS_CELL : "calcell",
    CSS_CELL_SELECTOR : "selector",
    CSS_CELL_SELECTED : "selected",
    CSS_CELL_SELECTABLE : "selectable",
    CSS_CELL_RESTRICTED : "restricted",
    CSS_CELL_TODAY : "today",
    CSS_CELL_OOM : "oom",
    CSS_CELL_OOB : "previous",
    CSS_HEADER : "calheader",
    CSS_HEADER_TEXT : "calhead",
    CSS_BODY : "calbody",
    CSS_WEEKDAY_CELL : "calweekdaycell",
    CSS_WEEKDAY_ROW : "calweekdayrow",
    CSS_FOOTER : "calfoot",
    CSS_CALENDAR : "yui-calendar",
    CSS_SINGLE : "single",
    CSS_CONTAINER : "yui-calcontainer",
    CSS_NAV_LEFT : "calnavleft",
    CSS_NAV_RIGHT : "calnavright",
    CSS_NAV : "calnav",
    CSS_CLOSE : "calclose",
    CSS_CELL_TOP : "calcelltop",
    CSS_CELL_LEFT : "calcellleft",
    CSS_CELL_RIGHT : "calcellright",
    CSS_CELL_BOTTOM : "calcellbottom",
    CSS_CELL_HOVER : "calcellhover",
    CSS_CELL_HIGHLIGHT1 : "highlight1",
    CSS_CELL_HIGHLIGHT2 : "highlight2",
    CSS_CELL_HIGHLIGHT3 : "highlight3",
    CSS_CELL_HIGHLIGHT4 : "highlight4",
    CSS_WITH_TITLE: "withtitle",
    CSS_FIXED_SIZE: "fixedsize",
    CSS_LINK_CLOSE: "link-close"
};

/**
* The set of default style constants for the Calendar
* @property YAHOO.widget.Calendar._STYLES
* @deprecated Made public. See the public STYLES property for details
* @final
* @static
* @private
* @type Object
*/
Calendar._STYLES = Calendar.STYLES;

Calendar.prototype = {

    /**
    * The configuration object used to set up the calendars various locale and style options.
    * @property Config
    * @private
    * @deprecated Configuration properties should be set by calling Calendar.cfg.setProperty.
    * @type Object
    */
    Config : null,

    /**
    * The parent CalendarGroup, only to be set explicitly by the parent group
    * @property parent
    * @type CalendarGroup
    */
    parent : null,

    /**
    * The index of this item in the parent group
    * @property index
    * @type Number
    */
    index : -1,

    /**
    * The collection of calendar table cells
    * @property cells
    * @type HTMLTableCellElement[]
    */
    cells : null,

    /**
    * The collection of calendar cell dates that is parallel to the cells collection. The array contains dates field arrays in the format of [YYYY, M, D].
    * @property cellDates
    * @type Array[](Number[])
    */
    cellDates : null,

    /**
    * The id that uniquely identifies this Calendar.
    * @property id
    * @type String
    */
    id : null,

    /**
    * The unique id associated with the Calendar's container
    * @property containerId
    * @type String
    */
    containerId: null,

    /**
    * The DOM element reference that points to this calendar's container element. The calendar will be inserted into this element when the shell is rendered.
    * @property oDomContainer
    * @type HTMLElement
    */
    oDomContainer : null,

    /**
    * A Date object representing today's date.
    * @deprecated Use the "today" configuration property
    * @property today
    * @type Date
    */
    today : null,

    /**
    * The list of render functions, along with required parameters, used to render cells.
    * @property renderStack
    * @type Array[]
    */
    renderStack : null,

    /**
    * A copy of the initial render functions created before rendering.
    * @property _renderStack
    * @private
    * @type Array
    */
    _renderStack : null,

    /**
    * A reference to the CalendarNavigator instance created for this Calendar.
    * Will be null if the "navigator" configuration property has not been set
    * @property oNavigator
    * @type CalendarNavigator
    */
    oNavigator : null,

    /**
    * The private list of initially selected dates.
    * @property _selectedDates
    * @private
    * @type Array
    */
    _selectedDates : null,

    /**
    * A map of DOM event handlers to attach to cells associated with specific CSS class names
    * @property domEventMap
    * @type Object
    */
    domEventMap : null,

    _parseArgs : function(args) {
        /*
           2.4.0 Constructors signatures

           new Calendar(String)
           new Calendar(HTMLElement)
           new Calendar(String, ConfigObject)
           new Calendar(HTMLElement, ConfigObject)

           Pre 2.4.0 Constructor signatures

           new Calendar(String, String)
           new Calendar(String, HTMLElement)
           new Calendar(String, String, ConfigObject)
           new Calendar(String, HTMLElement, ConfigObject)
         */
        var nArgs = {id:null, container:null, config:null};

        if (args && args.length && args.length > 0) {
            switch (args.length) {
                case 1:
                    nArgs.id = null;
                    nArgs.container = args[0];
                    nArgs.config = null;
                    break;
                case 2:
                    if (Lang.isObject(args[1]) && !args[1].tagName && !(args[1] instanceof String)) {
                        nArgs.id = null;
                        nArgs.container = args[0];
                        nArgs.config = args[1];
                    } else {
                        nArgs.id = args[0];
                        nArgs.container = args[1];
                        nArgs.config = null;
                    }
                    break;
                default: // 3+
                    nArgs.id = args[0];
                    nArgs.container = args[1];
                    nArgs.config = args[2];
                    break;
            }
        } else {
        }
        return nArgs;
    },

    /**
    * Initializes the Calendar widget.
    * @method init
    *
    * @param {String} id optional The id of the table element that will represent the Calendar widget. As of 2.4.0, this argument is optional.
    * @param {String | HTMLElement} container The id of the container div element that will wrap the Calendar table, or a reference to a DIV element which exists in the document.
    * @param {Object} config optional The configuration object containing the initial configuration values for the Calendar.
    */
    init : function(id, container, config) {
        var nArgs = this._parseArgs(arguments);

        id = nArgs.id;
        container = nArgs.container;
        config = nArgs.config;

        this.oDomContainer = Dom.get(container);

        if (!this.oDomContainer.id) {
            this.oDomContainer.id = Dom.generateId();
        }
        if (!id) {
            id = this.oDomContainer.id + "_t";
        }

        this.id = id;
        this.containerId = this.oDomContainer.id;

        this.initEvents();

        /**
        * The Config object used to hold the configuration variables for the Calendar
        * @property cfg
        * @type YAHOO.util.Config
        */
        this.cfg = new YAHOO.util.Config(this);

        /**
        * The local object which contains the Calendar's options
        * @property Options
        * @type Object
        */
        this.Options = {};

        /**
        * The local object which contains the Calendar's locale settings
        * @property Locale
        * @type Object
        */
        this.Locale = {};

        this.initStyles();

        Dom.addClass(this.oDomContainer, this.Style.CSS_CONTAINER);
        Dom.addClass(this.oDomContainer, this.Style.CSS_SINGLE);

        this.cellDates = [];
        this.cells = [];
        this.renderStack = [];
        this._renderStack = [];

        this.setupConfig();

        if (config) {
            this.cfg.applyConfig(config, true);
        }

        this.cfg.fireQueue();

        this.today = this.cfg.getProperty("today");
    },

    /**
    * Default Config listener for the iframe property. If the iframe config property is set to true,
    * renders the built-in IFRAME shim if the container is relatively or absolutely positioned.
    *
    * @method configIframe
    */
    configIframe : function(type, args, obj) {
        var useIframe = args[0];

        if (!this.parent) {
            if (Dom.inDocument(this.oDomContainer)) {
                if (useIframe) {
                    var pos = Dom.getStyle(this.oDomContainer, "position");

                    if (pos == "absolute" || pos == "relative") {

                        if (!Dom.inDocument(this.iframe)) {
                            this.iframe = document.createElement("iframe");
                            this.iframe.src = "javascript:false;";

                            Dom.setStyle(this.iframe, "opacity", "0");

                            if (YAHOO.env.ua.ie && YAHOO.env.ua.ie <= 6) {
                                Dom.addClass(this.iframe, this.Style.CSS_FIXED_SIZE);
                            }

                            this.oDomContainer.insertBefore(this.iframe, this.oDomContainer.firstChild);
                        }
                    }
                } else {
                    if (this.iframe) {
                        if (this.iframe.parentNode) {
                            this.iframe.parentNode.removeChild(this.iframe);
                        }
                        this.iframe = null;
                    }
                }
            }
        }
    },

    /**
    * Default handler for the "title" property
    * @method configTitle
    */
    configTitle : function(type, args, obj) {
        var title = args[0];

        if (title) {
            this.createTitleBar(title);
        } else {
            var close = this.cfg.getProperty(DEF_CFG.CLOSE.key);
            if (!close) {
                this.removeTitleBar();
            } else {
                this.createTitleBar("&#160;");
            }
        }
    },

    /**
    * Default handler for the "close" property
    * @method configClose
    */
    configClose : function(type, args, obj) {
        var close = args[0],
            title = this.cfg.getProperty(DEF_CFG.TITLE.key);

        if (close) {
            if (!title) {
                this.createTitleBar("&#160;");
            }
            this.createCloseButton();
        } else {
            this.removeCloseButton();
            if (!title) {
                this.removeTitleBar();
            }
        }
    },

    /**
    * Initializes Calendar's built-in CustomEvents
    * @method initEvents
    */
    initEvents : function() {

        var defEvents = Calendar._EVENT_TYPES,
            CE = YAHOO.util.CustomEvent,
            cal = this; // To help with minification

        /**
        * Fired before a date selection is made
        * @event beforeSelectEvent
        */
        cal.beforeSelectEvent = new CE(defEvents.BEFORE_SELECT);

        /**
        * Fired when a date selection is made
        * @event selectEvent
        * @param {Array} Array of Date field arrays in the format [YYYY, MM, DD].
        */
        cal.selectEvent = new CE(defEvents.SELECT);

        /**
        * Fired before a date or set of dates is deselected
        * @event beforeDeselectEvent
        */
        cal.beforeDeselectEvent = new CE(defEvents.BEFORE_DESELECT);

        /**
        * Fired when a date or set of dates is deselected
        * @event deselectEvent
        * @param {Array} Array of Date field arrays in the format [YYYY, MM, DD].
        */
        cal.deselectEvent = new CE(defEvents.DESELECT);

        /**
        * Fired when the Calendar page is changed
        * @event changePageEvent
        * @param {Date} prevDate The date before the page was changed
        * @param {Date} newDate The date after the page was changed
        */
        cal.changePageEvent = new CE(defEvents.CHANGE_PAGE);

        /**
        * Fired before the Calendar is rendered
        * @event beforeRenderEvent
        */
        cal.beforeRenderEvent = new CE(defEvents.BEFORE_RENDER);

        /**
        * Fired when the Calendar is rendered
        * @event renderEvent
        */
        cal.renderEvent = new CE(defEvents.RENDER);

        /**
        * Fired just before the Calendar is to be destroyed
        * @event beforeDestroyEvent
        */
        cal.beforeDestroyEvent = new CE(defEvents.BEFORE_DESTROY);

        /**
        * Fired after the Calendar is destroyed. This event should be used
        * for notification only. When this event is fired, important Calendar instance
        * properties, dom references and event listeners have already been
        * removed/dereferenced, and hence the Calendar instance is not in a usable
        * state.
        *
        * @event destroyEvent
        */
        cal.destroyEvent = new CE(defEvents.DESTROY);

        /**
        * Fired when the Calendar is reset
        * @event resetEvent
        */
        cal.resetEvent = new CE(defEvents.RESET);

        /**
        * Fired when the Calendar is cleared
        * @event clearEvent
        */
        cal.clearEvent = new CE(defEvents.CLEAR);

        /**
        * Fired just before the Calendar is to be shown
        * @event beforeShowEvent
        */
        cal.beforeShowEvent = new CE(defEvents.BEFORE_SHOW);

        /**
        * Fired after the Calendar is shown
        * @event showEvent
        */
        cal.showEvent = new CE(defEvents.SHOW);

        /**
        * Fired just before the Calendar is to be hidden
        * @event beforeHideEvent
        */
        cal.beforeHideEvent = new CE(defEvents.BEFORE_HIDE);

        /**
        * Fired after the Calendar is hidden
        * @event hideEvent
        */
        cal.hideEvent = new CE(defEvents.HIDE);

        /**
        * Fired just before the CalendarNavigator is to be shown
        * @event beforeShowNavEvent
        */
        cal.beforeShowNavEvent = new CE(defEvents.BEFORE_SHOW_NAV);

        /**
        * Fired after the CalendarNavigator is shown
        * @event showNavEvent
        */
        cal.showNavEvent = new CE(defEvents.SHOW_NAV);

        /**
        * Fired just before the CalendarNavigator is to be hidden
        * @event beforeHideNavEvent
        */
        cal.beforeHideNavEvent = new CE(defEvents.BEFORE_HIDE_NAV);

        /**
        * Fired after the CalendarNavigator is hidden
        * @event hideNavEvent
        */
        cal.hideNavEvent = new CE(defEvents.HIDE_NAV);

        /**
        * Fired just before the CalendarNavigator is to be rendered
        * @event beforeRenderNavEvent
        */
        cal.beforeRenderNavEvent = new CE(defEvents.BEFORE_RENDER_NAV);

        /**
        * Fired after the CalendarNavigator is rendered
        * @event renderNavEvent
        */
        cal.renderNavEvent = new CE(defEvents.RENDER_NAV);

        cal.beforeSelectEvent.subscribe(cal.onBeforeSelect, this, true);
        cal.selectEvent.subscribe(cal.onSelect, this, true);
        cal.beforeDeselectEvent.subscribe(cal.onBeforeDeselect, this, true);
        cal.deselectEvent.subscribe(cal.onDeselect, this, true);
        cal.changePageEvent.subscribe(cal.onChangePage, this, true);
        cal.renderEvent.subscribe(cal.onRender, this, true);
        cal.resetEvent.subscribe(cal.onReset, this, true);
        cal.clearEvent.subscribe(cal.onClear, this, true);
    },

    /**
    * The default event handler for clicks on the "Previous Month" navigation UI
    *
    * @method doPreviousMonthNav
    * @param {DOMEvent} e The DOM event
    * @param {Calendar} cal A reference to the calendar
    */
    doPreviousMonthNav : function(e, cal) {
        Event.preventDefault(e);
        setTimeout(function() {
            cal.previousMonth();
            var navs = Dom.getElementsByClassName(cal.Style.CSS_NAV_LEFT, "a", cal.oDomContainer);
            if (navs && navs[0]) {
                try {
                    navs[0].focus();
                } catch (ex) {
                }
            }
        }, 0);
    },

    /**
     * The default event handler for clicks on the "Next Month" navigation UI
     *
     * @method doNextMonthNav
     * @param {DOMEvent} e The DOM event
     * @param {Calendar} cal A reference to the calendar
     */
    doNextMonthNav : function(e, cal) {
        Event.preventDefault(e);
        setTimeout(function() {
            cal.nextMonth();
            var navs = Dom.getElementsByClassName(cal.Style.CSS_NAV_RIGHT, "a", cal.oDomContainer);
            if (navs && navs[0]) {
                try {
                    navs[0].focus();
                } catch (ex) {
                }
            }
        }, 0);
    },

    /**
    * The default event handler for date cell selection. Currently attached to
    * the Calendar's bounding box, referenced by it's <a href="#property_oDomContainer">oDomContainer</a> property.
    *
    * @method doSelectCell
    * @param {DOMEvent} e The DOM event
    * @param {Calendar} cal A reference to the calendar
    */
    doSelectCell : function(e, cal) {
        var cell, d, date, index;

        var target = Event.getTarget(e),
            tagName = target.tagName.toLowerCase(),
            defSelector = false;

        while (tagName != "td" && !Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {

            if (!defSelector && tagName == "a" && Dom.hasClass(target, cal.Style.CSS_CELL_SELECTOR)) {
                defSelector = true;
            }

            target = target.parentNode;
            tagName = target.tagName.toLowerCase();

            if (target == this.oDomContainer || tagName == "html") {
                return;
            }
        }

        if (defSelector) {
            Event.preventDefault(e);
        }

        cell = target;

        if (Dom.hasClass(cell, cal.Style.CSS_CELL_SELECTABLE)) {
            index = cal.getIndexFromId(cell.id);
            if (index > -1) {
                d = cal.cellDates[index];
                if (d) {
                    date = DateMath.getDate(d[0],d[1]-1,d[2]);

                    var link;

                    if (cal.Options.MULTI_SELECT) {
                        link = cell.getElementsByTagName("a")[0];
                        if (link) {
                            link.blur();
                        }

                        var cellDate = cal.cellDates[index];
                        var cellDateIndex = cal._indexOfSelectedFieldArray(cellDate);

                        if (cellDateIndex > -1) {
                            cal.deselectCell(index);
                        } else {
                            cal.selectCell(index);
                        }

                    } else {
                        link = cell.getElementsByTagName("a")[0];
                        if (link) {
                            link.blur();
                        }
                        cal.selectCell(index);
                    }
                }
            }
        }
    },

    /**
    * The event that is executed when the user hovers over a cell
    * @method doCellMouseOver
    * @param {DOMEvent} e The event
    * @param {Calendar} cal A reference to the calendar passed by the Event utility
    */
    doCellMouseOver : function(e, cal) {
        var target;
        if (e) {
            target = Event.getTarget(e);
        } else {
            target = this;
        }

        while (target.tagName && target.tagName.toLowerCase() != "td") {
            target = target.parentNode;
            if (!target.tagName || target.tagName.toLowerCase() == "html") {
                return;
            }
        }

        if (Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {
            Dom.addClass(target, cal.Style.CSS_CELL_HOVER);
        }
    },

    /**
    * The event that is executed when the user moves the mouse out of a cell
    * @method doCellMouseOut
    * @param {DOMEvent} e The event
    * @param {Calendar} cal A reference to the calendar passed by the Event utility
    */
    doCellMouseOut : function(e, cal) {
        var target;
        if (e) {
            target = Event.getTarget(e);
        } else {
            target = this;
        }

        while (target.tagName && target.tagName.toLowerCase() != "td") {
            target = target.parentNode;
            if (!target.tagName || target.tagName.toLowerCase() == "html") {
                return;
            }
        }

        if (Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {
            Dom.removeClass(target, cal.Style.CSS_CELL_HOVER);
        }
    },

    setupConfig : function() {

        var cfg = this.cfg;

        /**
        * The date to use to represent "Today".
        *
        * @config today
        * @type Date
        * @default The client side date (new Date()) when the Calendar is instantiated.
        */
        cfg.addProperty(DEF_CFG.TODAY.key, { value: new Date(DEF_CFG.TODAY.value.getTime()), supercedes:DEF_CFG.TODAY.supercedes, handler:this.configToday, suppressEvent:true } );

        /**
        * The month/year representing the current visible Calendar date (mm/yyyy)
        * @config pagedate
        * @type String | Date
        * @default Today's date
        */
        cfg.addProperty(DEF_CFG.PAGEDATE.key, { value: DEF_CFG.PAGEDATE.value || new Date(DEF_CFG.TODAY.value.getTime()), handler:this.configPageDate } );

        /**
        * The date or range of dates representing the current Calendar selection
        * @config selected
        * @type String
        * @default []
        */
        cfg.addProperty(DEF_CFG.SELECTED.key, { value:DEF_CFG.SELECTED.value.concat(), handler:this.configSelected } );

        /**
        * The title to display above the Calendar's month header
        * @config title
        * @type String
        * @default ""
        */
        cfg.addProperty(DEF_CFG.TITLE.key, { value:DEF_CFG.TITLE.value, handler:this.configTitle } );

        /**
        * Whether or not a close button should be displayed for this Calendar
        * @config close
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.CLOSE.key, { value:DEF_CFG.CLOSE.value, handler:this.configClose } );

        /**
        * Whether or not an iframe shim should be placed under the Calendar to prevent select boxes from bleeding through in Internet Explorer 6 and below.
        * This property is enabled by default for IE6 and below. It is disabled by default for other browsers for performance reasons, but can be
        * enabled if required.
        *
        * @config iframe
        * @type Boolean
        * @default true for IE6 and below, false for all other browsers
        */
        cfg.addProperty(DEF_CFG.IFRAME.key, { value:DEF_CFG.IFRAME.value, handler:this.configIframe, validator:cfg.checkBoolean } );

        /**
        * The minimum selectable date in the current Calendar (mm/dd/yyyy)
        * @config mindate
        * @type String | Date
        * @default null
        */
        cfg.addProperty(DEF_CFG.MINDATE.key, { value:DEF_CFG.MINDATE.value, handler:this.configMinDate } );

        /**
        * The maximum selectable date in the current Calendar (mm/dd/yyyy)
        * @config maxdate
        * @type String | Date
        * @default null
        */
        cfg.addProperty(DEF_CFG.MAXDATE.key, { value:DEF_CFG.MAXDATE.value, handler:this.configMaxDate } );


        /**
        * True if the Calendar should allow multiple selections. False by default.
        * @config MULTI_SELECT
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.MULTI_SELECT.key, { value:DEF_CFG.MULTI_SELECT.value, handler:this.configOptions, validator:cfg.checkBoolean } );

        /**
        * The weekday the week begins on. Default is 0 (Sunday = 0, Monday = 1 ... Saturday = 6).
        * @config START_WEEKDAY
        * @type number
        * @default 0
        */
        cfg.addProperty(DEF_CFG.START_WEEKDAY.key, { value:DEF_CFG.START_WEEKDAY.value, handler:this.configOptions, validator:cfg.checkNumber  } );

        /**
        * True if the Calendar should show weekday labels. True by default.
        * @config SHOW_WEEKDAYS
        * @type Boolean
        * @default true
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEKDAYS.key, { value:DEF_CFG.SHOW_WEEKDAYS.value, handler:this.configOptions, validator:cfg.checkBoolean  } );

        /**
        * True if the Calendar should show week row headers. False by default.
        * @config SHOW_WEEK_HEADER
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEK_HEADER.key, { value:DEF_CFG.SHOW_WEEK_HEADER.value, handler:this.configOptions, validator:cfg.checkBoolean } );

        /**
        * True if the Calendar should show week row footers. False by default.
        * @config SHOW_WEEK_FOOTER
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEK_FOOTER.key,{ value:DEF_CFG.SHOW_WEEK_FOOTER.value, handler:this.configOptions, validator:cfg.checkBoolean } );

        /**
        * True if the Calendar should suppress weeks that are not a part of the current month. False by default.
        * @config HIDE_BLANK_WEEKS
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.HIDE_BLANK_WEEKS.key, { value:DEF_CFG.HIDE_BLANK_WEEKS.value, handler:this.configOptions, validator:cfg.checkBoolean } );

        /**
        * The image that should be used for the left navigation arrow.
        * @config NAV_ARROW_LEFT
        * @type String
        * @deprecated You can customize the image by overriding the default CSS class for the left arrow - "calnavleft"
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV_ARROW_LEFT.key, { value:DEF_CFG.NAV_ARROW_LEFT.value, handler:this.configOptions } );

        /**
        * The image that should be used for the right navigation arrow.
        * @config NAV_ARROW_RIGHT
        * @type String
        * @deprecated You can customize the image by overriding the default CSS class for the right arrow - "calnavright"
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV_ARROW_RIGHT.key, { value:DEF_CFG.NAV_ARROW_RIGHT.value, handler:this.configOptions } );


        /**
        * The short month labels for the current locale.
        * @config MONTHS_SHORT
        * @type String[]
        * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        */
        cfg.addProperty(DEF_CFG.MONTHS_SHORT.key, { value:DEF_CFG.MONTHS_SHORT.value, handler:this.configLocale } );

        /**
        * The long month labels for the current locale.
        * @config MONTHS_LONG
        * @type String[]
        * @default ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
        */
        cfg.addProperty(DEF_CFG.MONTHS_LONG.key,  { value:DEF_CFG.MONTHS_LONG.value, handler:this.configLocale } );

        /**
        * The 1-character weekday labels for the current locale.
        * @config WEEKDAYS_1CHAR
        * @type String[]
        * @default ["S", "M", "T", "W", "T", "F", "S"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_1CHAR.key, { value:DEF_CFG.WEEKDAYS_1CHAR.value, handler:this.configLocale } );

        /**
        * The short weekday labels for the current locale.
        * @config WEEKDAYS_SHORT
        * @type String[]
        * @default ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_SHORT.key, { value:DEF_CFG.WEEKDAYS_SHORT.value, handler:this.configLocale } );

        /**
        * The medium weekday labels for the current locale.
        * @config WEEKDAYS_MEDIUM
        * @type String[]
        * @default ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_MEDIUM.key, { value:DEF_CFG.WEEKDAYS_MEDIUM.value, handler:this.configLocale } );

        /**
        * The long weekday labels for the current locale.
        * @config WEEKDAYS_LONG
        * @type String[]
        * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_LONG.key, { value:DEF_CFG.WEEKDAYS_LONG.value, handler:this.configLocale } );

        /**
        * Refreshes the locale values used to build the Calendar.
        * @method refreshLocale
        * @private
        */
        var refreshLocale = function() {
            cfg.refireEvent(DEF_CFG.LOCALE_MONTHS.key);
            cfg.refireEvent(DEF_CFG.LOCALE_WEEKDAYS.key);
        };

        cfg.subscribeToConfigEvent(DEF_CFG.START_WEEKDAY.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.MONTHS_SHORT.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.MONTHS_LONG.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.WEEKDAYS_1CHAR.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.WEEKDAYS_SHORT.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.WEEKDAYS_MEDIUM.key, refreshLocale, this, true);
        cfg.subscribeToConfigEvent(DEF_CFG.WEEKDAYS_LONG.key, refreshLocale, this, true);

        /**
        * The setting that determines which length of month labels should be used. Possible values are "short" and "long".
        * @config LOCALE_MONTHS
        * @type String
        * @default "long"
        */
        cfg.addProperty(DEF_CFG.LOCALE_MONTHS.key, { value:DEF_CFG.LOCALE_MONTHS.value, handler:this.configLocaleValues } );

        /**
        * The setting that determines which length of weekday labels should be used. Possible values are "1char", "short", "medium", and "long".
        * @config LOCALE_WEEKDAYS
        * @type String
        * @default "short"
        */
        cfg.addProperty(DEF_CFG.LOCALE_WEEKDAYS.key, { value:DEF_CFG.LOCALE_WEEKDAYS.value, handler:this.configLocaleValues } );

        /**
        * The positive or negative year offset from the Gregorian calendar year (assuming a January 1st rollover) to
        * be used when displaying and parsing dates. NOTE: All JS Date objects returned by methods, or expected as input by
        * methods will always represent the Gregorian year, in order to maintain date/month/week values.
        *
        * @config YEAR_OFFSET
        * @type Number
        * @default 0
        */
        cfg.addProperty(DEF_CFG.YEAR_OFFSET.key, { value:DEF_CFG.YEAR_OFFSET.value, supercedes:DEF_CFG.YEAR_OFFSET.supercedes, handler:this.configLocale  } );

        /**
        * The value used to delimit individual dates in a date string passed to various Calendar functions.
        * @config DATE_DELIMITER
        * @type String
        * @default ","
        */
        cfg.addProperty(DEF_CFG.DATE_DELIMITER.key,  { value:DEF_CFG.DATE_DELIMITER.value, handler:this.configLocale } );

        /**
        * The value used to delimit date fields in a date string passed to various Calendar functions.
        * @config DATE_FIELD_DELIMITER
        * @type String
        * @default "/"
        */
        cfg.addProperty(DEF_CFG.DATE_FIELD_DELIMITER.key, { value:DEF_CFG.DATE_FIELD_DELIMITER.value, handler:this.configLocale } );

        /**
        * The value used to delimit date ranges in a date string passed to various Calendar functions.
        * @config DATE_RANGE_DELIMITER
        * @type String
        * @default "-"
        */
        cfg.addProperty(DEF_CFG.DATE_RANGE_DELIMITER.key, { value:DEF_CFG.DATE_RANGE_DELIMITER.value, handler:this.configLocale } );

        /**
        * The position of the month in a month/year date string
        * @config MY_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MY_MONTH_POSITION.key, { value:DEF_CFG.MY_MONTH_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the year in a month/year date string
        * @config MY_YEAR_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MY_YEAR_POSITION.key, { value:DEF_CFG.MY_YEAR_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the month in a month/day date string
        * @config MD_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MD_MONTH_POSITION.key, { value:DEF_CFG.MD_MONTH_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the day in a month/year date string
        * @config MD_DAY_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MD_DAY_POSITION.key,  { value:DEF_CFG.MD_DAY_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the month in a month/day/year date string
        * @config MDY_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MDY_MONTH_POSITION.key, { value:DEF_CFG.MDY_MONTH_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the day in a month/day/year date string
        * @config MDY_DAY_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MDY_DAY_POSITION.key, { value:DEF_CFG.MDY_DAY_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the year in a month/day/year date string
        * @config MDY_YEAR_POSITION
        * @type Number
        * @default 3
        */
        cfg.addProperty(DEF_CFG.MDY_YEAR_POSITION.key, { value:DEF_CFG.MDY_YEAR_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the month in the month year label string used as the Calendar header
        * @config MY_LABEL_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_MONTH_POSITION.key, { value:DEF_CFG.MY_LABEL_MONTH_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The position of the year in the month year label string used as the Calendar header
        * @config MY_LABEL_YEAR_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_YEAR_POSITION.key, { value:DEF_CFG.MY_LABEL_YEAR_POSITION.value, handler:this.configLocale, validator:cfg.checkNumber } );

        /**
        * The suffix used after the month when rendering the Calendar header
        * @config MY_LABEL_MONTH_SUFFIX
        * @type String
        * @default " "
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_MONTH_SUFFIX.key, { value:DEF_CFG.MY_LABEL_MONTH_SUFFIX.value, handler:this.configLocale } );

        /**
        * The suffix used after the year when rendering the Calendar header
        * @config MY_LABEL_YEAR_SUFFIX
        * @type String
        * @default ""
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_YEAR_SUFFIX.key, { value:DEF_CFG.MY_LABEL_YEAR_SUFFIX.value, handler:this.configLocale } );

        /**
        * Configuration for the Month/Year CalendarNavigator UI which allows the user to jump directly to a
        * specific Month/Year without having to scroll sequentially through months.
        * <p>
        * Setting this property to null (default value) or false, will disable the CalendarNavigator UI.
        * </p>
        * <p>
        * Setting this property to true will enable the CalendarNavigatior UI with the default CalendarNavigator configuration values.
        * </p>
        * <p>
        * This property can also be set to an object literal containing configuration properties for the CalendarNavigator UI.
        * The configuration object expects the the following case-sensitive properties, with the "strings" property being a nested object.
        * Any properties which are not provided will use the default values (defined in the CalendarNavigator class).
        * </p>
        * <dl>
        * <dt>strings</dt>
        * <dd><em>Object</em> :  An object with the properties shown below, defining the string labels to use in the Navigator's UI
        *     <dl>
        *         <dt>month</dt><dd><em>String</em> : The string to use for the month label. Defaults to "Month".</dd>
        *         <dt>year</dt><dd><em>String</em> : The string to use for the year label. Defaults to "Year".</dd>
        *         <dt>submit</dt><dd><em>String</em> : The string to use for the submit button label. Defaults to "Okay".</dd>
        *         <dt>cancel</dt><dd><em>String</em> : The string to use for the cancel button label. Defaults to "Cancel".</dd>
        *         <dt>invalidYear</dt><dd><em>String</em> : The string to use for invalid year values. Defaults to "Year needs to be a number".</dd>
        *     </dl>
        * </dd>
        * <dt>monthFormat</dt><dd><em>String</em> : The month format to use. Either YAHOO.widget.Calendar.LONG, or YAHOO.widget.Calendar.SHORT. Defaults to YAHOO.widget.Calendar.LONG</dd>
        * <dt>initialFocus</dt><dd><em>String</em> : Either "year" or "month" specifying which input control should get initial focus. Defaults to "year"</dd>
        * </dl>
        * <p>E.g.</p>
        * <pre>
        * var navConfig = {
        *   strings: {
        *    month:"Calendar Month",
        *    year:"Calendar Year",
        *    submit: "Submit",
        *    cancel: "Cancel",
        *    invalidYear: "Please enter a valid year"
        *   },
        *   monthFormat: YAHOO.widget.Calendar.SHORT,
        *   initialFocus: "month"
        * }
        * </pre>
        * @config navigator
        * @type {Object|Boolean}
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV.key, { value:DEF_CFG.NAV.value, handler:this.configNavigator } );

        /**
         * The map of UI strings which the Calendar UI uses.
         *
         * @config strings
         * @type {Object}
         * @default An object with the properties shown below:
         *     <dl>
         *         <dt>previousMonth</dt><dd><em>String</em> : The string to use for the "Previous Month" navigation UI. Defaults to "Previous Month".</dd>
         *         <dt>nextMonth</dt><dd><em>String</em> : The string to use for the "Next Month" navigation UI. Defaults to "Next Month".</dd>
         *         <dt>close</dt><dd><em>String</em> : The string to use for the close button label. Defaults to "Close".</dd>
         *     </dl>
         */
        cfg.addProperty(DEF_CFG.STRINGS.key, {
            value:DEF_CFG.STRINGS.value,
            handler:this.configStrings,
            validator: function(val) {
                return Lang.isObject(val);
            },
            supercedes:DEF_CFG.STRINGS.supercedes
        });
    },

    /**
    * The default handler for the "strings" property
    * @method configStrings
    */
    configStrings : function(type, args, obj) {
        var val = Lang.merge(DEF_CFG.STRINGS.value, args[0]);
        this.cfg.setProperty(DEF_CFG.STRINGS.key, val, true);
    },

    /**
    * The default handler for the "pagedate" property
    * @method configPageDate
    */
    configPageDate : function(type, args, obj) {
        this.cfg.setProperty(DEF_CFG.PAGEDATE.key, this._parsePageDate(args[0]), true);
    },

    /**
    * The default handler for the "mindate" property
    * @method configMinDate
    */
    configMinDate : function(type, args, obj) {
        var val = args[0];
        if (Lang.isString(val)) {
            val = this._parseDate(val);
            this.cfg.setProperty(DEF_CFG.MINDATE.key, DateMath.getDate(val[0],(val[1]-1),val[2]));
        }
    },

    /**
    * The default handler for the "maxdate" property
    * @method configMaxDate
    */
    configMaxDate : function(type, args, obj) {
        var val = args[0];
        if (Lang.isString(val)) {
            val = this._parseDate(val);
            this.cfg.setProperty(DEF_CFG.MAXDATE.key, DateMath.getDate(val[0],(val[1]-1),val[2]));
        }
    },

    /**
    * The default handler for the "today" property
    * @method configToday
    */
    configToday : function(type, args, obj) {
        var val = args[0];
        if (Lang.isString(val)) {
            val = this._parseDate(val);
        }
        var today = DateMath.clearTime(val);
        if (!this.cfg.initialConfig[DEF_CFG.PAGEDATE.key]) {
            this.cfg.setProperty(DEF_CFG.PAGEDATE.key, today);
        }
        this.today = today;
        this.cfg.setProperty(DEF_CFG.TODAY.key, today, true);
    },

    /**
    * The default handler for the "selected" property
    * @method configSelected
    */
    configSelected : function(type, args, obj) {
        var selected = args[0],
            cfgSelected = DEF_CFG.SELECTED.key;

        if (selected) {
            if (Lang.isString(selected)) {
                this.cfg.setProperty(cfgSelected, this._parseDates(selected), true);
            }
        }
        if (! this._selectedDates) {
            this._selectedDates = this.cfg.getProperty(cfgSelected);
        }
    },

    /**
    * The default handler for all configuration options properties
    * @method configOptions
    */
    configOptions : function(type, args, obj) {
        this.Options[type.toUpperCase()] = args[0];
    },

    /**
    * The default handler for all configuration locale properties
    * @method configLocale
    */
    configLocale : function(type, args, obj) {
        this.Locale[type.toUpperCase()] = args[0];

        this.cfg.refireEvent(DEF_CFG.LOCALE_MONTHS.key);
        this.cfg.refireEvent(DEF_CFG.LOCALE_WEEKDAYS.key);
    },

    /**
    * The default handler for all configuration locale field length properties
    * @method configLocaleValues
    */
    configLocaleValues : function(type, args, obj) {

        type = type.toLowerCase();

        var val = args[0],
            cfg = this.cfg,
            Locale = this.Locale;

        switch (type) {
            case DEF_CFG.LOCALE_MONTHS.key:
                switch (val) {
                    case Calendar.SHORT:
                        Locale.LOCALE_MONTHS = cfg.getProperty(DEF_CFG.MONTHS_SHORT.key).concat();
                        break;
                    case Calendar.LONG:
                        Locale.LOCALE_MONTHS = cfg.getProperty(DEF_CFG.MONTHS_LONG.key).concat();
                        break;
                }
                break;
            case DEF_CFG.LOCALE_WEEKDAYS.key:
                switch (val) {
                    case Calendar.ONE_CHAR:
                        Locale.LOCALE_WEEKDAYS = cfg.getProperty(DEF_CFG.WEEKDAYS_1CHAR.key).concat();
                        break;
                    case Calendar.SHORT:
                        Locale.LOCALE_WEEKDAYS = cfg.getProperty(DEF_CFG.WEEKDAYS_SHORT.key).concat();
                        break;
                    case Calendar.MEDIUM:
                        Locale.LOCALE_WEEKDAYS = cfg.getProperty(DEF_CFG.WEEKDAYS_MEDIUM.key).concat();
                        break;
                    case Calendar.LONG:
                        Locale.LOCALE_WEEKDAYS = cfg.getProperty(DEF_CFG.WEEKDAYS_LONG.key).concat();
                        break;
                }

                var START_WEEKDAY = cfg.getProperty(DEF_CFG.START_WEEKDAY.key);

                if (START_WEEKDAY > 0) {
                    for (var w=0; w < START_WEEKDAY; ++w) {
                        Locale.LOCALE_WEEKDAYS.push(Locale.LOCALE_WEEKDAYS.shift());
                    }
                }
                break;
        }
    },

    /**
     * The default handler for the "navigator" property
     * @method configNavigator
     */
    configNavigator : function(type, args, obj) {
        var val = args[0];
        if (YAHOO.widget.CalendarNavigator && (val === true || Lang.isObject(val))) {
            if (!this.oNavigator) {
                this.oNavigator = new YAHOO.widget.CalendarNavigator(this);
                this.beforeRenderEvent.subscribe(function () {
                    if (!this.pages) {
                        this.oNavigator.erase();
                    }
                }, this, true);
            }
        } else {
            if (this.oNavigator) {
                this.oNavigator.destroy();
                this.oNavigator = null;
            }
        }
    },

    /**
    * Defines the style constants for the Calendar
    * @method initStyles
    */
    initStyles : function() {

        var defStyle = Calendar.STYLES;

        this.Style = {
            /**
            * @property Style.CSS_ROW_HEADER
            */
            CSS_ROW_HEADER: defStyle.CSS_ROW_HEADER,
            /**
            * @property Style.CSS_ROW_FOOTER
            */
            CSS_ROW_FOOTER: defStyle.CSS_ROW_FOOTER,
            /**
            * @property Style.CSS_CELL
            */
            CSS_CELL : defStyle.CSS_CELL,
            /**
            * @property Style.CSS_CELL_SELECTOR
            */
            CSS_CELL_SELECTOR : defStyle.CSS_CELL_SELECTOR,
            /**
            * @property Style.CSS_CELL_SELECTED
            */
            CSS_CELL_SELECTED : defStyle.CSS_CELL_SELECTED,
            /**
            * @property Style.CSS_CELL_SELECTABLE
            */
            CSS_CELL_SELECTABLE : defStyle.CSS_CELL_SELECTABLE,
            /**
            * @property Style.CSS_CELL_RESTRICTED
            */
            CSS_CELL_RESTRICTED : defStyle.CSS_CELL_RESTRICTED,
            /**
            * @property Style.CSS_CELL_TODAY
            */
            CSS_CELL_TODAY : defStyle.CSS_CELL_TODAY,
            /**
            * @property Style.CSS_CELL_OOM
            */
            CSS_CELL_OOM : defStyle.CSS_CELL_OOM,
            /**
            * @property Style.CSS_CELL_OOB
            */
            CSS_CELL_OOB : defStyle.CSS_CELL_OOB,
            /**
            * @property Style.CSS_HEADER
            */
            CSS_HEADER : defStyle.CSS_HEADER,
            /**
            * @property Style.CSS_HEADER_TEXT
            */
            CSS_HEADER_TEXT : defStyle.CSS_HEADER_TEXT,
            /**
            * @property Style.CSS_BODY
            */
            CSS_BODY : defStyle.CSS_BODY,
            /**
            * @property Style.CSS_WEEKDAY_CELL
            */
            CSS_WEEKDAY_CELL : defStyle.CSS_WEEKDAY_CELL,
            /**
            * @property Style.CSS_WEEKDAY_ROW
            */
            CSS_WEEKDAY_ROW : defStyle.CSS_WEEKDAY_ROW,
            /**
            * @property Style.CSS_FOOTER
            */
            CSS_FOOTER : defStyle.CSS_FOOTER,
            /**
            * @property Style.CSS_CALENDAR
            */
            CSS_CALENDAR : defStyle.CSS_CALENDAR,
            /**
            * @property Style.CSS_SINGLE
            */
            CSS_SINGLE : defStyle.CSS_SINGLE,
            /**
            * @property Style.CSS_CONTAINER
            */
            CSS_CONTAINER : defStyle.CSS_CONTAINER,
            /**
            * @property Style.CSS_NAV_LEFT
            */
            CSS_NAV_LEFT : defStyle.CSS_NAV_LEFT,
            /**
            * @property Style.CSS_NAV_RIGHT
            */
            CSS_NAV_RIGHT : defStyle.CSS_NAV_RIGHT,
            /**
            * @property Style.CSS_NAV
            */
            CSS_NAV : defStyle.CSS_NAV,
            /**
            * @property Style.CSS_CLOSE
            */
            CSS_CLOSE : defStyle.CSS_CLOSE,
            /**
            * @property Style.CSS_CELL_TOP
            */
            CSS_CELL_TOP : defStyle.CSS_CELL_TOP,
            /**
            * @property Style.CSS_CELL_LEFT
            */
            CSS_CELL_LEFT : defStyle.CSS_CELL_LEFT,
            /**
            * @property Style.CSS_CELL_RIGHT
            */
            CSS_CELL_RIGHT : defStyle.CSS_CELL_RIGHT,
            /**
            * @property Style.CSS_CELL_BOTTOM
            */
            CSS_CELL_BOTTOM : defStyle.CSS_CELL_BOTTOM,
            /**
            * @property Style.CSS_CELL_HOVER
            */
            CSS_CELL_HOVER : defStyle.CSS_CELL_HOVER,
            /**
            * @property Style.CSS_CELL_HIGHLIGHT1
            */
            CSS_CELL_HIGHLIGHT1 : defStyle.CSS_CELL_HIGHLIGHT1,
            /**
            * @property Style.CSS_CELL_HIGHLIGHT2
            */
            CSS_CELL_HIGHLIGHT2 : defStyle.CSS_CELL_HIGHLIGHT2,
            /**
            * @property Style.CSS_CELL_HIGHLIGHT3
            */
            CSS_CELL_HIGHLIGHT3 : defStyle.CSS_CELL_HIGHLIGHT3,
            /**
            * @property Style.CSS_CELL_HIGHLIGHT4
            */
            CSS_CELL_HIGHLIGHT4 : defStyle.CSS_CELL_HIGHLIGHT4,
            /**
             * @property Style.CSS_WITH_TITLE
             */
            CSS_WITH_TITLE : defStyle.CSS_WITH_TITLE,
             /**
             * @property Style.CSS_FIXED_SIZE
             */
            CSS_FIXED_SIZE : defStyle.CSS_FIXED_SIZE,
             /**
             * @property Style.CSS_LINK_CLOSE
             */
            CSS_LINK_CLOSE : defStyle.CSS_LINK_CLOSE
        };
    },

    /**
    * Builds the date label that will be displayed in the calendar header or
    * footer, depending on configuration.
    * @method buildMonthLabel
    * @return {String} The formatted calendar month label
    */
    buildMonthLabel : function() {
        return this._buildMonthLabel(this.cfg.getProperty(DEF_CFG.PAGEDATE.key));
    },

    /**
     * Helper method, to format a Month Year string, given a JavaScript Date, based on the
     * Calendar localization settings
     *
     * @method _buildMonthLabel
     * @private
     * @param {Date} date
     * @return {String} Formated month, year string
     */
    _buildMonthLabel : function(date) {
        var monthLabel  = this.Locale.LOCALE_MONTHS[date.getMonth()] + this.Locale.MY_LABEL_MONTH_SUFFIX,
            yearLabel = (date.getFullYear() + this.Locale.YEAR_OFFSET) + this.Locale.MY_LABEL_YEAR_SUFFIX;

        if (this.Locale.MY_LABEL_MONTH_POSITION == 2 || this.Locale.MY_LABEL_YEAR_POSITION == 1) {
            return yearLabel + monthLabel;
        } else {
            return monthLabel + yearLabel;
        }
    },

    /**
    * Builds the date digit that will be displayed in calendar cells
    * @method buildDayLabel
    * @param {Date} workingDate The current working date
    * @return {String} The formatted day label
    */
    buildDayLabel : function(workingDate) {
        return workingDate.getDate();
    },

    /**
     * Creates the title bar element and adds it to Calendar container DIV
     *
     * @method createTitleBar
     * @param {String} strTitle The title to display in the title bar
     * @return The title bar element
     */
    createTitleBar : function(strTitle) {
        var tDiv = Dom.getElementsByClassName(YAHOO.widget.CalendarGroup.CSS_2UPTITLE, "div", this.oDomContainer)[0] || document.createElement("div");
        tDiv.className = YAHOO.widget.CalendarGroup.CSS_2UPTITLE;
        tDiv.innerHTML = strTitle;
        this.oDomContainer.insertBefore(tDiv, this.oDomContainer.firstChild);

        Dom.addClass(this.oDomContainer, this.Style.CSS_WITH_TITLE);

        return tDiv;
    },

    /**
     * Removes the title bar element from the DOM
     *
     * @method removeTitleBar
     */
    removeTitleBar : function() {
        var tDiv = Dom.getElementsByClassName(YAHOO.widget.CalendarGroup.CSS_2UPTITLE, "div", this.oDomContainer)[0] || null;
        if (tDiv) {
            Event.purgeElement(tDiv);
            this.oDomContainer.removeChild(tDiv);
        }
        Dom.removeClass(this.oDomContainer, this.Style.CSS_WITH_TITLE);
    },

    /**
     * Creates the close button HTML element and adds it to Calendar container DIV
     *
     * @method createCloseButton
     * @return The close HTML element created
     */
    createCloseButton : function() {
        var cssClose = YAHOO.widget.CalendarGroup.CSS_2UPCLOSE,
            cssLinkClose = this.Style.CSS_LINK_CLOSE,
            DEPR_CLOSE_PATH = "us/my/bn/x_d.gif",

            lnk = Dom.getElementsByClassName(cssLinkClose, "a", this.oDomContainer)[0],
            strings = this.cfg.getProperty(DEF_CFG.STRINGS.key),
            closeStr = (strings && strings.close) ? strings.close : "";

        if (!lnk) {
            lnk = document.createElement("a");
            Event.addListener(lnk, "click", function(e, cal) {
                cal.hide();
                Event.preventDefault(e);
            }, this);
        }

        lnk.href = "#";
        lnk.className = cssLinkClose;

        if (Calendar.IMG_ROOT !== null) {
            var img = Dom.getElementsByClassName(cssClose, "img", lnk)[0] || document.createElement("img");
            img.src = Calendar.IMG_ROOT + DEPR_CLOSE_PATH;
            img.className = cssClose;
            lnk.appendChild(img);
        } else {
            lnk.innerHTML = '<span class="' + cssClose + ' ' + this.Style.CSS_CLOSE + '">' + closeStr + '</span>';
        }
        this.oDomContainer.appendChild(lnk);

        return lnk;
    },

    /**
     * Removes the close button HTML element from the DOM
     *
     * @method removeCloseButton
     */
    removeCloseButton : function() {
        var btn = Dom.getElementsByClassName(this.Style.CSS_LINK_CLOSE, "a", this.oDomContainer)[0] || null;
        if (btn) {
            Event.purgeElement(btn);
            this.oDomContainer.removeChild(btn);
        }
    },

    /**
    * Renders the calendar header.
    * @method renderHeader
    * @param {Array} html The current working HTML array
    * @return {Array} The current working HTML array
    */
    renderHeader : function(html) {


        var colSpan = 7,
            DEPR_NAV_LEFT = "us/tr/callt.gif",
            DEPR_NAV_RIGHT = "us/tr/calrt.gif",
            cfg = this.cfg,
            pageDate = cfg.getProperty(DEF_CFG.PAGEDATE.key),
            strings= cfg.getProperty(DEF_CFG.STRINGS.key),
            prevStr = (strings && strings.previousMonth) ?  strings.previousMonth : "",
            nextStr = (strings && strings.nextMonth) ? strings.nextMonth : "",
            monthLabel;

        if (cfg.getProperty(DEF_CFG.SHOW_WEEK_HEADER.key)) {
            colSpan += 1;
        }

        if (cfg.getProperty(DEF_CFG.SHOW_WEEK_FOOTER.key)) {
            colSpan += 1;
        }

        html[html.length] = "<thead>";
        html[html.length] =  "<tr>";
        html[html.length] =   '<th colspan="' + colSpan + '" class="' + this.Style.CSS_HEADER_TEXT + '">';
        html[html.length] =    '<div class="' + this.Style.CSS_HEADER + '">';

        var renderLeft, renderRight = false;

        if (this.parent) {
            if (this.index === 0) {
                renderLeft = true;
            }
            if (this.index == (this.parent.cfg.getProperty("pages") -1)) {
                renderRight = true;
            }
        } else {
            renderLeft = true;
            renderRight = true;
        }

        if (renderLeft) {
            monthLabel  = this._buildMonthLabel(DateMath.subtract(pageDate, DateMath.MONTH, 1));

            var leftArrow = cfg.getProperty(DEF_CFG.NAV_ARROW_LEFT.key);
            if (leftArrow === null && Calendar.IMG_ROOT !== null) {
                leftArrow = Calendar.IMG_ROOT + DEPR_NAV_LEFT;
            }
            var leftStyle = (leftArrow === null) ? "" : ' style="background-image:url(' + leftArrow + ')"';
            html[html.length] = '<a class="' + this.Style.CSS_NAV_LEFT + '"' + leftStyle + ' href="#">' + prevStr + ' (' + monthLabel + ')' + '</a>';
        }

        var lbl = this.buildMonthLabel();
        var cal = this.parent || this;
        if (cal.cfg.getProperty("navigator")) {
            lbl = "<a class=\"" + this.Style.CSS_NAV + "\" href=\"#\">" + lbl + "</a>";
        }
        html[html.length] = lbl;

        if (renderRight) {
            monthLabel  = this._buildMonthLabel(DateMath.add(pageDate, DateMath.MONTH, 1));

            var rightArrow = cfg.getProperty(DEF_CFG.NAV_ARROW_RIGHT.key);
            if (rightArrow === null && Calendar.IMG_ROOT !== null) {
                rightArrow = Calendar.IMG_ROOT + DEPR_NAV_RIGHT;
            }
            var rightStyle = (rightArrow === null) ? "" : ' style="background-image:url(' + rightArrow + ')"';
            html[html.length] = '<a class="' + this.Style.CSS_NAV_RIGHT + '"' + rightStyle + ' href="#">' + nextStr + ' (' + monthLabel + ')' + '</a>';
        }

        html[html.length] = '</div>\n</th>\n</tr>';

        if (cfg.getProperty(DEF_CFG.SHOW_WEEKDAYS.key)) {
            html = this.buildWeekdays(html);
        }

        html[html.length] = '</thead>';

        return html;
    },

    /**
    * Renders the Calendar's weekday headers.
    * @method buildWeekdays
    * @param {Array} html The current working HTML array
    * @return {Array} The current working HTML array
    */
    buildWeekdays : function(html) {

        html[html.length] = '<tr class="' + this.Style.CSS_WEEKDAY_ROW + '">';

        if (this.cfg.getProperty(DEF_CFG.SHOW_WEEK_HEADER.key)) {
            html[html.length] = '<th>&#160;</th>';
        }

        for(var i=0;i < this.Locale.LOCALE_WEEKDAYS.length; ++i) {
            html[html.length] = '<th class="' + this.Style.CSS_WEEKDAY_CELL + '">' + this.Locale.LOCALE_WEEKDAYS[i] + '</th>';
        }

        if (this.cfg.getProperty(DEF_CFG.SHOW_WEEK_FOOTER.key)) {
            html[html.length] = '<th>&#160;</th>';
        }

        html[html.length] = '</tr>';

        return html;
    },

    /**
    * Renders the calendar body.
    * @method renderBody
    * @param {Date} workingDate The current working Date being used for the render process
    * @param {Array} html The current working HTML array
    * @return {Array} The current working HTML array
    */
    renderBody : function(workingDate, html) {

        var startDay = this.cfg.getProperty(DEF_CFG.START_WEEKDAY.key);

        this.preMonthDays = workingDate.getDay();
        if (startDay > 0) {
            this.preMonthDays -= startDay;
        }
        if (this.preMonthDays < 0) {
            this.preMonthDays += 7;
        }

        this.monthDays = DateMath.findMonthEnd(workingDate).getDate();
        this.postMonthDays = Calendar.DISPLAY_DAYS-this.preMonthDays-this.monthDays;


        workingDate = DateMath.subtract(workingDate, DateMath.DAY, this.preMonthDays);

        var weekNum,
            weekClass,
            weekPrefix = "w",
            cellPrefix = "_cell",
            workingDayPrefix = "wd",
            dayPrefix = "d",
            cellRenderers,
            renderer,
            t = this.today,
            cfg = this.cfg,
            todayYear = t.getFullYear(),
            todayMonth = t.getMonth(),
            todayDate = t.getDate(),
            useDate = cfg.getProperty(DEF_CFG.PAGEDATE.key),
            hideBlankWeeks = cfg.getProperty(DEF_CFG.HIDE_BLANK_WEEKS.key),
            showWeekFooter = cfg.getProperty(DEF_CFG.SHOW_WEEK_FOOTER.key),
            showWeekHeader = cfg.getProperty(DEF_CFG.SHOW_WEEK_HEADER.key),
            mindate = cfg.getProperty(DEF_CFG.MINDATE.key),
            maxdate = cfg.getProperty(DEF_CFG.MAXDATE.key),
            yearOffset = this.Locale.YEAR_OFFSET;

        if (mindate) {
            mindate = DateMath.clearTime(mindate);
        }
        if (maxdate) {
            maxdate = DateMath.clearTime(maxdate);
        }

        html[html.length] = '<tbody class="m' + (useDate.getMonth()+1) + ' ' + this.Style.CSS_BODY + '">';

        var i = 0,
            tempDiv = document.createElement("div"),
            cell = document.createElement("td");

        tempDiv.appendChild(cell);

        var cal = this.parent || this;

        for (var r=0;r<6;r++) {
            weekNum = DateMath.getWeekNumber(workingDate, startDay);
            weekClass = weekPrefix + weekNum;

            if (r !== 0 && hideBlankWeeks === true && workingDate.getMonth() != useDate.getMonth()) {
                break;
            } else {
                html[html.length] = '<tr class="' + weekClass + '">';

                if (showWeekHeader) { html = this.renderRowHeader(weekNum, html); }

                for (var d=0; d < 7; d++){ // Render actual days

                    cellRenderers = [];

                    this.clearElement(cell);
                    cell.className = this.Style.CSS_CELL;
                    cell.id = this.id + cellPrefix + i;

                    if (workingDate.getDate()  == todayDate &&
                        workingDate.getMonth()  == todayMonth &&
                        workingDate.getFullYear() == todayYear) {
                        cellRenderers[cellRenderers.length]=cal.renderCellStyleToday;
                    }

                    var workingArray = [workingDate.getFullYear(),workingDate.getMonth()+1,workingDate.getDate()];
                    this.cellDates[this.cellDates.length] = workingArray; // Add this date to cellDates

                    if (workingDate.getMonth() != useDate.getMonth()) {
                        cellRenderers[cellRenderers.length]=cal.renderCellNotThisMonth;
                    } else {
                        Dom.addClass(cell, workingDayPrefix + workingDate.getDay());
                        Dom.addClass(cell, dayPrefix + workingDate.getDate());

                        for (var s=0;s<this.renderStack.length;++s) {

                            renderer = null;

                            var rArray = this.renderStack[s],
                                type = rArray[0],
                                month,
                                day,
                                year;

                            switch (type) {
                                case Calendar.DATE:
                                    month = rArray[1][1];
                                    day = rArray[1][2];
                                    year = rArray[1][0];

                                    if (workingDate.getMonth()+1 == month && workingDate.getDate() == day && workingDate.getFullYear() == year) {
                                        renderer = rArray[2];
                                        this.renderStack.splice(s,1);
                                    }
                                    break;
                                case Calendar.MONTH_DAY:
                                    month = rArray[1][0];
                                    day = rArray[1][1];

                                    if (workingDate.getMonth()+1 == month && workingDate.getDate() == day) {
                                        renderer = rArray[2];
                                        this.renderStack.splice(s,1);
                                    }
                                    break;
                                case Calendar.RANGE:
                                    var date1 = rArray[1][0],
                                        date2 = rArray[1][1],
                                        d1month = date1[1],
                                        d1day = date1[2],
                                        d1year = date1[0],
                                        d1 = DateMath.getDate(d1year, d1month-1, d1day),
                                        d2month = date2[1],
                                        d2day = date2[2],
                                        d2year = date2[0],
                                        d2 = DateMath.getDate(d2year, d2month-1, d2day);

                                    if (workingDate.getTime() >= d1.getTime() && workingDate.getTime() <= d2.getTime()) {
                                        renderer = rArray[2];

                                        if (workingDate.getTime()==d2.getTime()) {
                                            this.renderStack.splice(s,1);
                                        }
                                    }
                                    break;
                                case Calendar.WEEKDAY:
                                    var weekday = rArray[1][0];
                                    if (workingDate.getDay()+1 == weekday) {
                                        renderer = rArray[2];
                                    }
                                    break;
                                case Calendar.MONTH:
                                    month = rArray[1][0];
                                    if (workingDate.getMonth()+1 == month) {
                                        renderer = rArray[2];
                                    }
                                    break;
                            }

                            if (renderer) {
                                cellRenderers[cellRenderers.length]=renderer;
                            }
                        }

                    }

                    if (this._indexOfSelectedFieldArray(workingArray) > -1) {
                        cellRenderers[cellRenderers.length]=cal.renderCellStyleSelected;
                    }

                    if ((mindate && (workingDate.getTime() < mindate.getTime())) ||
                        (maxdate && (workingDate.getTime() > maxdate.getTime()))
                    ) {
                        cellRenderers[cellRenderers.length]=cal.renderOutOfBoundsDate;
                    } else {
                        cellRenderers[cellRenderers.length]=cal.styleCellDefault;
                        cellRenderers[cellRenderers.length]=cal.renderCellDefault;
                    }

                    for (var x=0; x < cellRenderers.length; ++x) {
                        if (cellRenderers[x].call(cal, workingDate, cell) == Calendar.STOP_RENDER) {
                            break;
                        }
                    }

                    workingDate.setTime(workingDate.getTime() + DateMath.ONE_DAY_MS);
                    workingDate = DateMath.clearTime(workingDate);

                    if (i >= 0 && i <= 6) {
                        Dom.addClass(cell, this.Style.CSS_CELL_TOP);
                    }
                    if ((i % 7) === 0) {
                        Dom.addClass(cell, this.Style.CSS_CELL_LEFT);
                    }
                    if (((i+1) % 7) === 0) {
                        Dom.addClass(cell, this.Style.CSS_CELL_RIGHT);
                    }

                    var postDays = this.postMonthDays;
                    if (hideBlankWeeks && postDays >= 7) {
                        var blankWeeks = Math.floor(postDays/7);
                        for (var p=0;p<blankWeeks;++p) {
                            postDays -= 7;
                        }
                    }

                    if (i >= ((this.preMonthDays+postDays+this.monthDays)-7)) {
                        Dom.addClass(cell, this.Style.CSS_CELL_BOTTOM);
                    }

                    html[html.length] = tempDiv.innerHTML;
                    i++;
                }

                if (showWeekFooter) { html = this.renderRowFooter(weekNum, html); }

                html[html.length] = '</tr>';
            }
        }

        html[html.length] = '</tbody>';

        return html;
    },

    /**
    * Renders the calendar footer. In the default implementation, there is
    * no footer.
    * @method renderFooter
    * @param {Array} html The current working HTML array
    * @return {Array} The current working HTML array
    */
    renderFooter : function(html) { return html; },

    /**
    * Renders the calendar after it has been configured. The render() method has a specific call chain that will execute
    * when the method is called: renderHeader, renderBody, renderFooter.
    * Refer to the documentation for those methods for information on
    * individual render tasks.
    * @method render
    */
    render : function() {
        this.beforeRenderEvent.fire();

        var workingDate = DateMath.findMonthStart(this.cfg.getProperty(DEF_CFG.PAGEDATE.key));

        this.resetRenderers();
        this.cellDates.length = 0;

        Event.purgeElement(this.oDomContainer, true);

        var html = [];

        html[html.length] = '<table cellSpacing="0" class="' + this.Style.CSS_CALENDAR + ' y' + (workingDate.getFullYear() + this.Locale.YEAR_OFFSET) +'" id="' + this.id + '">';
        html = this.renderHeader(html);
        html = this.renderBody(workingDate, html);
        html = this.renderFooter(html);
        html[html.length] = '</table>';

        this.oDomContainer.innerHTML = html.join("\n");

        this.applyListeners();
        this.cells = Dom.getElementsByClassName(this.Style.CSS_CELL, "td", this.id);

        this.cfg.refireEvent(DEF_CFG.TITLE.key);
        this.cfg.refireEvent(DEF_CFG.CLOSE.key);
        this.cfg.refireEvent(DEF_CFG.IFRAME.key);

        this.renderEvent.fire();
    },

    /**
    * Applies the Calendar's DOM listeners to applicable elements.
    * @method applyListeners
    */
    applyListeners : function() {
        var root = this.oDomContainer,
            cal = this.parent || this,
            anchor = "a",
            click = "click";

        var linkLeft = Dom.getElementsByClassName(this.Style.CSS_NAV_LEFT, anchor, root),
            linkRight = Dom.getElementsByClassName(this.Style.CSS_NAV_RIGHT, anchor, root);

        if (linkLeft && linkLeft.length > 0) {
            this.linkLeft = linkLeft[0];
            Event.addListener(this.linkLeft, click, this.doPreviousMonthNav, cal, true);
        }

        if (linkRight && linkRight.length > 0) {
            this.linkRight = linkRight[0];
            Event.addListener(this.linkRight, click, this.doNextMonthNav, cal, true);
        }

        if (cal.cfg.getProperty("navigator") !== null) {
            this.applyNavListeners();
        }

        if (this.domEventMap) {
            var el,elements;
            for (var cls in this.domEventMap) {
                if (Lang.hasOwnProperty(this.domEventMap, cls)) {
                    var items = this.domEventMap[cls];

                    if (! (items instanceof Array)) {
                        items = [items];
                    }

                    for (var i=0;i<items.length;i++) {
                        var item = items[i];
                        elements = Dom.getElementsByClassName(cls, item.tag, this.oDomContainer);

                        for (var c=0;c<elements.length;c++) {
                            el = elements[c];
                             Event.addListener(el, item.event, item.handler, item.scope, item.correct );
                        }
                    }
                }
            }
        }

        Event.addListener(this.oDomContainer, "click", this.doSelectCell, this);
        Event.addListener(this.oDomContainer, "mouseover", this.doCellMouseOver, this);
        Event.addListener(this.oDomContainer, "mouseout", this.doCellMouseOut, this);
    },

    applyNavListeners : function() {
        var calParent = this.parent || this,
            cal = this,
            navBtns = Dom.getElementsByClassName(this.Style.CSS_NAV, "a", this.oDomContainer);

        if (navBtns.length > 0) {

            Event.addListener(navBtns, "click", function (e, obj) {
                var target = Event.getTarget(e);
                if (this === target || Dom.isAncestor(this, target)) {
                    Event.preventDefault(e);
                }
                var navigator = calParent.oNavigator;
                if (navigator) {
                    var pgdate = cal.cfg.getProperty("pagedate");
                    navigator.setYear(pgdate.getFullYear() + cal.Locale.YEAR_OFFSET);
                    navigator.setMonth(pgdate.getMonth());
                    navigator.show();
                }
            });
        }
    },

    /**
    * Retrieves the Date object for the specified Calendar cell
    * @method getDateByCellId
    * @param {String} id The id of the cell
    * @return {Date} The Date object for the specified Calendar cell
    */
    getDateByCellId : function(id) {
        var date = this.getDateFieldsByCellId(id);
        return (date) ? DateMath.getDate(date[0],date[1]-1,date[2]) : null;
    },

    /**
    * Retrieves the Date object for the specified Calendar cell
    * @method getDateFieldsByCellId
    * @param {String} id The id of the cell
    * @return {Array} The array of Date fields for the specified Calendar cell
    */
    getDateFieldsByCellId : function(id) {
        id = this.getIndexFromId(id);
        return (id > -1) ? this.cellDates[id] : null;
    },

    /**
     * Find the Calendar's cell index for a given date.
     * If the date is not found, the method returns -1.
     * <p>
     * The returned index can be used to lookup the cell HTMLElement
     * using the Calendar's cells array or passed to selectCell to select
     * cells by index.
     * </p>
     *
     * See <a href="#cells">cells</a>, <a href="#selectCell">selectCell</a>.
     *
     * @method getCellIndex
     * @param {Date} date JavaScript Date object, for which to find a cell index.
     * @return {Number} The index of the date in Calendars cellDates/cells arrays, or -1 if the date
     * is not on the curently rendered Calendar page.
     */
    getCellIndex : function(date) {
        var idx = -1;
        if (date) {
            var m = date.getMonth(),
                y = date.getFullYear(),
                d = date.getDate(),
                dates = this.cellDates;

            for (var i = 0; i < dates.length; ++i) {
                var cellDate = dates[i];
                if (cellDate[0] === y && cellDate[1] === m+1 && cellDate[2] === d) {
                    idx = i;
                    break;
                }
            }
        }
        return idx;
    },

    /**
     * Given the id used to mark each Calendar cell, this method
     * extracts the index number from the id.
     *
     * @param {String} strId The cell id
     * @return {Number} The index of the cell, or -1 if id does not contain an index number
     */
    getIndexFromId : function(strId) {
        var idx = -1,
            li = strId.lastIndexOf("_cell");

        if (li > -1) {
            idx = parseInt(strId.substring(li + 5), 10);
        }

        return idx;
    },


    /**
    * Renders a cell that falls before the minimum date or after the maximum date.
    * widget class.
    * @method renderOutOfBoundsDate
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    * @return {String} YAHOO.widget.Calendar.STOP_RENDER if rendering should stop with this style, null or nothing if rendering
    *   should not be terminated
    */
    renderOutOfBoundsDate : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_OOB);
        cell.innerHTML = workingDate.getDate();
        return Calendar.STOP_RENDER;
    },

    /**
    * Renders the row header for a week.
    * @method renderRowHeader
    * @param {Number} weekNum The week number of the current row
    * @param {Array} cell The current working HTML array
    */
    renderRowHeader : function(weekNum, html) {
        html[html.length] = '<th class="' + this.Style.CSS_ROW_HEADER + '">' + weekNum + '</th>';
        return html;
    },

    /**
    * Renders the row footer for a week.
    * @method renderRowFooter
    * @param {Number} weekNum The week number of the current row
    * @param {Array} cell The current working HTML array
    */
    renderRowFooter : function(weekNum, html) {
        html[html.length] = '<th class="' + this.Style.CSS_ROW_FOOTER + '">' + weekNum + '</th>';
        return html;
    },

    /**
    * Renders a single standard calendar cell in the calendar widget table.
    * All logic for determining how a standard default cell will be rendered is
    * encapsulated in this method, and must be accounted for when extending the
    * widget class.
    * @method renderCellDefault
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellDefault : function(workingDate, cell) {
        cell.innerHTML = '<a href="#" class="' + this.Style.CSS_CELL_SELECTOR + '">' + this.buildDayLabel(workingDate) + "</a>";
    },

    /**
    * Styles a selectable cell.
    * @method styleCellDefault
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    styleCellDefault : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_SELECTABLE);
    },


    /**
    * Renders a single standard calendar cell using the CSS hightlight1 style
    * @method renderCellStyleHighlight1
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellStyleHighlight1 : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_HIGHLIGHT1);
    },

    /**
    * Renders a single standard calendar cell using the CSS hightlight2 style
    * @method renderCellStyleHighlight2
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellStyleHighlight2 : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_HIGHLIGHT2);
    },

    /**
    * Renders a single standard calendar cell using the CSS hightlight3 style
    * @method renderCellStyleHighlight3
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellStyleHighlight3 : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_HIGHLIGHT3);
    },

    /**
    * Renders a single standard calendar cell using the CSS hightlight4 style
    * @method renderCellStyleHighlight4
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellStyleHighlight4 : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_HIGHLIGHT4);
    },

    /**
    * Applies the default style used for rendering today's date to the current calendar cell
    * @method renderCellStyleToday
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    */
    renderCellStyleToday : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_TODAY);
    },

    /**
    * Applies the default style used for rendering selected dates to the current calendar cell
    * @method renderCellStyleSelected
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    * @return {String} YAHOO.widget.Calendar.STOP_RENDER if rendering should stop with this style, null or nothing if rendering
    *   should not be terminated
    */
    renderCellStyleSelected : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_SELECTED);
    },

    /**
    * Applies the default style used for rendering dates that are not a part of the current
    * month (preceding or trailing the cells for the current month)
    * @method renderCellNotThisMonth
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    * @return {String} YAHOO.widget.Calendar.STOP_RENDER if rendering should stop with this style, null or nothing if rendering
    *   should not be terminated
    */
    renderCellNotThisMonth : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL_OOM);
        cell.innerHTML=workingDate.getDate();
        return Calendar.STOP_RENDER;
    },

    /**
    * Renders the current calendar cell as a non-selectable "black-out" date using the default
    * restricted style.
    * @method renderBodyCellRestricted
    * @param {Date}     workingDate  The current working Date object being used to generate the calendar
    * @param {HTMLTableCellElement} cell   The current working cell in the calendar
    * @return {String} YAHOO.widget.Calendar.STOP_RENDER if rendering should stop with this style, null or nothing if rendering
    *   should not be terminated
    */
    renderBodyCellRestricted : function(workingDate, cell) {
        Dom.addClass(cell, this.Style.CSS_CELL);
        Dom.addClass(cell, this.Style.CSS_CELL_RESTRICTED);
        cell.innerHTML=workingDate.getDate();
        return Calendar.STOP_RENDER;
    },



    /**
    * Adds the designated number of months to the current calendar month, and sets the current
    * calendar page date to the new month.
    * @method addMonths
    * @param {Number} count The number of months to add to the current calendar
    */
    addMonths : function(count) {
        var cfgPageDate = DEF_CFG.PAGEDATE.key,

        prevDate = this.cfg.getProperty(cfgPageDate),
        newDate = DateMath.add(prevDate, DateMath.MONTH, count);

        this.cfg.setProperty(cfgPageDate, newDate);
        this.resetRenderers();
        this.changePageEvent.fire(prevDate, newDate);
    },

    /**
    * Subtracts the designated number of months from the current calendar month, and sets the current
    * calendar page date to the new month.
    * @method subtractMonths
    * @param {Number} count The number of months to subtract from the current calendar
    */
    subtractMonths : function(count) {
        this.addMonths(-1*count);
    },

    /**
    * Adds the designated number of years to the current calendar, and sets the current
    * calendar page date to the new month.
    * @method addYears
    * @param {Number} count The number of years to add to the current calendar
    */
    addYears : function(count) {
        var cfgPageDate = DEF_CFG.PAGEDATE.key,

        prevDate = this.cfg.getProperty(cfgPageDate),
        newDate = DateMath.add(prevDate, DateMath.YEAR, count);

        this.cfg.setProperty(cfgPageDate, newDate);
        this.resetRenderers();
        this.changePageEvent.fire(prevDate, newDate);
    },

    /**
    * Subtcats the designated number of years from the current calendar, and sets the current
    * calendar page date to the new month.
    * @method subtractYears
    * @param {Number} count The number of years to subtract from the current calendar
    */
    subtractYears : function(count) {
        this.addYears(-1*count);
    },

    /**
    * Navigates to the next month page in the calendar widget.
    * @method nextMonth
    */
    nextMonth : function() {
        this.addMonths(1);
    },

    /**
    * Navigates to the previous month page in the calendar widget.
    * @method previousMonth
    */
    previousMonth : function() {
        this.addMonths(-1);
    },

    /**
    * Navigates to the next year in the currently selected month in the calendar widget.
    * @method nextYear
    */
    nextYear : function() {
        this.addYears(1);
    },

    /**
    * Navigates to the previous year in the currently selected month in the calendar widget.
    * @method previousYear
    */
    previousYear : function() {
        this.addYears(-1);
    },



    /**
    * Resets the calendar widget to the originally selected month and year, and
    * sets the calendar to the initial selection(s).
    * @method reset
    */
    reset : function() {
        this.cfg.resetProperty(DEF_CFG.SELECTED.key);
        this.cfg.resetProperty(DEF_CFG.PAGEDATE.key);
        this.resetEvent.fire();
    },

    /**
    * Clears the selected dates in the current calendar widget and sets the calendar
    * to the current month and year.
    * @method clear
    */
    clear : function() {
        this.cfg.setProperty(DEF_CFG.SELECTED.key, []);
        this.cfg.setProperty(DEF_CFG.PAGEDATE.key, new Date(this.today.getTime()));
        this.clearEvent.fire();
    },

    /**
    * Selects a date or a collection of dates on the current calendar. This method, by default,
    * does not call the render method explicitly. Once selection has completed, render must be
    * called for the changes to be reflected visually.
    *
    * Any dates which are OOB (out of bounds, not selectable) will not be selected and the array of
    * selected dates passed to the selectEvent will not contain OOB dates.
    *
    * If all dates are OOB, the no state change will occur; beforeSelect and select events will not be fired.
    *
    * @method select
    * @param {String/Date/Date[]} date The date string of dates to select in the current calendar. Valid formats are
    *        individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
    *        Multiple comma-delimited dates can also be passed to this method (12/24/2005,12/11/2005-12/13/2005).
    *        This method can also take a JavaScript Date object or an array of Date objects.
    * @return {Date[]}   Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    select : function(date) {

        var aToBeSelected = this._toFieldArray(date),
            validDates = [],
            selected = [],
            cfgSelected = DEF_CFG.SELECTED.key;


        for (var a=0; a < aToBeSelected.length; ++a) {
            var toSelect = aToBeSelected[a];

            if (!this.isDateOOB(this._toDate(toSelect))) {

                if (validDates.length === 0) {
                    this.beforeSelectEvent.fire();
                    selected = this.cfg.getProperty(cfgSelected);
                }
                validDates.push(toSelect);

                if (this._indexOfSelectedFieldArray(toSelect) == -1) {
                    selected[selected.length] = toSelect;
                }
            }
        }


        if (validDates.length > 0) {
            if (this.parent) {
                this.parent.cfg.setProperty(cfgSelected, selected);
            } else {
                this.cfg.setProperty(cfgSelected, selected);
            }
            this.selectEvent.fire(validDates);
        }

        return this.getSelectedDates();
    },

    /**
    * Selects a date on the current calendar by referencing the index of the cell that should be selected.
    * This method is used to easily select a single cell (usually with a mouse click) without having to do
    * a full render. The selected style is applied to the cell directly.
    *
    * If the cell is not marked with the CSS_CELL_SELECTABLE class (as is the case by default for out of month
    * or out of bounds cells), it will not be selected and in such a case beforeSelect and select events will not be fired.
    *
    * @method selectCell
    * @param {Number} cellIndex The index of the cell to select in the current calendar.
    * @return {Date[]} Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    selectCell : function(cellIndex) {

        var cell = this.cells[cellIndex],
            cellDate = this.cellDates[cellIndex],
            dCellDate = this._toDate(cellDate),
            selectable = Dom.hasClass(cell, this.Style.CSS_CELL_SELECTABLE);


        if (selectable) {

            this.beforeSelectEvent.fire();

            var cfgSelected = DEF_CFG.SELECTED.key;
            var selected = this.cfg.getProperty(cfgSelected);

            var selectDate = cellDate.concat();

            if (this._indexOfSelectedFieldArray(selectDate) == -1) {
                selected[selected.length] = selectDate;
            }
            if (this.parent) {
                this.parent.cfg.setProperty(cfgSelected, selected);
            } else {
                this.cfg.setProperty(cfgSelected, selected);
            }
            this.renderCellStyleSelected(dCellDate,cell);
            this.selectEvent.fire([selectDate]);

            this.doCellMouseOut.call(cell, null, this);
        }

        return this.getSelectedDates();
    },

    /**
    * Deselects a date or a collection of dates on the current calendar. This method, by default,
    * does not call the render method explicitly. Once deselection has completed, render must be
    * called for the changes to be reflected visually.
    *
    * The method will not attempt to deselect any dates which are OOB (out of bounds, and hence not selectable)
    * and the array of deselected dates passed to the deselectEvent will not contain any OOB dates.
    *
    * If all dates are OOB, beforeDeselect and deselect events will not be fired.
    *
    * @method deselect
    * @param {String/Date/Date[]} date The date string of dates to deselect in the current calendar. Valid formats are
    *        individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
    *        Multiple comma-delimited dates can also be passed to this method (12/24/2005,12/11/2005-12/13/2005).
    *        This method can also take a JavaScript Date object or an array of Date objects.
    * @return {Date[]}   Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    deselect : function(date) {

        var aToBeDeselected = this._toFieldArray(date),
            validDates = [],
            selected = [],
            cfgSelected = DEF_CFG.SELECTED.key;


        for (var a=0; a < aToBeDeselected.length; ++a) {
            var toDeselect = aToBeDeselected[a];

            if (!this.isDateOOB(this._toDate(toDeselect))) {

                if (validDates.length === 0) {
                    this.beforeDeselectEvent.fire();
                    selected = this.cfg.getProperty(cfgSelected);
                }

                validDates.push(toDeselect);

                var index = this._indexOfSelectedFieldArray(toDeselect);
                if (index != -1) {
                    selected.splice(index,1);
                }
            }
        }


        if (validDates.length > 0) {
            if (this.parent) {
                this.parent.cfg.setProperty(cfgSelected, selected);
            } else {
                this.cfg.setProperty(cfgSelected, selected);
            }
            this.deselectEvent.fire(validDates);
        }

        return this.getSelectedDates();
    },

    /**
    * Deselects a date on the current calendar by referencing the index of the cell that should be deselected.
    * This method is used to easily deselect a single cell (usually with a mouse click) without having to do
    * a full render. The selected style is removed from the cell directly.
    *
    * If the cell is not marked with the CSS_CELL_SELECTABLE class (as is the case by default for out of month
    * or out of bounds cells), the method will not attempt to deselect it and in such a case, beforeDeselect and
    * deselect events will not be fired.
    *
    * @method deselectCell
    * @param {Number} cellIndex The index of the cell to deselect in the current calendar.
    * @return {Date[]} Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    deselectCell : function(cellIndex) {
        var cell = this.cells[cellIndex],
            cellDate = this.cellDates[cellIndex],
            cellDateIndex = this._indexOfSelectedFieldArray(cellDate);

        var selectable = Dom.hasClass(cell, this.Style.CSS_CELL_SELECTABLE);

        if (selectable) {

            this.beforeDeselectEvent.fire();

            var selected = this.cfg.getProperty(DEF_CFG.SELECTED.key),
                dCellDate = this._toDate(cellDate),
                selectDate = cellDate.concat();

            if (cellDateIndex > -1) {
                if (this.cfg.getProperty(DEF_CFG.PAGEDATE.key).getMonth() == dCellDate.getMonth() &&
                    this.cfg.getProperty(DEF_CFG.PAGEDATE.key).getFullYear() == dCellDate.getFullYear()) {
                    Dom.removeClass(cell, this.Style.CSS_CELL_SELECTED);
                }
                selected.splice(cellDateIndex, 1);
            }

            if (this.parent) {
                this.parent.cfg.setProperty(DEF_CFG.SELECTED.key, selected);
            } else {
                this.cfg.setProperty(DEF_CFG.SELECTED.key, selected);
            }

            this.deselectEvent.fire([selectDate]);
        }

        return this.getSelectedDates();
    },

    /**
    * Deselects all dates on the current calendar.
    * @method deselectAll
    * @return {Date[]}  Array of JavaScript Date objects representing all individual dates that are currently selected.
    *      Assuming that this function executes properly, the return value should be an empty array.
    *      However, the empty array is returned for the sake of being able to check the selection status
    *      of the calendar.
    */
    deselectAll : function() {
        this.beforeDeselectEvent.fire();

        var cfgSelected = DEF_CFG.SELECTED.key,
            selected = this.cfg.getProperty(cfgSelected),
            count = selected.length,
            sel = selected.concat();

        if (this.parent) {
            this.parent.cfg.setProperty(cfgSelected, []);
        } else {
            this.cfg.setProperty(cfgSelected, []);
        }

        if (count > 0) {
            this.deselectEvent.fire(sel);
        }

        return this.getSelectedDates();
    },



    /**
    * Converts a date (either a JavaScript Date object, or a date string) to the internal data structure
    * used to represent dates: [[yyyy,mm,dd],[yyyy,mm,dd]].
    * @method _toFieldArray
    * @private
    * @param {String/Date/Date[]} date The date string of dates to deselect in the current calendar. Valid formats are
    *        individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
    *        Multiple comma-delimited dates can also be passed to this method (12/24/2005,12/11/2005-12/13/2005).
    *        This method can also take a JavaScript Date object or an array of Date objects.
    * @return {Array[](Number[])} Array of date field arrays
    */
    _toFieldArray : function(date) {
        var returnDate = [];

        if (date instanceof Date) {
            returnDate = [[date.getFullYear(), date.getMonth()+1, date.getDate()]];
        } else if (Lang.isString(date)) {
            returnDate = this._parseDates(date);
        } else if (Lang.isArray(date)) {
            for (var i=0;i<date.length;++i) {
                var d = date[i];
                returnDate[returnDate.length] = [d.getFullYear(),d.getMonth()+1,d.getDate()];
            }
        }

        return returnDate;
    },

    /**
    * Converts a date field array [yyyy,mm,dd] to a JavaScript Date object. The date field array
    * is the format in which dates are as provided as arguments to selectEvent and deselectEvent listeners.
    *
    * @method toDate
    * @param {Number[]} dateFieldArray The date field array to convert to a JavaScript Date.
    * @return {Date} JavaScript Date object representing the date field array.
    */
    toDate : function(dateFieldArray) {
        return this._toDate(dateFieldArray);
    },

    /**
    * Converts a date field array [yyyy,mm,dd] to a JavaScript Date object.
    * @method _toDate
    * @private
    * @deprecated Made public, toDate
    * @param {Number[]}  dateFieldArray The date field array to convert to a JavaScript Date.
    * @return {Date} JavaScript Date object representing the date field array
    */
    _toDate : function(dateFieldArray) {
        if (dateFieldArray instanceof Date) {
            return dateFieldArray;
        } else {
            return DateMath.getDate(dateFieldArray[0],dateFieldArray[1]-1,dateFieldArray[2]);
        }
    },



    /**
    * Determines if 2 field arrays are equal.
    * @method _fieldArraysAreEqual
    * @private
    * @param {Number[]} array1 The first date field array to compare
    * @param {Number[]} array2 The first date field array to compare
    * @return {Boolean} The boolean that represents the equality of the two arrays
    */
    _fieldArraysAreEqual : function(array1, array2) {
        var match = false;

        if (array1[0]==array2[0]&&array1[1]==array2[1]&&array1[2]==array2[2]) {
            match=true;
        }

        return match;
    },

    /**
    * Gets the index of a date field array [yyyy,mm,dd] in the current list of selected dates.
    * @method _indexOfSelectedFieldArray
    * @private
    * @param {Number[]}  find The date field array to search for
    * @return {Number}   The index of the date field array within the collection of selected dates.
    *        -1 will be returned if the date is not found.
    */
    _indexOfSelectedFieldArray : function(find) {
        var selected = -1,
            seldates = this.cfg.getProperty(DEF_CFG.SELECTED.key);

        for (var s=0;s<seldates.length;++s) {
            var sArray = seldates[s];
            if (find[0]==sArray[0]&&find[1]==sArray[1]&&find[2]==sArray[2]) {
                selected = s;
                break;
            }
        }

        return selected;
    },

    /**
    * Determines whether a given date is OOM (out of month).
    * @method isDateOOM
    * @param {Date} date The JavaScript Date object for which to check the OOM status
    * @return {Boolean} true if the date is OOM
    */
    isDateOOM : function(date) {
        return (date.getMonth() != this.cfg.getProperty(DEF_CFG.PAGEDATE.key).getMonth());
    },

    /**
    * Determines whether a given date is OOB (out of bounds - less than the mindate or more than the maxdate).
    *
    * @method isDateOOB
    * @param {Date} date The JavaScript Date object for which to check the OOB status
    * @return {Boolean} true if the date is OOB
    */
    isDateOOB : function(date) {
        var minDate = this.cfg.getProperty(DEF_CFG.MINDATE.key),
            maxDate = this.cfg.getProperty(DEF_CFG.MAXDATE.key),
            dm = DateMath;

        if (minDate) {
            minDate = dm.clearTime(minDate);
        }
        if (maxDate) {
            maxDate = dm.clearTime(maxDate);
        }

        var clearedDate = new Date(date.getTime());
        clearedDate = dm.clearTime(clearedDate);

        return ((minDate && clearedDate.getTime() < minDate.getTime()) || (maxDate && clearedDate.getTime() > maxDate.getTime()));
    },

    /**
     * Parses a pagedate configuration property value. The value can either be specified as a string of form "mm/yyyy" or a Date object
     * and is parsed into a Date object normalized to the first day of the month. If no value is passed in, the month and year from today's date are used to create the Date object
     * @method _parsePageDate
     * @private
     * @param {Date|String} date Pagedate value which needs to be parsed
     * @return {Date} The Date object representing the pagedate
     */
    _parsePageDate : function(date) {
        var parsedDate;

        if (date) {
            if (date instanceof Date) {
                parsedDate = DateMath.findMonthStart(date);
            } else {
                var month, year, aMonthYear;
                aMonthYear = date.split(this.cfg.getProperty(DEF_CFG.DATE_FIELD_DELIMITER.key));
                month = parseInt(aMonthYear[this.cfg.getProperty(DEF_CFG.MY_MONTH_POSITION.key)-1], 10)-1;
                year = parseInt(aMonthYear[this.cfg.getProperty(DEF_CFG.MY_YEAR_POSITION.key)-1], 10) - this.Locale.YEAR_OFFSET;

                parsedDate = DateMath.getDate(year, month, 1);
            }
        } else {
            parsedDate = DateMath.getDate(this.today.getFullYear(), this.today.getMonth(), 1);
        }
        return parsedDate;
    },



    /**
    * Event executed before a date is selected in the calendar widget.
    * @deprecated Event handlers for this event should be susbcribed to beforeSelectEvent.
    */
    onBeforeSelect : function() {
        if (this.cfg.getProperty(DEF_CFG.MULTI_SELECT.key) === false) {
            if (this.parent) {
                this.parent.callChildFunction("clearAllBodyCellStyles", this.Style.CSS_CELL_SELECTED);
                this.parent.deselectAll();
            } else {
                this.clearAllBodyCellStyles(this.Style.CSS_CELL_SELECTED);
                this.deselectAll();
            }
        }
    },

    /**
    * Event executed when a date is selected in the calendar widget.
    * @param {Array} selected An array of date field arrays representing which date or dates were selected. Example: [ [2006,8,6],[2006,8,7],[2006,8,8] ]
    * @deprecated Event handlers for this event should be susbcribed to selectEvent.
    */
    onSelect : function(selected) { },

    /**
    * Event executed before a date is deselected in the calendar widget.
    * @deprecated Event handlers for this event should be susbcribed to beforeDeselectEvent.
    */
    onBeforeDeselect : function() { },

    /**
    * Event executed when a date is deselected in the calendar widget.
    * @param {Array} selected An array of date field arrays representing which date or dates were deselected. Example: [ [2006,8,6],[2006,8,7],[2006,8,8] ]
    * @deprecated Event handlers for this event should be susbcribed to deselectEvent.
    */
    onDeselect : function(deselected) { },

    /**
    * Event executed when the user navigates to a different calendar page.
    * @deprecated Event handlers for this event should be susbcribed to changePageEvent.
    */
    onChangePage : function() {
        this.render();
    },

    /**
    * Event executed when the calendar widget is rendered.
    * @deprecated Event handlers for this event should be susbcribed to renderEvent.
    */
    onRender : function() { },

    /**
    * Event executed when the calendar widget is reset to its original state.
    * @deprecated Event handlers for this event should be susbcribed to resetEvemt.
    */
    onReset : function() { this.render(); },

    /**
    * Event executed when the calendar widget is completely cleared to the current month with no selections.
    * @deprecated Event handlers for this event should be susbcribed to clearEvent.
    */
    onClear : function() { this.render(); },

    /**
    * Validates the calendar widget. This method has no default implementation
    * and must be extended by subclassing the widget.
    * @return Should return true if the widget validates, and false if
    * it doesn't.
    * @type Boolean
    */
    validate : function() { return true; },



    /**
    * Converts a date string to a date field array
    * @private
    * @param {String} sDate   Date string. Valid formats are mm/dd and mm/dd/yyyy.
    * @return    A date field array representing the string passed to the method
    * @type Array[](Number[])
    */
    _parseDate : function(sDate) {
        var aDate = sDate.split(this.Locale.DATE_FIELD_DELIMITER),
            rArray;

        if (aDate.length == 2) {
            rArray = [aDate[this.Locale.MD_MONTH_POSITION-1],aDate[this.Locale.MD_DAY_POSITION-1]];
            rArray.type = Calendar.MONTH_DAY;
        } else {
            rArray = [aDate[this.Locale.MDY_YEAR_POSITION-1] - this.Locale.YEAR_OFFSET, aDate[this.Locale.MDY_MONTH_POSITION-1],aDate[this.Locale.MDY_DAY_POSITION-1]];
            rArray.type = Calendar.DATE;
        }

        for (var i=0;i<rArray.length;i++) {
            rArray[i] = parseInt(rArray[i], 10);
        }

        return rArray;
    },

    /**
    * Converts a multi or single-date string to an array of date field arrays
    * @private
    * @param {String} sDates  Date string with one or more comma-delimited dates. Valid formats are mm/dd, mm/dd/yyyy, mm/dd/yyyy-mm/dd/yyyy
    * @return       An array of date field arrays
    * @type Array[](Number[])
    */
    _parseDates : function(sDates) {
        var aReturn = [],
            aDates = sDates.split(this.Locale.DATE_DELIMITER);

        for (var d=0;d<aDates.length;++d) {
            var sDate = aDates[d];

            if (sDate.indexOf(this.Locale.DATE_RANGE_DELIMITER) != -1) {
                var aRange = sDate.split(this.Locale.DATE_RANGE_DELIMITER),
                    dateStart = this._parseDate(aRange[0]),
                    dateEnd = this._parseDate(aRange[1]),
                    fullRange = this._parseRange(dateStart, dateEnd);

                aReturn = aReturn.concat(fullRange);
            } else {
                var aDate = this._parseDate(sDate);
                aReturn.push(aDate);
            }
        }
        return aReturn;
    },

    /**
    * Converts a date range to the full list of included dates
    * @private
    * @param {Number[]} startDate Date field array representing the first date in the range
    * @param {Number[]} endDate  Date field array representing the last date in the range
    * @return       An array of date field arrays
    * @type Array[](Number[])
    */
    _parseRange : function(startDate, endDate) {
        var dCurrent = DateMath.add(DateMath.getDate(startDate[0],startDate[1]-1,startDate[2]),DateMath.DAY,1),
            dEnd     = DateMath.getDate(endDate[0],  endDate[1]-1,  endDate[2]),
            results = [];

        results.push(startDate);
        while (dCurrent.getTime() <= dEnd.getTime()) {
            results.push([dCurrent.getFullYear(),dCurrent.getMonth()+1,dCurrent.getDate()]);
            dCurrent = DateMath.add(dCurrent,DateMath.DAY,1);
        }
        return results;
    },



    /**
    * Resets the render stack of the current calendar to its original pre-render value.
    */
    resetRenderers : function() {
        this.renderStack = this._renderStack.concat();
    },

    /**
     * Removes all custom renderers added to the Calendar through the addRenderer, addMonthRenderer and
     * addWeekdayRenderer methods. Calendar's render method needs to be called after removing renderers
     * to re-render the Calendar without custom renderers applied.
     */
    removeRenderers : function() {
        this._renderStack = [];
        this.renderStack = [];
    },

    /**
    * Clears the inner HTML, CSS class and style information from the specified cell.
    * @method clearElement
    * @param {HTMLTableCellElement} cell The cell to clear
    */
    clearElement : function(cell) {
        cell.innerHTML = "&#160;";
        cell.className="";
    },

    /**
    * Adds a renderer to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the conditions specified in the date string for this renderer.
    * @method addRenderer
    * @param {String} sDates  A date string to associate with the specified renderer. Valid formats
    *         include date (12/24/2005), month/day (12/24), and range (12/1/2004-1/1/2005)
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addRenderer : function(sDates, fnRender) {
        var aDates = this._parseDates(sDates);
        for (var i=0;i<aDates.length;++i) {
            var aDate = aDates[i];

            if (aDate.length == 2) { // this is either a range or a month/day combo
                if (aDate[0] instanceof Array) { // this is a range
                    this._addRenderer(Calendar.RANGE,aDate,fnRender);
                } else { // this is a month/day combo
                    this._addRenderer(Calendar.MONTH_DAY,aDate,fnRender);
                }
            } else if (aDate.length == 3) {
                this._addRenderer(Calendar.DATE,aDate,fnRender);
            }
        }
    },

    /**
    * The private method used for adding cell renderers to the local render stack.
    * This method is called by other methods that set the renderer type prior to the method call.
    * @method _addRenderer
    * @private
    * @param {String} type  The type string that indicates the type of date renderer being added.
    *         Values are YAHOO.widget.Calendar.DATE, YAHOO.widget.Calendar.MONTH_DAY, YAHOO.widget.Calendar.WEEKDAY,
    *         YAHOO.widget.Calendar.RANGE, YAHOO.widget.Calendar.MONTH
    * @param {Array}  aDates  An array of dates used to construct the renderer. The format varies based
    *         on the renderer type
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    _addRenderer : function(type, aDates, fnRender) {
        var add = [type,aDates,fnRender];
        this.renderStack.unshift(add);
        this._renderStack = this.renderStack.concat();
    },

    /**
    * Adds a month to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the month passed to this method.
    * @method addMonthRenderer
    * @param {Number} month  The month (1-12) to associate with this renderer
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addMonthRenderer : function(month, fnRender) {
        this._addRenderer(Calendar.MONTH,[month],fnRender);
    },

    /**
    * Adds a weekday to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the weekday passed to this method.
    * @method addWeekdayRenderer
    * @param {Number} weekday  The weekday (Sunday = 1, Monday = 2 ... Saturday = 7) to associate with this renderer
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addWeekdayRenderer : function(weekday, fnRender) {
        this._addRenderer(Calendar.WEEKDAY,[weekday],fnRender);
    },



    /**
    * Removes all styles from all body cells in the current calendar table.
    * @method clearAllBodyCellStyles
    * @param {style} style The CSS class name to remove from all calendar body cells
    */
    clearAllBodyCellStyles : function(style) {
        for (var c=0;c<this.cells.length;++c) {
            Dom.removeClass(this.cells[c],style);
        }
    },


    /**
    * Sets the calendar's month explicitly
    * @method setMonth
    * @param {Number} month  The numeric month, from 0 (January) to 11 (December)
    */
    setMonth : function(month) {
        var cfgPageDate = DEF_CFG.PAGEDATE.key,
            current = this.cfg.getProperty(cfgPageDate);
        current.setMonth(parseInt(month, 10));
        this.cfg.setProperty(cfgPageDate, current);
    },

    /**
    * Sets the calendar's year explicitly.
    * @method setYear
    * @param {Number} year  The numeric 4-digit year
    */
    setYear : function(year) {
        var cfgPageDate = DEF_CFG.PAGEDATE.key,
            current = this.cfg.getProperty(cfgPageDate);

        current.setFullYear(parseInt(year, 10) - this.Locale.YEAR_OFFSET);
        this.cfg.setProperty(cfgPageDate, current);
    },

    /**
    * Gets the list of currently selected dates from the calendar.
    * @method getSelectedDates
    * @return {Date[]} An array of currently selected JavaScript Date objects.
    */
    getSelectedDates : function() {
        var returnDates = [],
            selected = this.cfg.getProperty(DEF_CFG.SELECTED.key);

        for (var d=0;d<selected.length;++d) {
            var dateArray = selected[d];

            var date = DateMath.getDate(dateArray[0],dateArray[1]-1,dateArray[2]);
            returnDates.push(date);
        }

        returnDates.sort( function(a,b) { return a-b; } );
        return returnDates;
    },


    /**
    * Hides the Calendar's outer container from view.
    * @method hide
    */
    hide : function() {
        if (this.beforeHideEvent.fire()) {
            this.oDomContainer.style.display = "none";
            this.hideEvent.fire();
        }
    },

    /**
    * Shows the Calendar's outer container.
    * @method show
    */
    show : function() {
        if (this.beforeShowEvent.fire()) {
            this.oDomContainer.style.display = "block";
            this.showEvent.fire();
        }
    },

    /**
    * Returns a string representing the current browser.
    * @deprecated As of 2.3.0, environment information is available in YAHOO.env.ua
    * @see YAHOO.env.ua
    * @property browser
    * @type String
    */
    browser : (function() {
                var ua = navigator.userAgent.toLowerCase();
                      if (ua.indexOf('opera')!=-1) { // Opera (check first in case of spoof)
                         return 'opera';
                      } else if (ua.indexOf('msie 7')!=-1) { // IE7
                         return 'ie7';
                      } else if (ua.indexOf('msie') !=-1) { // IE
                         return 'ie';
                      } else if (ua.indexOf('safari')!=-1) { // Safari (check before Gecko because it includes "like Gecko")
                         return 'safari';
                      } else if (ua.indexOf('gecko') != -1) { // Gecko
                         return 'gecko';
                      } else {
                         return false;
                      }
                })(),
    /**
    * Returns a string representation of the object.
    * @method toString
    * @return {String} A string representation of the Calendar object.
    */
    toString : function() {
        return "Calendar " + this.id;
    },

    /**
     * Destroys the Calendar instance. The method will remove references
     * to HTML elements, remove any event listeners added by the Calendar,
     * and destroy the Config and CalendarNavigator instances it has created.
     *
     * @method destroy
     */
    destroy : function() {

        if (this.beforeDestroyEvent.fire()) {
            var cal = this;

            if (cal.navigator) {
                cal.navigator.destroy();
            }

            if (cal.cfg) {
                cal.cfg.destroy();
            }

            Event.purgeElement(cal.oDomContainer, true);

            Dom.removeClass(cal.oDomContainer, cal.Style.CSS_WITH_TITLE);
            Dom.removeClass(cal.oDomContainer, cal.Style.CSS_CONTAINER);
            Dom.removeClass(cal.oDomContainer, cal.Style.CSS_SINGLE);
            cal.oDomContainer.innerHTML = "";

            cal.oDomContainer = null;
            cal.cells = null;

            this.destroyEvent.fire();
        }
    }
};

YAHOO.widget.Calendar = Calendar;

/**
* @namespace YAHOO.widget
* @class Calendar_Core
* @extends YAHOO.widget.Calendar
* @deprecated The old Calendar_Core class is no longer necessary.
*/
YAHOO.widget.Calendar_Core = YAHOO.widget.Calendar;

YAHOO.widget.Cal_Core = YAHOO.widget.Calendar;

})();
(function() {

    var Dom = YAHOO.util.Dom,
        DateMath = YAHOO.widget.DateMath,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Calendar = YAHOO.widget.Calendar;

/**
* YAHOO.widget.CalendarGroup is a special container class for YAHOO.widget.Calendar. This class facilitates
* the ability to have multi-page calendar views that share a single dataset and are
* dependent on each other.
*
* The calendar group instance will refer to each of its elements using a 0-based index.
* For example, to construct the placeholder for a calendar group widget with id "cal1" and
* containerId of "cal1Container", the markup would be as follows:
*   <xmp>
*       <div id="cal1Container_0"></div>
*       <div id="cal1Container_1"></div>
*   </xmp>
* The tables for the calendars ("cal1_0" and "cal1_1") will be inserted into those containers.
*
* <p>
* <strong>NOTE: As of 2.4.0, the constructor's ID argument is optional.</strong>
* The CalendarGroup can be constructed by simply providing a container ID string,
* or a reference to a container DIV HTMLElement (the element needs to exist
* in the document).
*
* E.g.:
*   <xmp>
*       var c = new YAHOO.widget.CalendarGroup("calContainer", configOptions);
*   </xmp>
* or:
*   <xmp>
*       var containerDiv = YAHOO.util.Dom.get("calContainer");
*       var c = new YAHOO.widget.CalendarGroup(containerDiv, configOptions);
*   </xmp>
* </p>
* <p>
* If not provided, the ID will be generated from the container DIV ID by adding an "_t" suffix.
* For example if an ID is not provided, and the container's ID is "calContainer", the CalendarGroup's ID will be set to "calContainer_t".
* </p>
*
* @namespace YAHOO.widget
* @class CalendarGroup
* @constructor
* @param {String} id optional The id of the table element that will represent the CalendarGroup widget. As of 2.4.0, this argument is optional.
* @param {String | HTMLElement} container The id of the container div element that will wrap the CalendarGroup table, or a reference to a DIV element which exists in the document.
* @param {Object} config optional The configuration object containing the initial configuration values for the CalendarGroup.
*/
function CalendarGroup(id, containerId, config) {
    if (arguments.length > 0) {
        this.init.apply(this, arguments);
    }
}

/**
* The set of default Config property keys and values for the CalendarGroup.
*
* <p>
* NOTE: This property is made public in order to allow users to change
* the default values of configuration properties. Users should not
* modify the key string, unless they are overriding the Calendar implementation
* </p>
*
* @property YAHOO.widget.CalendarGroup.DEFAULT_CONFIG
* @static
* @type Object An object with key/value pairs, the key being the
* uppercase configuration property name and the value being an objec
* literal with a key string property, and a value property, specifying the
* default value of the property
*/

/**
* The set of default Config property keys and values for the CalendarGroup
* @property YAHOO.widget.CalendarGroup._DEFAULT_CONFIG
* @deprecated Made public. See the public DEFAULT_CONFIG property for details
* @private
* @static
* @type Object
*/
CalendarGroup.DEFAULT_CONFIG = CalendarGroup._DEFAULT_CONFIG = Calendar.DEFAULT_CONFIG;
CalendarGroup.DEFAULT_CONFIG.PAGES = {key:"pages", value:2};

var DEF_CFG = CalendarGroup.DEFAULT_CONFIG;

CalendarGroup.prototype = {

    /**
    * Initializes the calendar group. All subclasses must call this method in order for the
    * group to be initialized properly.
    * @method init
    * @param {String} id optional The id of the table element that will represent the CalendarGroup widget. As of 2.4.0, this argument is optional.
    * @param {String | HTMLElement} container The id of the container div element that will wrap the CalendarGroup table, or a reference to a DIV element which exists in the document.
    * @param {Object} config optional The configuration object containing the initial configuration values for the CalendarGroup.
    */
    init : function(id, container, config) {

        var nArgs = this._parseArgs(arguments);

        id = nArgs.id;
        container = nArgs.container;
        config = nArgs.config;

        this.oDomContainer = Dom.get(container);

        if (!this.oDomContainer.id) {
            this.oDomContainer.id = Dom.generateId();
        }
        if (!id) {
            id = this.oDomContainer.id + "_t";
        }

        /**
        * The unique id associated with the CalendarGroup
        * @property id
        * @type String
        */
        this.id = id;

        /**
        * The unique id associated with the CalendarGroup container
        * @property containerId
        * @type String
        */
        this.containerId = this.oDomContainer.id;

        this.initEvents();
        this.initStyles();

        /**
        * The collection of Calendar pages contained within the CalendarGroup
        * @property pages
        * @type YAHOO.widget.Calendar[]
        */
        this.pages = [];

        Dom.addClass(this.oDomContainer, CalendarGroup.CSS_CONTAINER);
        Dom.addClass(this.oDomContainer, CalendarGroup.CSS_MULTI_UP);

        /**
        * The Config object used to hold the configuration variables for the CalendarGroup
        * @property cfg
        * @type YAHOO.util.Config
        */
        this.cfg = new YAHOO.util.Config(this);

        /**
        * The local object which contains the CalendarGroup's options
        * @property Options
        * @type Object
        */
        this.Options = {};

        /**
        * The local object which contains the CalendarGroup's locale settings
        * @property Locale
        * @type Object
        */
        this.Locale = {};

        this.setupConfig();

        if (config) {
            this.cfg.applyConfig(config, true);
        }

        this.cfg.fireQueue();

        if (YAHOO.env.ua.opera){
            this.renderEvent.subscribe(this._fixWidth, this, true);
            this.showEvent.subscribe(this._fixWidth, this, true);
        }

    },

    setupConfig : function() {

        var cfg = this.cfg;

        /**
        * The number of pages to include in the CalendarGroup. This value can only be set once, in the CalendarGroup's constructor arguments.
        * @config pages
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.PAGES.key, { value:DEF_CFG.PAGES.value, validator:cfg.checkNumber, handler:this.configPages } );

        /**
        * The positive or negative year offset from the Gregorian calendar year (assuming a January 1st rollover) to
        * be used when displaying or parsing dates.  NOTE: All JS Date objects returned by methods, or expected as input by
        * methods will always represent the Gregorian year, in order to maintain date/month/week values.
        *
        * @config year_offset
        * @type Number
        * @default 0
        */
        cfg.addProperty(DEF_CFG.YEAR_OFFSET.key, { value:DEF_CFG.YEAR_OFFSET.value, handler: this.delegateConfig, supercedes:DEF_CFG.YEAR_OFFSET.supercedes, suppressEvent:true } );

        /**
        * The date to use to represent "Today".
        *
        * @config today
        * @type Date
        * @default Today's date
        */
        cfg.addProperty(DEF_CFG.TODAY.key, { value: new Date(DEF_CFG.TODAY.value.getTime()), supercedes:DEF_CFG.TODAY.supercedes, handler: this.configToday, suppressEvent:false } );

        /**
        * The month/year representing the current visible Calendar date (mm/yyyy)
        * @config pagedate
        * @type String | Date
        * @default Today's date
        */
        cfg.addProperty(DEF_CFG.PAGEDATE.key, { value: DEF_CFG.PAGEDATE.value || new Date(DEF_CFG.TODAY.value.getTime()), handler:this.configPageDate } );

        /**
        * The date or range of dates representing the current Calendar selection
        *
        * @config selected
        * @type String
        * @default []
        */
        cfg.addProperty(DEF_CFG.SELECTED.key, { value:[], handler:this.configSelected } );

        /**
        * The title to display above the CalendarGroup's month header
        * @config title
        * @type String
        * @default ""
        */
        cfg.addProperty(DEF_CFG.TITLE.key, { value:DEF_CFG.TITLE.value, handler:this.configTitle } );

        /**
        * Whether or not a close button should be displayed for this CalendarGroup
        * @config close
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.CLOSE.key, { value:DEF_CFG.CLOSE.value, handler:this.configClose } );

        /**
        * Whether or not an iframe shim should be placed under the Calendar to prevent select boxes from bleeding through in Internet Explorer 6 and below.
        * This property is enabled by default for IE6 and below. It is disabled by default for other browsers for performance reasons, but can be
        * enabled if required.
        *
        * @config iframe
        * @type Boolean
        * @default true for IE6 and below, false for all other browsers
        */
        cfg.addProperty(DEF_CFG.IFRAME.key, { value:DEF_CFG.IFRAME.value, handler:this.configIframe, validator:cfg.checkBoolean } );

        /**
        * The minimum selectable date in the current Calendar (mm/dd/yyyy)
        * @config mindate
        * @type String | Date
        * @default null
        */
        cfg.addProperty(DEF_CFG.MINDATE.key, { value:DEF_CFG.MINDATE.value, handler:this.delegateConfig } );

        /**
        * The maximum selectable date in the current Calendar (mm/dd/yyyy)
        * @config maxdate
        * @type String | Date
        * @default null
        */
        cfg.addProperty(DEF_CFG.MAXDATE.key, { value:DEF_CFG.MAXDATE.value, handler:this.delegateConfig  } );


        /**
        * True if the Calendar should allow multiple selections. False by default.
        * @config MULTI_SELECT
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.MULTI_SELECT.key, { value:DEF_CFG.MULTI_SELECT.value, handler:this.delegateConfig, validator:cfg.checkBoolean } );

        /**
        * The weekday the week begins on. Default is 0 (Sunday).
        * @config START_WEEKDAY
        * @type number
        * @default 0
        */
        cfg.addProperty(DEF_CFG.START_WEEKDAY.key, { value:DEF_CFG.START_WEEKDAY.value, handler:this.delegateConfig, validator:cfg.checkNumber  } );

        /**
        * True if the Calendar should show weekday labels. True by default.
        * @config SHOW_WEEKDAYS
        * @type Boolean
        * @default true
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEKDAYS.key, { value:DEF_CFG.SHOW_WEEKDAYS.value, handler:this.delegateConfig, validator:cfg.checkBoolean } );

        /**
        * True if the Calendar should show week row headers. False by default.
        * @config SHOW_WEEK_HEADER
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEK_HEADER.key,{ value:DEF_CFG.SHOW_WEEK_HEADER.value, handler:this.delegateConfig, validator:cfg.checkBoolean } );

        /**
        * True if the Calendar should show week row footers. False by default.
        * @config SHOW_WEEK_FOOTER
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.SHOW_WEEK_FOOTER.key,{ value:DEF_CFG.SHOW_WEEK_FOOTER.value, handler:this.delegateConfig, validator:cfg.checkBoolean } );

        /**
        * True if the Calendar should suppress weeks that are not a part of the current month. False by default.
        * @config HIDE_BLANK_WEEKS
        * @type Boolean
        * @default false
        */
        cfg.addProperty(DEF_CFG.HIDE_BLANK_WEEKS.key,{ value:DEF_CFG.HIDE_BLANK_WEEKS.value, handler:this.delegateConfig, validator:cfg.checkBoolean } );

        /**
        * The image that should be used for the left navigation arrow.
        * @config NAV_ARROW_LEFT
        * @type String
        * @deprecated You can customize the image by overriding the default CSS class for the left arrow - "calnavleft"
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV_ARROW_LEFT.key, { value:DEF_CFG.NAV_ARROW_LEFT.value, handler:this.delegateConfig } );

        /**
        * The image that should be used for the right navigation arrow.
        * @config NAV_ARROW_RIGHT
        * @type String
        * @deprecated You can customize the image by overriding the default CSS class for the right arrow - "calnavright"
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV_ARROW_RIGHT.key, { value:DEF_CFG.NAV_ARROW_RIGHT.value, handler:this.delegateConfig } );


        /**
        * The short month labels for the current locale.
        * @config MONTHS_SHORT
        * @type String[]
        * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        */
        cfg.addProperty(DEF_CFG.MONTHS_SHORT.key, { value:DEF_CFG.MONTHS_SHORT.value, handler:this.delegateConfig } );

        /**
        * The long month labels for the current locale.
        * @config MONTHS_LONG
        * @type String[]
        * @default ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
        */
        cfg.addProperty(DEF_CFG.MONTHS_LONG.key,  { value:DEF_CFG.MONTHS_LONG.value, handler:this.delegateConfig } );

        /**
        * The 1-character weekday labels for the current locale.
        * @config WEEKDAYS_1CHAR
        * @type String[]
        * @default ["S", "M", "T", "W", "T", "F", "S"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_1CHAR.key, { value:DEF_CFG.WEEKDAYS_1CHAR.value, handler:this.delegateConfig } );

        /**
        * The short weekday labels for the current locale.
        * @config WEEKDAYS_SHORT
        * @type String[]
        * @default ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_SHORT.key, { value:DEF_CFG.WEEKDAYS_SHORT.value, handler:this.delegateConfig } );

        /**
        * The medium weekday labels for the current locale.
        * @config WEEKDAYS_MEDIUM
        * @type String[]
        * @default ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_MEDIUM.key, { value:DEF_CFG.WEEKDAYS_MEDIUM.value, handler:this.delegateConfig } );

        /**
        * The long weekday labels for the current locale.
        * @config WEEKDAYS_LONG
        * @type String[]
        * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        */
        cfg.addProperty(DEF_CFG.WEEKDAYS_LONG.key, { value:DEF_CFG.WEEKDAYS_LONG.value, handler:this.delegateConfig } );

        /**
        * The setting that determines which length of month labels should be used. Possible values are "short" and "long".
        * @config LOCALE_MONTHS
        * @type String
        * @default "long"
        */
        cfg.addProperty(DEF_CFG.LOCALE_MONTHS.key, { value:DEF_CFG.LOCALE_MONTHS.value, handler:this.delegateConfig } );

        /**
        * The setting that determines which length of weekday labels should be used. Possible values are "1char", "short", "medium", and "long".
        * @config LOCALE_WEEKDAYS
        * @type String
        * @default "short"
        */
        cfg.addProperty(DEF_CFG.LOCALE_WEEKDAYS.key, { value:DEF_CFG.LOCALE_WEEKDAYS.value, handler:this.delegateConfig } );

        /**
        * The value used to delimit individual dates in a date string passed to various Calendar functions.
        * @config DATE_DELIMITER
        * @type String
        * @default ","
        */
        cfg.addProperty(DEF_CFG.DATE_DELIMITER.key,  { value:DEF_CFG.DATE_DELIMITER.value, handler:this.delegateConfig } );

        /**
        * The value used to delimit date fields in a date string passed to various Calendar functions.
        * @config DATE_FIELD_DELIMITER
        * @type String
        * @default "/"
        */
        cfg.addProperty(DEF_CFG.DATE_FIELD_DELIMITER.key,{ value:DEF_CFG.DATE_FIELD_DELIMITER.value, handler:this.delegateConfig } );

        /**
        * The value used to delimit date ranges in a date string passed to various Calendar functions.
        * @config DATE_RANGE_DELIMITER
        * @type String
        * @default "-"
        */
        cfg.addProperty(DEF_CFG.DATE_RANGE_DELIMITER.key,{ value:DEF_CFG.DATE_RANGE_DELIMITER.value, handler:this.delegateConfig } );

        /**
        * The position of the month in a month/year date string
        * @config MY_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MY_MONTH_POSITION.key, { value:DEF_CFG.MY_MONTH_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the year in a month/year date string
        * @config MY_YEAR_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MY_YEAR_POSITION.key, { value:DEF_CFG.MY_YEAR_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the month in a month/day date string
        * @config MD_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MD_MONTH_POSITION.key, { value:DEF_CFG.MD_MONTH_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the day in a month/year date string
        * @config MD_DAY_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MD_DAY_POSITION.key,  { value:DEF_CFG.MD_DAY_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the month in a month/day/year date string
        * @config MDY_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MDY_MONTH_POSITION.key, { value:DEF_CFG.MDY_MONTH_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the day in a month/day/year date string
        * @config MDY_DAY_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MDY_DAY_POSITION.key, { value:DEF_CFG.MDY_DAY_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the year in a month/day/year date string
        * @config MDY_YEAR_POSITION
        * @type Number
        * @default 3
        */
        cfg.addProperty(DEF_CFG.MDY_YEAR_POSITION.key, { value:DEF_CFG.MDY_YEAR_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the month in the month year label string used as the Calendar header
        * @config MY_LABEL_MONTH_POSITION
        * @type Number
        * @default 1
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_MONTH_POSITION.key, { value:DEF_CFG.MY_LABEL_MONTH_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The position of the year in the month year label string used as the Calendar header
        * @config MY_LABEL_YEAR_POSITION
        * @type Number
        * @default 2
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_YEAR_POSITION.key, { value:DEF_CFG.MY_LABEL_YEAR_POSITION.value, handler:this.delegateConfig, validator:cfg.checkNumber } );

        /**
        * The suffix used after the month when rendering the Calendar header
        * @config MY_LABEL_MONTH_SUFFIX
        * @type String
        * @default " "
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_MONTH_SUFFIX.key, { value:DEF_CFG.MY_LABEL_MONTH_SUFFIX.value, handler:this.delegateConfig } );

        /**
        * The suffix used after the year when rendering the Calendar header
        * @config MY_LABEL_YEAR_SUFFIX
        * @type String
        * @default ""
        */
        cfg.addProperty(DEF_CFG.MY_LABEL_YEAR_SUFFIX.key, { value:DEF_CFG.MY_LABEL_YEAR_SUFFIX.value, handler:this.delegateConfig } );

        /**
        * Configuration for the Month Year Navigation UI. By default it is disabled
        * @config NAV
        * @type Object
        * @default null
        */
        cfg.addProperty(DEF_CFG.NAV.key, { value:DEF_CFG.NAV.value, handler:this.configNavigator } );

        /**
         * The map of UI strings which the CalendarGroup UI uses.
         *
         * @config strings
         * @type {Object}
         * @default An object with the properties shown below:
         *     <dl>
         *         <dt>previousMonth</dt><dd><em>String</em> : The string to use for the "Previous Month" navigation UI. Defaults to "Previous Month".</dd>
         *         <dt>nextMonth</dt><dd><em>String</em> : The string to use for the "Next Month" navigation UI. Defaults to "Next Month".</dd>
         *         <dt>close</dt><dd><em>String</em> : The string to use for the close button label. Defaults to "Close".</dd>
         *     </dl>
         */
        cfg.addProperty(DEF_CFG.STRINGS.key, {
            value:DEF_CFG.STRINGS.value,
            handler:this.configStrings,
            validator: function(val) {
                return Lang.isObject(val);
            },
            supercedes: DEF_CFG.STRINGS.supercedes
        });
    },

    /**
    * Initializes CalendarGroup's built-in CustomEvents
    * @method initEvents
    */
    initEvents : function() {

        var me = this,
            strEvent = "Event",
            CE = YAHOO.util.CustomEvent;

        /**
        * Proxy subscriber to subscribe to the CalendarGroup's child Calendars' CustomEvents
        * @method sub
        * @private
        * @param {Function} fn The function to subscribe to this CustomEvent
        * @param {Object} obj The CustomEvent's scope object
        * @param {Boolean} bOverride Whether or not to apply scope correction
        */
        var sub = function(fn, obj, bOverride) {
            for (var p=0;p<me.pages.length;++p) {
                var cal = me.pages[p];
                cal[this.type + strEvent].subscribe(fn, obj, bOverride);
            }
        };

        /**
        * Proxy unsubscriber to unsubscribe from the CalendarGroup's child Calendars' CustomEvents
        * @method unsub
        * @private
        * @param {Function} fn The function to subscribe to this CustomEvent
        * @param {Object} obj The CustomEvent's scope object
        */
        var unsub = function(fn, obj) {
            for (var p=0;p<me.pages.length;++p) {
                var cal = me.pages[p];
                cal[this.type + strEvent].unsubscribe(fn, obj);
            }
        };

        var defEvents = Calendar._EVENT_TYPES;

        /**
        * Fired before a date selection is made
        * @event beforeSelectEvent
        */
        me.beforeSelectEvent = new CE(defEvents.BEFORE_SELECT);
        me.beforeSelectEvent.subscribe = sub; me.beforeSelectEvent.unsubscribe = unsub;

        /**
        * Fired when a date selection is made
        * @event selectEvent
        * @param {Array} Array of Date field arrays in the format [YYYY, MM, DD].
        */
        me.selectEvent = new CE(defEvents.SELECT);
        me.selectEvent.subscribe = sub; me.selectEvent.unsubscribe = unsub;

        /**
        * Fired before a date or set of dates is deselected
        * @event beforeDeselectEvent
        */
        me.beforeDeselectEvent = new CE(defEvents.BEFORE_DESELECT);
        me.beforeDeselectEvent.subscribe = sub; me.beforeDeselectEvent.unsubscribe = unsub;

        /**
        * Fired when a date or set of dates has been deselected
        * @event deselectEvent
        * @param {Array} Array of Date field arrays in the format [YYYY, MM, DD].
        */
        me.deselectEvent = new CE(defEvents.DESELECT);
        me.deselectEvent.subscribe = sub; me.deselectEvent.unsubscribe = unsub;

        /**
        * Fired when the Calendar page is changed
        * @event changePageEvent
        */
        me.changePageEvent = new CE(defEvents.CHANGE_PAGE);
        me.changePageEvent.subscribe = sub; me.changePageEvent.unsubscribe = unsub;

        /**
        * Fired before the Calendar is rendered
        * @event beforeRenderEvent
        */
        me.beforeRenderEvent = new CE(defEvents.BEFORE_RENDER);
        me.beforeRenderEvent.subscribe = sub; me.beforeRenderEvent.unsubscribe = unsub;

        /**
        * Fired when the Calendar is rendered
        * @event renderEvent
        */
        me.renderEvent = new CE(defEvents.RENDER);
        me.renderEvent.subscribe = sub; me.renderEvent.unsubscribe = unsub;

        /**
        * Fired when the Calendar is reset
        * @event resetEvent
        */
        me.resetEvent = new CE(defEvents.RESET);
        me.resetEvent.subscribe = sub; me.resetEvent.unsubscribe = unsub;

        /**
        * Fired when the Calendar is cleared
        * @event clearEvent
        */
        me.clearEvent = new CE(defEvents.CLEAR);
        me.clearEvent.subscribe = sub; me.clearEvent.unsubscribe = unsub;

        /**
        * Fired just before the CalendarGroup is to be shown
        * @event beforeShowEvent
        */
        me.beforeShowEvent = new CE(defEvents.BEFORE_SHOW);

        /**
        * Fired after the CalendarGroup is shown
        * @event showEvent
        */
        me.showEvent = new CE(defEvents.SHOW);

        /**
        * Fired just before the CalendarGroup is to be hidden
        * @event beforeHideEvent
        */
        me.beforeHideEvent = new CE(defEvents.BEFORE_HIDE);

        /**
        * Fired after the CalendarGroup is hidden
        * @event hideEvent
        */
        me.hideEvent = new CE(defEvents.HIDE);

        /**
        * Fired just before the CalendarNavigator is to be shown
        * @event beforeShowNavEvent
        */
        me.beforeShowNavEvent = new CE(defEvents.BEFORE_SHOW_NAV);

        /**
        * Fired after the CalendarNavigator is shown
        * @event showNavEvent
        */
        me.showNavEvent = new CE(defEvents.SHOW_NAV);

        /**
        * Fired just before the CalendarNavigator is to be hidden
        * @event beforeHideNavEvent
        */
        me.beforeHideNavEvent = new CE(defEvents.BEFORE_HIDE_NAV);

        /**
        * Fired after the CalendarNavigator is hidden
        * @event hideNavEvent
        */
        me.hideNavEvent = new CE(defEvents.HIDE_NAV);

        /**
        * Fired just before the CalendarNavigator is to be rendered
        * @event beforeRenderNavEvent
        */
        me.beforeRenderNavEvent = new CE(defEvents.BEFORE_RENDER_NAV);

        /**
        * Fired after the CalendarNavigator is rendered
        * @event renderNavEvent
        */
        me.renderNavEvent = new CE(defEvents.RENDER_NAV);

        /**
        * Fired just before the CalendarGroup is to be destroyed
        * @event beforeDestroyEvent
        */
        me.beforeDestroyEvent = new CE(defEvents.BEFORE_DESTROY);

        /**
        * Fired after the CalendarGroup is destroyed. This event should be used
        * for notification only. When this event is fired, important CalendarGroup instance
        * properties, dom references and event listeners have already been
        * removed/dereferenced, and hence the CalendarGroup instance is not in a usable
        * state.
        *
        * @event destroyEvent
        */
        me.destroyEvent = new CE(defEvents.DESTROY);
    },

    /**
    * The default Config handler for the "pages" property
    * @method configPages
    * @param {String} type The CustomEvent type (usually the property name)
    * @param {Object[]} args The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value for the property.
    * @param {Object} obj The scope object. For configuration handlers, this will usually equal the owner.
    */
    configPages : function(type, args, obj) {
        var pageCount = args[0],
            cfgPageDate = DEF_CFG.PAGEDATE.key,
            sep = "_",
            caldate,
            firstPageDate = null,
            groupCalClass = "groupcal",
            firstClass = "first-of-type",
            lastClass = "last-of-type";

        for (var p=0;p<pageCount;++p) {
            var calId = this.id + sep + p,
                calContainerId = this.containerId + sep + p,
                childConfig = this.cfg.getConfig();

            childConfig.close = false;
            childConfig.title = false;
            childConfig.navigator = null;

            if (p > 0) {
                caldate = new Date(firstPageDate);
                this._setMonthOnDate(caldate, caldate.getMonth() + p);
                childConfig.pageDate = caldate;
            }

            var cal = this.constructChild(calId, calContainerId, childConfig);

            Dom.removeClass(cal.oDomContainer, this.Style.CSS_SINGLE);
            Dom.addClass(cal.oDomContainer, groupCalClass);

            if (p===0) {
                firstPageDate = cal.cfg.getProperty(cfgPageDate);
                Dom.addClass(cal.oDomContainer, firstClass);
            }

            if (p==(pageCount-1)) {
                Dom.addClass(cal.oDomContainer, lastClass);
            }

            cal.parent = this;
            cal.index = p;

            this.pages[this.pages.length] = cal;
        }
    },

    /**
    * The default Config handler for the "pagedate" property
    * @method configPageDate
    * @param {String} type The CustomEvent type (usually the property name)
    * @param {Object[]} args The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value for the property.
    * @param {Object} obj The scope object. For configuration handlers, this will usually equal the owner.
    */
    configPageDate : function(type, args, obj) {
        var val = args[0],
            firstPageDate;

        var cfgPageDate = DEF_CFG.PAGEDATE.key;

        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            if (p === 0) {
                firstPageDate = cal._parsePageDate(val);
                cal.cfg.setProperty(cfgPageDate, firstPageDate);
            } else {
                var pageDate = new Date(firstPageDate);
                this._setMonthOnDate(pageDate, pageDate.getMonth() + p);
                cal.cfg.setProperty(cfgPageDate, pageDate);
            }
        }
    },

    /**
    * The default Config handler for the CalendarGroup "selected" property
    * @method configSelected
    * @param {String} type The CustomEvent type (usually the property name)
    * @param {Object[]} args The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value for the property.
    * @param {Object} obj The scope object. For configuration handlers, this will usually equal the owner.
    */
    configSelected : function(type, args, obj) {
        var cfgSelected = DEF_CFG.SELECTED.key;
        this.delegateConfig(type, args, obj);
        var selected = (this.pages.length > 0) ? this.pages[0].cfg.getProperty(cfgSelected) : [];
        this.cfg.setProperty(cfgSelected, selected, true);
    },


    /**
    * Delegates a configuration property to the CustomEvents associated with the CalendarGroup's children
    * @method delegateConfig
    * @param {String} type The CustomEvent type (usually the property name)
    * @param {Object[]} args The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value for the property.
    * @param {Object} obj The scope object. For configuration handlers, this will usually equal the owner.
    */
    delegateConfig : function(type, args, obj) {
        var val = args[0];
        var cal;

        for (var p=0;p<this.pages.length;p++) {
            cal = this.pages[p];
            cal.cfg.setProperty(type, val);
        }
    },

    /**
    * Adds a function to all child Calendars within this CalendarGroup.
    * @method setChildFunction
    * @param {String}  fnName  The name of the function
    * @param {Function}  fn   The function to apply to each Calendar page object
    */
    setChildFunction : function(fnName, fn) {
        var pageCount = this.cfg.getProperty(DEF_CFG.PAGES.key);

        for (var p=0;p<pageCount;++p) {
            this.pages[p][fnName] = fn;
        }
    },

    /**
    * Calls a function within all child Calendars within this CalendarGroup.
    * @method callChildFunction
    * @param {String}  fnName  The name of the function
    * @param {Array}  args  The arguments to pass to the function
    */
    callChildFunction : function(fnName, args) {
        var pageCount = this.cfg.getProperty(DEF_CFG.PAGES.key);

        for (var p=0;p<pageCount;++p) {
            var page = this.pages[p];
            if (page[fnName]) {
                var fn = page[fnName];
                fn.call(page, args);
            }
        }
    },

    /**
    * Constructs a child calendar. This method can be overridden if a subclassed version of the default
    * calendar is to be used.
    * @method constructChild
    * @param {String} id   The id of the table element that will represent the calendar widget
    * @param {String} containerId The id of the container div element that will wrap the calendar table
    * @param {Object} config  The configuration object containing the Calendar's arguments
    * @return {YAHOO.widget.Calendar} The YAHOO.widget.Calendar instance that is constructed
    */
    constructChild : function(id,containerId,config) {
        var container = document.getElementById(containerId);
        if (! container) {
            container = document.createElement("div");
            container.id = containerId;
            this.oDomContainer.appendChild(container);
        }
        return new Calendar(id,containerId,config);
    },

    /**
    * Sets the calendar group's month explicitly. This month will be set into the first
    * page of the multi-page calendar, and all other months will be iterated appropriately.
    * @method setMonth
    * @param {Number} month  The numeric month, from 0 (January) to 11 (December)
    */
    setMonth : function(month) {
        month = parseInt(month, 10);
        var currYear;

        var cfgPageDate = DEF_CFG.PAGEDATE.key;

        for (var p=0; p<this.pages.length; ++p) {
            var cal = this.pages[p];
            var pageDate = cal.cfg.getProperty(cfgPageDate);
            if (p === 0) {
                currYear = pageDate.getFullYear();
            } else {
                pageDate.setFullYear(currYear);
            }
            this._setMonthOnDate(pageDate, month+p);
            cal.cfg.setProperty(cfgPageDate, pageDate);
        }
    },

    /**
    * Sets the calendar group's year explicitly. This year will be set into the first
    * page of the multi-page calendar, and all other months will be iterated appropriately.
    * @method setYear
    * @param {Number} year  The numeric 4-digit year
    */
    setYear : function(year) {

        var cfgPageDate = DEF_CFG.PAGEDATE.key;

        year = parseInt(year, 10);
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            var pageDate = cal.cfg.getProperty(cfgPageDate);

            if ((pageDate.getMonth()+1) == 1 && p>0) {
                year+=1;
            }
            cal.setYear(year);
        }
    },

    /**
    * Calls the render function of all child calendars within the group.
    * @method render
    */
    render : function() {
        this.renderHeader();
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.render();
        }
        this.renderFooter();
    },

    /**
    * Selects a date or a collection of dates on the current calendar. This method, by default,
    * does not call the render method explicitly. Once selection has completed, render must be
    * called for the changes to be reflected visually.
    * @method select
    * @param    {String/Date/Date[]}    date    The date string of dates to select in the current calendar. Valid formats are
    *                               individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
    *                               Multiple comma-delimited dates can also be passed to this method (12/24/2005,12/11/2005-12/13/2005).
    *                               This method can also take a JavaScript Date object or an array of Date objects.
    * @return {Date[]} Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    select : function(date) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.select(date);
        }
        return this.getSelectedDates();
    },

    /**
    * Selects dates in the CalendarGroup based on the cell index provided. This method is used to select cells without having to do a full render. The selected style is applied to the cells directly.
    * The value of the MULTI_SELECT Configuration attribute will determine the set of dates which get selected.
    * <ul>
    *    <li>If MULTI_SELECT is false, selectCell will select the cell at the specified index for only the last displayed Calendar page.</li>
    *    <li>If MULTI_SELECT is true, selectCell will select the cell at the specified index, on each displayed Calendar page.</li>
    * </ul>
    * @method selectCell
    * @param {Number} cellIndex The index of the cell to be selected.
    * @return {Date[]} Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    selectCell : function(cellIndex) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.selectCell(cellIndex);
        }
        return this.getSelectedDates();
    },

    /**
    * Deselects a date or a collection of dates on the current calendar. This method, by default,
    * does not call the render method explicitly. Once deselection has completed, render must be
    * called for the changes to be reflected visually.
    * @method deselect
    * @param {String/Date/Date[]} date The date string of dates to deselect in the current calendar. Valid formats are
    *        individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
    *        Multiple comma-delimited dates can also be passed to this method (12/24/2005,12/11/2005-12/13/2005).
    *        This method can also take a JavaScript Date object or an array of Date objects.
    * @return {Date[]}   Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    deselect : function(date) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.deselect(date);
        }
        return this.getSelectedDates();
    },

    /**
    * Deselects all dates on the current calendar.
    * @method deselectAll
    * @return {Date[]}  Array of JavaScript Date objects representing all individual dates that are currently selected.
    *      Assuming that this function executes properly, the return value should be an empty array.
    *      However, the empty array is returned for the sake of being able to check the selection status
    *      of the calendar.
    */
    deselectAll : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.deselectAll();
        }
        return this.getSelectedDates();
    },

    /**
    * Deselects dates in the CalendarGroup based on the cell index provided. This method is used to select cells without having to do a full render. The selected style is applied to the cells directly.
    * deselectCell will deselect the cell at the specified index on each displayed Calendar page.
    *
    * @method deselectCell
    * @param {Number} cellIndex The index of the cell to deselect.
    * @return {Date[]} Array of JavaScript Date objects representing all individual dates that are currently selected.
    */
    deselectCell : function(cellIndex) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.deselectCell(cellIndex);
        }
        return this.getSelectedDates();
    },

    /**
    * Resets the calendar widget to the originally selected month and year, and
    * sets the calendar to the initial selection(s).
    * @method reset
    */
    reset : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.reset();
        }
    },

    /**
    * Clears the selected dates in the current calendar widget and sets the calendar
    * to the current month and year.
    * @method clear
    */
    clear : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.clear();
        }

        this.cfg.setProperty(DEF_CFG.SELECTED.key, []);
        this.cfg.setProperty(DEF_CFG.PAGEDATE.key, new Date(this.pages[0].today.getTime()));
        this.render();
    },

    /**
    * Navigates to the next month page in the calendar widget.
    * @method nextMonth
    */
    nextMonth : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.nextMonth();
        }
    },

    /**
    * Navigates to the previous month page in the calendar widget.
    * @method previousMonth
    */
    previousMonth : function() {
        for (var p=this.pages.length-1;p>=0;--p) {
            var cal = this.pages[p];
            cal.previousMonth();
        }
    },

    /**
    * Navigates to the next year in the currently selected month in the calendar widget.
    * @method nextYear
    */
    nextYear : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.nextYear();
        }
    },

    /**
    * Navigates to the previous year in the currently selected month in the calendar widget.
    * @method previousYear
    */
    previousYear : function() {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.previousYear();
        }
    },

    /**
    * Gets the list of currently selected dates from the calendar.
    * @return   An array of currently selected JavaScript Date objects.
    * @type Date[]
    */
    getSelectedDates : function() {
        var returnDates = [];
        var selected = this.cfg.getProperty(DEF_CFG.SELECTED.key);
        for (var d=0;d<selected.length;++d) {
            var dateArray = selected[d];

            var date = DateMath.getDate(dateArray[0],dateArray[1]-1,dateArray[2]);
            returnDates.push(date);
        }

        returnDates.sort( function(a,b) { return a-b; } );
        return returnDates;
    },

    /**
    * Adds a renderer to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the conditions specified in the date string for this renderer.
    * @method addRenderer
    * @param {String} sDates  A date string to associate with the specified renderer. Valid formats
    *         include date (12/24/2005), month/day (12/24), and range (12/1/2004-1/1/2005)
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addRenderer : function(sDates, fnRender) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.addRenderer(sDates, fnRender);
        }
    },

    /**
    * Adds a month to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the month passed to this method.
    * @method addMonthRenderer
    * @param {Number} month  The month (1-12) to associate with this renderer
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addMonthRenderer : function(month, fnRender) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.addMonthRenderer(month, fnRender);
        }
    },

    /**
    * Adds a weekday to the render stack. The function reference passed to this method will be executed
    * when a date cell matches the weekday passed to this method.
    * @method addWeekdayRenderer
    * @param {Number} weekday  The weekday (1-7) to associate with this renderer. 1=Sunday, 2=Monday etc.
    * @param {Function} fnRender The function executed to render cells that match the render rules for this renderer.
    */
    addWeekdayRenderer : function(weekday, fnRender) {
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            cal.addWeekdayRenderer(weekday, fnRender);
        }
    },

    /**
     * Removes all custom renderers added to the CalendarGroup through the addRenderer, addMonthRenderer and
     * addWeekRenderer methods. CalendarGroup's render method needs to be called to after removing renderers
     * to see the changes applied.
     *
     * @method removeRenderers
     */
    removeRenderers : function() {
        this.callChildFunction("removeRenderers");
    },

    /**
    * Renders the header for the CalendarGroup.
    * @method renderHeader
    */
    renderHeader : function() {
    },

    /**
    * Renders a footer for the 2-up calendar container. By default, this method is
    * unimplemented.
    * @method renderFooter
    */
    renderFooter : function() {
    },

    /**
    * Adds the designated number of months to the current calendar month, and sets the current
    * calendar page date to the new month.
    * @method addMonths
    * @param {Number} count The number of months to add to the current calendar
    */
    addMonths : function(count) {
        this.callChildFunction("addMonths", count);
    },

    /**
    * Subtracts the designated number of months from the current calendar month, and sets the current
    * calendar page date to the new month.
    * @method subtractMonths
    * @param {Number} count The number of months to subtract from the current calendar
    */
    subtractMonths : function(count) {
        this.callChildFunction("subtractMonths", count);
    },

    /**
    * Adds the designated number of years to the current calendar, and sets the current
    * calendar page date to the new month.
    * @method addYears
    * @param {Number} count The number of years to add to the current calendar
    */
    addYears : function(count) {
        this.callChildFunction("addYears", count);
    },

    /**
    * Subtcats the designated number of years from the current calendar, and sets the current
    * calendar page date to the new month.
    * @method subtractYears
    * @param {Number} count The number of years to subtract from the current calendar
    */
    subtractYears : function(count) {
        this.callChildFunction("subtractYears", count);
    },

    /**
     * Returns the Calendar page instance which has a pagedate (month/year) matching the given date.
     * Returns null if no match is found.
     *
     * @method getCalendarPage
     * @param {Date} date The JavaScript Date object for which a Calendar page is to be found.
     * @return {Calendar} The Calendar page instance representing the month to which the date
     * belongs.
     */
    getCalendarPage : function(date) {
        var cal = null;
        if (date) {
            var y = date.getFullYear(),
                m = date.getMonth();

            var pages = this.pages;
            for (var i = 0; i < pages.length; ++i) {
                var pageDate = pages[i].cfg.getProperty("pagedate");
                if (pageDate.getFullYear() === y && pageDate.getMonth() === m) {
                    cal = pages[i];
                    break;
                }
            }
        }
        return cal;
    },

    /**
    * Sets the month on a Date object, taking into account year rollover if the month is less than 0 or greater than 11.
    * The Date object passed in is modified. It should be cloned before passing it into this method if the original value needs to be maintained
    * @method _setMonthOnDate
    * @private
    * @param {Date} date The Date object on which to set the month index
    * @param {Number} iMonth The month index to set
    */
    _setMonthOnDate : function(date, iMonth) {
        if (YAHOO.env.ua.webkit && YAHOO.env.ua.webkit < 420 && (iMonth < 0 || iMonth > 11)) {
            var newDate = DateMath.add(date, DateMath.MONTH, iMonth-date.getMonth());
            date.setTime(newDate.getTime());
        } else {
            date.setMonth(iMonth);
        }
    },

    /**
     * Fixes the width of the CalendarGroup container element, to account for miswrapped floats
     * @method _fixWidth
     * @private
     */
    _fixWidth : function() {
        var w = 0;
        for (var p=0;p<this.pages.length;++p) {
            var cal = this.pages[p];
            w += cal.oDomContainer.offsetWidth;
        }
        if (w > 0) {
            this.oDomContainer.style.width = w + "px";
        }
    },

    /**
    * Returns a string representation of the object.
    * @method toString
    * @return {String} A string representation of the CalendarGroup object.
    */
    toString : function() {
        return "CalendarGroup " + this.id;
    },

    /**
     * Destroys the CalendarGroup instance. The method will remove references
     * to HTML elements, remove any event listeners added by the CalendarGroup.
     *
     * It will also destroy the Config and CalendarNavigator instances created by the
     * CalendarGroup and the individual Calendar instances created for each page.
     *
     * @method destroy
     */
    destroy : function() {

        if (this.beforeDestroyEvent.fire()) {

            var cal = this;

            if (cal.navigator) {
                cal.navigator.destroy();
            }

            if (cal.cfg) {
                cal.cfg.destroy();
            }

            Event.purgeElement(cal.oDomContainer, true);

            Dom.removeClass(cal.oDomContainer, CalendarGroup.CSS_CONTAINER);
            Dom.removeClass(cal.oDomContainer, CalendarGroup.CSS_MULTI_UP);

            for (var i = 0, l = cal.pages.length; i < l; i++) {
                cal.pages[i].destroy();
                cal.pages[i] = null;
            }

            cal.oDomContainer.innerHTML = "";

            cal.oDomContainer = null;

            this.destroyEvent.fire();
        }
    }
};

/**
* CSS class representing the container for the calendar
* @property YAHOO.widget.CalendarGroup.CSS_CONTAINER
* @static
* @final
* @type String
*/
CalendarGroup.CSS_CONTAINER = "yui-calcontainer";

/**
* CSS class representing the container for the calendar
* @property YAHOO.widget.CalendarGroup.CSS_MULTI_UP
* @static
* @final
* @type String
*/
CalendarGroup.CSS_MULTI_UP = "multi";

/**
* CSS class representing the title for the 2-up calendar
* @property YAHOO.widget.CalendarGroup.CSS_2UPTITLE
* @static
* @final
* @type String
*/
CalendarGroup.CSS_2UPTITLE = "title";

/**
* CSS class representing the close icon for the 2-up calendar
* @property YAHOO.widget.CalendarGroup.CSS_2UPCLOSE
* @static
* @final
* @deprecated Along with Calendar.IMG_ROOT and NAV_ARROW_LEFT, NAV_ARROW_RIGHT configuration properties.
*     Calendar's <a href="YAHOO.widget.Calendar.html#Style.CSS_CLOSE">Style.CSS_CLOSE</a> property now represents the CSS class used to render the close icon
* @type String
*/
CalendarGroup.CSS_2UPCLOSE = "close-icon";

YAHOO.lang.augmentProto(CalendarGroup, Calendar, "buildDayLabel",
                                                 "buildMonthLabel",
                                                 "renderOutOfBoundsDate",
                                                 "renderRowHeader",
                                                 "renderRowFooter",
                                                 "renderCellDefault",
                                                 "styleCellDefault",
                                                 "renderCellStyleHighlight1",
                                                 "renderCellStyleHighlight2",
                                                 "renderCellStyleHighlight3",
                                                 "renderCellStyleHighlight4",
                                                 "renderCellStyleToday",
                                                 "renderCellStyleSelected",
                                                 "renderCellNotThisMonth",
                                                 "renderBodyCellRestricted",
                                                 "initStyles",
                                                 "configTitle",
                                                 "configClose",
                                                 "configIframe",
                                                 "configStrings",
                                                 "configToday",
                                                 "configNavigator",
                                                 "createTitleBar",
                                                 "createCloseButton",
                                                 "removeTitleBar",
                                                 "removeCloseButton",
                                                 "hide",
                                                 "show",
                                                 "toDate",
                                                 "_toDate",
                                                 "_parseArgs",
                                                 "browser");

YAHOO.widget.CalGrp = CalendarGroup;
YAHOO.widget.CalendarGroup = CalendarGroup;

/**
* @class YAHOO.widget.Calendar2up
* @extends YAHOO.widget.CalendarGroup
* @deprecated The old Calendar2up class is no longer necessary, since CalendarGroup renders in a 2up view by default.
*/
YAHOO.widget.Calendar2up = function(id, containerId, config) {
    this.init(id, containerId, config);
};

YAHOO.extend(YAHOO.widget.Calendar2up, CalendarGroup);

/**
* @deprecated The old Calendar2up class is no longer necessary, since CalendarGroup renders in a 2up view by default.
*/
YAHOO.widget.Cal2up = YAHOO.widget.Calendar2up;

})();
/**
 * The CalendarNavigator is used along with a Calendar/CalendarGroup to
 * provide a Month/Year popup navigation control, allowing the user to navigate
 * to a specific month/year in the Calendar/CalendarGroup without having to
 * scroll through months sequentially
 *
 * @namespace YAHOO.widget
 * @class CalendarNavigator
 * @constructor
 * @param {Calendar|CalendarGroup} cal The instance of the Calendar or CalendarGroup to which this CalendarNavigator should be attached.
 */
YAHOO.widget.CalendarNavigator = function(cal) {
    this.init(cal);
};

(function() {
    var CN = YAHOO.widget.CalendarNavigator;

    /**
     * YAHOO.widget.CalendarNavigator.CLASSES contains constants
     * for the class values applied to the CalendarNaviatgator's
     * DOM elements
     * @property YAHOO.widget.CalendarNavigator.CLASSES
     * @type Object
     * @static
     */
    CN.CLASSES = {
        /**
         * Class applied to the Calendar Navigator's bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.NAV
         * @type String
         * @static
         */
        NAV :"yui-cal-nav",
        /**
         * Class applied to the Calendar/CalendarGroup's bounding box to indicate
         * the Navigator is currently visible
         * @property YAHOO.widget.CalendarNavigator.CLASSES.NAV_VISIBLE
         * @type String
         * @static
         */
        NAV_VISIBLE: "yui-cal-nav-visible",
        /**
         * Class applied to the Navigator mask's bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.MASK
         * @type String
         * @static
         */
        MASK : "yui-cal-nav-mask",
        /**
         * Class applied to the year label/control bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.YEAR
         * @type String
         * @static
         */
        YEAR : "yui-cal-nav-y",
        /**
         * Class applied to the month label/control bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.MONTH
         * @type String
         * @static
         */
        MONTH : "yui-cal-nav-m",
        /**
         * Class applied to the submit/cancel button's bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.BUTTONS
         * @type String
         * @static
         */
        BUTTONS : "yui-cal-nav-b",
        /**
         * Class applied to buttons wrapping element
         * @property YAHOO.widget.CalendarNavigator.CLASSES.BUTTON
         * @type String
         * @static
         */
        BUTTON : "yui-cal-nav-btn",
        /**
         * Class applied to the validation error area's bounding box
         * @property YAHOO.widget.CalendarNavigator.CLASSES.ERROR
         * @type String
         * @static
         */
        ERROR : "yui-cal-nav-e",
        /**
         * Class applied to the year input control
         * @property YAHOO.widget.CalendarNavigator.CLASSES.YEAR_CTRL
         * @type String
         * @static
         */
        YEAR_CTRL : "yui-cal-nav-yc",
        /**
         * Class applied to the month input control
         * @property YAHOO.widget.CalendarNavigator.CLASSES.MONTH_CTRL
         * @type String
         * @static
         */
        MONTH_CTRL : "yui-cal-nav-mc",
        /**
         * Class applied to controls with invalid data (e.g. a year input field with invalid an year)
         * @property YAHOO.widget.CalendarNavigator.CLASSES.INVALID
         * @type String
         * @static
         */
        INVALID : "yui-invalid",
        /**
         * Class applied to default controls
         * @property YAHOO.widget.CalendarNavigator.CLASSES.DEFAULT
         * @type String
         * @static
         */
        DEFAULT : "yui-default"
    };

    /**
     * Object literal containing the default configuration values for the CalendarNavigator
     * The configuration object is expected to follow the format below, with the properties being
     * case sensitive.
     * <dl>
     * <dt>strings</dt>
     * <dd><em>Object</em> :  An object with the properties shown below, defining the string labels to use in the Navigator's UI
     *     <dl>
     *         <dt>month</dt><dd><em>String</em> : The string to use for the month label. Defaults to "Month".</dd>
     *         <dt>year</dt><dd><em>String</em> : The string to use for the year label. Defaults to "Year".</dd>
     *         <dt>submit</dt><dd><em>String</em> : The string to use for the submit button label. Defaults to "Okay".</dd>
     *         <dt>cancel</dt><dd><em>String</em> : The string to use for the cancel button label. Defaults to "Cancel".</dd>
     *         <dt>invalidYear</dt><dd><em>String</em> : The string to use for invalid year values. Defaults to "Year needs to be a number".</dd>
     *     </dl>
     * </dd>
     * <dt>monthFormat</dt><dd><em>String</em> : The month format to use. Either YAHOO.widget.Calendar.LONG, or YAHOO.widget.Calendar.SHORT. Defaults to YAHOO.widget.Calendar.LONG</dd>
     * <dt>initialFocus</dt><dd><em>String</em> : Either "year" or "month" specifying which input control should get initial focus. Defaults to "year"</dd>
     * </dl>
     * @property DEFAULT_CONFIG
     * @type Object
     * @static
     */
    CN.DEFAULT_CONFIG = {
        strings : {
            month: "Month",
            year: "Year",
            submit: "Okay",
            cancel: "Cancel",
            invalidYear : "Year needs to be a number"
        },
        monthFormat: YAHOO.widget.Calendar.LONG,
        initialFocus: "year"
    };

    /**
     * Object literal containing the default configuration values for the CalendarNavigator
     * @property _DEFAULT_CFG
     * @protected
     * @deprecated Made public. See the public DEFAULT_CONFIG property
     * @type Object
     * @static
     */
    CN._DEFAULT_CFG = CN.DEFAULT_CONFIG;


    /**
     * The suffix added to the Calendar/CalendarGroup's ID, to generate
     * a unique ID for the Navigator and it's bounding box.
     * @property YAHOO.widget.CalendarNavigator.ID_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.ID_SUFFIX = "_nav";
    /**
     * The suffix added to the Navigator's ID, to generate
     * a unique ID for the month control.
     * @property YAHOO.widget.CalendarNavigator.MONTH_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.MONTH_SUFFIX = "_month";
    /**
     * The suffix added to the Navigator's ID, to generate
     * a unique ID for the year control.
     * @property YAHOO.widget.CalendarNavigator.YEAR_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.YEAR_SUFFIX = "_year";
    /**
     * The suffix added to the Navigator's ID, to generate
     * a unique ID for the error bounding box.
     * @property YAHOO.widget.CalendarNavigator.ERROR_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.ERROR_SUFFIX = "_error";
    /**
     * The suffix added to the Navigator's ID, to generate
     * a unique ID for the "Cancel" button.
     * @property YAHOO.widget.CalendarNavigator.CANCEL_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.CANCEL_SUFFIX = "_cancel";
    /**
     * The suffix added to the Navigator's ID, to generate
     * a unique ID for the "Submit" button.
     * @property YAHOO.widget.CalendarNavigator.SUBMIT_SUFFIX
     * @static
     * @type String
     * @final
     */
    CN.SUBMIT_SUFFIX = "_submit";

    /**
     * The number of digits to which the year input control is to be limited.
     * @property YAHOO.widget.CalendarNavigator.YR_MAX_DIGITS
     * @static
     * @type Number
     */
    CN.YR_MAX_DIGITS = 4;

    /**
     * The amount by which to increment the current year value,
     * when the arrow up/down key is pressed on the year control
     * @property YAHOO.widget.CalendarNavigator.YR_MINOR_INC
     * @static
     * @type Number
     */
    CN.YR_MINOR_INC = 1;

    /**
     * The amount by which to increment the current year value,
     * when the page up/down key is pressed on the year control
     * @property YAHOO.widget.CalendarNavigator.YR_MAJOR_INC
     * @static
     * @type Number
     */
    CN.YR_MAJOR_INC = 10;

    /**
     * Artificial delay (in ms) between the time the Navigator is hidden
     * and the Calendar/CalendarGroup state is updated. Allows the user
     * the see the Calendar/CalendarGroup page changing. If set to 0
     * the Calendar/CalendarGroup page will be updated instantly
     * @property YAHOO.widget.CalendarNavigator.UPDATE_DELAY
     * @static
     * @type Number
     */
    CN.UPDATE_DELAY = 50;

    /**
     * Regular expression used to validate the year input
     * @property YAHOO.widget.CalendarNavigator.YR_PATTERN
     * @static
     * @type RegExp
     */
    CN.YR_PATTERN = /^\d+$/;
    /**
     * Regular expression used to trim strings
     * @property YAHOO.widget.CalendarNavigator.TRIM
     * @static
     * @type RegExp
     */
    CN.TRIM = /^\s*(.*?)\s*$/;
})();

YAHOO.widget.CalendarNavigator.prototype = {

    /**
     * The unique ID for this CalendarNavigator instance
     * @property id
     * @type String
     */
    id : null,

    /**
     * The Calendar/CalendarGroup instance to which the navigator belongs
     * @property cal
     * @type {Calendar|CalendarGroup}
     */
    cal : null,

    /**
     * Reference to the HTMLElement used to render the navigator's bounding box
     * @property navEl
     * @type HTMLElement
     */
    navEl : null,

    /**
     * Reference to the HTMLElement used to render the navigator's mask
     * @property maskEl
     * @type HTMLElement
     */
    maskEl : null,

    /**
     * Reference to the HTMLElement used to input the year
     * @property yearEl
     * @type HTMLElement
     */
    yearEl : null,

    /**
     * Reference to the HTMLElement used to input the month
     * @property monthEl
     * @type HTMLElement
     */
    monthEl : null,

    /**
     * Reference to the HTMLElement used to display validation errors
     * @property errorEl
     * @type HTMLElement
     */
    errorEl : null,

    /**
     * Reference to the HTMLElement used to update the Calendar/Calendar group
     * with the month/year values
     * @property submitEl
     * @type HTMLElement
     */
    submitEl : null,

    /**
     * Reference to the HTMLElement used to hide the navigator without updating the
     * Calendar/Calendar group
     * @property cancelEl
     * @type HTMLElement
     */
    cancelEl : null,

    /**
     * Reference to the first focusable control in the navigator (by default monthEl)
     * @property firstCtrl
     * @type HTMLElement
     */
    firstCtrl : null,

    /**
     * Reference to the last focusable control in the navigator (by default cancelEl)
     * @property lastCtrl
     * @type HTMLElement
     */
    lastCtrl : null,

    /**
     * The document containing the Calendar/Calendar group instance
     * @protected
     * @property _doc
     * @type HTMLDocument
     */
    _doc : null,

    /**
     * Internal state property for the current year displayed in the navigator
     * @protected
     * @property _year
     * @type Number
     */
    _year: null,

    /**
     * Internal state property for the current month index displayed in the navigator
     * @protected
     * @property _month
     * @type Number
     */
    _month: 0,

    /**
     * Private internal state property which indicates whether or not the
     * Navigator has been rendered.
     * @private
     * @property __rendered
     * @type Boolean
     */
    __rendered: false,

    /**
     * Init lifecycle method called as part of construction
     *
     * @method init
     * @param {Calendar} cal The instance of the Calendar or CalendarGroup to which this CalendarNavigator should be attached
     */
    init : function(cal) {
        var calBox = cal.oDomContainer;

        this.cal = cal;
        this.id = calBox.id + YAHOO.widget.CalendarNavigator.ID_SUFFIX;
        this._doc = calBox.ownerDocument;

        /**
         * Private flag, to identify IE Quirks
         * @private
         * @property __isIEQuirks
         */
        var ie = YAHOO.env.ua.ie;
        this.__isIEQuirks = (ie && ((ie <= 6) || (this._doc.compatMode == "BackCompat")));
    },

    /**
     * Displays the navigator and mask, updating the input controls to reflect the
     * currently set month and year. The show method will invoke the render method
     * if the navigator has not been renderered already, allowing for lazy rendering
     * of the control.
     *
     * The show method will fire the Calendar/CalendarGroup's beforeShowNav and showNav events
     *
     * @method show
     */
    show : function() {
        var CLASSES = YAHOO.widget.CalendarNavigator.CLASSES;

        if (this.cal.beforeShowNavEvent.fire()) {
            if (!this.__rendered) {
                this.render();
            }
            this.clearErrors();

            this._updateMonthUI();
            this._updateYearUI();
            this._show(this.navEl, true);

            this.setInitialFocus();
            this.showMask();

            YAHOO.util.Dom.addClass(this.cal.oDomContainer, CLASSES.NAV_VISIBLE);
            this.cal.showNavEvent.fire();
        }
    },

    /**
     * Hides the navigator and mask
     *
     * The show method will fire the Calendar/CalendarGroup's beforeHideNav event and hideNav events
     * @method hide
     */
    hide : function() {
        var CLASSES = YAHOO.widget.CalendarNavigator.CLASSES;

        if (this.cal.beforeHideNavEvent.fire()) {
            this._show(this.navEl, false);
            this.hideMask();
            YAHOO.util.Dom.removeClass(this.cal.oDomContainer, CLASSES.NAV_VISIBLE);
            this.cal.hideNavEvent.fire();
        }
    },


    /**
     * Displays the navigator's mask element
     *
     * @method showMask
     */
    showMask : function() {
        this._show(this.maskEl, true);
        if (this.__isIEQuirks) {
            this._syncMask();
        }
    },

    /**
     * Hides the navigator's mask element
     *
     * @method hideMask
     */
    hideMask : function() {
        this._show(this.maskEl, false);
    },

    /**
     * Returns the current month set on the navigator
     *
     * Note: This may not be the month set in the UI, if
     * the UI contains an invalid value.
     *
     * @method getMonth
     * @return {Number} The Navigator's current month index
     */
    getMonth: function() {
        return this._month;
    },

    /**
     * Returns the current year set on the navigator
     *
     * Note: This may not be the year set in the UI, if
     * the UI contains an invalid value.
     *
     * @method getYear
     * @return {Number} The Navigator's current year value
     */
    getYear: function() {
        return this._year;
    },

    /**
     * Sets the current month on the Navigator, and updates the UI
     *
     * @method setMonth
     * @param {Number} nMonth The month index, from 0 (Jan) through 11 (Dec).
     */
    setMonth : function(nMonth) {
        if (nMonth >= 0 && nMonth < 12) {
            this._month = nMonth;
        }
        this._updateMonthUI();
    },

    /**
     * Sets the current year on the Navigator, and updates the UI. If the
     * provided year is invalid, it will not be set.
     *
     * @method setYear
     * @param {Number} nYear The full year value to set the Navigator to.
     */
    setYear : function(nYear) {
        var yrPattern = YAHOO.widget.CalendarNavigator.YR_PATTERN;
        if (YAHOO.lang.isNumber(nYear) && yrPattern.test(nYear+"")) {
            this._year = nYear;
        }
        this._updateYearUI();
    },

    /**
     * Renders the HTML for the navigator, adding it to the
     * document and attaches event listeners if it has not
     * already been rendered.
     *
     * @method render
     */
    render: function() {
        this.cal.beforeRenderNavEvent.fire();
        if (!this.__rendered) {
            this.createNav();
            this.createMask();
            this.applyListeners();
            this.__rendered = true;
        }
        this.cal.renderNavEvent.fire();
    },

    /**
     * Creates the navigator's containing HTMLElement, it's contents, and appends
     * the containg element to the Calendar/CalendarGroup's container.
     *
     * @method createNav
     */
    createNav : function() {
        var NAV = YAHOO.widget.CalendarNavigator;
        var doc = this._doc;

        var d = doc.createElement("div");
        d.className = NAV.CLASSES.NAV;

        var htmlBuf = this.renderNavContents([]);

        d.innerHTML = htmlBuf.join('');
        this.cal.oDomContainer.appendChild(d);

        this.navEl = d;

        this.yearEl = doc.getElementById(this.id + NAV.YEAR_SUFFIX);
        this.monthEl = doc.getElementById(this.id + NAV.MONTH_SUFFIX);
        this.errorEl = doc.getElementById(this.id + NAV.ERROR_SUFFIX);
        this.submitEl = doc.getElementById(this.id + NAV.SUBMIT_SUFFIX);
        this.cancelEl = doc.getElementById(this.id + NAV.CANCEL_SUFFIX);

        if (YAHOO.env.ua.gecko && this.yearEl && this.yearEl.type == "text") {
            this.yearEl.setAttribute("autocomplete", "off");
        }

        this._setFirstLastElements();
    },

    /**
     * Creates the Mask HTMLElement and appends it to the Calendar/CalendarGroups
     * container.
     *
     * @method createMask
     */
    createMask : function() {
        var C = YAHOO.widget.CalendarNavigator.CLASSES;

        var d = this._doc.createElement("div");
        d.className = C.MASK;

        this.cal.oDomContainer.appendChild(d);
        this.maskEl = d;
    },

    /**
     * Used to set the width/height of the mask in pixels to match the Calendar Container.
     * Currently only used for IE6 or IE in quirks mode. The other A-Grade browser are handled using CSS (width/height 100%).
     * <p>
     * The method is also registered as an HTMLElement resize listener on the Calendars container element.
     * </p>
     * @protected
     * @method _syncMask
     */
    _syncMask : function() {
        var c = this.cal.oDomContainer;
        if (c && this.maskEl) {
            var r = YAHOO.util.Dom.getRegion(c);
            YAHOO.util.Dom.setStyle(this.maskEl, "width", r.right - r.left + "px");
            YAHOO.util.Dom.setStyle(this.maskEl, "height", r.bottom - r.top + "px");
        }
    },

    /**
     * Renders the contents of the navigator
     *
     * @method renderNavContents
     *
     * @param {Array} html The HTML buffer to append the HTML to.
     * @return {Array} A reference to the buffer passed in.
     */
    renderNavContents : function(html) {
        var NAV = YAHOO.widget.CalendarNavigator,
            C = NAV.CLASSES,
            h = html; // just to use a shorter name

        h[h.length] = '<div class="' + C.MONTH + '">';
        this.renderMonth(h);
        h[h.length] = '</div>';
        h[h.length] = '<div class="' + C.YEAR + '">';
        this.renderYear(h);
        h[h.length] = '</div>';
        h[h.length] = '<div class="' + C.BUTTONS + '">';
        this.renderButtons(h);
        h[h.length] = '</div>';
        h[h.length] = '<div class="' + C.ERROR + '" id="' + this.id + NAV.ERROR_SUFFIX + '"></div>';

        return h;
    },

    /**
     * Renders the month label and control for the navigator
     *
     * @method renderNavContents
     * @param {Array} html The HTML buffer to append the HTML to.
     * @return {Array} A reference to the buffer passed in.
     */
    renderMonth : function(html) {
        var NAV = YAHOO.widget.CalendarNavigator,
            C = NAV.CLASSES;

        var id = this.id + NAV.MONTH_SUFFIX,
            mf = this.__getCfg("monthFormat"),
            months = this.cal.cfg.getProperty((mf == YAHOO.widget.Calendar.SHORT) ? "MONTHS_SHORT" : "MONTHS_LONG"),
            h = html;

        if (months && months.length > 0) {
            h[h.length] = '<label for="' + id + '">';
            h[h.length] = this.__getCfg("month", true);
            h[h.length] = '</label>';
            h[h.length] = '<select name="' + id + '" id="' + id + '" class="' + C.MONTH_CTRL + '">';
            for (var i = 0; i < months.length; i++) {
                h[h.length] = '<option value="' + i + '">';
                h[h.length] = months[i];
                h[h.length] = '</option>';
            }
            h[h.length] = '</select>';
        }
        return h;
    },

    /**
     * Renders the year label and control for the navigator
     *
     * @method renderYear
     * @param {Array} html The HTML buffer to append the HTML to.
     * @return {Array} A reference to the buffer passed in.
     */
    renderYear : function(html) {
        var NAV = YAHOO.widget.CalendarNavigator,
            C = NAV.CLASSES;

        var id = this.id + NAV.YEAR_SUFFIX,
            size = NAV.YR_MAX_DIGITS,
            h = html;

        h[h.length] = '<label for="' + id + '">';
        h[h.length] = this.__getCfg("year", true);
        h[h.length] = '</label>';
        h[h.length] = '<input type="text" name="' + id + '" id="' + id + '" class="' + C.YEAR_CTRL + '" maxlength="' + size + '"/>';
        return h;
    },

    /**
     * Renders the submit/cancel buttons for the navigator
     *
     * @method renderButton
     * @return {String} The HTML created for the Button UI
     */
    renderButtons : function(html) {
        var C = YAHOO.widget.CalendarNavigator.CLASSES;
        var h = html;

        h[h.length] = '<span class="' + C.BUTTON + ' ' + C.DEFAULT + '">';
        h[h.length] = '<button type="button" id="' + this.id + '_submit' + '">';
        h[h.length] = this.__getCfg("submit", true);
        h[h.length] = '</button>';
        h[h.length] = '</span>';
        h[h.length] = '<span class="' + C.BUTTON +'">';
        h[h.length] = '<button type="button" id="' + this.id + '_cancel' + '">';
        h[h.length] = this.__getCfg("cancel", true);
        h[h.length] = '</button>';
        h[h.length] = '</span>';

        return h;
    },

    /**
     * Attaches DOM event listeners to the rendered elements
     * <p>
     * The method will call applyKeyListeners, to setup keyboard specific
     * listeners
     * </p>
     * @method applyListeners
     */
    applyListeners : function() {
        var E = YAHOO.util.Event;

        function yearUpdateHandler() {
            if (this.validate()) {
                this.setYear(this._getYearFromUI());
            }
        }

        function monthUpdateHandler() {
            this.setMonth(this._getMonthFromUI());
        }

        E.on(this.submitEl, "click", this.submit, this, true);
        E.on(this.cancelEl, "click", this.cancel, this, true);
        E.on(this.yearEl, "blur", yearUpdateHandler, this, true);
        E.on(this.monthEl, "change", monthUpdateHandler, this, true);

        if (this.__isIEQuirks) {
            YAHOO.util.Event.on(this.cal.oDomContainer, "resize", this._syncMask, this, true);
        }

        this.applyKeyListeners();
    },

    /**
     * Removes/purges DOM event listeners from the rendered elements
     *
     * @method purgeListeners
     */
    purgeListeners : function() {
        var E = YAHOO.util.Event;
        E.removeListener(this.submitEl, "click", this.submit);
        E.removeListener(this.cancelEl, "click", this.cancel);
        E.removeListener(this.yearEl, "blur");
        E.removeListener(this.monthEl, "change");
        if (this.__isIEQuirks) {
            E.removeListener(this.cal.oDomContainer, "resize", this._syncMask);
        }

        this.purgeKeyListeners();
    },

    /**
     * Attaches DOM listeners for keyboard support.
     * Tab/Shift-Tab looping, Enter Key Submit on Year element,
     * Up/Down/PgUp/PgDown year increment on Year element
     * <p>
     * NOTE: MacOSX Safari 2.x doesn't let you tab to buttons and
     * MacOSX Gecko does not let you tab to buttons or select controls,
     * so for these browsers, Tab/Shift-Tab looping is limited to the
     * elements which can be reached using the tab key.
     * </p>
     * @method applyKeyListeners
     */
    applyKeyListeners : function() {
        var E = YAHOO.util.Event,
            ua = YAHOO.env.ua;

        var arrowEvt = (ua.ie || ua.webkit) ? "keydown" : "keypress";

        var tabEvt = (ua.ie || ua.opera || ua.webkit) ? "keydown" : "keypress";

        E.on(this.yearEl, "keypress", this._handleEnterKey, this, true);

        E.on(this.yearEl, arrowEvt, this._handleDirectionKeys, this, true);
        E.on(this.lastCtrl, tabEvt, this._handleTabKey, this, true);
        E.on(this.firstCtrl, tabEvt, this._handleShiftTabKey, this, true);
    },

    /**
     * Removes/purges DOM listeners for keyboard support
     *
     * @method purgeKeyListeners
     */
    purgeKeyListeners : function() {
        var E = YAHOO.util.Event,
            ua = YAHOO.env.ua;

        var arrowEvt = (ua.ie || ua.webkit) ? "keydown" : "keypress";
        var tabEvt = (ua.ie || ua.opera || ua.webkit) ? "keydown" : "keypress";

        E.removeListener(this.yearEl, "keypress", this._handleEnterKey);
        E.removeListener(this.yearEl, arrowEvt, this._handleDirectionKeys);
        E.removeListener(this.lastCtrl, tabEvt, this._handleTabKey);
        E.removeListener(this.firstCtrl, tabEvt, this._handleShiftTabKey);
    },

    /**
     * Updates the Calendar/CalendarGroup's pagedate with the currently set month and year if valid.
     * <p>
     * If the currently set month/year is invalid, a validation error will be displayed and the
     * Calendar/CalendarGroup's pagedate will not be updated.
     * </p>
     * @method submit
     */
    submit : function() {
        if (this.validate()) {
            this.hide();

            this.setMonth(this._getMonthFromUI());
            this.setYear(this._getYearFromUI());

            var cal = this.cal;

            var delay = YAHOO.widget.CalendarNavigator.UPDATE_DELAY;
            if (delay > 0) {
                var nav = this;
                window.setTimeout(function(){ nav._update(cal); }, delay);
            } else {
                this._update(cal);
            }
        }
    },

    /**
     * Updates the Calendar rendered state, based on the state of the CalendarNavigator
     * @method _update
     * @param cal The Calendar instance to update
     * @protected
     */
    _update : function(cal) {
        var date = YAHOO.widget.DateMath.getDate(this.getYear() - cal.cfg.getProperty("YEAR_OFFSET"), this.getMonth(), 1);
        cal.cfg.setProperty("pagedate", date);
        cal.render();
    },

    /**
     * Hides the navigator and mask, without updating the Calendar/CalendarGroup's state
     *
     * @method cancel
     */
    cancel : function() {
        this.hide();
    },

    /**
     * Validates the current state of the UI controls
     *
     * @method validate
     * @return {Boolean} true, if the current UI state contains valid values, false if not
     */
    validate : function() {
        if (this._getYearFromUI() !== null) {
            this.clearErrors();
            return true;
        } else {
            this.setYearError();
            this.setError(this.__getCfg("invalidYear", true));
            return false;
        }
    },

    /**
     * Displays an error message in the Navigator's error panel
     * @method setError
     * @param {String} msg The error message to display
     */
    setError : function(msg) {
        if (this.errorEl) {
            this.errorEl.innerHTML = msg;
            this._show(this.errorEl, true);
        }
    },

    /**
     * Clears the navigator's error message and hides the error panel
     * @method clearError
     */
    clearError : function() {
        if (this.errorEl) {
            this.errorEl.innerHTML = "";
            this._show(this.errorEl, false);
        }
    },

    /**
     * Displays the validation error UI for the year control
     * @method setYearError
     */
    setYearError : function() {
        YAHOO.util.Dom.addClass(this.yearEl, YAHOO.widget.CalendarNavigator.CLASSES.INVALID);
    },

    /**
     * Removes the validation error UI for the year control
     * @method clearYearError
     */
    clearYearError : function() {
        YAHOO.util.Dom.removeClass(this.yearEl, YAHOO.widget.CalendarNavigator.CLASSES.INVALID);
    },

    /**
     * Clears all validation and error messages in the UI
     * @method clearErrors
     */
    clearErrors : function() {
        this.clearError();
        this.clearYearError();
    },

    /**
     * Sets the initial focus, based on the configured value
     * @method setInitialFocus
     */
    setInitialFocus : function() {
        var el = this.submitEl,
            f = this.__getCfg("initialFocus");

        if (f && f.toLowerCase) {
            f = f.toLowerCase();
            if (f == "year") {
                el = this.yearEl;
                try {
                    this.yearEl.select();
                } catch (selErr) {
                }
            } else if (f == "month") {
                el = this.monthEl;
            }
        }

        if (el && YAHOO.lang.isFunction(el.focus)) {
            try {
                el.focus();
            } catch (focusErr) {
            }
        }
    },

    /**
     * Removes all renderered HTML elements for the Navigator from
     * the DOM, purges event listeners and clears (nulls) any property
     * references to HTML references
     * @method erase
     */
    erase : function() {
        if (this.__rendered) {
            this.purgeListeners();

            this.yearEl = null;
            this.monthEl = null;
            this.errorEl = null;
            this.submitEl = null;
            this.cancelEl = null;
            this.firstCtrl = null;
            this.lastCtrl = null;
            if (this.navEl) {
                this.navEl.innerHTML = "";
            }

            var p = this.navEl.parentNode;
            if (p) {
                p.removeChild(this.navEl);
            }
            this.navEl = null;

            var pm = this.maskEl.parentNode;
            if (pm) {
                pm.removeChild(this.maskEl);
            }
            this.maskEl = null;
            this.__rendered = false;
        }
    },

    /**
     * Destroys the Navigator object and any HTML references
     * @method destroy
     */
    destroy : function() {
        this.erase();
        this._doc = null;
        this.cal = null;
        this.id = null;
    },

    /**
     * Protected implementation to handle how UI elements are
     * hidden/shown.
     *
     * @method _show
     * @protected
     */
    _show : function(el, bShow) {
        if (el) {
            YAHOO.util.Dom.setStyle(el, "display", (bShow) ? "block" : "none");
        }
    },

    /**
     * Returns the month value (index), from the month UI element
     * @protected
     * @method _getMonthFromUI
     * @return {Number} The month index, or 0 if a UI element for the month
     * is not found
     */
    _getMonthFromUI : function() {
        if (this.monthEl) {
            return this.monthEl.selectedIndex;
        } else {
            return 0; // Default to Jan
        }
    },

    /**
     * Returns the year value, from the Navitator's year UI element
     * @protected
     * @method _getYearFromUI
     * @return {Number} The year value set in the UI, if valid. null is returned if
     * the UI does not contain a valid year value.
     */
    _getYearFromUI : function() {
        var NAV = YAHOO.widget.CalendarNavigator;

        var yr = null;
        if (this.yearEl) {
            var value = this.yearEl.value;
            value = value.replace(NAV.TRIM, "$1");

            if (NAV.YR_PATTERN.test(value)) {
                yr = parseInt(value, 10);
            }
        }
        return yr;
    },

    /**
     * Updates the Navigator's year UI, based on the year value set on the Navigator object
     * @protected
     * @method _updateYearUI
     */
    _updateYearUI : function() {
        if (this.yearEl && this._year !== null) {
            this.yearEl.value = this._year;
        }
    },

    /**
     * Updates the Navigator's month UI, based on the month value set on the Navigator object
     * @protected
     * @method _updateMonthUI
     */
    _updateMonthUI : function() {
        if (this.monthEl) {
            this.monthEl.selectedIndex = this._month;
        }
    },

    /**
     * Sets up references to the first and last focusable element in the Navigator's UI
     * in terms of tab order (Naviagator's firstEl and lastEl properties). The references
     * are used to control modality by looping around from the first to the last control
     * and visa versa for tab/shift-tab navigation.
     * <p>
     * See <a href="#applyKeyListeners">applyKeyListeners</a>
     * </p>
     * @protected
     * @method _setFirstLastElements
     */
    _setFirstLastElements : function() {
        this.firstCtrl = this.monthEl;
        this.lastCtrl = this.cancelEl;

        if (this.__isMac) {
            if (YAHOO.env.ua.webkit && YAHOO.env.ua.webkit < 420){
                this.firstCtrl = this.monthEl;
                this.lastCtrl = this.yearEl;
            }
            if (YAHOO.env.ua.gecko) {
                this.firstCtrl = this.yearEl;
                this.lastCtrl = this.yearEl;
            }
        }
    },

    /**
     * Default Keyboard event handler to capture Enter
     * on the Navigator's year control (yearEl)
     *
     * @method _handleEnterKey
     * @protected
     * @param {Event} e The DOM event being handled
     */
    _handleEnterKey : function(e) {
        var KEYS = YAHOO.util.KeyListener.KEY;

        if (YAHOO.util.Event.getCharCode(e) == KEYS.ENTER) {
            YAHOO.util.Event.preventDefault(e);
            this.submit();
        }
    },

    /**
     * Default Keyboard event handler to capture up/down/pgup/pgdown
     * on the Navigator's year control (yearEl).
     *
     * @method _handleDirectionKeys
     * @protected
     * @param {Event} e The DOM event being handled
     */
    _handleDirectionKeys : function(e) {
        var E = YAHOO.util.Event,
            KEYS = YAHOO.util.KeyListener.KEY,
            NAV = YAHOO.widget.CalendarNavigator;

        var value = (this.yearEl.value) ? parseInt(this.yearEl.value, 10) : null;
        if (isFinite(value)) {
            var dir = false;
            switch(E.getCharCode(e)) {
                case KEYS.UP:
                    this.yearEl.value = value + NAV.YR_MINOR_INC;
                    dir = true;
                    break;
                case KEYS.DOWN:
                    this.yearEl.value = Math.max(value - NAV.YR_MINOR_INC, 0);
                    dir = true;
                    break;
                case KEYS.PAGE_UP:
                    this.yearEl.value = value + NAV.YR_MAJOR_INC;
                    dir = true;
                    break;
                case KEYS.PAGE_DOWN:
                    this.yearEl.value = Math.max(value - NAV.YR_MAJOR_INC, 0);
                    dir = true;
                    break;
                default:
                    break;
            }
            if (dir) {
                E.preventDefault(e);
                try {
                    this.yearEl.select();
                } catch(err) {
                }
            }
        }
    },

    /**
     * Default Keyboard event handler to capture Tab
     * on the last control (lastCtrl) in the Navigator.
     *
     * @method _handleTabKey
     * @protected
     * @param {Event} e The DOM event being handled
     */
    _handleTabKey : function(e) {
        var E = YAHOO.util.Event,
            KEYS = YAHOO.util.KeyListener.KEY;

        if (E.getCharCode(e) == KEYS.TAB && !e.shiftKey) {
            try {
                E.preventDefault(e);
                this.firstCtrl.focus();
            } catch (err) {
            }
        }
    },

    /**
     * Default Keyboard event handler to capture Shift-Tab
     * on the first control (firstCtrl) in the Navigator.
     *
     * @method _handleShiftTabKey
     * @protected
     * @param {Event} e The DOM event being handled
     */
    _handleShiftTabKey : function(e) {
        var E = YAHOO.util.Event,
            KEYS = YAHOO.util.KeyListener.KEY;

        if (e.shiftKey && E.getCharCode(e) == KEYS.TAB) {
            try {
                E.preventDefault(e);
                this.lastCtrl.focus();
            } catch (err) {
            }
        }
    },

    /**
     * Retrieve Navigator configuration values from
     * the parent Calendar/CalendarGroup's config value.
     * <p>
     * If it has not been set in the user provided configuration, the method will
     * return the default value of the configuration property, as set in DEFAULT_CONFIG
     * </p>
     * @private
     * @method __getCfg
     * @param {String} Case sensitive property name.
     * @param {Boolean} true, if the property is a string property, false if not.
     * @return The value of the configuration property
     */
    __getCfg : function(prop, bIsStr) {
        var DEF_CFG = YAHOO.widget.CalendarNavigator.DEFAULT_CONFIG;
        var cfg = this.cal.cfg.getProperty("navigator");

        if (bIsStr) {
            return (cfg !== true && cfg.strings && cfg.strings[prop]) ? cfg.strings[prop] : DEF_CFG.strings[prop];
        } else {
            return (cfg !== true && cfg[prop]) ? cfg[prop] : DEF_CFG[prop];
        }
    },

    /**
     * Private flag, to identify MacOS
     * @private
     * @property __isMac
     */
    __isMac : (navigator.userAgent.toLowerCase().indexOf("macintosh") != -1)

};
YAHOO.register("calendar", YAHOO.widget.Calendar, {version: "2.8.2r1", build: "7"});

/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global UX, YAHOO*/
/*--members Button, Element, Menu, addClass, addClassName, align,
    appendChild, cfg, context, createElement, fn, hide,
    insertAdjacentElement, isChrome, isFF, isIE, isSafari, isQuirksMode, offsetHeight,
    offsetWidth, onclick, ownerDocument, render, scope, setProperty,
    setStyle, show, subscribe, toggle, type, util, widget
*/

/**
  class:DropBox
  Attaches a dropbox and button to an element.

  containerElement - {Element} The element used to contain the dropbox and button
  referenceElement - {Element} The element used to position the button and dropbox on the screen
  dropElement - {Element} The element that will become the content of the dropbox
*/

function DropBox(containerElement, referenceElement, dropElement) {
  this.PRIVATE = {containerElement:containerElement,referenceElement:referenceElement};
  this.PRIVATE.m_showing = false;

  var button,
  callbackScope,
  buttonElement = document.createElement("button"),
  btnHeight,
  deltaPosition = 0,
  referenceYUIElement = new YAHOO.util.Element(this.PRIVATE.referenceElement),
  dropWrapper = document.createElement("div");

  UX.addClassName(this.PRIVATE.containerElement, "yui-skin-sam");
  UX.addClassName(this.PRIVATE.containerElement, "ux-dropbox-container");

  this.PRIVATE.referenceElement.insertAdjacentElement("afterEnd", buttonElement);

  button = new YAHOO.widget.Button(buttonElement, {type: "push", onclick: { scope: this, fn: this.toggle } });
  button.addClass("ux-drop-button");
  referenceYUIElement.setStyle("display", "inline-block");

  btnHeight = this.PRIVATE.referenceElement.offsetHeight;

  button.setStyle("height", btnHeight + "px");

  if (UX.isIE || UX.isSafari || !UX.isQuirksMode) {
    button.setStyle("vertical-align", "bottom");
  } else {
    button.setStyle("vertical-align", "middle");
    if (UX.isChrome) {
      deltaPosition = -2;
    } else if (UX.isFF) {
      deltaPosition = -1;
    }
    button.setStyle("top", deltaPosition);
  }

  UX.addClassName(dropWrapper, "yuimenu");
  this.PRIVATE.containerElement.appendChild(dropWrapper);
  UX.addClassName(dropElement, "bd");
  dropWrapper.appendChild(dropElement);
  this.PRIVATE.m_Menu = new YAHOO.widget.Menu(dropWrapper, {context: [this.PRIVATE.referenceElement, "tl", "bl"]});
  this.PRIVATE.m_Menu.render();

  callbackScope = this;
  this.PRIVATE.m_Menu.subscribe("hide", function () {
    setTimeout(function ()
    {
      callbackScope.PRIVATE.m_showing = false;
    }, 100);
  });
  this.PRIVATE.m_Menu.subscribe("show", function () {
    setTimeout(function ()
    {
      callbackScope.PRIVATE.m_showing = true;
    }, 100);
  });
}

/**
  method:toggle
  If the dropbox is currently hidden, shows the dropbox.  If it is visible, hides it.
*/
DropBox.prototype.toggle = function(){
  if (this.PRIVATE.m_showing) {
    this.hide();
  } else {
    this.show();
  }
};

/**
  function:show
  shows the dropbox.
*/
DropBox.prototype.show = function () {
  this.PRIVATE.m_Menu.align("tl", "bl");
  this.PRIVATE.m_Menu.cfg.setProperty("width", this.PRIVATE.referenceElement.offsetWidth + "px");
  this.PRIVATE.m_Menu.show();
};
  /**
    function:hide
    hides the dropbox.
  */

DropBox.prototype.hide = function () {
    this.PRIVATE.m_Menu.hide();
};






/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (C) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var UX = {};
var g_sBehaviourDirectory = "/backplanejs/assets/";

/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function(){
	var ua = navigator.userAgent.toLowerCase();

	UX.userAgent = ua;

	UX.isFF2 = /firefox\/2/.test(ua);
	UX.isFF3 = /firefox\/3/.test(ua);
	UX.isFF = /firefox/.test(ua);

	UX.isIE6 = /msie 6/.test(ua);
	UX.isIE7 = /msie 7/.test(ua);
	UX.isIE8 = /msie 8/.test(ua);
	UX.isIE = /msie/.test(ua);

	UX.isChrome = /chrome/.test(ua)
	UX.isWebKit = /safari/.test(ua);
	UX.isSafari = UX.isWebKit && !UX.isChrome;

	UX.isOpera = /opera/.test(ua);

	UX.isXHTML = !!(document.xmlVersion || (document.contentType && document.contentType === "application/xhtml+xml"));

	UX.hasDecorationSupport = UX.isIE && (document.location.protocol != 'file:');

	UX.isQuirksMode = document.compatMode === "BackCompat";
})();
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global Element, FormsProcessor, HTMLElement, NamespaceManager, UX, YAHOO, _getEvaluationContext , getFirstNode , spawn , xpathDomEval */
/**
 @fileoverview
 For browsers such as Firefox, that do not support IE's rather handy bonus functions
 insertAdjacentHTML, and insertAdjacentElement.
 */

/**
 XML Parsing in Firefox does not support getElementById by default (except on XHTML and XUL elements_
 To work around this problem, the xpath evaluation is done to returnh the element with the specified id.
 */
if (UX.isXHTML) {
	/* override the getElementById on the document object */
	document.nativeGetElementById = document.getElementById;
	document.getElementById = function(sID) {
		/* try to get the element by the default getElementById */
		var oElement = document.nativeGetElementById(sID);
		/* if it doesn't work, try to find by different route */
		if (oElement === null) {
			var oRes = xpathDomEval('//*[@id="' + sID + '"]', document.documentElement);
			oElement = (oRes && oRes.nodeSetValue() && oRes.nodeSetValue()[0]) ? oRes.nodeSetValue()[0] : null;
		}
		return oElement;
	};
} (function() {
	/**
	 Inserts an element into the DOM at a given location.	This is an addon applied to Elements
	 in the target environment.	Nodes must be of compatible types in the target DOM, i.e.
	 this will not be able to insert an XML Element into an HTML tree unless the underlying
	 DOMs allow it.	To mix incompatible DOMs, serialise the inserted node, and use insertAdjacentHTML
	 @param {String} where One of beforeBegin, afterBegin, beforeEnd, or afterEnd
	 @param {Node} parsedNode a node to insert into this element
	 @addon
	 */
	function insertAdjacentElement(where, parsedNode) {
		switch (where) {
		case 'beforeBegin':
			this.parentNode.insertBefore(parsedNode, this);
			break;
		case 'afterBegin':
			this.insertBefore(parsedNode, this.firstChild);
			break;
		case 'beforeEnd':
			this.appendChild(parsedNode);
			break;
		case 'afterEnd':
			if (this.nextSibling) {
				this.parentNode.insertBefore(parsedNode, this.nextSibling);
			} else {
				this.parentNode.appendChild(parsedNode);
			}
			break;
		}
	}

	/**
	 Inserts some markup into the DOM at a given location.	 This is an addon applied to Elements
	 in the target environment.
	 @param {String} where One of beforeBegin, afterBegin, beforeEnd, or afterEnd
	 @param {String} htmlStr markup to insert into this element
	 @addon
	 */
	function insertAdjacentHTML(where, htmlStr) {
		var r = this.ownerDocument.createRange();
		r.setStartBefore(this);
		var parsedHTML = r.createContextualFragment(htmlStr);
		this.insertAdjacentElement(where, parsedHTML);
	}

	/**
	 Inserts some text into the DOM at a given location, ignoring markup.
	 This is an addon applied to Elements in the target environment.
	 If parseable (or poorly-formed) markup is present in txtStr it will
	 be escaped and inserted into the target element as text.
	 @param {String} where One of beforeBegin, afterBegin, beforeEnd, or afterEnd
	 @param {String} txtStr text to insert into this element
	 @addon
	 */
	function insertAdjacentText(where, txtStr) {
		var parsedText = document.createTextNode(txtStr);
		this.insertAdjacentElement(where, parsedText);
	}

	/**
	 Checks whether o is a descendent of the current element
	 @param {Node} o The candidate descendent node to investigate
	 @returns true if o is within "this", otherwise false.
	 */
	function contains(o) {

		var parent = o;
		var retval = false;
		while (parent) {
			if (parent === this) {
				retval = true;
				break;
			} else {
				parent = parent.parentNode;
			}
		}
		return retval;
	}

	if (typeof HTMLElement != "undefined") {
		HTMLElement.prototype.insertAdjacentElement = HTMLElement.prototype.insertAdjacentElement || insertAdjacentElement;
		HTMLElement.prototype.insertAdjacentText = HTMLElement.prototype.insertAdjacentText || insertAdjacentText;
		HTMLElement.prototype.insertAdjacentHTML = HTMLElement.prototype.insertAdjacentHTML || insertAdjacentHTML;
		HTMLElement.prototype.contains = HTMLElement.prototype.contains || contains;
	}

	if (typeof Element != "undefined" && !Element.prototype.insertAdjacentElement) {
		Element.prototype.insertAdjacentElement = Element.prototype.insertAdjacentElement || insertAdjacentElement;
		Element.prototype.insertAdjacentText = Element.prototype.insertAdjacentText || insertAdjacentText;
		Element.prototype.insertAdjacentHTML = Element.prototype.insertAdjacentHTML || insertAdjacentHTML;
		Element.prototype.contains = Element.prototype.contains || contains;
	}

})();

(function() {

	var rspace = /\s+/;
	var rtrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

	var addClassNameNative = function(element, classString) {
		try {
			element.classList.add(classString);
		} catch(e) {
			if (e.code != e.INVALID_CHARACTER_ERR) throw e;
			var className = classString.replace(rtrim, '');
			try {
				element.classList.add(className);
			} catch(e) {
				if (e.code != e.INVALID_CHARACTER_ERR) throw e;
				var splits = className.split(rspace);
				if (splits.length > 1) {
					UX.addClassNames(element, splits);
				}
			}
		}
	};

	var addClassAttribute = function(element, classString) {
		var setClass = element.getAttribute('class');
		if (!setClass) {
			element.setAttribute('class', classString);
			element.className = classString;
		} else {
			var className = " " + setClass + " ";
			var classNames = (classString || "").split(rspace);
			for (var c = 0, cl = classNames.length; c < cl; c++) {
				if (className.indexOf(" " + classNames[c] + " ") < 0) {
					setClass += " " + classNames[c];
				}
			}
			var newClassName = (setClass || "").replace(rtrim, "");
			element.setAttribute('class', newClassName);
			element.className = newClassName;
		}
	};

	UX.addClassName = function(element, classString) {
		if (!element) return;
		if (element.nodeType !== 1) return;
		if (!classString || typeof classString !== 'string') return;

		if (!UX.isXHTML && !element.className) {
			element.className = classString;
			return;
		}

		if (element.classList && typeof(element.classList) == 'object') {
			addClassNameNative(element, classString);
			return;
		} else if (UX.isXHTML && element.namespaceURI != "http://www.w3.org/1999/xhtml") {
			addClassAttribute(element, classString);
		} else {
			var className = " " + element.className + " ",
				setClass = element.className;
			if (className.indexOf(' ' + classString + ' ') != -1) return;
			var classNames = (classString || "").split(rspace);
			for (var c = 0, cl = classNames.length; c < cl; c++) {
				if (className.indexOf(" " + classNames[c] + " ") < 0) {
					setClass += " " + classNames[c];
				}
			}
			element.className = (setClass || "").replace(rtrim, "");
		}
	};
	UX.addClassNames = function(oElement, classNames) {
		if (!oElement || oElement.nodeType !== 1) return;
		if (classNames && typeof(classNames) == 'object' && classNames.length > 0) {
			if (!oElement.className) {
				oElement.className = classNames.join(' ');
				return;
			} else {
				if (typeof(oElement.classList) == 'object') {
					for (var i = 0, l = classNames.length; i < l; i++) {
						UX.addClassName(oElement, classNames[i]);
					}
					return;
				}
			}
		}
	};
	/**

	 * Utility to remove a class attribute.
	 */

	UX.removeClassName = function(oElement, classString) {
		if (!oElement) return;
		if (oElement.nodeType !== 1) return;
		if (!oElement.className) return;
		if(!classString) return;
		if (typeof(oElement.classList) == 'object') {
			oElement.classList.remove(classString);
			return;
		}
		oElement.className = oElement.className.replace(
		new RegExp("(^|\\s+)" + classString + "(\\s+|$)"), ' ');
	};

	UX.hasClassName = function(element, className) {
		if (!element || element.nodeType !== 1 || !element.className) return false;
		if (typeof element.classList === 'object') {
			try {
				return element.classList.contains(className);
			} catch(e) {}
		}
		var elementClassName = ' ' + element.className + ' ';
		return (elementClassName.indexOf(' ' + className + ' ') != -1);
	};

	/**
	 * Utility to replace a className attribute.
	 */
	UX.replaceClassName = function(element, oldClassString, newClassString) {
		UX.removeClassName(element, oldClassString);
		UX.addClassName(element, newClassString);
	};

})();

/**
 Utility to add a className property for Firefox (XML), this alone doesn't affect how classNames are interpreted.
 */
if (typeof Element != "undefined" && !Element.prototype.className) {
	Element.prototype.className = "";
}

/**
 Utility to add a style to elements.
 With the XML Parser in Firefox, the style property is not supported, instead styles are set with the stylesheet
 objects. This utility centralizes setting the style on an Element to one location.
 */
UX.addStyle = function(oElement, styleName, value) {
	var stylesheet, selector;
	if (oElement.style) {
		oElement.style[styleName] = value;
	} else if (UX.isXHTML) {
		if (document.defaultView.getComputedStyle(oElement, null)[styleName] !== value) {
			stylesheet = oElement.ownerDocument.styleSheets[0];
			try {
				stylesheet.insertRule("@namespace " + oElement.prefix + " url(http://www.w3.org/2002/xforms);", 0);
				selector = UX.id(oElement) ? ('[id="' + UX.id(oElement) + '"]') : "";
				stylesheet.insertRule(oElement.prefix + "|" + oElement.localName + selector + " {" + styleName + ":" + value + ";}", (stylesheet.cssRules.length === 0) ? 1 : stylesheet.cssRules.length);
			} catch(e) {
				document.logger.log("INFO: Couldn't set style " + styleName + " to " + value);
			}
		}
	}
};
/**
 Utility to get a style for an element.
 With the XML Parser in Firefox, the style property is not supported, instead styles are set with the stylesheet
 objects. This utility centralizes getting the style on an Element to one location.
 */
UX.getStyle = function(oElement, styleName) {
	var style = null;
	var match = null;
	var result = null;
	if (oElement.style) {
		return oElement.style[styleName];
	} else if (UX.isXHTML) {
		style = oElement.getAttribute("style");
		if (style) {
			match = new RegExp("(?:(?:^|;)\\s*" + styleName + "\\s*:\\s*)(\\w+)(?:\\s*;|$)");
			result = match.exec(style);
			if (result && result[1]) {
				return result[1];
			}
		}
		return document.defaultView.getComputedStyle(oElement, null)[styleName];
	}
};
/**
 Utility to get a property for an element.
 If an element has a special property attribute, that value will be used.	If an element has a child element
 with that tagname, then that value will be used.	The child element value has precedence over the attribute
 value.	If that child element has a value attribute on it, then that value will be used.	That attribute value
 has precedence over the child element's inline text.
 */
UX.getPropertyValue = function(self, type) {
	var aChildNode = NamespaceManager.getElementsByTagNameNS(self.element, "http://www.w3.org/2002/xforms", type)[0];
	return (aChildNode) ? UX.getElementValueOrContent(Context.prototype.getEvaluationContext.apply(self), aChildNode) : self.element.getAttribute(type);
};
/**
 *	Utility method to create a event and dispatch it on the target
 */
UX.dispatchEvent = function(oTarget, sEventName, bBubble, bCancel, bSpawn) {
	var oEvent = document.createEvent("Events");
	oEvent.initEvent(sEventName, bBubble, bCancel);

	if (bSpawn) {
		spawn(function() {
			FormsProcessor.dispatchEvent(oTarget, oEvent);
		});
	} else {
		FormsProcessor.dispatchEvent(oTarget, oEvent);
	}
};

/**
 * Utility method to create an element in a namespace
 */

UX.createElementNS = function(oNode, sNamespaceURI, sQualifiedName) {
	var oElement = null;
	var sPrefix = null;
	var oDocument = oNode ? oNode.ownerDocument : document;
	var oPrefixes = null;

	if (UX.isXHTML) {
		oElement = oDocument.createElementNS(sNamespaceURI, sQualifiedName);
	} else {
		oPrefixes = NamespaceManager.getOutputPrefixesFromURI(sNamespaceURI);

		if (oPrefixes && oPrefixes.length > 0) {
			sPrefix = oPrefixes[0];
		} else if (sNamespaceURI === "http://www.w3.org/2002/xforms") {
			sPrefix = "xf";
		}
		oElement = oDocument.createElement(sPrefix + ":" + sQualifiedName);
	}
	return oElement;
};

UX.focusFirstEligibleChild = function(childNodes) {
	for (var i = 0, l = childNodes.length; i < l; i++) {
		if (this.focusTree(childNodes.item(i))) {
			return true;
		}
	}
	return false;
};

UX.focusTree = function(node) {
	var behaviour = DECORATOR.getBehaviour(node);
	if (behaviour && behaviour.giveFocus) {
		return behaviour.giveFocus();
	}
	return this.focusFirstEligibleChild(node.childNodes);
};

UX.global = this;

UX.isArrayLike = function(o) {
	return (typeof(o.push) === 'function' && typeof(o.shift) === 'function' && typeof(o.length) === 'number');
};

UX.type = function(o) {
	return (o && UX.isArrayLike(o)) ? 'array' : typeof(o);
};

/*
	Extended DOM Navigation.
*/
(function() {

	var forwards = function(o) {
		return o.nextSibling;
	},

	backwards = function(o) {
		return o.previousSibling;
	},

	getEndNodeByName = function(searchWithin, name, namespace, direction) {
		var newCandidateNode = null,
			candidateNode;

		if (direction === forwards) {
			candidateNode = searchWithin.firstChild;
		} else {
			candidateNode = searchWithin.lastChild;
		}

		while (candidateNode && !NamespaceManager.compareFullName(candidateNode, name, namespace)) {
			if (candidateNode.hasChildNodes()) {
				newCandidateNode = getEndNodeByName(candidateNode, name, namespace, direction);
				if (newCandidateNode) {
					candidateNode = newCandidateNode;
					break;
				}
			}

			candidateNode = direction(candidateNode);
		}
		return candidateNode;
	},

	getNearestAncestralSibling = function(referenceNode, directionFunction, commonAncestor) {
		var candidateAncestralSibling = null,
			candidateAncestor = referenceNode.parentNode;
		while (!candidateAncestralSibling && candidateAncestor && candidateAncestor !== commonAncestor) {
			candidateAncestralSibling = directionFunction(candidateAncestor);
			candidateAncestor = candidateAncestor.parentNode;
		}
		return candidateAncestralSibling;
	},

	getNearestNodeByName = function(referenceNode, name, namespace, searchWithin, directionFunction) {
		var newCandidateNode = null,
			candidateNode = directionFunction(referenceNode);

		if (!candidateNode) {
			candidateNode = getNearestAncestralSibling(referenceNode, directionFunction, searchWithin);
		}

		while (candidateNode && !NamespaceManager.compareFullName(candidateNode, name, namespace)) {
			if (candidateNode.hasChildNodes) {
				newCandidateNode = getEndNodeByName(candidateNode, name, namespace, directionFunction);

				if (newCandidateNode) {
					candidateNode = newCandidateNode;
					break;
				}
			}
			newCandidateNode = directionFunction(candidateNode);
			if (newCandidateNode) {
				candidateNode = newCandidateNode;
			} else {
				candidateNode = getNearestAncestralSibling(candidateNode, directionFunction, searchWithin);
			}
		}
		return candidateNode;
	};

	UX.getNextNodeByName = function(referenceNode, name, namespace, constrainingAncestor) {
		return getNearestNodeByName(referenceNode, name, namespace, constrainingAncestor, forwards);
	};

	UX.getPreviousNodeByName = function(referenceNode, name, namespace, constrainingAncestor) {
		return getNearestNodeByName(referenceNode, name, namespace, constrainingAncestor, backwards);
	};

	UX.getFirstNodeByName = function(searchWithin, name, namespace) {
		return getEndNodeByName(searchWithin, name, namespace, forwards);
	};
} ());

UX.isNodeReadonly = function(oNode) {
	var proxy = UX.getProxyNode(oNode, true);
	return (proxy && proxy.readonly && proxy.readonly.getValue());
};

UX.isEquivalentNode = function(lhs, rhs) {
	return xmlText(lhs) === xmlText(rhs);
};

UX.isArray = function(v) {
	return (v && typeof v === "object" && typeof v.length === "number" && typeof v.splice === "function" && !v.propertyIsEnumerable("length"));
};

/**
 *	Utility method to construct an object that inherits (prototypically) from a given object.
 */
UX.beget = function(o) {
	function Constructor() {}
	Constructor.prototype = o;
	return new Constructor();
};

/**
 *	Utility method to retrieve the @id of a given element.
 */
UX.id = function(oElement) {
	return (UX.isXHTML ? (oElement && typeof oElement.getAttribute === 'function' ? oElement.getAttribute("id") : undefined) : (oElement ? oElement.id : undefined));
};

UX.JsBooleanFromXsdBoolean = function(fromValue, defaultValue) {
	var toValue = {
		"true": true,
		"1": true,
		"false": false,
		"0": false
	} [fromValue];

	return (toValue !== undefined) ? toValue : ((defaultValue !== undefined) ? UX.JsBooleanFromXsdBoolean(defaultValue) : undefined);
};

UX.cancelHTMLEvent = function(evt) {
	evt.cancelBubble = true;
	evt.returnValue = false;

	if (typeof evt.preventDefault === 'function') {
		evt.preventDefault();
	}

	if (typeof evt.stopPropagation === 'function') {
		evt.stopPropagation();
	}

	return false;
};

UX.isHTMLTabKeyEvent = function(keyEvent) {
	return UX.isTabKeyCode(UX.getHTMLKeyEventCode(keyEvent));
};

UX.isShiftKeyPressed = function(keyEvent) {
	return keyEvent.shiftKey || keyEvent.shiftLeft;
};

UX.isControlKeyPressed = function(keyEvent) {
	return keyEvent.ctrlKey || keyEvent.ctrlLeft;
};

UX.isAltKeyPressed = function(keyEvent) {
	return keyEvent.altKey || keyEvent.altLeft;
};

UX.isMetaKeyPressed = function(keyEvent) {
	return keyEvent.metaKey;
};

UX.getHTMLEvent = function(eventArgument) {
	return eventArgument || window.event;
};

UX.getHTMLKeyEventCode = function(keyEvent) {
	return keyEvent.keyCode || keyEvent.which || keyEvent.charCode;
};

UX.isTabKeyCode = function(keyCode) {
	return UX.getTabKeyCode() === keyCode;
};

UX.getTabKeyCode = function() {
	return 9;
};

UX.Class = function(params) {

	var klass = function() {
		var value = this.initialize ? this.initialize.apply(this, arguments) : this;
		return value;
	};

	var add = {
		"initialize": 1,
		"onDocumentReady": 1,
		"onContentReady": 1
	};

	function extend(p, v) {
		if (add.hasOwnProperty(p)) {
			if (!klass.prototype[p]) {
				klass.prototype[p] = function() {
					var stack = arguments.callee.stack;
					for (var j = 0, m = stack.length; j < m; j++) {
						stack[j].apply(this, arguments);
					}
				};
				klass.prototype[p].stack = [];
			}
			if(!v.stack) {
				klass.prototype[p].stack.push(v);
			} else {
				for(var i = 0, l = v.stack.length; i < l; i++) {
					klass.prototype[p].stack.push(v.stack[i]);
				}
			}
		} else {
			klass.prototype[p] = v;
		}
	};

	var i, l, p;

	if (params.Mixins) {
		for (i = 0, l = params.Mixins.length; i < l; i++) {
			for (p in params.Mixins[i].prototype) {
				extend(p, params.Mixins[i].prototype[p]);
			}
		}
	}

	for (p in params) {
		extend(p, params[p]);
	}

	return klass;

};


UX.extend = function(src, dst) {
	for(var p in dst) {
		src[p] = dst[p];
	}
	return src;
};


UX.cloneDocument = function(doc, deep) {
	if(deep == undefined) deep = true;
	if(UX.isIE || UX.isFF) {
		return doc.cloneNode(deep);
	} else {
		var cloneDoc = document.DOMImplementation.createDocument('', '', null);
		if(deep) {
			cloneDoc.appendChild(doc.importNode(doc.documentElement, true));
		}
		return cloneDoc;
	}
};

UX.cloneNode = function(node, deep) {
	if(deep == undefined) deep = true;
	if(node.nodeType == 9) {
		return UX.cloneDocument(node, deep);
	} else {
		return node.cloneNode(deep);
	}
};

(function() {

	var UID = 0;

	UX.getNodeUID = function(node) {//returns xml node uid
		var uid;
		if(!UX.isIE) {
			uid = node.ux_uid;
			if(uid) return uid;
			node.ux_uid = ++UID;
			return UID;
		}
		if(node.nodeType == 1) {//element
			uid = node.getAttribute('ux_uid');
			if(uid) return uid;
			node.setAttribute('ux_uid', ++UID);
			return UID;
		} else if(node.nodeType == 2) {//attr
			var ownerElement = !UX.isIE ? node.ownerElement : node.selectSingleNode('..');
			uid = ownerElement.getAttribute('ux_uid-' + node.nodeName);
			if(uid) return uid;
			ownerElement.setAttribute('ux_uid-' + node.nodeName, ++UID);
			return UID;
		} else if(node.nodeType == 9) {//doc
			uid = node.documentElement.getAttribute('ux_uid-doc');
			if(uid) return uid;
			node.documentElement.setAttribute('ux_uid-doc', ++UID);
			return UID;
		} else if(node.nodeType == 3) {//text node
			var parent = node.parentNode;
			var index = 0;
			var previous = node.previousSibling;
			while(previous) {
				++index;
				previous = previous.previousSibling;
			}
			uid = parent.getAttribute('ux_uid_' + index);
			if(uid) return uid;
			parent.setAttribute('ux_uid_' + index, ++UID);
			return UID;
		}
	};

})();

UX.getElementsById = function(node, id, founded) {
	founded = founded || [];

	var nodeId;

	var children = node.childNodes;
	for(var i = 0, l = children.length; i < l; i++) {
		var child = children[i];
		if(child.nodeType != 1) continue;//if not element continue
		nodeId = child.getAttribute('id');
		if (!nodeId) {
			nodeId = child.getAttribute('xml:id');
			if (!nodeId && child.getAttribute('xsi:type') === 'xsd:ID') {
				nodeId = child.firstChild.nodeValue.trim();
			}
		}
		if (nodeId === id) {
			founded.push(child);
		}
		if(child.hasChildNodes()) arguments.callee(child, id, founded);
	}
	return founded;
};

/*
 * Needs moving somewhere else...but not sure where yet.
 *
 * Note that there are umpteen implementations of this in libraries like prototype, so we
 * don't need another one here. But since we are only relying on YUI at the moment, we'll
 * need something.
 */

function ubArray() {
	this._list = [ ];
}

ubArray.prototype.add = function(key, obj, bLock) {
	var found = false,
	    i;

	for (i = 0; i < this._list.length; i++) {
		if (this._list[i].name === key) {
			found = true;
			break;
		}
	}

	if (found && !this._list[i].locked) {
		this._list[i].item = obj;
	} else {
		this._list.push(
			{
				name: key,
				item: obj,
				locked: bLock
			}
		);
		i = this._list.length - 1;
	}
	return this._list[i].item;
};//add()

ubArray.prototype.get = function(key) {
	var oRet = null,
	    i;

	if (typeof(key) === "number" && (key >= 0 && key < this._list.length)) {
		oRet = this._list[key].item;
	} else {
		for (i = 0; i < this._list.length; i++) {
			if (this._list[i].name === key) {
				oRet = this._list[i].item;
				break;
			}
		}
	}//if ( key is an index ) ... else ...
	return oRet;
};//get()
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global setTimeout*/

function spawn(pFunc,pOnEnd)
{
	if(pOnEnd){
		setTimeout(function(){pFunc();spawn(pOnEnd);}, 1);
	}
	else{
		setTimeout(pFunc, 1);
	}
}

function SpawnLooper(pFuncs,pOnEnd)
{
	var m_pFuncs = pFuncs?pFuncs:[];
	var m_pOnEnd = pOnEnd;
	var m_activeSpawns = 0;

	this.addSpawn = function(pFunc)
	{
		m_pFuncs.push(pFunc);
	};

	this.decrementActiveSpawns = function()
	{
		if(--m_activeSpawns === 0){
			if(m_pOnEnd){
				spawn(m_pOnEnd);
			}
		}
	};

	this.go = function()
	{
		var len = m_pFuncs.length;
		var callback = this.decrementActiveSpawns;
		m_activeSpawns = m_pFuncs.length;
		for(var i = 0;i< len;++i)
		{
			spawn(m_pFuncs[i],callback);
		}
	};
}
function mappings() {
	this._list = new ubArray();
}

mappings.prototype.add = function(prefix, uri) {
	return this._list.add(prefix, uri);
};

mappings.prototype.get = function(prefix) {
	return this._list.get(prefix);
};

mappings.prototype.addFromElement = function(element) {
	var i;

		/*
     * In IE, any namespaces that are placed on the HTML element
     * get parsed out and treated specially, which means that we
     * won't see them when we process the actual <html> element.
     * Therefore we need to ensure that we process them on the
     * document object itself.
     */

    if (element.nodeType === 9) {
        var oNamespaces = null;

        try
        {
            oNamespaces = element.namespaces;
        }
        catch(e)
        {
        }

        if (oNamespaces)
        {
            var oNamespace;

            for (i = 0; i < oNamespaces.length; i++)
            {
                oNamespace = oNamespaces[i];

                this._list.add(oNamespace.name, oNamespace.urn);
            }
        }//if (there is a namespaces collection)
    }
    else
    {
        var attributes = element.attributes;

        if (attributes)
        {
            var sName;

            for (i = 0; i < attributes.length; i++)
            {
                /*
                 * [TODO] Should use a regular expression to crack this
                 * open.
                 */

                if (attributes[i].name.substring(0, 5) == "xmlns")
                {
                    if (attributes[i].name.length == 5) {
                        this._list.add("", attributes[i].value);
                    }

                    if (attributes[i].name.substring(5, 6) != ':') {
                        continue;
                    }

                    var prefix = attributes[i].name.substring(6);
                    var uri = attributes[i].value;

                    this._list.add(prefix, uri);
                }
            }
        }//if (there are attributes)
    }
    return;
};//addFromElement


if (!document.createElementNS) {
	document.createElementNS = function(namespaceURI, elementName) {
		var element = document.createElement(elementName);

		element.namespaceURI = namespaceURI;
		return element;
	};
}

if (document.implementation) {
	if (document.implementation.createDocument) {
		document.DOMImplementation = document.implementation;
	} else {
		document.DOMImplementation = {
			createDocument: function(namespaceURI, qualifiedName, doctype) {
				var doc = null;

				/**
				 * According to http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
				 * best practice is to try MSXML 6.0 and then fall back to MSXML 3.0.
				 */

				if (typeof(ActiveXObject) != "undefined") {
					try {
						doc = new ActiveXObject("Msxml2.DOMDocument.6.0");
					} catch(e) {
						try {
							doc = new ActiveXObject("Msxml2.DOMDocument.3.0");
							doc.setProperty("SelectionLanguage", "XPath");
						} catch(e) {
							throw "No MSXML parser is installed."
						}
					}

					if (doc) {
						doc.async = false;
					}
				}

				return doc;
			}
		};
	}//if ( there is no createDocument ) method
}
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global document*/
/*
 * If there is no document.createEvent function then add one.
 */

if (!document.createEvent)
{

	/*
	* [TODO] Create some kind of object with a lookup
	* so that it's easy to add other event types.
	*/

	document.createEvent = function(eventType)
	{
		var oRet = null;

		switch (eventType)
		{
			case "Events":
				oRet = new Event();
				break;

			case "MutationEvents":
				oRet = new MutationEvent();
				break;

			case "UIEvents":
				oRet = new UIEvent();
				break;

			default:
				throw "NOT_SUPPORTED_ERR";
		}
		return oRet;
	};


	/*
	* E V E N T
	* =========
	*/

	var Event = function (){
	    var that = {};

	    that.CAPTURING_PHASE = 0;
  		that.AT_TARGET = 1;
  		that.BUBBLING_PHASE = 2;
  		that.DEFAULT_PHASE = 3;

	    that.initEvent = function(eventTypeArg, canBubbleArg, cancellableArg){

			that.type = eventTypeArg;
			that.target = null;
			that.currentTarget = null;
			that.eventPhase = null;
			that.bubbles = canBubbleArg;
			that.cancelable = cancellableArg;
			that.timeStamp = new Date();

			that._cancelled = false;
			that._stopPropagation = false;
			that._stopImmediatePropagation = false;
		  return;
		};

		that.stopPropagation = function() {
			that._stopPropagation = true;
		return;
	};

		that.stopImmediatePropagation = function(){
			that._stopImmediatePropagation = true;
			that.stopPropagation();
		return;
	};

		that.preventDefault = function()	{
			if (that.cancelable)
				that._cancelled = true;
		return;
	};


	   return that;
	};





	/*
	* U I E V E N T
	* =============
	*/

	var UIEvent = function (){
	    var that = Event();

		    that.initUIEvent = function(
		eventTypeArg,
		canBubbleArg,
		cancellableArg,
		viewArg,
				detailArg) {
				that.initEvent(eventTypeArg, canBubbleArg, cancellableArg);

				that.view = viewArg;
				that.detail = detailArg;
	};

		return that;
	};

	/*
	* M U T A T I O N E V E N T
	* =========================
	*/

	var MutationEvent = function()
	{
    var that = Event();
    that.MODIFICATION = 1;
		that.ADDITION = 2;
		that.REMOVAL = 3;

		that.initMutationEvent = function(
  		eventTypeArg,
  		canBubbleArg,
  		cancellableArg,
  		relatedNodeArg,
  		prevValueArg,
  		newValueArg,
  		attrNameArg,
  		attrChangeArg) {

     		that.initEvent(eventTypeArg, canBubbleArg, cancellableArg);

    		that.relatedNode = relatedNodeArg;
    		that.prevValue = prevValueArg;
    		that.newValue = newValueArg;
    		that.attrName = attrNameArg;
    		that.attrChange = attrChangeArg;
    	};
	    return that;
	};

}
function getBaseUrl(doc) {
  return makeAbsoluteURI("", getCurrentUrl(doc));
}

function getCurrentUrl(doc) {
  if (!doc) {
    doc = document;
  }

  /*
   * If there is a 'base' element then we use its URL, otherwise
   * use the document's URL.
   */
  var baseColl = doc.getElementsByTagName("base");

  return (baseColl && baseColl.length) ? baseColl[0].href : doc.URL;
}

function spliturl(s)
{
	/*
	 *    See: http://www.gbiv.com/protocols/uri/rfc/rfc3986.html
	 */

    s.replace(/\\/g,"/").match( /^(([^\:\/\?#]+):)?(\/\/([^\/\?#]*))?([^\?#]*)(\?([^#]*))?(#([^\:#\[\]\@\!\$\&\\'\(\)\*\+\,\;\=]*))?/ );
    /*                            12              3    4            5        6  7        8 9 */

  return {
		/* protocol: RegExp.$1,
		hostname: RegExp.$4,
		pathname: RegExp.$5,
		filename: RegExp.$7,
		search : RegExp.$8,
		hash : RegExp.$9 */
		scheme: (RegExp.$1) ? RegExp.$2 : null,
		authority: (RegExp.$3) ? RegExp.$4 : null,
		path: RegExp.$5,
		query : (RegExp.$6) ? RegExp.$7 : null,
		fragment : (RegExp.$8) ? RegExp.$9 : null
	};
}

function makeAbsoluteURI(sBase, sURI, strict)
{
	return recomposeURI(
	    makeAbsolutePath(
	        spliturl(sBase),
	        spliturl(sURI),
	        strict
	    ),
	    true
	);
}

function makeAbsolutePath(Base, R, strict)
{
    var T = { };

		if (!strict  && (R.scheme === Base.scheme)) {
			R.scheme = null;
		}

    if (R.scheme)
    {
      T.scheme    = R.scheme;
      T.authority = R.authority;
      T.path      = remove_dot_segments(R.path);
      T.query     = R.query;
   }
   else
   {
      if (R.authority)
      {
         T.authority = R.authority;
         T.path      = remove_dot_segments(R.path);
         T.query     = R.query;
      }
      else
      {
         if (R.path == "")
         {
            T.path = Base.path;
            if (R.query)
               T.query = R.query;
            else
               T.query = Base.query;
         }
         else
         {
        	if (R.path.substring(0, 1) == '/')
               T.path = remove_dot_segments(R.path);
            else
            {
               if (Base.authority && !Base.path)
                  T.path = "/" + R.path;
               else
                  T.path = Base.path.substring(0, Base.path.lastIndexOf("/") + 1) + R.path;
               T.path = remove_dot_segments(T.path);
            }
            T.query = R.query;
         }
         T.authority = Base.authority;
      }
      T.scheme = Base.scheme;
   }

   T.fragment = R.fragment;
   return T;
}//makeAbsolutePath()

function remove_dot_segments(sURI) {
  var inputBuffer = sURI,
      outputBuffer = "",
      pos;

  while (inputBuffer !== "") {
    if (!inputBuffer.indexOf("../")) {
      inputBuffer = inputBuffer.substring(3);
    } else if (!inputBuffer.indexOf("./")) {
      inputBuffer = inputBuffer.substring(2);
    }
    else if (!inputBuffer.indexOf("/./")) {
      inputBuffer = "/" + inputBuffer.substring(3);
    } else if (inputBuffer === "/.") {
      inputBuffer = "/";
    }
    else if (!inputBuffer.indexOf("/../")) {
      inputBuffer = "/" + inputBuffer.substring(4);
      outputBuffer = outputBuffer.substring(0, outputBuffer.lastIndexOf("/"));
    } else if (inputBuffer === "/..") {
      inputBuffer = "/";
      outputBuffer = outputBuffer.substring(0, outputBuffer.lastIndexOf("/"));
    }
    else if ((inputBuffer === ".") || (inputBuffer === "..")) {
      inputBuffer = "";
    }
    else {
      pos = inputBuffer.indexOf("/", 1);
      if (pos > -1 ) {
        outputBuffer += inputBuffer.substring(0, pos);
        inputBuffer = inputBuffer.substring(pos);
      } else {
        outputBuffer += inputBuffer;
        inputBuffer = "";
      }
    }
  }
  return outputBuffer;
}

function recomposeURI(o, bFragment) {
   var sRet = ""

   if (o.scheme !== null)
      sRet += o.scheme + ":";

   if (o.authority !== null)
      sRet += "//" + o.authority;

   sRet += o.path;

   if (o.query !== null)
      sRet += "?" + o.query;

   if ((o.fragment !== null) && bFragment)
      sRet += "#" + o.fragment;

   return sRet;
}


function safeCurieOrUri(base, curieOrUri, namespaces) {
	if ((curieOrUri.indexOf('[') === 0) && (curieOrUri.lastIndexOf(']') === curieOrUri.length - 1)) {
		return curieToUri(curieOrUri, namespaces);
	} else {
		return makeAbsoluteURI(base, curieOrUri);
	}
}//safeCurieOrUri()


function curieToUri(curie, namespaces) {
	var s,
	    position;

	s = curie.substring(curie.indexOf('[') === 0 ? 1 : 0);
	s = s.substring(0, s.length - ((s.length === s.indexOf(']') + 1) ? 1 : 0));
  position = s.indexOf(':');

	if (position === -1) {
		return namespaces.get(s) || s;
	}

  var prefix = s.substring(0, position);
  var suffix = s.substring(position + 1);

  return (namespaces.get(prefix) ? namespaces.get(prefix) : "unmapped:" + prefix) + suffix;
}//curieToUri()


function buildGetUrl(action, params, separator) {
	var key, pairs = [ ];

	separator = separator || "&";

	if (params) {
		for (key in params) {
			if (params.hasOwnProperty(key) && typeof(params[key]) !== "function") {
				pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
			}
		}
	}//if ( there are parameters to add to the action )

	return action
		+ (
			(pairs.length)
				? "?" + pairs.join(separator)
				: ""
		);
};//buildGetUrl

function getLocalPath(origPath) {
	var originalPath = /* convertUriToUTF8( */ origPath /*,config.options.txtFileSystemCharSet)*/;
	var argPos = originalPath.indexOf("?");
	if (argPos != -1)
		originalPath = originalPath.substr(0,argPos);
	var hashPos = originalPath.indexOf("#");
	if (hashPos != -1)
		originalPath = originalPath.substr(0,hashPos);
	if(originalPath.indexOf("file://localhost/") == 0)
		originalPath = "file://" + originalPath.substr(16);
	var localPath;
	if(originalPath.charAt(9) == ":") // pc local file
		localPath = unescape(originalPath.substr(8)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.charAt(8) == ":") // pc local file
		localPath = unescape(originalPath.substr(7)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file://///") == 0) // FireFox pc network file
		localPath = "\\\\" + unescape(originalPath.substr(10)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file:///") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(7));
	else if(originalPath.indexOf("file:/") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(5));
	else // pc network file
		localPath = "\\\\" + unescape(originalPath.substr(7)).replace(new RegExp("/","g"),"\\");
	return localPath;
};
window.netscape = window.netscape || {
	security: {
		PrivilegeManager: {
			enablePrivilege: function(val) {
				return;
			}
		}
	}
};

document.fileIOFactory = document.fileIOFactory || {
	createFile: function(pathName) {
		return {
			pathSeparator: "/",
			pathSeparatorChar: "/",
			separator: ":",
			separatorChar: ":",

			_pathName: pathName,

			createNewFile: function() {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
				var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);

				file.initWithPath( this.getPath() );
				if ( !file.exists() ) {
					file.create( Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 420 );
					if ( file.exists() ) {
						return true;
					}
				}
				return false;
			},

			"delete": function() {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
				var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);

				file.initWithPath( this.getPath() );
				file.remove( false );
				return !file.exists();
			},

			getAbsolutePath: function() {
				return makeAbsoluteURI(getBaseUrl(), this._pathName);
			},

			getPath: function() {
				return getLocalPath( this.getAbsolutePath() );
			},

			toString: function() {
				return this.getAbsolutePath();
			}
		};
	},
	createFileReader: function(fileName) {
		var file, fileReader, objFSO, url = makeAbsoluteURI(getBaseUrl(), fileName);

		fileName = getLocalPath(url);

		if (navigator.userAgent.toLowerCase().indexOf('webkit') !== -1) {
			fileReader = {
				read: function() {
					var xhr = new XMLHttpRequest();
					xhr.open('GET', url, false);
					xhr.send();
					return xhr.responseText;
				},
				close: function() {
				}
			};
		} else if (navigator.userAgent.toLowerCase().indexOf("gecko") !== -1) {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);

				file.initWithPath(fileName);
				if (!file.exists()) {

				}
			fileReader = {
				_file: file,
				__stream: Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream),
				_stream: Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream),

				read: function() {
					netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
					if (!arguments.length) {
						return this._stream.read(1);
					} else {
						buf = arguments[0];
						offset = arguments[1];
						return this._stream.read(arguments[2]);
					}
				},

				close: function() {
					netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
					this.__stream.close();
					return this._stream.close();
				}
			};
				fileReader.__stream.init(file, 1, 0, false);
				fileReader._stream.init(fileReader.__stream);
	  } else {
			objFSO = new ActiveXObject("Scripting.FileSystemObject");
			fileReader = {
				_stream: objFSO.CreateTextFile(fileName),

				write: function(s) {
					return this._stream.WriteLine(s);
				},

				close: function() {
					return this._stream.Close();
				}
			};
		}
		return fileReader;
	},//createFileReader()

	createFileWriter: function(fileName) {
		var file, fileWriter, objFSO;

		fileName = getLocalPath(
			makeAbsoluteURI(getBaseUrl(), fileName)
		);

		if (navigator.userAgent.toLowerCase().indexOf("gecko") !== -1) {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);

				file.initWithPath(fileName);
				if (!file.exists()) {
					file.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 420);
				}
			fileWriter = {
				_file: file,
				_stream: Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream),

				write: function(s) {
					netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
					this._stream.write(s, s.length);
					return;
				},

				close: function() {
					netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
					return this._stream.close();
				}
			};
				fileWriter._stream.init(file, 0x02 | 0x08 | 0x20, 0666, 0);
	  } else {
			objFSO = new ActiveXObject("Scripting.FileSystemObject");
			fileWriter = {
				_stream: objFSO.CreateTextFile(fileName),

				write: function(s) {
					return this._stream.WriteLine(s);
				},

				close: function() {
					return this._stream.Close();
				}
			};
		}
		return fileWriter;
	}//createFileWriter()
};

document.DOMImplementationLS = document.DOMImplementationLS || {
	MODE_SYNCHRONOUS: 1,
	MODE_ASYNCHRONOUS: 2,

	/* LSOutput */ createLSOutput: function() {
		return {
			characterStream: null,
			byteStream: null,
			systemId: null,
			encoding: null
		};
	},//createLSOutput()

	/* LSInput */ createLSInput: function() {
		return {
			characterStream: null,
			byteStream: null,
			stringData: null,
			systemId: null,
			publicId: null,
			baseURI: null,
			encoding: null,
			certifiedText: false
		};
	},//createLSInput()

	/* LSParser */ createLSParser: function() {
		return {
		};
	},//createLSParser

	/* LSSerializer */ createLSSerializer: function() {
		return {
			writeToURI: function(nodeArg, uri) {
				var output = document.DOMImplementationLS.createLSOutput();

				output.systemID = uri;
				return this.write(nodeArg, output);
			},

			write: function(nodeArg, destination) {
				var characterStream;

				if (!destination.characterStream) {
					destination.characterStream = document.fileIOFactory.createFileWriter(destination.systemID);
				}
				characterStream = destination.characterStream;
				try {
					characterStream.write(nodeArg);
					characterStream.close();
					return true;
				} catch(e) {
					return false;
				}
			}
		};
	}//createLSSerializer()
};
if (typeof(XPathEvaluator) == "undefined") {

	/**
	 * XPathException
	 * @param code
	 */

	XPathException = function(code) {
		this.code = code;
	};

	XPathException.INVALID_EXPRESSION_ERR      = 51;
	XPathException.TYPE_ERR                    = 52;

	/**
	 * XPathResult
	 */

	XPathResult = function() {
		this.resultType = XPathResult.ANY_TYPE;

		/**
		 * Note that we purposefully don't set default values for
		 * properties like snapshotLength so that exceptions are
		 * thrown if they are accessed when using an incompatible
		 * type.
		 */
	};

	XPathResult.ANY_TYPE                       = 0;
	XPathResult.NUMBER_TYPE                    = 1;
	XPathResult.STRING_TYPE                    = 2;
	XPathResult.BOOLEAN_TYPE                   = 3;
	XPathResult.UNORDERED_NODE_ITERATOR_TYPE   = 4;
	XPathResult.ORDERED_NODE_ITERATOR_TYPE     = 5;
	XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE   = 6;
	XPathResult.ORDERED_NODE_SNAPSHOT_TYPE     = 7;
	XPathResult.ANY_UNORDERED_NODE_TYPE        = 8;
	XPathResult.FIRST_ORDERED_NODE_TYPE        = 9;

	XPathResult.prototype.iterateNext = function() {
		if (this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE) {
			throw new XPathException(XPathException.TYPE_ERR);
		}
		if (this._iteratorNext >= this._iterator.length) {
			return null;
		}
		return this._iterator[this._iteratorNext++];
	};

	XPathResult.prototype.snapshotItem = function(index) {
		if (this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE) {
			throw new XPathException(XPathException.TYPE_ERR);
		}

		if (index < 0 || index >= this.snapshotLength) {
			return null;
		}
		return this._snapshot[index];
	};

	/**
	 * XPathExpression
	 */

	XPathExpression = function(expression, resolver) {
		this._expression = xpathParse( expression );
		this._resolver = resolver;
	};

	XPathExpression.prototype._selectSingleNode = function(node, expression) {
		return this._expression.evaluate( node );
		return node.selectSingleNode(expression);
	};

	XPathExpression.prototype._selectNodes = function(node, expression) {
		return node.selectNodes(expression);
	};

	XPathExpression.prototype._evaluate = function(node, type, result) {
	    var ctx = new ExprContext(node);

	    switch (type) {
			case XPathResult.ANY_UNORDERED_NODE_TYPE:
			case XPathResult.FIRST_ORDERED_NODE_TYPE:
				return this._expression.evaluate(ctx).nodeSetValue()[0];

			case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
			case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
				return this._expression.evaluate(ctx).nodeSetValue();
		}
	};

	XPathExpression.prototype.evaluate = function(node, type, result) {
		var res = result || new XPathResult();

		delete res.snapshotLength;
		delete res._iterator;
		delete res._snapshot;

		switch (type) {
			case XPathResult.ANY_UNORDERED_NODE_TYPE:
			case XPathResult.FIRST_ORDERED_NODE_TYPE:
				res.resultType = type;
				res.singleNodeValue = this._evaluate(node, type, result);
				break;

			case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
				res.resultType = type;
				res._snapshot = this._evaluate(node, type, result);
				res.snapshotLength = res._snapshot.length;
				break;

			case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
				res.resultType = type;
				res._iterator = this._evaluate(node, type, result);
				res._iteratorNext = 0;
				break;

			default:
				break;
		}
		return res;
	};

	/**
	 * XPathEvaluator
	 */

	XPathEvaluator = function() { };

	XPathEvaluator.prototype.createExpression = function(expression, resolver) {
		return new XPathExpression(expression, resolver);
	};

	XPathEvaluator.prototype.evaluate = function(expression, node, resolver, type, result) {
		var expr = this.createExpression(expression, resolver);

		return expr.evaluate(node, type, result);
	};

}

if (typeof(DOMParser) == "undefined") {
	DOMParser = function() { };

	DOMParser.prototype.parseFromString = function(str, contentType) {
		var doc = null;

		if (document.DOMImplementation && document.DOMImplementation.createDocument) {
			doc = document.DOMImplementation.createDocument();

			doc.loadXML(str);
		} else if (typeof(XMLHttpRequest) != "undefined") {
			doc = new XMLHttpRequest;

			contentType = contentType || "application/xml";
			doc.open("GET", "data:" + contentType + ";charset=utf-8," + encodeURIComponent(str), false);
			if (doc.overrideMimeType) {
				doc.overrideMimeType(contentType);
			}
			doc.send(null);
			doc = doc.responseXML;
		}
		return doc;
	};
}
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global FormsProcessor, document, UX, setTimeout*/
var EventTarget = null;



function dispatchXformsHint(element, event) {
	var oEvt, savedHintOffCounter;
	oEvt = element.ownerDocument.createEvent("UIEvents");
	savedHintOffCounter = FormsProcessor.hintOffCounter;
	setTimeout(function() {
		if (savedHintOffCounter === FormsProcessor.hintOffCounter) {
			oEvt.initUIEvent("xforms-hint", true, true, null, 1);
			FormsProcessor.dispatchEvent(element, oEvt);
		}
	}, 200);

	event.stop();
}



function dispatchXformsHintOff(element, event) {
	var oEvt = document.createEvent("UIEvents");
	FormsProcessor.hintOffCounter++;

	oEvt.initUIEvent("xforms-hint-off", true, true, null, 1);
	FormsProcessor.dispatchEvent(element, oEvt);
	event.stop();
}

function mapdblclick2domactivate(element, event) {
	var oEvt = element.ownerDocument.createEvent("UIEvents");

	oEvt.initUIEvent("DOMActivate", true, true, null, 2);
	FormsProcessor.dispatchEvent(element, oEvt);
	event.stop();
}



function StyleHoverishly(element) {
	UX.addClassName(element, "pc-hover");
}

function StyleUnhoverishly(element) {
	UX.removeClassName(element, "pc-hover");
}

function StyleFocussedly(element) {
	UX.addClassName(element, "pc-focus");
}

function StyleUnfocussedly(element) {
	UX.removeClassName(element, "pc-focus");
}



function findEventListenerIdx(oArray, oListener) {
	var len = oArray.length;
	var i;

	for (i = 0; i < len; i++) {
		if (oArray[i] === oListener) {
			break;
		}
	}

	return ((len === i) ? -1 : i);
}

if (UX.isIE) {

	function EventTargetProxy(element) {
		this.element = element;
		this.arrListener = this.element.arrListener || {};
	}

	EventTarget = EventTargetProxy;

	/*
     * P R I V A T E
     * =============
     */
	var g_iEventsInProgress = 0;
	var g_pendingEvents = [];

	var flushEventQueue = function() {
		var oPendingEvent = g_pendingEvents.pop();
		while (oPendingEvent) {
			oPendingEvent.target._dispatchEvent(oPendingEvent.evt);
			oPendingEvent = g_pendingEvents.pop();
		}
	};

	(function() {
		var PHASE_CAPTURE = 0;
		var PHASE_BUBBLE = 1;
		var PHASE_DEFAULT = 2;

		var _addEventListener = function(sType, oListener, bPhase) {
			var iPhase = PHASE_BUBBLE;

			if (typeof(sType) !== "string" || typeof(bPhase) !== "boolean" || !oListener) {
				this.element.document.logger.log("addEventListener: invalid arguments");
				return;
			}

			if (bPhase) {
				iPhase = PHASE_CAPTURE;
			}

			this.arrListener[sType] = this.arrListener[sType] || [];
			this.arrListener[sType][iPhase] = this.arrListener[sType][iPhase] || [];

			if (findEventListenerIdx(this.arrListener[sType][iPhase], oListener) < 0) {
				this.arrListener[sType][iPhase].push(oListener);
			}
		}; //_addEventListener
		var _removeEventListener = function(sType, oListener, bPhase) {
			var oList = null;
			var idx = 0;
			var iPhase = PHASE_BUBBLE;

			if (typeof(sType) !== "string" || typeof(bPhase) !== "boolean" || !oListener || !this.arrListener[sType]) {
				this.element.document.logger.log("removeEventListener: invalid arguments");
				return;
			}

			if (bPhase) {
				iPhase = PHASE_CAPTURE;
			}

			oList = this.arrListener[sType][iPhase];

			if (oList) {
				idx = findEventListenerIdx(oList, oListener);

				if (idx !== -1) {
					this.element.document.logger.log("Removed listener for " + sType + ", phase " + iPhase, "evnt");
					oList.splice(idx, 1);
				}
			} // if ( some listeners exist for this type and phase )
		}; //_removeEventListener
		var __notifyListeners = function(thisArg, oEvt) {

			/*
			 * First get the list of listeners for this type
			 */
			var arr = thisArg.arrListener[oEvt.type];

			if (arr) {
				/*
				 * Next, narrow it down to just those listeners
				 * for the correct phase
				 */
				var iPhase;

				switch (oEvt.eventPhase) {
				case oEvt.AT_TARGET:
					iPhase = PHASE_BUBBLE;
					break;

				case oEvt.BUBBLING_PHASE:
					iPhase = PHASE_BUBBLE;
					break;

				case oEvt.CAPTURING_PHASE:
					iPhase = PHASE_CAPTURE;
					break;

				case oEvt.DEFAULT_PHASE:
					iPhase = PHASE_DEFAULT;
					break;

				default:
					throw "[CEventTarget._notifyListeners] Invalid phase: " + oEvt.eventPhase;
				} // switch ( on the event phase )
				/*
				 * For each phase there will be one or more groups
				 */
				arr = arr[iPhase];

				if (arr && arr.length) {
					/*
					 * If we have a list of listeners then invoke their
					 * handlers
					 */
					thisArg.element.document.logger.log(oEvt.type + ": Notifying " + arr.length + " handlers", "evnt");

					for (var i = 0; i < arr.length; i++) {
						flushEventQueue();

						var oListener = arr[i];
						var bInvoke = true;

						/*
						 * If @ev:target is present then the listener is only
						 * invoked if event target has the same ID.
						 */
						if (oListener["ev:target"]) {
							if (oEvt.target.id != oListener["ev:target"]) {
								bInvoke = false;
							}
						}

						if (typeof(oListener.handleEvent) == "undefined") {
							bInvoke = false;
						}

						if (bInvoke) {
							oListener.handleEvent(oEvt);
						}

						/*
						 * If @ev:preventDefault is set then the default
						 * handler is to be cancelled.
						 */
						var sDefaultAction = thisArg.element["ev:defaultAction"];
						var bPreventDefault;

						switch (sDefaultAction) {
						case "cancel":
							bPreventDefault = true;
							break;

						case "perform":
							bPreventDefault = false;
							break;

						default:
							bPreventDefault = false;
							break;
						}

						if (bPreventDefault) {
							oEvt.preventDefault();
						}

						/*
						 * If @ev:propagate is set then we need to
						 * stop propagation.
						 */
						var sPropagate = thisArg.element["ev:propagate"];
						var bStopPropagation;

						switch (sPropagate) {
						case "stop":
							bPreventDefault = true;
							break;

						case "continue":
							bPreventDefault = false;
							break;

						default:
							bPreventDefault = false;
							break;
						}

						if (bStopPropagation) {
							oEvt.stopPropagation();
						}

						/*
						 * Stop propagation doesn't stop a group,
						 * but "stop immediate" does
						 */
						if (oEvt._stopImmediatePropagation) {
							break;
						}
					} //for ( each listener in this group )
					flushEventQueue();

					/*
					 * Stop propagation let's the current group complete
					 * before stopping all other listeners
					 */

				} // if ( there are groups for this phase )
			} // if ( there are listeners for this event )
		}; //_notifyListeners()
		var getTargetList = function(oEvt) {
			var bRet = [];
			var oNode = oEvt.target.parentElement;

			while (oNode) {
				var sTypeOfAddEventListener = typeof oNode.addEventListener;
				if (sTypeOfAddEventListener == "function" || sTypeOfAddEventListener == "unknown") {
					bRet.push(oNode);
				}
				oNode = oNode.parentElement;
			}
			return bRet;
		};

		var capture = function(oEvt, arrTargetList) {
			/*
			 * CAPTURE PHASE
			 * In the capture phase we target ancestors in order
			 * from the root to our target.
			 *
			 * After notifying each listener we check oEvt._stopPropogation
			 * to see if the process should continue, although for
			 * each target we carry out all listeners, uninterrupted.
			 *
			 * Note that capturing does *not* happen on the target of the
			 * event.
			 */
			oEvt.eventPhase = oEvt.CAPTURING_PHASE;
			var i, oNode;

			for (i = arrTargetList.length - 1; i >= 0; i--) {
				oNode = arrTargetList[i];
				oNode.currentTarget = oNode;
				__notifyListeners(oNode, oEvt);

				if (oEvt._stopPropagation) {
					break;
				}
			} // for ( each ancestor )
		};

		var bubble = function(thisArg, oEvt, arrTargetList) {
			/*
			 * BUBBLE PHASE
			 * In the bubble phase we target ancestors in reverse order,
			 * i.e., from the target up to the root. Begin with the
			 * 'current' target.
			 */
			var i, oNode;
			if (!oEvt._stopPropagation) {
				oEvt.eventPhase = oEvt.AT_TARGET;
				oEvt.currentTarget = thisArg.element;
				__notifyListeners(thisArg, oEvt);
			}

			if (!oEvt._stopPropagation) {
				if (oEvt.bubbles) {
					oEvt.eventPhase = oEvt.BUBBLING_PHASE;

					for (i = 0; i < arrTargetList.length; i++) {
						oNode = arrTargetList[i];
						oEvt.currentTarget = oNode;
						__notifyListeners(oNode, oEvt);

						if (oEvt._stopPropagation) {
							break;
						}
					} // for ( each ancestor )
				} // if ( the event is a bubbling event )
			} // if ( propogation has not been stopped )
		};

		var notifydefault = function(thisArg, oEvt) {
			/*
			 * Finally, perform the default handlers if not cancelled
			 */
			if (!oEvt._cancelled) {
				oEvt.eventPhase = oEvt.DEFAULT_PHASE;
				oEvt.currentTarget = thisArg.element;

				__notifyListeners(thisArg, oEvt);
			}
		};



		function _dispatchEvent(oEvt) {
			if (g_iEventsInProgress > 1) {
				return __dispatchEvent(this, oEvt);
			} else {
				return __dispatchEvent(this, oEvt);
			}
		}



		function __dispatchEvent(thisArg, oEvt) {
			++g_iEventsInProgress;
			try {
				var sType = oEvt.type;

				/*
				 * The 'target' is always the same, although the 'currentTarget' will
				 * change as bubbling and capture take place.
				 */

				oEvt.target = thisArg.element;
				document.logger.log("Dispatching: " + sType + " to " + oEvt.target.tagName + ":" + oEvt.target.uniqueID, "evnt");

				/*
				 * Increase the action depth, since we don't
				 * want to update the models until we exit
				 * the top-level action handler.
				 */

				if (oEvt._actionDepth === undefined) {
					oEvt._actionDepth = 0;
				}

				if (oEvt._actionDepth != -1) {
					oEvt._actionDepth++;
				}

				/*
				 * First build a list of the node's ancestors. Since the
				 * list of event targets that is used in the bubble and capture
				 * phases is set at the beginning of the event, we can use
				 * the same list twice
				 */

				var arrTargetList = getTargetList(oEvt);
				capture(oEvt, arrTargetList);
				bubble(thisArg, oEvt, arrTargetList);

				if (oEvt._stopPropagation) {
					document.logger.log("*** Propagation stopped ***", "evnt");
				}

				if (oEvt._cancelled) {
					document.logger.log("*** Cancelled ***", "evnt");
				}

				document.logger.log("End of dispatchEvent: " + sType, "evnt");
				notifydefault(thisArg, oEvt);

			} catch(e) {
			} finally {
				--g_iEventsInProgress;
			}
			/*
			 * Let the caller know if the default handlers were
			 * cancelled
			 */

			return !oEvt._cancelled;
		} //dispatchEvent
		/*
		 * There are essentially 4 phases:
		 * 1. capturing
		 * 2. at target
		 * 3. bubbling
		 * 4. processing defaults
		 *
		 * However, from the point of view of storing the listeners
		 * we can keep the target and bubbling listeners in the
		 * same place.
		 */
		EventTargetProxy.prototype.addEventListener = _addEventListener;
		EventTargetProxy.prototype.removeEventListener = _removeEventListener;
		EventTargetProxy.prototype.dispatchEvent = _dispatchEvent;
	} ());
} else {

	EventTarget = function(element) {
		this.element = element;
		this.element.addEventListener("click", function(evt) {
			mapclick2domactivate(element, evt);
		},
		false);
		this.element.addEventListener("mouseover", function(evt) {
			StyleHoverishly(element);
		},
		false);
		this.element.addEventListener("mouseout", function(evt) {
			StyleUnhoverishly(element);
		},
		false);

		this.element.addEventListener("mouseover", function(evt) {
			dispatchXformsHint(element, evt);
		},
		false);
		this.element.addEventListener("mouseout", function(evt) {
			dispatchXformsHintOff(element, evt);
		},
		false);
		this.element.addEventListener("click", function(evt) {
			dispatchXformsHintOff(element, evt);
		},
		false);
		this.element.addEventListener("keyup", function(evt) {
			dispatchXformsHintOff(element, evt);
		},
		false);

		this.element.addEventListener("focus", function(evt) {
			StyleFocussedly(element);
			if (UX.isFF) {
				UX.dispatchEvent(element, "DOMFocusIn", true, false, true);
			}
		},
		true);
		this.element.addEventListener("blur", function(evt) {
			StyleUnfocussedly(element);
			if (UX.isFF) {
				UX.dispatchEvent(element, "DOMFocusOut", true, false, true);
			}
		},
		true);
		this.element.addEventListener("keydown", function(evt) {
			if (typeof this.onKeyDown === "function") {
				this.onKeyDown(evt);
			}
		},
		false);
	};
}

(function() {

	var methods = {};
	var uid = 0;

	UX.Element = function(element) {
		if (element.ux_extended)  return methods[element.ux_extended];
		element.ux_extended = ++uid;
		var extended = new UX.Element.Methods(element);
		methods[uid] = extended;
		return extended;
	};

	UX.Element.Methods = new UX.Class({

		initialize: function(element) {
			this.element = element;
		},

		addListener: function(type, fn, capture) {
			type = type.replace(/^on/, '');
			if (UX.isIE) {
				this.element.attachEvent('on' + type, fn);
			} else {
				this.element.addEventListener(type, fn, !!capture);
			}
			return this;
		},

		addEvent: function(type, fn) {
			var capture = false;
			if (type == 'focus' || type == 'blur') {
				if (UX.isIE) {
					type = type == 'focus' ? 'focusin' : 'focusout';
				} else {
					capture = true;
				}
			}
			var element = this.element;
			var eventFn = function(event) {
				fn.apply(element, [new UX.Element.Event(event)]);
			};
			return this.addListener(type, eventFn, capture);
		},

		addEvents: function(events) {
			for(var type in events) {
				this.addEvent(type, events[type]);
			}
			return this;
		},

		addClass: function(cls) {
			UX.addClassName(this.element, cls);
			return this;
		},

		removeClass: function(cls) {
			UX.removeClassName(this.element, cls);
			return this;
		},

		hasChild: function(child) {
			var parent = child.parentNode;
			while (parent) {
				if (parent === this.element) return true;
				parent = parent.parentNode;
			}
			return false;
		}

});

UX.Element.Event = function(event) {
	if (!event) event = window.event || {};
	this.event = event;

	var target = event.target || event.srcElement;
	while (target && target.nodeType == 3) target = target.parentNode;
	this.target = target;

	if (event.shiftKey) this.shift = true;
	if (event.metaKey) this.meta = true;
	if (event.ctrlKey) this.control = true;
	if (event.altKey) this.alt = true;

	this.wheel = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;

	var code = event.which || event.keyCode;
	this.code = code;
	if (code) {
		var key = UX.Element.Event.Key[code];
		if (key) {
			this.key = key;
		} else if (event.type == 'keydown' && code - 111 > 0 && code - 111 < 13) {
			this.key = 'f' + code - 111;
		} else {
			this.key = String.fromCharCode(code).toLowerCase();
		}
	}

	this.rightClick = (event.which == 3) || (event.button == 2);

	var type = event.type;
	if (/over|out/.test(type)){
		related = event.relatedTarget || event[(type == 'mouseover' ? 'from' : 'to') + 'Element'];
		var testRelated = function(){
			while (related && related.nodeType == 3) related = related.parentNode;
			return true;
		};
		var hasRelated = testRelated();
		related = (hasRelated) ? related : null;
		this.relatedTarget = related;
	}

	this.stopPropagation = function(){
		if (event.stopPropagation) event.stopPropagation();
		else event.cancelBubble = true;
		return this;
	};

	this.preventDefault = function(){
		if (event.preventDefault) event.preventDefault();
		else event.returnValue = false;
		return this;
	};

	this.stop = function(){
		this.stoped = true;
		return this.stopPropagation().preventDefault();
	};
};

UX.Element.Event.Key = {
	13: 'enter',
	38: 'up',
	40: 'down',
	37: 'left',
	39: 'right',
	27: 'esc',
	32: 'space',
	8: 'backspace',
	9: 'tab',
	46: 'delete'
};

})();


YAHOO.util.Event.onDOMReady(function() {

	UX.Element(document).addEvent('click', function(event) {
		var element = event.target;
		while (element) {
			if (event.stoped) break;
			var behaviour = DECORATOR.getBehaviour(element);
			if (!behaviour) {
				element = element.parentNode;
				continue;
			}
			var oEvt = document.createEvent("UIEvents");
			oEvt.initUIEvent("DOMActivate", true, true, null, 1);
			oEvt.mappedFromClick = true;
			FormsProcessor.dispatchEvent(element, oEvt);
			if (UX.isIE) {
				event.stop();
			} else {
				event.stopPropagation();
			}
			dispatchXformsHintOff(element, event);
			element = element.parentNode;
		}
	})
	.addEvent('mouseover', function(event) {
		var target = event.target;
		if (!DECORATOR.getObject(target)) return;
		UX.Element(target).addClass("pc-hover");
		dispatchXformsHint(target, event);
	})
	.addEvent('mouseout', function(event) {
		var target = event.target;
		if (!DECORATOR.getObject(target)) return;
		UX.Element(target).removeClass("pc-hover");
		dispatchXformsHintOff(target, event);
	})
	.addEvent('keyup', function(event) {
		var target = event.target;
		if (!DECORATOR.getObject(target)) return;
		dispatchXformsHintOff(target, event);
	})
	.addEvent('keydown', function(event) {
		var element = event.target;
		while (element) {
			var behaviour = DECORATOR.getBehaviour(element);
			if (behaviour) {
				UX.Element(element).addClass('pc-focus');
				UX.dispatchEvent(element, "DOMFocusIn", true, false, true);
				if (behaviour.onKeyDown) {
					behaviour.onKeyDown(event);
				}
				if (event.stoped) break;
				FormsProcessor.onKeyDown(event);
			}
			element = element.parentNode;
		}
	})
	.addEvent('focus', function(event) {
		var element = event.target;
		while (element) {
			if (DECORATOR.getObject(element)) {
				UX.Element(element).addClass('pc-focus');
				UX.dispatchEvent(element, "DOMFocusIn", true, false, true);
			}
			element = element.parentNode;
		}
	})
	.addEvent('blur', function(event) {
		var element = event.target;
		while (element) {
			if (DECORATOR.getObject(element)) {
				UX.Element(element).addClass('pc-focus');
				UX.dispatchEvent(element, "DOMFocusOut", true, false, true);
			}
			element = element.parentNode;
		}
	});

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global UX, DECORATOR, EventTarget, NamespaceManager */
/*
 * The key to the whole thing is @ev:event, so there's
 * no point in proceeding if we don't have that.
 */
var Listener = new UX.Class({

	toString: function() {
		return 'xf:listener';
	},

	initialize: function(element) {
		this.element = element;
	},

	onDocumentReady: function() {
		var element = this.element;

		var sEvent = NamespaceManager.getAttributeNS(element, "http://www.w3.org/2001/xml-events", "event");
		if (!sEvent) return;

		var sObserverRef = NamespaceManager.getAttributeNS(element, "http://www.w3.org/2001/xml-events", "observer");
		var sPhase = NamespaceManager.getAttributeNS(element, "http://www.w3.org/2001/xml-events", "phase");
		var bUseCapture = sPhase === "capture";
		var oObserver = null;

		if (sObserverRef) {
			oObserver = element.ownerDocument.getElementById(sObserverRef);
		} else {
			oObserver = element.parentNode;
		}

		try {
			if (oObserver && sEvent) {
				var self = this;
				var thisAsListener = this;

				if (UX.isIE) {
					if (!oObserver.addEventListener) {
						UX.extend(oObserver, new EventTarget(oObserver));
					}
				} else {
					thisAsListener = function(evt) {
						if (UX.isWebKit && evt.type === 'DOMActivate' && !evt.mappedFromClick) {
							return;
						}
						self.handleEvent(evt);
					};
				}

				oObserver.addEventListener(sEvent, thisAsListener, bUseCapture);
			}
		} catch(e) {
			console.log("Error adding listener.");
		}
	},

	detach: function() {
		/* [TODO] Detach the registered listener.*/
	}

});

Listener.prototype.attachListeners = Listener.prototype.onDocumentReady;
if (typeof(XMLSerializer) == "undefined") {
	XMLSerializer = function() { };

	XMLSerializer.prototype.serializeToString = function(node) {
		if (node.xml) {
			var str = node.xml;

			/**
			 * MSXML likes to add a trailing CR+LF, so remove it.
			 */
			if(node.nodeType == 9) {//doc
				str = str.replace(/<\?xml.*?\?>\r/, '<?xml ' + node.firstChild.nodeValue + '?>');
			}
			return str.replace(/\r\n$/, "")
			.replace(/( ux_uid.*?".*?")/g, "");//remove ux_uid* attributes (see UX.getNodeUID for info about this attr)
		}
		return null;
	};
}


var schemeHandlers = [ ];

schemeHandlers["file"] = [ ];

schemeHandlers["file"]["PUT"] = function (fileName, data, timeout, callback) {
	var fileWriter,
	    isSuccess;

	try {
		fileWriter = document.fileIOFactory.createFileWriter(fileName);
		fileWriter.write(data);
		fileWriter.close();
		isSuccess = true;
	} catch(e) {
		isSuccess = false;
	}

	if (callback) {
		callback.processResult(
			{
				method: "PUT",
				status : 200,
				statusText : "",
				responseText : data,
				responseHeaders : "",
				resourceURI : fileName
			},
			!isSuccess
		);
	}
	return isSuccess;
};

schemeHandlers["file"]["GET"] = function (fileName, data, timeout, callback) {
	var fileReader,
	    data,
	    isSuccess;

	try {
		fileReader = document.fileIOFactory.createFileReader(fileName);
		data = fileReader.read(null, null, -1);
		fileReader.close();
		isSuccess = true;
	} catch(e) {
		isSuccess = false;
	}

	if (callback) {
		callback.processResult(
			{
				method: "GET",
				status : 200,
				statusText : "",
				responseText : data,
				responseHeaders : "",
				resourceURI : fileName
			},
			!isSuccess
		);
	}
	return isSuccess;
};

schemeHandlers["file"]["DELETE"] = function (fileName, data, timeout, callback) {
	var file,
	    isSuccess;

	try {
		file = document.fileIOFactory.createFile(fileName);
		isSuccess = file["delete"]();
	} catch(e) {
		isSuccess = false;
	}

	if (callback) {
		callback.processResult(
			{
				method: "DELETE",
				status : 200,
				statusText : "",
				responseText : data,
				responseHeaders : "",
				resourceURI : fileName
			},
			!isSuccess
		);
	}
	return isSuccess;
};
/*
 * xH provides a standards-based suite of browser enhancements for
 * building a new generation of internet-related applications.
 * Copyright (C) 2007-8 Mark Birbeck
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Mark Birbeck can be contacted at:
 *
 *  36 Tritton Road
 *  London
 *  SE21 8DE
 *  United Kingdom
 *
 *  mark.birbeck@gmail.com
 */
/* This is a temporary home. */

if (!document.submissionJSON)
{
    document.submissionJSON = {
        _timeoutlength: 120000,  /* 2 minutes, by default */
        _running: [ ],

        _timeout: function(id, url)
        {
            var cbo = this._running[id];

            this._running[id] = null;
            if (!cbo.callbackErr)
                return;
            cbo.callbackErr("Timeout", -1, cbo.self);
        },//_timeout

        _callbackhandler: function(o)
        {
            var cbo = this._running[callbackIndex];

            if (!cbo)
                return;
            this._running[callbackIndex] = null;
            window.clearTimeout(cbo.timeout);
            if (!o /* || !o.count */)
            {
                if (!cbo.callbackErr)
                    return;
                cbo.callbackErr("Bad response", -2, cbo.self);
                    return;
            }

            if (!cbo.callbackOk)
                return;
            cbo.callbackOk(o, cbo.userData, cbo.self);
        },//_callbackhandler

        _execute: function(url, id, userData, fnName, callbackOk, callbackErr, timeoutlength)
        {
            var s = document.createElement("script");

            s.setAttribute("src", url);

            var fn = "" + this._callbackhandler;
            var self = this;

            fn = fn.replace(/callbackIndex/g, id);
            eval("document.submissionJSON._callbackhandler_" + id + "=" + fn);
            if (fnName)
              eval(fnName + "= function(o) { document.submissionJSON._callbackhandler_" + id + "(o) }");
            this._running.push(
                {
                    self: this,
                    userData: userData,
                    callbackOk: callbackOk,
                    callbackErr: callbackErr,
                    timeout: window.setTimeout(
                        function()
                        {
                            self._timeout(id, url);
                        },
                        timeoutlength
                    )
                }
            );
            document.getElementsByTagName("head")[0].appendChild(s);
            return id;
        },//_execute

        /* use these three calls to run and cancel Pipes calls */
        cancelrequest: function(id)
        {
            var cbo = this._running[i];

            window.clearTimeout(cbo.timeout);
            this._running[i]=null;
        },//cancelrequest

        cancelallrequests: function()
        {
            for (var i = 0; i < this._running.length; i++)
                this.cancelrequest(i);
        },//cancelallrequests

        run: function(action, params, userData, callbackOk, callbackErr, timeoutLength)
        {
            if (!timeoutLength)
                timeoutLength = this._timeoutlength;
            var id = this._running.length;
            var sCallBackParamName = "callback";
            var fnName = null;

            if (params["callbackName"])
            {
              fnName = params["callbackName"];
              params["callbackName"] = null;
            }
            else
            {
              if (params["callbackParamName"])
              {
                sCallBackParamName = params["callbackParamName"];
                params["callbackParamName"] = null;
              }

              params[sCallBackParamName] = "document.submissionJSON._callbackhandler_" + id;
            }

            return this._execute(
                buildGetUrl(action, params),
                id,
                userData,
                fnName,
                callbackOk,
                callbackErr,
                timeoutLength
            );
        }//run
    };//pipesrpc
}//if ( document.submissionJSON is not defined )


/**
  function: crackNVPairs
  Cracks a list of Name-value pairs, into either an array, or as members of saveIn (if present)

  list - {String} a list of name-value pairs in the required format.
  innerSeparator - {String} The string used to separate a name from a value
  outerSeparator - {String} The string used to separate pairs from other pairs in the list
  saveIn - {Object} (optional) Object in which to save the name-value pairs.

  returns - If saveIn is present, an empty array, if saveIn is absent, an array of Pair objects, Pair objects have two properties, "left" and "right"
     corresponding to the LHS and RHS of the pair in the string that it corresponds to.
*/
function crackNVPairs(list, innerSeparator, outerSeparator, saveIn ){
  var unparsedPairs = list.split(outerSeparator), parsedPairs = [], i, thisPairAsArray, leftVal,rightVal;

  for(i = 0;i < unparsedPairs.length;++i) {
    thisPairAsArray  = unparsedPairs[i].split(innerSeparator);
    leftVal = thisPairAsArray.shift();
    rightVal = thisPairAsArray.join(innerSeparator);
    if(!saveIn) {
      parsedPairs.push({left: leftVal, right: rightVal});
    }
    else {
      saveIn[leftVal] = rightVal;
    }

  }
  return parsedPairs;
}

/**
  class: FragmentParser
    Used to parse xpointer style URL fragments.
*/
var FragmentParser = function(){
  var self = {};
  var m_expr = (/\s*([^\(]+)\((([^\^\)]*(?:(\^\)))*(?:\^\^)*)*)\)/g);
  var m_schemeHandlers = {};
  /**
    function: parseFragment
    Splits an XPointer style fragment into an array of objects broken into scheme and content,
      where "content" corresponds to the content of an expression,
    s - {String} The fragment portion of a URL

    returns - A list of objects of the form {scheme:A,rawData:B,data:C}, each representing a pointer part.
      Where A is the scheme of the pointer part, and B, its content. If the FragmentParser has been provided with a mechanism for parsing content
      for the given scheme, then C will contain its output.  Otherwise, the content may be further processed by the calling application according to the scheme.
  */
  var parseFragment = function(s) {
    var result, fullResult = null, content, pos;
    result = m_expr.exec(s);

    if(result) {
      fullResult = [];
    }

    while(result) {
      content = result[2];
      pos = content.indexOf("^");
      while(pos > -1 && pos < content.length - 1) {
        content = content.slice(0,pos) + content.slice(pos+1);
        if( content.charAt(pos)==="^") {
          ++pos;
        }
        pos = content.indexOf("^",pos);
      }
      var schemeHandler = m_schemeHandlers[result[1]];
      var parsedContent = null;
      if(typeof schemeHandler == 'function') {
        parsedContent = schemeHandler(content);
      }
      fullResult.push({scheme : result[1], rawData : content, data:parsedContent  });
      result = m_expr.exec(s);
    }
    return fullResult;
  };


  var setSchemeHandler = function (scheme,handler) {
    m_schemeHandlers[scheme] = handler;
  };

  setSchemeHandler('vars',
    function(s) {
     return crackNVPairs(s,'=',',');
    }
  );

  self.setSchemeHandler = setSchemeHandler;
  self.parseFragment = parseFragment;
  return self;
}();


/**
  function: saveParametersFromURL
  Saves parameters set in a vars pointer part in a url, as properties on a given object.

  s - A URL with a fragment that contains a "vars" pointer part
  o - the object in which the vars will be stored as properties.
*/
function saveParametersFromURL(s, o) {
  var fragmentMarker = s.indexOf("#");
  if(fragmentMarker > -1) {
    var fragment = s.slice(s.indexOf("#") + 1, s.length);
    var parsedFragment = FragmentParser.parseFragment(fragment);
    for(var i = 0 ; i < parsedFragment.length; ++i) {
      if(parsedFragment[i].scheme === 'vars') {
        for(var j = 0; j < parsedFragment[i].data.length;++j) {
          var currentDataItem = parsedFragment[i].data[j];
          o[currentDataItem.left] = currentDataItem.right;
        }
      }
    }
  }
}



function pathToModule(module) {
  if (!module) {
    throw("Missing or null parameter supplied.");
  }

  var scriptNodes = document.getElementsByTagName( "script" );
  var l = scriptNodes.length;
  var i;
  var head;
  var s = null;
  var el, src, pos;

  for (i = 0; i < l; ++i) {
    el = scriptNodes[i];
    src = el.src;
    if (src) {
      pos = src.lastIndexOf(module + ".js");

      if (pos != -1 && (!pos || src.charAt(pos - 1) === "/" || src.charAt(pos - 1) === "\\")) {
        s = src.slice(0, pos);
        break;
      }
    }// if @src is present
  }// for each script node

  if (!s) {
    throw("No Module called '" + module + "' was found.");
  }
  return s;
}

/*
 * Needs moving somewhere else...but not sure where yet.
 *
 * Note that there are umpteen implementations of this in libraries like prototype, so we
 * don't need another one here. But since we are only relying on YUI at the moment, we'll
 * need something.
 */

function myList()
{
    this._list = [];
}

function findKey(arr, key)
{
    var oRet = null;

    if (typeof(key) == "number")
        oRet = arr[key].item;
    else
    {
        for (var i = 0; i < arr.length; i++)
        {
            if (arr[i].name == key)
            {
                oRet = arr[i].item;
                break;
            }
        }
    }//if ( key is an index ) ... else ...
    return oRet;
}//findKey

myList.prototype.add = function(key, obj)
{
    var found = false;

    for (var i = 0; i < this._list.length; i++)
    {
        if (this._list[i].name == key)
        {
            found = true;
            break;
        }
    }
    if (!found)
    {
        this._list.push(
            {
                name: key,
                item: obj
            }
        );
        i = this._list.length - 1;
    }
    return this._list[i].item;
};//add

myList.prototype.get = function(key)
{
    var oRet = null;

    if (typeof(key) == "number")
        oRet = this._list[key].item;
    else
    {
        for (var i = 0; i < this._list.length; i++)
        {
            if (this._list[i].name == key)
            {
                oRet = this._list[i].item;
                break;
            }
        }
    }//if ( key is an index ) ... else ...
    return oRet;
};//get


/*
 * This first part is essentially 'Growl core'. It should be moved into its own module at
 * some point.
 */

function GrowlRawNotification()
{
    this.displayName = null;
    this.text = null;
    this.style = null;
    this.name = null;
    this.title = null;
    this.description = null;
    this.enabled = false;
    this.iconData = null;
    this.priority = 0;
    this.reserved = 0;
    this.isSticky = false;
    this.clickContext = null;
    this.clickCallback = null;
}//GrowlRawNotification

function GrowlNotification()
{
    this.name = null;
    this.title = null;
    this.description = null;
    this.enabled = true;
    this.iconData = null;
    this.priority = 0;
    this.reserved = 0;
    this.isSticky = false;
    this.clickContext = null;
    this.clickCallback = null;
}//GrowlNotification

if (!document.Growl)
{
    document.Growl = {
        _applicationsList: new myList(),

        _displayList: [],
        _displayDefault: null,

        _notifyContainer: null,

        _notifyCount: 0,

        _userSettings: null,

        addUserSettings: function(settings)
        {
            this._userSettings = settings;
            return;
        },//addUserSettings()

        rawNotification: function(app, displayStyle, notification)
        {
            if (displayStyle.impl.init())
            {
                var delegate = app.delegate;
                var panel = (notification.useExternal && displayStyle.implExternal)
                  ? displayStyle.implExternal.createPanel()
                  : displayStyle.impl.createPanel();

                panel.setMessage(notification);
                panel.show();

                if (!notification.isSticky)
                {
                    setTimeout(
                        function ()
                        {
                            if (panel)
                            {
                                panel.destroy();
                                panel = null;
                            }//if ( the panel is still around )
                            if (notification.clickContext && delegate.growlNotificationTimedOut)
                                delegate.growlNotificationTimedOut("id");
                        },
                        (notification.duration) ? notification.duration * 1000 : 4000
                    );
                }
                panel.registerForClick(
                    function()
                    {
                        if (panel)
                        {
                            panel.destroy();
                            panel = null;
                        }

                        /*
                         * The 'per notification' callback overrides the delegate's.
                         */

                        if (notification.clickCallback)
                            notification.clickCallback.call(notification.clickContext);
                        else
                        {
                            if (delegate.growlNotificationWasClicked)
                                delegate.growlNotificationWasClicked("id");
                        }
                    }//onclick handler
                );
            }//if ( the style handler was initialised successfully )
        },//rawNotification()

        setGrowlDelegate: function(delegate)
        {

            /*
             * Create a new notification list for each application.
             */

            var appname;

            if (!delegate.applicationNameForGrowl)
                throw "Growl delegate must implement applicationNameForGrowl()";
            else
                appname = delegate.applicationNameForGrowl();

            /*
             * It doesn't hurt to try to add it even if it's already there.
             */

            var app = this._applicationsList.add(
                appname,
                {
                    delegate: null,
                    displayName: "default",
                    _notificationsList: new myList()
                }
            );

            if (app.delegate)
                app.delegate.release();
            app.delegate = delegate;

            var nl = app._notificationsList;

            /*
             * Each notification that is being registered gets its own entry
             * in the list.
             */

            var dictionary;

            if (!delegate.registrationDictionaryForGrowl)
                throw "Growl delegate must implement registrationDictionaryForGrowl()";
            else
                dictionary = delegate.registrationDictionaryForGrowl();

            var fullList = dictionary[0];

            for (var i = 0; i < fullList.length; i++)
                nl.add(fullList[i], { displayName: "default", enabled: false } );

            /*
            * Now we can set the default 'enable' state of the notifications.
            */

            var enabledList = dictionary[1];

            for (i = 0; i < enabledList.length; i++)
            {
                var n = nl.get(enabledList[i]);

                    n.enabled = true;
            }
            return;
        },//setGrowlDelegate()

        notify: function(notificationName, title, description, applicationName, image, sticky, priority)
        {
            /*
             * First create a notification object that will hold the format of our message.
             */

            var notification = new GrowlRawNotification();

            notification.title = title;
            notification.description = description;

            /*
             * Next get the various settings. These come from:
             *
             * - a user's global default settings;
             * - a user's per application settings;
             * - a user's per notification settings;
             * - a user's per display settings;
             * - parameters set by the author in the call to this function.
             */

            /*
             * Get the application from the list of registered applications, and
             * get the notification that we're about to use.
             */

            var app = this._applicationsList.get(applicationName);

            if (app)
            {
                var n = app._notificationsList.get(notificationName);

                notification.enabled = n.enabled;

                /*
                 * See if the user has any settings for this application, and if so
                 * get the settings for the notification.
                 */

                var userNotification = null;

                if (this._userSettings)
                {
                    var userApp = findKey(this._userSettings._applicationsList, applicationName);

                    if (userApp)
                        userNotification = findKey(userApp._notificationsList, notificationName);
                }

                /*
                 * First work out the theme to use. If the user has set one, for the
                 * notification or for the application then it takes priority.
                 */

                var displayName = "default";

                if (userNotification && userNotification.displayName)
                    displayName = userNotification.displayName;

                if (displayName == "default")
                {
                    if (userApp && userApp._default && userApp._default.displayName)
                        displayName = userApp._default.displayName;
                }

                if (displayName == "default")
                    displayName = this._displayDefault;

                /*
                 * Now that we have a display theme we copy all of its properties into
                 * our notification object.
                 */

                var d = this._displayList[displayName];

                for (var k in d)
                    notification[k] = d[k];


                /*
                 * Get some defaults for the application. If there is no image then use the
                 * application image.
                 */

                notification.iconData = app.delegate.applicationIconDataForGrowl();


                /*
                 * Now we override the display settings with any parameters passed.
                 */

                if (image)
                    notification.iconData = image;
                if (sticky)
                    notification.isSticky = sticky;
                if (priority)
                    notification.priority = priority;

                /*
                 * Finally, we apply any changes to the settings that the user has put on.
                 */

                if (userNotification)
                {
                    for (k in userNotification)
                        notification[k] = userNotification[k];
                }
                notification.displayName = displayName;

                /*
                 * Only show the notification if it is enabled.
                 */

                if (notification.enabled)
                    this.rawNotification(app, d, notification);
            }//if ( the application is registered )
            return;
        },//notify()

        /*
         * This method will add themes stored in a Google spreadsheet.
         */

        addThemes: function(json)
        {
          for (var i = 0; i < json.feed.entry.length; i++)
          {
            var x = json.feed.entry[i].content.$t;
            var o;
            eval( "o = {" + json.feed.entry[i].content.$t + "}" );
            var name = o.n;
            var t = o.t;
            var b = o.b;
            var op = o.o;
            var d = o.d;
            var f = o.f;

            document.Growl._displayList[name] = {
                text: t,
                style: "background-color: " + b + "; opacity: " + op + ";",
                duration: d,
                floatingicon: false,
                impl: document.displayYui
            };
          }//for ( each theme )
          return;
        }//addThemes()
    };

    /*
     * These are the default styles.
     */

    document.Growl._displayList["plain"] = {
        text: "black",
        style: "background-color: #D0D0D0; border: thin solid black",
        radius: 0,
        opacity: 95,
        duration: 4,
        floatingicon: false
    };

    document.Growl._displayList["smoke"] = {
        text: "white",
        style: "background-color: black;",
        radius: 10,
        opacity: 15,
        duration: 4,
        floatingicon: false
    };

    /*
     * The user will be able to control this.
     */

    document.Growl._displayDefault = "smoke";
}//if ( there is no Growl object )


if (!document.Yowl)
{
    document.Yowl = {
        _dictionary: [],

        notify: function(notificationName, title, description, applicationName, image, sticky, priority)
        {
            document.Growl.notify(
                notificationName,
                title,
                description,
                applicationName,
                image,
                sticky,
                priority
            );
            return;
        },//notify()

        register: function(applicationName, allNotifications, defaultNotifications, iconOfApplication)
        {
            this._dictionary[0] = applicationName;
            this._dictionary[1] = allNotifications;
            this._dictionary[2] = defaultNotifications;
            this._dictionary[3] = iconOfApplication;
            this.setGrowlDelegate(this);
            return;
        },//register()

        setGrowlDelegate: function(delegate)
        {
            document.Growl.setGrowlDelegate(delegate);
            return;
        },//setGrowlDelegate()

        getGrowlDelegate: function()
        {
            return this;
        },//getGrowlDelegate()

        /*
         * The following are for the delegate interface.
         */

        registrationDictionaryForGrowl: function()
        {
            return [ this._dictionary[1], this._dictionary[2] ];
        },

        applicationNameForGrowl: function()
        {
            return this._dictionary[0];
        },

        applicationIconDataForGrowl: function()
        {
            return this._dictionary[3];
        },

        release: function()
        {
            return;
        },//release()

        growlIsReady: function()
        {
            return;
        },

        growlNotificationWasClicked: function(id)
        {
            return;
        },

        growlNotificationTimedOut: function(id)
        {
            return;
        }
    };
}//if ( there is no document.Yowl )

var IFrameObj; // our IFrame object
function callToServer() {
  if (!document.createElement) {
  	return true;
  }
  var IFrameDoc;
  var URL = 'server.html';
  if (!IFrameObj && document.createElement) {
   try {
      var tempIFrame=document.createElement('iframe');
      tempIFrame.setAttribute('id','RSIFrame');
      tempIFrame.style.border='0px';
      tempIFrame.style.width='0px';
      tempIFrame.style.height='0px';
      IFrameObj = document.body.appendChild(tempIFrame);

      if (document.frames) {
        IFrameObj = document.frames['RSIFrame'];
      }
    } catch(exception) {
      iframeHTML='\<iframe id="RSIFrame" style="';
      iframeHTML+='border:0px;';
      iframeHTML+='width:0px;';
      iframeHTML+='height:0px;';
      iframeHTML+='"><\/iframe>';
      document.body.innerHTML+=iframeHTML;
      IFrameObj = new Object();
      IFrameObj.document = new Object();
      IFrameObj.document.location = new Object();
      IFrameObj.document.location.iframe = document.getElementById('RSIFrame');
      IFrameObj.document.location.replace = function(location) {
        this.iframe.src = location;
      };
    }
  }

  if (navigator.userAgent.indexOf('Gecko') !=-1 && !IFrameObj.contentDocument) {
    setTimeout('callToServer()',10);
    return false;
  }

  if (IFrameObj.contentDocument) {
    IFrameDoc = IFrameObj.contentDocument;
  } else if (IFrameObj.contentWindow) {
    IFrameDoc = IFrameObj.contentWindow.document;
  } else if (IFrameObj.document) {
    IFrameDoc = IFrameObj.document;
  } else {
    return true;
  }

  IFrameDoc.location.replace(URL);
  return false;
}
if (!document.displayYui)
{
    function panel(id)
    {
        this._panel = new YAHOO.widget.Module(
                "smoke-notification-" + id,
                {
                    visible: false
                }
            );

        this.setMessage = function(notification)
            {
        			  var style = "-moz-border-radius: " + notification.radius + "px; "
        			    + "filter: alpha(opacity=" + notification.opacity + "); opacity: " + (notification.opacity / 100) + "; "
        			    + notification.style;

                this._panel.setBody(
                    "<div class='notification " + notification.displayName + " " + notification.priority + "' style='color: " + notification.text + "'>"
                        + "<div class='background' style='" + style + "'></div>"
                        + "<div class='icon'>"
                            + ((notification.iconData) ? "<img src='" + notification.iconData + "' />" : "")
                        + "</div>"
                        + "<div class='title'>" + notification.title + "</div>"
                        + "<div class='text'>" + notification.description + "</div>"
                    + "</div>"
                );
                this._panel.render(document.displayYui._containerId);
                return;
            };//setMessage()

        this.registerForClick = function(f)
            {
                this._panel.element.onclick = f;
                return;
            };//registerForClick

        this.show = function()
            {
                this._panel.show();
                return;
            };//show()

        this.destroy = function()
            {
                /*
                 * We kick off a fade out animation, and when it's complete
                 * we do the actual destroy.
                 */

                var anim = new YAHOO.util.Anim(
                    this._panel.id,
                    { opacity: { to: 0 } },
                    1,
                    YAHOO.util.Easing.easeOut
                );
                var self = this;
                anim.onComplete.subscribe(
                    function ()
                    {
                        if (self._panel)
                        {
                            self._panel.destroy();
                            self._panel = null;
                        }
                    }
                );
                anim.animate();
                return;
            };//destory()
    };//panel()

    document.displayYui = {
        _containerId: "yui_notification_container",
        _initialised: false,
        _notificationContainer: null,
        _notifyCount: 0,

        init: function()
            {
                if (!this._notificationContainer)
                {
                    var el = document.createElement("div");

                    el.setAttribute("id", this._containerId);
                    document.body.appendChild(el);

                    this._notificationContainer = el;

                    if (false)
                    this._notificationContainer = new YAHOO.widget.Overlay(
                        this._containerId,
                        {
                            context: [document.body, "tl", "tl"],
                            visible: false,
                            width: "300px",
                            constraintoviewport: true
                        }
                    );

                    /*
                     * Instantiate the container for the messages.
                     */

                    if (this._notificationContainer)
                    {
                        this._initialised = true;
                    }
                }//if ( there is no notification container )
                return this._initialised;
            },//init

        createPanel: function()
            {
                return new panel(this._notifyCount++);
            }//createPanel
    }//YUI object

    document.Growl._displayList["plain"].impl = document.displayYui;
    document.Growl._displayList["smoke"].impl = document.displayYui;
}//if ( the YUI module is not initialised )

document.notify = document.notify || { };

var global_window_counter = 0;

UX.addClassName(document.body, "yui-skin-sam");

document.notify.messageWindow = function(self, activate) {
    var width_style = UX.getStyle(self.element, "width");
    var height_style = UX.getStyle(self.element, "height");

    self.yahooPanel = new YAHOO.widget.SimpleDialog(
        "dialog-window" + global_window_counter,
        {
            appendtodocumentbody: true,
            close: false,
            fixedcenter: true,
            constraintoviewport: false,
            modal: activate,
            visible: false,
            width: (width_style && width_style !== "auto") ? width_style : "300px",
            height: (height_style && height_style !== "auto") ? height_style : "140px"
        }
    );

    self.yahooPanel2 = new YAHOO.widget.SimpleDialog(
        "background-shadow" + global_window_counter,
        {
            draggable: false,
            close: false,
            fixedcenter: true,
            constraintoviewport: false,
            visible: false
        }
    );

    self.yahooPanel.yahooPanel2 = self.yahooPanel2;

    global_window_counter++;

    UX.addClassName(self.yahooPanel2.element, "background-shadow");

    var handleOK = function() {
        this.hide();
        this.yahooPanel2.hide();
        this.yahooPanel2.destroy();
        this.destroy();
    };
    var myButtons = [ { text:"OK", handler:handleOK } ];
    self.yahooPanel.cfg.queueProperty("buttons", myButtons);

    self.yahooPanel.setHeader("[XForms]");
    if (UX.isIE) {
        self.yahooPanel.setBody(self.element.innerText);
    } else {
        self.yahooPanel.setBody(self.element.textContent);
    }
    self.yahooPanel.render(document.body);
    self.yahooPanel.show();

    if (activate) {
        self.yahooPanel2.render(document.body);
        self.yahooPanel2.show();
    }

    return;
};
/*
 * Copyright (C) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * An RDF Parser.
 *
 * @class RDFParser
 * @constructor
 * @param store {RDFStore}
 */

function RDFParser(oRDFStore)
{
  /*
   * Initialise the reference to the triple store.
   */

  this.store = oRDFStore;

  /*
   * Create a stack for the contexts.
   */

  this._context = [ ];
  return;
}

RDFParser.prototype.parse = function(oRoot, sBase, oWhy)
{
  var parserContext = this;
  var mapURIs = new mappings();

  /*
   * Set up some default URI mappings.
   */

  mapURIs.add("", "http://www.w3.org/1999/xhtml/vocab#", true);
  mapURIs.add("_", "bnode:" + sBase, true);
  mapURIs.add("_fresnel", "http://www.w3.org/2004/09/fresnel#", true);
  mapURIs.add("_xh", "http://www.w3.org/1999/xhtml", true);
  mapURIs.add("_rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#", true);
  mapURIs.add("_rdfs", "http://www.w3.org/2000/01/rdf-schema#", true);
  mapURIs.add("_dc", "http://purl.org/dc/elements/1.1/", true);

  /*
   * Add the predefined XHTML vocab tokens.
   */

  mapURIs.add("alternate", "http://www.w3.org/1999/xhtml/vocab#alternate", true);
  mapURIs.add("appendix", "http://www.w3.org/1999/xhtml/vocab#appendix", true);
  mapURIs.add("bookmark", "http://www.w3.org/1999/xhtml/vocab#bookmark", true);
  mapURIs.add("cite", "http://www.w3.org/1999/xhtml/vocab#cite", true);
  mapURIs.add("chapter", "http://www.w3.org/1999/xhtml/vocab#chapter", true);
  mapURIs.add("contents", "http://www.w3.org/1999/xhtml/vocab#contents", true);
  mapURIs.add("copyright", "http://www.w3.org/1999/xhtml/vocab#copyright", true);
  mapURIs.add("first", "http://www.w3.org/1999/xhtml/vocab#first", true);
  mapURIs.add("glossary", "http://www.w3.org/1999/xhtml/vocab#glossary", true);
  mapURIs.add("help", "http://www.w3.org/1999/xhtml/vocab#help", true);
  mapURIs.add("icon", "http://www.w3.org/1999/xhtml/vocab#icon", true);
  mapURIs.add("index", "http://www.w3.org/1999/xhtml/vocab#index", true);
  mapURIs.add("last", "http://www.w3.org/1999/xhtml/vocab#last", true);
  mapURIs.add("license", "http://www.w3.org/1999/xhtml/vocab#license", true);
  mapURIs.add("meta", "http://www.w3.org/1999/xhtml/vocab#meta", true);
  mapURIs.add("next", "http://www.w3.org/1999/xhtml/vocab#next", true);
  mapURIs.add("p3pv1", "http://www.w3.org/1999/xhtml/vocab#p3pv1", true);
  mapURIs.add("prev", "http://www.w3.org/1999/xhtml/vocab#prev", true);
  mapURIs.add("role", "http://www.w3.org/1999/xhtml/vocab#role", true);
  mapURIs.add("section", "http://www.w3.org/1999/xhtml/vocab#section", true);
  mapURIs.add("stylesheet", "http://www.w3.org/1999/xhtml/vocab#stylesheet", true);
  mapURIs.add("subsection", "http://www.w3.org/1999/xhtml/vocab#subsection", true);
  mapURIs.add("start", "http://www.w3.org/1999/xhtml/vocab#start", true);
  mapURIs.add("top", "http://www.w3.org/1999/xhtml/vocab#top", true);
  mapURIs.add("up", "http://www.w3.org/1999/xhtml/vocab#up", true);

  /*
   * Set the initial context and then begin the parsing.
   */

  parserContext.traverse(
    oRoot,
    {
      base: sBase,
      graph: this.store.getGraph( "" ),
      parentSubject: sBase,
      language: "",
      uriMappings: mapURIs,
      incompleteTriples: [ ],
      parentObject: null,
      classIsPredicate: false
    }
  );
};//parse



/*
 * Include the triples from another document, by parsing the RDFa.
 */

RDFParser.prototype.parseExternal = function(uri, callback) {
	var that = this;
	var baseURI;

	if (typeof uri === "object") {
		baseURI = uri.base;
		uri = uri.uri;
	} else {
		baseURI = uri;
	}

  if (uri.substr(0, 6) != "bnode:")
  {

    /*
     * Create an iframe ready to take the external document, but note that we don't
     * put the src attribute on yet.
     */

    var elHead = document.getElementsByTagName("head")[0];
    var el;

    el = document.createElement('iframe');
    elHead.appendChild(el);


    /*
     * Since we don't know how long it will take to load the document we register an
     * onload handler, and we do our parsing in there.
     */

    YAHOO.util.Event.addListener(
      el,
      "load",
      function()
      {

        /*
         * The DOM for the loaded document is in 'contentDocument'.
         */

        /*
         * If documents are from the same domain then this request will have no effect.
         * However, if the documents are from different domains, then it's up to the
         * user whether to allow this.
         */

        that.parse(this.contentDocument || this.contentWindow.document, baseURI, null);

        this.parentNode.removeChild(this);


        /*
         * Now that we've finished parsing, we query for any constructors
         * that have been loaded...
         */

				var loader = new YAHOO.util.YUILoader();

        var r = document.meta.query2(
          {
            select: [ "css" ],
            where:
              [
                { pattern: [ uri, "http://www.w3.org/1999/xhtml/vocab#stylesheet", "?css" ] }
              ]
          }
        );

        if (r && r.results.bindings[0] && r.results.bindings[0]["css"])
        {
          loader.addModule({ name: "fresnel-css-stylesheet", type: "css", fullpath: r.results.bindings[0]["css"] });
          loader.require( "fresnel-css-stylesheet" );
        }

	      loader.onSuccess = function(o) {
          var results = document.meta.query2(
            {
              select: [ "init" ],
              where:
                [
                  { pattern: [ "?s", "http://argot-hub.googlecode.com/constructor", "?init" ] }
                ]
            }
          );//query for a constructor

          /*
           * ...and for each one execute the script.
           */

          document.meta.walk2(
            results,
            {
              action: function(obj)
              {
                try
                {
                  eval( obj.init.content );
                }
                catch(e)
                {
                  alert("Constructor failed: " + e.description);
                }
              }//action()
            }
          );

          processFresnelSelectors(uri);

          /*
           * If there is a callback function then call it.
           */

          if ( callback ) {
            callback();
          }
        };
				loader.insert();
        return;
      },
      false
    );

    /*
     * We leave the setting of the iframe's URL until last, because we have to be
     * sure that our event handler is in place.
     */

    el.setAttribute("src", uri);
  }//if ( the URI is not a bnode )
  return;
};//parseExternal()


RDFParser.prototype.traverse = function(element, oContext)
{
    var bRet = false;
    var bRecurse = true;
    var bSkip = false;

    var bCreateBNode = false;

    var incompleteTriples = [ ];
    var uriMappings = oContext.uriMappings;
    var language = oContext.language;
    var graph = oContext.graph;

    var sThisSubject = "";
    var sThisObject = null;
    var oUser = element;
    var sPred, arrPred;
		var i;

   /*
    * First add any URI mappings.
    *
    * Note that we do this outside of our test for an ELEMENT because in IE
    * namespaces get moved off the HTML element to the document object.
    */

    uriMappings.addFromElement(element);

    if (element.nodeType == 1 /* ELEMENT */)
    {

      var elementname = element.nodeName.toLowerCase();

      /*
       * Next set any language information.
       */

      language = element.getAttribute("lang") || language;

      /*
       * The first step is to set any subject and object information.
       */

      if (element.getAttribute("rel") !== null || element.getAttribute("rev") !== null)
      {
        if (element.getAttribute("about") !== null) {
					sThisSubject = safeCurieOrUri(oContext.base, element.getAttribute("about"), oContext.uriMappings);
				}
        else if (element.getAttribute("src") !== null)
        {
          sThisSubject = makeAbsoluteURI(oContext.base, element.getAttribute("src"));
        }
        else if ((elementname == "head") || (elementname == "body"))
        {
          sThisSubject = makeAbsoluteURI(oContext.base, "");
          bRet = true;
        }
        else if (element.getAttribute("typeof") !== null)
        {
          sThisSubject = curieToUri("_:" + element.nodeName.toLowerCase() + this.store.bnode_counter++, oContext.uriMappings);
        }
        else if (oContext.parentObject)
        {
          sThisSubject = oContext.parentObject;
        }

        if (element.getAttribute("resource") !== null) {
					sThisObject = safeCurieOrUri(oContext.base, element.getAttribute("resource"), oContext.uriMappings);
				}
        else if (element.getAttribute("href") !== null)
        {
          sThisObject = makeAbsoluteURI(oContext.base, element.getAttribute("href"));
        }
        else
        {
          bCreateBNode = true;
        }
      }
      else
      {
				if (element.getAttribute("about") !== null) {
					sThisSubject = safeCurieOrUri(oContext.base, element.getAttribute("about"), oContext.uriMappings);
					bRet = true;
				}
        else if (element.getAttribute("src") !== null)
        {
          sThisSubject = makeAbsoluteURI(oContext.base, element.getAttribute("src"));
          bRet = true;
        }
        else if (element.getAttribute("resource") !== null)
        {
					sThisSubject = safeCurieOrUri(oContext.base, element.getAttribute("resource"), oContext.uriMappings);
          bRet = true;
        }
        else if (element.getAttribute("href") !== null)
        {
          sThisSubject = makeAbsoluteURI(oContext.base, element.getAttribute("href"));
          bRet = true;
        }
        else if ((elementname == "head") || (elementname == "body"))
        {
          sThisSubject = makeAbsoluteURI(oContext.base, "");
          bRet = true;
        }
        else if (element.getAttribute("typeof") !== null)
        {
          sThisSubject = curieToUri("_:" + element.nodeName.toLowerCase() + this.store.bnode_counter++, oContext.uriMappings);
          bRet = true;
        }
        else if (oContext.parentObject)
        {
          if (!element.getAttribute("property")) {
            bSkip = true;
          }
          sThisSubject = oContext.parentObject;
        }
      }

      /*
       * And use @typeof.
       */

      if (element.getAttribute("typeof") !== null) {
        var sTypeOf = element.getAttribute("typeof");
        var arrTypeOf = sTypeOf.split(/[\s]/);

        for (i = 0; i < arrTypeOf.length; i++) {
	        graph.add(
	          sThisSubject,
	          curieToUri("_rdf:type", oContext.uriMappings),
	          curieToUri(arrTypeOf[i], oContext.uriMappings),
	          false,
	          oUser
	        );
        }//for (each type)
        bRet = true;
      }//if (there is a @typeof)

      if (bCreateBNode)
      {
        if (element.getAttribute("rel") !== null)
        {
          sPred = element.getAttribute('rel');
          arrPred = sPred.split(/[\s]/);

          for (i = 0; i < arrPred.length; i++)
          {
            incompleteTriples.push(
              {
                rel: true,
                predicate: curieToUri(arrPred[i], oContext.uriMappings),
                user: oUser
              }
            );
          }//for (each predicate)
        }//if (there is a @rel)

        /*
         * Next use @rev.
         */

        if (element.getAttribute("rev") !== null)
        {
          sPred = element.getAttribute('rev');
          arrPred = sPred.split(/[\s]/);

          for (i = 0; i < arrPred.length; i++)
          {
            incompleteTriples.push(
              {
                rel: false,
                predicate: curieToUri(arrPred[i], oContext.uriMappings),
                user: oUser
              }
            );
          }
        }//if (there is a @rev)
        sThisObject = curieToUri("_:" + element.nodeName.toLowerCase() + this.store.bnode_counter++, oContext.uriMappings);
      }//if ( there is no object )


      /*
       * Next the object literal with datatype.
       */

      if (element.getAttribute('property') !== null)
      {

        /*
         * If @datatype="" is set then we use it, even if the literal contains mark-up.
         *
         * This allows authors to prevent XML literals being created, by using
         */

        var sObjectLiteralDataType =
          (element.getAttribute("datatype") !== null)
            ? element.getAttribute("datatype")
            : (
              (element.getAttribute("content") || element.innerHTML.indexOf("<") == -1)
                ? ""
                : "_rdf:XMLLiteral"
            );

        if (sObjectLiteralDataType != "") {
          sObjectLiteralDataType = curieToUri(sObjectLiteralDataType, oContext.uriMappings);
        }

        var sObjectLiteral =
          element.getAttribute("content")
          ||
          (
            (sObjectLiteralDataType == "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral")
              ? element.innerHTML
              : (element.textContent || element.innerText)
          );

      /*
       * Now that we have all the subjects and objects, we can generate some triples.
       * First use the property attribute.
       */

        graph.add(
          sThisSubject,
          curieToUri(element.getAttribute('property'), oContext.uriMappings),
          {
            content: sObjectLiteral,
            datatype: sObjectLiteralDataType
          },
          true,
          oUser
        );
        bRet = true;

        /*
         * We stop recursing if we're processing an XML literal.
         */

        if (sObjectLiteralDataType == "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral") {
          bRecurse = false;
        }
      }//if (there is a property attribute)

      /*
       * Next use @rel.
       */

      if (sThisObject && !bCreateBNode)
      {
        if (element.getAttribute("rel") !== null)
        {
          sPred = element.getAttribute('rel');
          arrPred = sPred.split(/[\s]/);

          for (i = 0; i < arrPred.length; i++)
          {
            graph.add(
              sThisSubject,
              curieToUri(arrPred[i], oContext.uriMappings),
              sThisObject,
              false,
              oUser
            );
            bRet = true;
          }//for (each predicate)
        }//if (there is a @rel)


        /*
         * Next use @rev.
         */

        if (element.getAttribute("rev") !== null)
        {
          sPred = element.getAttribute('rev');
          arrPred = sPred.split(/[\s]/);

          for (i = 0; i < arrPred.length; i++)
          {
            graph.add(
              sThisObject,
              curieToUri(arrPred[i], oContext.uriMappings),
              sThisSubject,
              false,
              oUser
            );
            bRet = true;
          }
        }//if (there is a @rev)
      }//if ( the is an object )
    }//if ( the node is an element )

    if (bRecurse)
    {
      var children = element.childNodes;
      var bWorthCompletingTriples = false;

      for (i = 0; i < children.length; i++) {
          bWorthCompletingTriples = this.traverse(
            children[i],
            bSkip ?
                {
                  base: oContext.base,
                  graph: graph,
                  parentSubject: oContext.parentSubject,
                  parentObject: oContext.parentObject,
                  uriMappings: uriMappings,
                  incompleteTriples: oContext.incompleteTriples,
                  language: language
                }
              :
                {
                  base: oContext.base,
                  graph: graph,
                  parentSubject: sThisSubject || oContext.parentSubject,
                  parentObject: sThisObject || sThisSubject || oContext.parentSubject,
                  uriMappings: uriMappings,
                  incompleteTriples: incompleteTriples,
                  language: language
                }
          )
          || bWorthCompletingTriples;
      }
      bRet = bRet || bWorthCompletingTriples;
    }//if ( recurse )

    if (!bSkip && sThisSubject /*((sThisSubject && !bCreateBNode) || bRet)*/)
    {

      /*
       * ...complete any incomplete triples...
       */

      if (oContext.incompleteTriples.length)
      {
        for (i = 0; i < oContext.incompleteTriples.length; i++)
        {
          graph.add(
            (oContext.incompleteTriples[i].rel) ? oContext.parentSubject : sThisSubject,
            oContext.incompleteTriples[i].predicate,
            (oContext.incompleteTriples[i].rel) ? sThisSubject : oContext.parentSubject,
            false,
            oContext.incompleteTriples[i].user
          );
        }
        bRet = true;
      }
    }

    return bRet;
};//traverse
/*
 * Ubiquity provides a standards-based suite of browser enhancements for
 * building a new generation of internet-related applications.
 * Copyright (C) 2007-8 Mark Birbeck
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Mark Birbeck can be contacted at:
 *
 *  36 Tritton Road
 *  London
 *  SE21 8DE
 *  United Kingdom
 *
 *  mark.birbeck@gmail.com
 */
/*
 * Ubiquity provides a standards-based suite of browser enhancements for
 * building a new generation of internet-related applications.
 *
 * Copyright (C) 2007-8 Mark Birbeck
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Mark Birbeck can be contacted at:
 *
 *  36 Tritton Road
 *  London
 *  SE21 8DE
 *  United Kingdom
 *
 *  mark.birbeck@gmail.com
 */

/*
 * This triple store is very basic, and simply holds a list of triples. All resources are
 * placed in a list, and an index is used in the triple list.
 */

function RDFGraph() {
    this.resources = [ ];
    this.triples = [ ];
    this.somenum = 0;

    /*
     * Find the index for a resource.
     */

    this.resources.find = function(sURI)
    {
        for (var i = 0, len = this.length; i < len; i++)
        {
            if (this[i].resource == sURI) {
                return i;
            }
        }
        return -1;
    };//find


    /*
     * Add a resource to our list of resources, returning an index.
     * For each resource we keep a list of triples that make use
     * of it.
     */

    this.resources.add = function(sURI)
    {
        return this.push(
            {
                resource: sURI,
                triples: [ ]
            }
        );
    };//add

    this.resources.len = function() {
        return this.length;
    };
}//RDFStore()


/*
 * To empty a store, reset the list of triples and resources.
 */

RDFGraph.prototype.clear = function()
{
    this.triples.length = 0;
    this.resources.length = 0;
};


/*
 * Add a triple to the store.
 */

RDFGraph.prototype.add = function(sSubject, sPredicate, sObject, bObjectIsLiteral, oUser)
{
    var bRet = true;

    /*
     * We don't deal with resources directly, but use indexes. So the first
     * step is to work out the index, or create a new entry if one is needed.
     */

    var iURI = this.resources.find(sSubject);

    if (iURI == -1) {
        iURI = this.resources.add(sSubject) - 1;
    }

    /*
     * Next create a 'triple' using the ID of the element in the document,
     * and the three components of the triple itself.
     */

    if (!bObjectIsLiteral)
    {
      if (sPredicate == "a") {
        sPredicate = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
      }
      else if (sPredicate === "stylesheet") {
        sPredicate = "http://www.w3.org/1999/xhtml/vocab#stylesheet";
      }
    }

    var t = {
        subject: iURI,
        predicate: sPredicate,
        object: sObject,
        object_literal_p: bObjectIsLiteral,
        user: oUser
    };


    /*
     * Save the triple into the master list of triples...
     */

    var iTriple = this.triples.push(t) - 1;

    /*
     * ... and then create an entry in the triple list for the
     * subject resource.
     */

    this.resources[iURI].triples.push( iTriple );

    /*
     * Notify any listeners.
     */

    this.tripleAdded( t );

    return bRet;
};//RDFStore.add()

RDFGraph.prototype.tripleAdded = function(triple) {
    return;
};

RDFGraph.prototype.createBindings = function(triple, pattern)
{
  var oRet = {
    bindings:
      [
        { uri: this.resources[ triple.subject ].resource },
        { uri: triple.predicate },
        (triple.object_literal_p) ? { literal: triple.object } : { uri: triple.object },

        /*
         * If the context flag is set, then set the context to be the context of the
         * current triple.
         */

        (pattern.setUserData) ? { name: "user", uri: triple.user } : { }
      ]
  };

  /*
   * If any of the pattern components are variable names then add the
   * name to the binding information.
   */

  if (pattern.pattern[0].charAt(0) == "?") {
    oRet.bindings[0].name = pattern.pattern[0].substring(1);
  }

  if (pattern.pattern[1].charAt(0) == "?") {
    oRet.bindings[1].name = pattern.pattern[1].substring(1);
  }

  if (pattern.pattern[2].charAt(0) == "?") {
    oRet.bindings[2].name = pattern.pattern[2].substring(1);
  }

  return oRet;
};


RDFGraph.prototype.serialiseResult = function(triple, pattern)
{
  var oRet = {
    bindings:
      [
        { uri: this.resources[ triple.subject ].resource },
        { uri: triple.predicate },
        { },
        { }
      ]
  };

  if (pattern.subject.charAt(0) == "?") {
    oRet.bindings[0].name = pattern.subject.substring(1);
  }

  if (pattern.predicate.charAt(0) == "?") {
    oRet.bindings[1].name = pattern.predicate.substring(1);
  }

  if (!triple.object_literal_p)
  {
    oRet.bindings[2].uri = triple.object;
    if (pattern.objectUri.charAt(0) == "?") {
      oRet.bindings[2].name = pattern.objectUri.substring(1);
    }
  }
  else
  {
    oRet.bindings[2].literal = triple.object;
    if (pattern.objectLiteral.charAt(0) == "?") {
      oRet.bindings[2].name = pattern.objectLiteral.substring(1);
    }
  }

  /*
   * If the context flag is set, then use the context of the current triple.
   */

  if (pattern.setContext)
  {
    oRet.bindings[3].uri = triple.user;
    oRet.bindings[3].name = "context";
  }
  return oRet;
};


RDFGraph.prototype.loadFormatters = function(oParser)
{
    var bRet = true;
    var obj;
    var resources = this.resources;
    var triples = this.triples;

    for (var i = 0, len = this.resources.length; i < len; i++)
    {
        var s = resources[i];

        for (var j = 0; j < s.triples.length; j++)
        {
            var t = triples[ s.triples[j] ];

            /*
             * An included document is just dropped straight in.
             */

            if (t.predicate === "http://argot-hub.googlecode.com/include" || t.predicate === "http://www.w3.org/2002/07/owl#imports") {
              oParser.parseExternal(t.object);
            }//if ( there is an 'included' document )
        }//for (each triple)
    }//for (each subject)
    return bRet;
};//loadFormatters()


RDFGraph.prototype.createObject = function(s)
{
    var oRet = new myList();
    var triples = this.triples;

    for (var i = 0; i < s.triples.length; i++)
    {
        var t = triples[ s.triples[i] ];

        if (t.object_literal_p) {
          oRet.add(t.predicate, t.object.content);
        } else {
          oRet.add(t.predicate, t.object);
        }
    }//for (each triple about this resource)
    return oRet;
};//createObject()

/**
 * An RDF triple store, holding a list of graphs.
 *
 * @class RDFStore
 * @constructor
 */

function RDFStore() {
	this.graphs = [ ];
	this.bnode_counter = 0;
}//RDFStore()


/*
 * To empty a store, clear all of the graphs.
 */

RDFStore.prototype.clear = function() {
	var name;

	for (name in this.graphs) {
		this.graphs[ name ].clear();
		delete this.graphs[ name ];
	}
	this.graphs.length = 0;
	return;
};//clear


RDFStore.prototype.getGraph = function( graphURI ) {
	graphURI = graphURI || "default";

	if ( !this.graphs[ graphURI ] ) {
		this.graphs[ graphURI ] = new RDFGraph( graphURI );
	}
	return this.graphs[ graphURI ];
};//getGraph


/*
 * Add a triple to the store.
 */

RDFStore.prototype.add = function(graphURI, sSubject, sPredicate, sObject, bObjectIsLiteral, oUser) {
	var t = this.getGraph( graphURI ).add(sSubject, sPredicate, sObject, bObjectIsLiteral, oUser);

	this.tripleAdded( t );
	return t;
};//RDFStore.add()

RDFStore.prototype.tripleAdded = function(triple) {
    return;
};

RDFStore.prototype.insert = function(graph) {
  var graphName, i, isResource, k, triple, subgraph, subj, obj;


  while (!graph.length) {
    if (graph.graph) {
      graph = graph.graph;
    } else {
      graph = [ graph ];
    }
  }

  for (i = 0; i < graph.length; i++) {
    subgraph = graph[i];
    graphName = subgraph.name || "";


    if (subgraph.pattern) {
      triple = graph[i].pattern;

      this.add(
        graphName,
        triple[0],
        triple[1],
        triple[2],
        triple[3],
        null
      );
    }


    else {

      subj = subgraph["$"] || ("bnode:dummy" + this.bnode_counter++);
			if ((typeof(subj) === "string") && (subj.indexOf('<') === 0) && (subj.lastIndexOf('>') === subj.length - 1)) {
				subj = subj.substring(1, subj.length - 1);
			}


      for (k in subgraph) {
        if (k !== "$") {
          obj = subgraph[k];

					if ((typeof(obj) === "string") && (obj.indexOf('<') === 0) && (obj.lastIndexOf('>') === obj.length - 1)) {
						isResource = true;
						obj = obj.substring(1, obj.length - 1);
					} else {
	          isResource = (typeof(obj) === "object" && !obj.exec)
	            || (k === "http://xmlns.com/foaf/0.1/accountServiceHomepage") || (k === "http://argot-hub.googlecode.com/tooltip") || (k === "http://argot-hub.googlecode.com/icon");
	        }


          this.add(
            graphName,
            subj,
            k,
            (isResource)
              ? (
                (typeof obj == "object")
                  ? this.insert(obj, graphName)
                  : obj
              )
              : { content: obj },
            !isResource,
            null
          );
        }//if this is not the subject property
      }//for each predicate
    }//if this is a pattern...else...
  }//for each graph

  return subj;
};//insert


RDFStore.prototype.createBindings = function(graphURI, triple, pattern) {
	return this.getGraph( graphURI ).createBindings(triple, pattern);
};


RDFStore.prototype.serialiseResult = function(graphURI, triple, pattern) {
	return this.getGraph( graphURI ).serialiseResult(triple, pattern);
};


RDFStore.prototype.loadFormatters = function(graphURI, parser) {
	return this.getGraph( graphURI ).loadFormatters( parser );
};//loadFormatters()


RDFStore.prototype.createObject = function(graphURI, s) {
	return this.getGraph( graphURI ).createObject( s );
};//createObject()

function RDFQuery(store) {
    this.store = store;
}//RDFQuery()


RDFQuery.prototype.ask = function(q) {
	var r = this.query2( q );

  return {
    head: { },
    "boolean": Boolean(r.results.bindings.length)
  };
};//ask

RDFQuery.prototype.processObject = function(oAction, obj) {
  var context = obj.user;

  if (context)
  {
    var icon = null;

    if (oAction.icon)
    {
      icon = context.document.createElement('img');

      icon.setAttribute("src", oAction.icon);
      context.appendChild(icon);
    }//if ( there is an icon for this action definition )

    if (oAction.style)
    {
      context.style["border"] = oAction.style.content;
    }//if ( there is a style for this action definition )

    if (obj.icon)
    {
      icon = context.document.createElement('img');

      icon.setAttribute("src", obj.icon);
      context.appendChild(icon);
    }//if ( there is an icon for this object definition )

    if (oAction.tooltip)
    {
      if (icon)
      {
        var x = new YAHOO.widget.Tooltip(
          "anon" + this.somenum++,
          {
            context: icon,
            text: eval(
              "'" +
              oAction.tooltip.content.replace(/\"/g, "\'").replace(/\r/g, "").replace(/\$[\{\%7B]([^\}\%7D]*)[\}\%7D]/g, "' + obj.$1 + '") +
              "'"
            )
          }
        );
      }
      else
      {
        var el = context.document.createElement('span');

        el.innerHTML = eval("'" + oAction.tooltip.content.replace(/\n/g, "").replace(/\$[\{\%7B]([^\}\%7D]*)[\}\%7D]/g, "' + obj.$1 + '") + "'");
        context.appendChild(el);
      }
    }//if ( there is a tooltip definition in the action )

    if (obj.tooltip && icon)
    {
      new YAHOO.widget.Tooltip(
        "anon" + this.somenum++,
        {
          context: icon,
          text: eval("'" + obj.tooltip.content.replace(/\n/g, "").replace(/\$[\{\%7B]([^\}\%7D]*)[\}\%7D]/g, "' + obj.$1 + '") + "'")
        }
      );
    }//if ( there is a tooltip definition from the triple store )
  }//if ( a context has been set )

  if (oAction.action)
  {
    oAction.action( obj );
  }//if ( there is an action )

  if (obj.imp)
  {
    var oParser = new RDFParser(this.store);

    oParser.parseExternal(obj.imp, oAction.onexternal);
  }//if ( there is an import instruction )

  return;
};//processObject()

RDFQuery.prototype.walk2 = function(sparql, oAction) {
    var bindings = sparql.results.bindings;

    for (var i = 0, len = bindings.length; i < len; i++)
    {
      var obj = bindings[i];

      this.processObject(oAction, obj);
    }//for (each object)

    return;
};//walk2()


RDFQuery.prototype.rawQuery = function(graphURI, q, callback) {
  var oRet =
    {
      head:
        {
          vars: [ ]
        },
      results:
        {
          ordered: false,
          distinct: (typeof q.distinct === "undefined") ? true : Boolean(q.distinct),
          bindings: [ ]
        }
    };

  var graphList = [ ];
  var results = [ ];
  var bindings, vars;
  var i, j, k, duplicate;
  var uuid = 0;

  this.addGraphs(graphURI, q.where, results, graphList);

  if (graphList.length)
    this.mergeGraphs(results, graphList);

  /*
   * Find all of the good matches, which simply means any match that hasn't failed.
   */

  for (i = 0; i < results.length; i++)
  {
    var temp = results[i];
    var result = { };

    /*
     * If we have a good match...
     */

    if (!temp.failed)
    {

      /*
       * ... copy all of requested properties.
       *
       * [TODO] A variable of '*' means copy everything.
       */

      if (q.select && (q.select[0] != "*"))
      {
        for (var j = 0; j < q.select.length; j++)
        {
          var variable = q.select[j];

          oRet.head.vars[j] = variable;
          result[variable] = temp.values[variable];
        }
      }
      else
      {
        for (j = 0; j < temp.values.length; j++)
        {
          throw "Not sure about whether this correctly gets the name of property or key. (This will have been set with a 'select * where ...')";

          var variable = temp.values[j].name;

          oRet.head.vars[j] = variable;
          result[variable] = temp.values[variable];
        }
      }
      result["uuid"] = uuid++;
      result.user = temp.values["user"];
      oRet.results.bindings.push( result );
    }//if ( the item passed all of the where clauses )
  }//for ( each result )

	if (oRet.results.bindings.length && oRet.results.distinct) {
		bindings = oRet.results.bindings;
		vars = oRet.head.vars;

		for (i = 0; i < bindings.length; i++) {
			bindings[i]["uuid"] = i;
			for (j = i + 1; j < bindings.length; j++) {
				duplicate = true;
				for (k = 0; k < vars.length; k++) {
					varname = vars[k];
					if (bindings[i][varname] !== bindings[j][varname]) {
						duplicate = false;
						break;
					}
				}
				if (duplicate) {
					bindings.splice(j--, 1);
				}
			}
		}
	}

  if (typeof(callback) === "function") {
    callback.call(null, oRet);
  }

  return oRet;
};//rawQuery()


RDFQuery.prototype.query2 = function(q, callback) {
	var oRet;
  var graphProcessor;
	var graphURI = q.from ? q.from : "default";
  var that = this;

	if (graphURI === "default" || graphURI === "about-graphs") {
		oRet = this.rawQuery(graphURI, q, callback);
	} else {

		/*
		 * See if there is any information about how to handle this graph.
		 */

	  graphProcessor = document.meta.query2({
	    select: [ "uri", "matches", "params", "adddata" ],
	    from: "about-graphs",
	    where:
	      [
	        { pattern: [ "?s", "http://argot-hub.googlecode.com/uri", "?uri" ] },
	        {
	        	pattern: [ "?s", "http://argot-hub.googlecode.com/matches", "?matches" ],
	        	filter: function(o) { return o["matches"].content.exec( graphURI ); }
	        },
	        { pattern: [ "?s", "http://argot-hub.googlecode.com/params", "?params" ], optional: true },
	        { pattern: [ "?s", "http://argot-hub.googlecode.com/adddata", "?adddata" ] }
	      ]
	  });

		if ( !graphProcessor.results.bindings.length ) {
			oRet = this.rawQuery(graphURI, q, callback);
		} else {
   		var uri = graphProcessor.results.bindings[0].uri.content.replace(/%s/, graphURI.match(graphProcessor.results.bindings[0].matches.content)[1]);
	    var requestId = document.submissionJSON.run(
	      uri,
	      {
          callbackParamName: "callback",
          count: "2"
        },
	      null,
	      function(data, userData)
	      {
	        if (graphProcessor.results.bindings[0].adddata) {
	        	execFuncWithObj(graphProcessor.results.bindings[0].adddata.content, { data: data, obj: userData}, "adddata");
	        }
	        if (graphProcessor.results.bindings[0].afterpipesdata) {
	          processFresnelSelectors(graphProcessor.results.bindings[0].afterpipesdata, userData);
	        }
					oRet = that.rawQuery(graphURI, q, callback);
	        return;
	      }//callback from Pipes
	    );
		}
	}

  return oRet;
};//query2()

RDFQuery.prototype.getSingleValue = function(where) {
	var r = document.meta.query2({
		select: [ "result" ],
		where: where
	});

	return (r && r.results.bindings[0] && r.results.bindings[0]["result"])
		? r.results.bindings[0]["result"].content
		: null;
};//getSingleValue()


RDFQuery.prototype.addGraphs = function(graphURI, where, results, graphList) {

  /*
   * First collect a set of graphs based on the where clauses. A triple matches if all of its components
   * match the query triple, or the query triple has a variable in the position of a component that does
   * not match.
   */

  var resources = this.store.getGraph( graphURI ).resources;
  var triples = this.store.getGraph( graphURI ).triples;

  for (var i = 0; i < where.length; i++)
  {
    var pattern = where[i];

    if (pattern.where)
    {

      /*
       * First, complete the previous graph.
       */

      if (graphList.length)
        this.mergeGraphs(results, graphList);

      var subgraphList = [ ];
      var subresults = [ ];

      this.addGraphs(graphURI, pattern.where, subresults, subgraphList);
      if (subgraphList.length)
      {
        this.mergeGraphs(subresults, subgraphList);
      }
    }
    else if (pattern.pattern)
    {
			if (typeof(pattern.pattern) === "string") {
				var arPattern = pattern.pattern.split("<");

				if ((typeof(arPattern[0]) === "string") && (arPattern[0].indexOf('<') === 0) && (arPattern[0].lastIndexOf('>') === arPattern[0].length - 1)) {
					arPattern[0] = arPattern[0].substring(1, arPattern[0].length - 1);
				}
				if ((typeof(arPattern[1]) === "string") && (arPattern[1].indexOf('<') === 0) && (arPattern[1].lastIndexOf('>') === arPattern[1].length - 1)) {
					arPattern[1] = arPattern[1].substring(1, arPattern[1].length - 1);
				}
				if ((typeof(arPattern[2]) === "string") && (arPattern[2].indexOf('<') === 0) && (arPattern[2].lastIndexOf('>') === arPattern[2].length - 1)) {
					arPattern[2] = arPattern[2].substring(1, arPattern[2].length - 1);
				}
				if ((typeof(arPattern[2]) === "string") && (arPattern[2].indexOf('"') === 0) && (arPattern[2].lastIndexOf('"') === arPattern[2].length - 1)) {
					arPattern[2] = arPattern[2].substring(1, arPattern[2].length - 1);
				}
				pattern.pattern = arPattern;
			}


      /*
       * Map a predicate of "a" to rdf:type.
       */

      if (pattern.pattern[1] == "a")
        pattern.pattern[1] = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";

      var graph =
        {
        	graphURI: graphURI,
          pattern: pattern,
          triples: [ ]
        };

      for (var j = 0, len = resources.length; j < len; j++)
      {
          var s = resources[j];

          if (pattern.pattern[0].charAt(0) == "?" || pattern.pattern[0].charAt(0) == "$" || (pattern.pattern[0] == s.resource))
          {
            for (var k = 0; k < s.triples.length; k++)
            {
                var t = triples[ s.triples[k] ];

                if (
                  (pattern.pattern[1].charAt(0) == "?" || pattern.pattern[1].charAt(0) == "$" || (pattern.pattern[1] == t.predicate))
                  &&
                  (pattern.pattern[2].charAt(0) == "?" || pattern.pattern[2].charAt(0) == "$" || ((pattern.pattern[2] == t.object) && !t.object_literal_p) || ((pattern.pattern[2] == t.object.content) && t.object_literal_p))
                )
                  graph.triples.push( t );
            }//for ( each triple tied to this resource )
          }//if ( the subjects match )
      }//for ( each resource )

      /*
       * Save the graph before moving on to the next where clause.
       */

      graphList.push( graph );
    }//if ( we have a basic pattern )
  }//for ( each pattern )

  return;
};//addGraphs


/*
 * Take a list of graphs and add them to a result-set.
 */

RDFQuery.prototype.mergeGraphs = function(results, graphList) {
  for (var i = 0; i < graphList.length; i++)
  {
    var graph = graphList[i];

    for (var j = 0; j < graph.triples.length; j++)
    {
      /*
       * For each triple create an object that contains the values plus any variable names.
       */

      var t = this.store.createBindings(graph.graphURI, graph.triples[j], graph.pattern);

      /*
       * Next go through each of the values, and if it has a variable name, copy it into
       * a temporary object.
       */

      var temp = [ ];

      for (var k = 0; k < 4; k++)
      {
        /*
         * If there is a named value, then use it as a property.
         */

        temp[k] = (t.bindings[k].name)
          ? { name: t.bindings[k].name, value: t.bindings[k].uri || t.bindings[k].literal }
          : null;
      }

      /*
       * Now we need to see if we already have an object in our results list to merge with.
       *
       * Note that first time through we always push onto the stack, since the first result
       * 'always matches'.
       */

      if (!i /*results.length*/)
      {
        var result = { matches: true, failed: false, values: [ ] };

        for (k = 0; k < 4; k++)
        {
          if (temp[k])
            result.values[temp[k].name] = temp[k].value;
        }
        results.push( result );
      }
      else
      {
        /*
         * If this is not the first time through, we need to see if there are any objects already
         * in the list of results that 'match' our object, and if so, merge the values.
         */

        for (k = 0; k < results.length; k++)
        {

          /*
           * Get the next object, and if it has previously been ruled out by failing a match then
           * we don't need to process it.
           */

          var toMerge = results[k];
          if (toMerge.failed)
            continue;


          /*
           * We're now looking to take any properties that are on the object to merge, and add them to any object
           * we already have that partially matches. The only reason not to do a merge is if there is a variable
           * that occurs in both objects but the value doesn't match.
           *
           * Note that if the two objects have nothing that matches then the match flag will be set to false. This
           * means that if the current search pattern is not optional, then the existing object will be marked as
           * failing to match, and be ignored.
           */

          var merge = true;

          for (var m = 0; m < 4; m++)
          {
            if (temp[m] && toMerge.values[temp[m].name] && (temp[m].value != toMerge.values[temp[m].name]))
            {
              merge = false;
              break;
            }
          }

          if (merge)
          {
            for (m = 0; m < 4; m++)
            {
              if (temp[m])
                toMerge.values[temp[m].name] = temp[m].value;
            }
            toMerge.matches = true;
          }
        }//for ( each item already found )
      }//if ( this is the first time through )
    }//for ( each graph in the results set )


    /*
     * Now we have to go back through the list of candidate objects and see if any of them failed to get a match. If they
     * did then we can mark them as having failed, and they won't feature in any further operations. Note that if the current
     * pattern is optional, then it always counts as a match.
     */

    for (k = 0; k < results.length; k++)
    {
      var temp = results[k];

      if (!(temp.matches || graph.pattern.optional) || (typeof(graph.pattern.filter) === "function" && !graph.pattern.filter.call(null, temp.values))) {
        temp.failed = true;
      } else {
        temp.matches = false;
      }
    }
  }//for ( each graph )


  /*
   * Now clear the graph-list.
   */

  graphList.length = 0;

  return;
};//mergeGraphs


function getPropertyFromVar(obj, m, errors) {
	var sRet;
	var propArr = m.match(/\$(?:\{|%7B)(.*?)(?:\}|%7D)/);

	if ( propArr ) {
		sRet = (obj[ propArr[1] ])
			? ((obj[ propArr[1] ].content) ? obj[ propArr[1] ].content : obj[ propArr[1] ])
			: ((errors) ? "No value for '" + propArr[1] + "' (" + m + ")" : "");
	} else {
		sRet = (errors) ? "No key in '" + m + "'" : "";
	}
	return sRet;
}

function execFuncWithObj(f, context, name) {
	var expanded;

	try {
		if (typeof f === "string") {
			expanded = f.replace(
				/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g,
				function (m) { return getPropertyFromVar(context.obj, m); }
			);
		  eval( expanded );
		 } else {
		 	f.call(null, context);
		 }
	} catch(e) {
		throw "Failed to execute '" + name + "' (" + (e.message ? e.message : e.description) + ")";
	}
	return;
}
function processFresnelSelectors(subj, obj) {
	/*
	 * First find any Fresnel class styles.
	 */

	var s = "?format";
	var g = (subj) ? subj : "?group";
	var q;

	var classstyles = document.meta.query2({
		select: [ "t", "cl", "action", "notify", "yowl", "icon", "tooltip", "pipesdata", "adddata", "afterpipesdata" ],
		where:
			[
				{ pattern: [ s,					"a",																									 "http://www.w3.org/2004/09/fresnel#Format" ] },
				{ pattern: [ s,					"http://www.w3.org/2004/09/fresnel#group",						 g ] },
				{ pattern: [ g,					"a",																									 "http://www.w3.org/2004/09/fresnel#Group" ] },
				{ pattern: [ s,					"http://www.w3.org/2004/09/fresnel#classFormatDomain", "?t" ] },
				{ pattern: [ s,					"http://www.w3.org/2004/09/fresnel#resourceStyle",		 "?cl" ],			 optional: true },
				{ pattern: [ s,					"http://argot-hub.googlecode.com/action",									"?action" ],	optional: true },
				{ pattern: [ s,					"http://argot-hub.googlecode.com/yowl",										"?yowl" ],		optional: true },
				{ pattern: [ s,					"http://argot-hub.googlecode.com/notify",									"?notify" ],		optional: true },
				{
					where:
						[
							{ pattern: [ s,			"http://argot-hub.googlecode.com/tooltip",					"?tt" ] },
							{ pattern: [ "?tt",			"http://argot-hub.googlecode.com/icon",							"?icon" ], optional: true },
							{ pattern: [ "?tt",			"http://argot-hub.googlecode.com/template",					"?tooltip" ] }
						],
					optional: true
				},
				{
					where:
						[
							{ pattern: [ s, "http://argot-hub.googlecode.com/pipesdata",				"?pipesdata" ] },
							{ pattern: [ s, "http://argot-hub.googlecode.com/adddata",					"?adddata" ] },
							{ pattern: [ s, "http://argot-hub.googlecode.com/afterpipesdata",		"?afterpipesdata" ], optional: true }
						],
					optional: true
				}
			]
	});

	/*
	 * Now find all elements that have the types indicated, and set the corresponding CSS class.
	 */

	document.meta.walk2(
		classstyles,
		{
			action: function(classobj)
			{
				var instances = document.meta.query2(
					{
						select: [ "s" ],
						where:
							[
								{ pattern: [ "?s", "a", classobj.t ], setUserData: true }
							]
					}
				);

				document.meta.walk2(
					instances,
					{
						action: function(instobj)
							{
								processFresnelFormats(instobj.user, classobj);
								processLibXhFormats(instobj, classobj);
							}
					}
				);
			}
		}
	);

	/*
	 * Now do the same for properties.
	 */

	classstyles = document.meta.query2({
		select: [ "p", "cl" ],
		where:
			[
				{ pattern: [ s, "a",																											"http://www.w3.org/2004/09/fresnel#Format" ] },
				{ pattern: [ s, "http://www.w3.org/2004/09/fresnel#propertyFormatDomain", "?p" ] },
				{ pattern: [ s, "http://www.w3.org/2004/09/fresnel#resourceStyle",				"?cl" ] }
			]
	});

	/*
	 * Now find all elements that have the predicates indicated, and set the corresponding CSS class.
	 */

	document.meta.walk2(
		classstyles,
		{
			action: function(classobj)
			{
				var results = document.meta.query2(
					{
						select: [ "o" ],
						where:
							[
								{ pattern: [ "?s", classobj.p, "?o" ], setUserData: true }
							]
					}
				);

				document.meta.walk2(
					results,
					{
						action: function(instobj)
						{
							processFresnelFormats(instobj.user, classobj);
						}
					}
				);
			}
		}
	);


	/*
	 * Now do the same for any SPARQL queries.
	 */

	classstyles = document.meta.query2({
		select: [ "q", "cl", "action", "notify", "yowl", "embedInit", "embedTemplate", "embedTitle", "icon", "tooltip", "pipesdata", "adddata", "afterpipesdata" ],
		where:
			[
				{ pattern: [ s, "a",																											"http://www.w3.org/2004/09/fresnel#Format" ] },
				{ pattern: [ s, "http://www.w3.org/2004/09/fresnel#group",								g ] },
				{ pattern: [ g, "a",																											"http://www.w3.org/2004/09/fresnel#Group" ] },
				{ pattern: [ s, "http://www.w3.org/2004/09/fresnel#instanceFormatDomain", "?q" ] },
				{ pattern: [ s, "http://www.w3.org/2004/09/fresnel#resourceStyle",				"?cl" ],			optional: true },
				{ pattern: [ s, "http://argot-hub.googlecode.com/action",										 "?action" ],	 optional: true },
				{ pattern: [ s, "http://argot-hub.googlecode.com/yowl",											 "?yowl" ],		 optional: true },
				{ pattern: [ s, "http://argot-hub.googlecode.com/notify",										 "?notify" ],	 optional: true },
				{
					where:
						[
							{ pattern: [ s, "http://argot-hub.googlecode.com/tooltip",						 "?tt" ] },
							{ pattern: [ "?tt",			"http://argot-hub.googlecode.com/icon",								 "?icon" ], optional: true },
							{ pattern: [ "?tt",			"http://argot-hub.googlecode.com/template",						 "?tooltip" ] }
						],
					optional: true
				},
				{
					where:
						[
							{ pattern: [ s,				 "http://argot-hub.googlecode.com/embed",		 "?embed" ] },
							{ pattern: [ "?embed", "http://argot-hub.googlecode.com/template", "?embedTemplate" ] },
							{ pattern: [ "?embed", "http://argot-hub.googlecode.com/init",		 "?embedInit" ], optional: true }
						],
					optional: true
				},
				{
					where:
						[
							{ pattern: [ s, "http://argot-hub.googlecode.com/pipesdata",					 "?pipesdata" ] },
							{ pattern: [ s, "http://argot-hub.googlecode.com/adddata",						 "?adddata" ] },
							{ pattern: [ s, "http://argot-hub.googlecode.com/afterpipesdata",			 "?afterpipesdata" ], optional: true }
						],
					optional: true
				}
			]
	});

	/*
	 * Now run each of the queries returned.
	 */

	document.meta.walk2(
		classstyles,
		{
			action: function(classobj)
			{
				var r;

				if (typeof classobj.q.content === "string") {
					try {
						q = classobj.q.content.replace(
							/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g,
							function (m) { return getPropertyFromVar(obj, m); }
						);
					} catch(e) {
					}

					r = document.meta.query2( eval( "({" + q + "})" ) );
				} else {
					r = document.meta.query2( classobj.q.content );
				}

				document.meta.walk2(
					r,
					{
						action: function(instobj)
						{
							processFresnelFormats(instobj.user, classobj);
							processLibXhFormats(instobj, classobj);
						}
					}
				);
			}
		}
	);
	return;
}//processFresnelSelectors

function processFresnelFormats(user, format) {
	if (format.cl)
	{
		YAHOO.util.Dom.addClass(user, format.cl.content);
	}
	return;
}//processFresnelFormats

function processLibXhFormats(obj, format) {
	var context = obj.user;

	/*
	 * Prioritise getting external data, just in case we need it.
	 */

	if (format.pipesdata)
	{
		var pThis = this;
		eval(
			"var rq = {" +
				format.pipesdata.content.replace(
					/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g,
					function (m) { return getPropertyFromVar(obj, m); }
				) +
			"};"
		);

		var requestId = document.submissionJSON.run(
			rq.url,
			rq.params,
			obj,
			function(data, userData)
			{
				if (format.adddata) {
					execFuncWithObj(format.adddata.content, { data: data, obj: userData}, "adddata");

				}
				if (format.afterpipesdata) {
					processFresnelSelectors(format.afterpipesdata, userData);
				}
				return;
			}//callback from Pipes
		);
	}//if ( we need to retrieve more data )


	if (context)
	{
		var icon = null;

		if (format.icon)
		{
			icon = context.ownerDocument.createElement('img');

			icon.setAttribute("src", format.icon);
			context.appendChild(icon);
		}//if ( there is an icon for this action definition )

		if (format.tooltip) {
			var t;
			try {
				eval(
					"t = '" +
					format.tooltip.content.replace((/\r/g), "").replace((/\'/g), "\\\'").replace(
						(/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g),
						"' + obj.$1 + '"
					) +
					"';"
				);
			} catch(e) {
				t = "error: " + e.description;
			}
			if (icon) {
				new YAHOO.widget.Tooltip(
					"anon" + this.somenum++,
					{
						context: icon,
						text: t
					}
				);
			} else {
				var el = context.ownerDocument.createElement('span');

				el.innerHTML = t;
				context.appendChild(el);
			}
		}//if ( there is a tooltip definition in the format )

		if (format.embedTemplate) {
			var t;
			var el = context.ownerDocument.createElement('span');

			try {
				t = format.embedTemplate.content.replace(
					/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g,
					function (m) { return getPropertyFromVar(obj, m, true); }
				);
			} catch(e) {
				t = "error: " + e.description;
			}
			el.innerHTML = t;

			context.parentNode.insertBefore(el, context.nextSibling);

			if (format.embedInit) {
				execFuncWithObj(format.embedInit.content, { data: context, obj: obj}, "embedInit");
			}
		}//if ( there is a template to embed )
	}//if ( there is a context )

	if (format.action) {
		if (typeof(format.action.content) === "string") {
			eval(
				format.action.content.replace(/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g, "obj.$1")
			);
		} else if (typeof(format.action.content) === "function") {
			format.action.content.call(null, obj);
		}
	}

	if (format.yowl) {
		eval(
			format.yowl.content.replace(/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g, "obj.$1")
		);
	}

	if (format.notify) {
		r = document.meta.query2({
			select: [ "name", "title", "summary" ],
			where:
				[
					{ pattern: [ format.notify, "http://argot-hub.googlecode.com/notifyName", "?name" ] },
					{ pattern: [ format.notify, "http://purl.org/dc/elements/1.1/title", "?title" ] },
					{ pattern: [ format.notify, "http://purl.org/dc/elements/1.1/summary", "?summary" ] }
				]
		});

		document.meta.walk2(
			r,
			{
				action: function(instobj)
				{
					document.Yowl.notify(
						instobj.name.content,
						instobj.title.content,
						instobj.summary.content.replace(
							/\$(?:\{|\%7B)(.*?)(?:\}|\%7D)/g,
							function (m) { return getPropertyFromVar(obj, m); }
						),
						"chem",
						null,
						true,
						0
					);
				}
			}
		);
	}
	return;
}//processLibXhFormats


function initialiseFresnelFormats(parser) {
	var loader = new YAHOO.util.YUILoader();
	var r = document.meta.query2(
		{
			select: [ "css" ],
			where:
				[
					{ pattern: [ "?s", "http://www.w3.org/1999/xhtml/vocab#stylesheet", "?css" ] }
				]
		}
	);//query for any stylesheets

	if (r && r.results.bindings[0] && r.results.bindings[0]["css"])
	{
		loader.addModule({ name: "fresnel-css-stylesheet", type: "css", fullpath: r.results.bindings[0]["css"] });
		if (window.external && window.external.document)
		{
			var d = window.external.document;
			var h = d.getElementsByTagName("head")[0];
			var l = d.createElement("link");

			l.setAttribute("rel", "stylesheet");
			l.setAttribute("href", r.results.bindings[0]["css"]);
			h.appendChild(l);
		}
	}
	loader.insert();

	r = document.meta.query2(
		{
			select: [ "init" ],
			where:
				[
					{ pattern: [ "?s" /* pThis.src */, "http://argot-hub.googlecode.com/constructor", "?init" ] }
				]
		}
	);//query for a constructor

	/*
	 * ...and for each one execute the script.
	 */

	document.meta.walk2(
		r,
		{
			action: function(obj)
			{
				try
				{
					(typeof obj.init.content === "function")
						? obj.init.content.call( null )
						: eval( false || obj.init.content );
				}
				catch(e)
				{
					alert("Constructor failed: " + e.description);
				}
			}//action()
		}
	);

	if (window.external && window.external.document)
		parser.parse(window.external.document, getBaseUrl(window.external.document), null);
	processFresnelSelectors();
	return;
};//initialiseFresnelFormats

/**
 * The RDFa Parsing Module provides utilities for parsing RDFa from a DOM
 * and placing the resulting triples into a queryable triple-store.
 *
 * @module RDFa
 * @title RDFa parsing module
 * @requires core
 */

/**
 * This is a made up class for now, to help YUI Doc.
 *
 * @class RDFa
 */

/*
 * Create a triple store to put all the triples into.
 */

if (!document.meta) {
	document.meta = new RDFQuery( new RDFStore() );
	document.Yowl.register(
		"RDFa Parser",
		[ "Parsing status" ],
		[ 0 ],
		null
	);
}

/**
 * Establish whether the document is running in a side-bar or the main browser window.
 *
 * @method getMainDoc
 */

var oDoc = getMainDoc();

function getMainDoc() {

	/*
	 * See if we're in a UBX side-bar
	 */

	if (window.external && window.external.document) {
		return window.external.document;
	} else if (window.parent) {
		return window.parent.document;
	}
	return window.document;
}

YAHOO.util.Event.onDOMReady(
function () {

	/*
	 * Create a parser, and give it access to the triple store.
	 */

	var oParser = new RDFParser(document.meta.store);


	/*
	 * If we're running as a bookmarklet, then load a default formatter.
	 */

	if (document.runContext === "bookmarklet") {
		document.meta.store.insert(
			[
				{
					"http://argot-hub.googlecode.com/formatter": "<http://ubiquity-rdfa.googlecode.com/svn/trunk/_samples/formats/debug>"
				}
			]
		);
	}

	/*
	 * Parse the document for triples. Note that we are parsing either 'this' document
	 * or an external document if we are in a sidebar, but the results always go to
	 * 'this' document.
	 */

	oParser.parse(oDoc, getBaseUrl(oDoc), null);

	var pThis = oParser;

	spawn(
		function()
		{
			if (document.meta.store.loadFormatters) {
				document.meta.store.loadFormatters("", oParser);
			}

			/*
			 * Register any formatters.
			 */

			var loader = new YAHOO.util.YUILoader();
			var r = document.meta.query2(
				{
					select: [ "formatter" ],
					where:
						[
							{ pattern: [ "?s", "http://argot-hub.googlecode.com/formatter", "?formatter" ] }
						]
				}
			);
			var uriFormatter;

			if (r && r.results.bindings[0] && r.results.bindings[0]["formatter"])
			{
				uriFormatter = r.results.bindings[0]["formatter"];

				loader.addModule({ name: "fresnel-formatter-css", type: "css", fullpath: r.results.bindings[0]["formatter"] + ".css" });
				loader.addModule({ name: "fresnel-formatter", type: "js", fullpath: r.results.bindings[0]["formatter"] + ".js",
					requires: [ "fresnel-formatter-css" ] });

				loader.require( "fresnel-formatter" );

				loader.onSuccess = function(o) {
					var loader = new YAHOO.util.YUILoader();
					var r = document.meta.query2(
						{
							select: [ "css" ],
							where:
								[
									{ pattern: [ "?s", "http://www.w3.org/1999/xhtml/vocab#stylesheet", "?css" ] }
								]
						}
					);//query for any stylesheets

					if (r && r.results.bindings[0] && r.results.bindings[0]["css"])
					{
						loader.addModule({ name: "fresnel-css-stylesheet", type: "css", fullpath: r.results.bindings[0]["css"] });
						if (window.external && window.external.document)
						{
							var d = window.external.document;
							var h = d.getElementsByTagName("head")[0];
							var l = d.createElement("link");

							l.setAttribute("rel", "stylesheet");
							l.setAttribute("href", r.results.bindings[0]["css"]);
							h.appendChild(l);
						}
					}
					loader.insert();
					if (window.external && window.external.document) {
						oParser.parse(window.external.document, getBaseUrl(window.external.document), null);
					}
					processFresnelSelectors( uriFormatter );
					return;
				};//onSuccess;
			}//if there are some formatters to load
			else {
				initialiseFresnelFormats(oParser);
			}
			loader.insert();
			return;
		},
		null
	);
	return;
}//get_metadata()
);

/**
 * The Knowledge-base Module provides utilities for reasoning.
 *
 * @module Knowledge-base
 * @title Knowledge-base Module
 * @requires core
 */

/**
 * @class KnowledgeBase
 */

function KnowledgeBase() {
	this.factList = [ ];
	this.ruleList = [ ];
}

KnowledgeBase.prototype.createCondition = function(cond, fact) {
	function Condition(cond, fact) {
		this.fact = fact;
		this.cond = cond;
		this.truth = null;

		fact.addCondition(this);
	}

	Condition.prototype.check = function() {
		if (this.fact.value === null) {
			this.truth = null;
		} else {
			this.truth = this.cond.test(this.fact.value);
		}
		return this.truth;
	};//check()

	return function(cond, factName) {
		return new Condition(cond, this.getFact( factName ));
	};
}();//createCondition()

KnowledgeBase.prototype.createConclusion = function( /* this function is called automatically on load */ ) {
	function Conclusion(fact, value) {
		this.fact = fact;
		this.value = value;

		fact.addConclusion(this);
	}

	Conclusion.prototype.addRuleRef = function(rule) {
		this.ruleRef = rule;
		return;
	};

	Conclusion.prototype.getRule = function() {
		return this.ruleRef;
	};//getRule()

	return function(factName, value) {
		return new Conclusion(this.getFact( factName ), value);
	};
}();//createConclusion()

KnowledgeBase.prototype.createEqualCondition = function(factName, condition) {
	function EqualCondition(condition) {
		this.condition = condition;
	}

	EqualCondition.prototype.test = function(value) {
		return (this.condition == value);
	};

	return function(factName, condition) {
		return this.createCondition(new EqualCondition(condition), factName);
	};
}();//createEqualCondition()

KnowledgeBase.prototype.createPresentCondition = function(factName) {
	function PresentCondition() {
	}

	PresentCondition.prototype.test = function(value) {
		return (value !== null);
	};

	return function(factName, condition) {
		return this.createCondition(new PresentCondition(), factName);
	};
}();//createPresentCondition()

KnowledgeBase.prototype.addRule = function( /* this creates a function */ ) {
	function Rule(kb, rule) {
		var condition, conditions, i;

		this.kb = kb;

		this.name = rule.name;

		this.conditions = [ ];

		for (conditions = rule.conditions, i = 0; i < conditions.length; i++) {
			if (conditions[ i ].value) {
				condition = kb.createEqualCondition(
					conditions[ i ].name,
					conditions[ i ].value
				);
			} else {
				condition = kb.createPresentCondition( conditions[ i ].name );
			}
			this.conditions.push( condition );
		}

		rule.conclusion.addRuleRef(this);
	}


	Rule.prototype.backChain = function( defaults ) {
		var condition, i;

		for (i = 0; i < this.conditions.length; i++) {
			condition = this.conditions[ i ];

			if (condition.truth === null) {
				this.kb.backChain( condition.fact.name );
			}

			if (condition.truth === null) {
				this.kb.setFactValue(condition.fact.name, defaults[ condition.fact.name ]);
			}

			if (!condition.truth) {
				return false;
			}
		}

		return true;
	};//backChain()

	return function( rule ) {
		var i;

		if (!rule.length) {
			rule = [ rule ];
		}
		for (i = 0; i < rule.length; i++) {
			this.ruleList.push(
				new Rule(
					this,
					{
						name: rule[ i ].name || "ANONYMOUS",
						conditions: rule[ i ].conditions,
						conclusion: this.createConclusion(rule[ i ].conclusion.name, rule[ i ].conclusion.value)
					}
				)
			);
		}// for ( each rule )
		return i;
	};
}();//addRule()

KnowledgeBase.prototype.backChain = function(goalFactName, defaults) {
	var
		goalConclusion,
		goalConclusions,
		goalRule,
		goalFact,
		i,
		ruleTruth
		;

	goalFact = this.getFact( goalFactName );
	goalConclusions = goalFact.conclusions;

	for (i = 0; i < goalConclusions.length; i++) {
		goalConclusion = goalConclusions[ i ];

		goalRule = goalConclusion.getRule();
		ruleTruth = goalRule.backChain( defaults );

		if (ruleTruth === null) {
		} else if (ruleTruth) {
			goalFact.setValue(goalConclusion.value);
		} else {
		}
	}//for ( each goalCondition )

	return goalFact;
};

KnowledgeBase.prototype.prove = function(conclusion, defaults) {
	var goalValue = this.backChain(conclusion.name, defaults).getValue();

	if (conclusion.value) {
		return goalValue == conclusion.value;
	} else {
		return goalValue !== null;
	}
};

KnowledgeBase.prototype.addFact = function(fact) {
	this.factList[ fact.name ] = fact;
	return;
};

KnowledgeBase.prototype.getFact = function(factName) {
	var fact = this.factList[ factName ];

	if (!fact) {
		fact = new Fact(this, factName);
	}
	return fact;
};

KnowledgeBase.prototype.getFactValue = function(factName) {
	return this.getFact( factName ).getValue();
};

KnowledgeBase.prototype.setFactValue = function(factName, value) {
	this.getFact( factName ).setValue(value);
	return;
};

/**
 * @class Fact
 */

function Fact(kb, name) {
	this.kb = kb;
	this.name = name;
	this.value = null;
	this.conditions = [ ];
	this.conclusions = [ ];

	kb.addFact(this);
}

Fact.prototype.addConclusion = function(conclusion) {
	this.conclusions.push(conclusion);
	return;
};

Fact.prototype.addCondition = function(condition) {
	this.conditions.push(condition);
	return;
};

Fact.prototype.getValue = function() {
	return this.value;
};

Fact.prototype.setValue = function(value) {
	this.value = value;
	this.updateConditions();
	return;
};

Fact.prototype.setRuleName = function(ruleName) {
	this.ruleName = ruleName;
	return;
};

Fact.prototype.updateConditions = function() {
	var i;

	for (i = 0; i < this.conditions.length; i++) {
		this.conditions[ i ].check();
	}
	return;
};

/*
 * Copyright (C) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*jslint browser:true*/
/*members  length, name, namespaces, urn, write*/
/*global g_sBehaviourDirectory*/
/**
 Inserts htc instruction to prevent IE mangling instancedata markup.
 @returns if an instancedata guard was successfully added, false, if no instancedata guard is implemented for the current environment.
 */
(
function() {
	if (document.namespaces) {
		var collNamespaces = document.namespaces;
		var i;
		if (typeof g_sBehaviourDirectory === "undefined") {
			g_sBehaviourDirectory = baseDefaultPath + "behaviours/";
		}

		for (i = 0; i < collNamespaces.length; ++i) {
			if (collNamespaces[i].urn == "http://www.w3.org/2002/xforms") {
				document.write('<?import  namespace="' + collNamespaces[i].name + '" implementation="' + g_sBehaviourDirectory + 'instance.htc"?>');
			}
		}
	}
} ());
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

UX.applySelectorsIE6 = function(doc) {

	var inputElements = doc.getElementsByTagName("input");
	for (var i = 0; i < inputElements.length; i++) {

		var datatype = inputElements[i].getAttribute("datatype"),
			appearance = inputElements[i].getAttribute("appearance");

		if (datatype === "xf:date" || datatype === "xforms:date" || datatype === "xsd:date") {
			if (appearance === "minimal") {
				continue;
			}
			inputElements[i].className += " yui-widget-calendar";
		}

		if (datatype === "xhd:color") {
			inputElements[i].className += " yui-widget-color";
		}
	}

};
var g_bDocumentLoaded = false;



function RegisterDocumentLoaded() {
	if (UX.isIE6) {
		UX.applySelectorsIE6(document);
	}
}

if (UX.isIE) {
	window.attachEvent("onload", RegisterDocumentLoaded);
} else {
}
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isFirefox3() {
	return (navigator.oscpu && document.getElementsByClassName);
}
/**
 Inserts an element as the last child of body, and sets up the CSS to bind this to onload.xml
 Calling this as a final step in the script loading process ensures that all existing elements
 have been bound to an appropriate XBL, and have performed their decorations, prior to
 calling any initialisation code that would otherwise have been called by onload.
 */
function FFInsertElementForOnloadXBL() {
	var oBody = document.getElementsByTagName("body")[0],
		cssNode, oHead, oStyle;

	if (!isFirefox3()) {
		oHead = document.getElementsByTagName("head")[0];
		oStyle = document.createElement('style');

		oStyle.setAttribute("type", "text/css");
		if (UX.isIE) {
			oStyle.styleSheet.cssText = "p#second-onload-loading-element { behavior: url(" + g_sBehaviourDirectory + "onload.htc); }";
		} else {
			oStyle.innerHTML = "p#second-onload-loading-element { -moz-binding: url(" + g_sBehaviourDirectory + "onload.xml#loader); }";
		}
		oHead.insertBefore(oStyle, null);
	}
	if(!(UX.isIE && !UX.hasDecorationSupport)) oBody.insertAdjacentHTML("beforeEnd", "<p id='second-onload-loading-element' style='width:0px;display:inline-block;'>Loading...</p>");

}

InsertElementForOnloadXBL = (UX.isFF || UX.isIE) ? FFInsertElementForOnloadXBL : function() {};
document.logger = {
	log: function(sText, sContext) {}
};

var loader = new YAHOO.util.YUILoader();

loader.onFailure = function(msg, xhrobj) {
	window.status = "Failed to load Ubiquity XForms: ";
};

var sBars = "";
loader.onProgress = function(o) {
	sBars += ("|");
	window.status = ("Loading Ubiquity modules: " + sBars + " [" + o.name + "]");
};

window.onload = function(o) {
	window.status = "Successfully loaded Ubiquity XForms";
	InsertElementForOnloadXBL();
};
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 Manages the potential disparity between namespaces referred to in a library, and their occurrence in a real
 world application.
 see: http://ubiquity-xforms.googlecode.com/svn/branches/0.3/_testsuite/units/NamespaceManager.html
 */

var NamespaceManager = {

	selectionNamespaces: {},

	outputNamespaces: {},

	outputNamespaceURIs: {},

	/**
	 returns the lists of namespaces to an uninitialised state.
	 */
	clean: function() {
		this.selectionNamespaces = {};
		this.outputNamespaces = {};
	},

	/**
	 Translates a given namespace-aware CSS selector, into an "escaped colon" style selector.
	 @param {String} a namespace-aware CSS selector - e.g. x|banana
	 @returns String the selector parameter, translated into an "escaped colon" style selector
	 */
	translateCSSSelector: function(selector) {
		var matchNamespacePrefix = (/(\w+)\|\w+/);
		var result = matchNamespacePrefix.exec(selector);
		while (result) {
			var l = result.length;
			if (l > 1) {
				selector = this._translateCSSSelectorForPrefix(selector, result[1]);
			}
			result = matchNamespacePrefix.exec(selector);
		}
		return selector;
	},

	/**
	 Removes all instances of namespace-aware CSS selectors for the given prefix from a selector,
	 replacing them with appropriate CSS1 selectors, based on the current output context.
	 @param {String} selector, the selector to translate
	 @param {String} The prefix to eradicate
	 @returns {String} selector, with prefix eradicated.
	 */
	_translateCSSSelectorForPrefix: function(selector, prefix) {
		var selectionURI = this.selectionNamespaces[prefix];
		if (selectionURI === undefined) {
			throw "Unknown Prefix: '" + prefix + "' in CSS selector '" + selector + "'";
		} else {
			var sMatchThisPrefix = prefix + "\\|";
			var matchGivenPrefix = new RegExp(sMatchThisPrefix, "g");
			var outputprefixes = this.outputNamespaces[selectionURI];

			if (!outputprefixes || !outputprefixes.length) {
				throw ("No output prefixes found for selection namespace prefix '" + prefix + "'");
			} else {
				var alternativesForThisURI = [];
				for (var i = 0, l = outputprefixes.length; i < l; i++) {
					alternativesForThisURI.push(selector.replace(matchGivenPrefix, outputprefixes[i] + "\\:"));
				}
			}
		}
		return alternativesForThisURI.join(", ");
	},

	/**
	 Retrieves the list of output prefixes that represent the given namespace.
	 @param {String} uri  The URI to look up.
	 @returns {Array} An array of prefixes that represent the given URI in the current output context.
	 */
	getOutputPrefixesFromURI: function(uri) {
		return this.outputNamespaces[uri];
	},

	/**
	 Retrieve an attribute reside in an specific namespace.
	 @param node {Node} The node to retrieve attribute from
	 @param nsURI {String} The namespace URI in which the attribute reside
	 @param attributeName {String} the name of attribute
	 @returns
	 */

	getAttributeNS: function(node, nsURI, attributeName) {
		if (UX.isXHTML) return node.getAttributeNS(nsURI, attributeName);
		var prefixes = this.getOutputPrefixesFromURI(nsURI);
		if(!prefixes) return null;
		return node.getAttribute(prefixes[0] + ":" + attributeName);
	},

	/**
	 Binds a namespace prefix to a URI for selection purposes.
	 @param {String} prefix The prefix used to select the given URI
	 @param {String} uri  The URI to which the prefix is to be bound
	 @returns true, if the prefix is successfully bound to the URI, or false, if it is already bound to the same URI.
	 @throws String if the prefix is already bound to a different URI
	 */
	addSelectionNamespace: function(prefix, uri) {
		var retVal;
		if (this.selectionNamespaces[prefix]) {
			if (this.selectionNamespaces[prefix] != uri) {
				throw "selection namespace prefix '" + prefix + "' being added to URI '" + uri + "' is already bound to URI '" + this.selectionNamespaces[prefix] + "'";
			}
			return false;
		}
		this.selectionNamespaces[prefix] = uri;
		return true;
	},

	/**
	 Binds a namespace URI to a prefix  for output purposes.
	 @param {String} prefix The prefix to be output for the given URI
	 @param {String} uri  The URI for prefix
	 */
	addOutputNamespace: function(prefix, uri) {
		if (!this.outputNamespaces[uri]) {
			this.outputNamespaces[uri] = [];
		}
		this.outputNamespaces[uri].push(prefix);
		this.outputNamespaceURIs[prefix] = uri;
		return true;
	},

	/**
	 Some parsers believe that ":" is just a character in a simple node name, rather than a separator between the local name,
	 and a prefix corresponding to a node's namespace.  Using this function to get the local name will return the proper local name.
	 */
	getLowerCaseLocalName: function(node) {
		var name = node.nodeName;
		return name.slice(name.indexOf(":") + 1, name.length).toLowerCase();
	},

	/**
	 Compares a node's name against a localname and namespaceURI
	 @param node {Node} The node whose name is in question
	 @param localName {String} A non-namespace-qualified local name, to match against the name of node
	 @param nsURI {String} The namespace URI in which node must reside, in order to match.
	 @returns true iff the local name and namespace uri of node, match those parameters given, false otehrwise.
	 */

	compareFullName: function(node, localName, nsURI) {
		var fullName = node.nodeName.toLowerCase();
		var segments = fullName.split(":");
		var nodeLocalName = segments.length == 1 ? segments[0] : segments[1];
		if(nodeLocalName != localName) return false;
		var nodePrefix = segments.length == 1 ? node.scopeName : segments[0];
		if ( ((!nodePrefix || nodePrefix == "HTML") && !nsURI) || (this.outputNamespaceURIs[nodePrefix] == nsURI) ) {
			return true;
		}
		return false;
	},

	getNamespaceURI: function(node) {
		if(UX.isXHTML) return node.namespaceURI;
		var segments = node.nodeName.toLowerCase().split(":");
		return this.outputNamespaceURIs[segments.length === 1 ? node.scopeName : segments[0]];
	},

	/**
	 populates the list of output namespaces if the document has a namespaces property
	 */
	readOutputNamespacesFromDocument: function(doc) {
		if(document.namespaces) {
			doc = doc || document;
			var nsList = doc.namespaces;
			for (var i = 0, l = nsList.length; i < l; i++) {
				this.addOutputNamespace(nsList[i].name, nsList[i].urn);
			}
		} else {
			this.readOutputNamespacesFromInstance(doc);
		}
	},

	readOutputNamespacesFromInstance: function(doc) {
		doc = doc || document;
		var attrMap = doc.documentElement.attributes;
		for (var i = 0, l = attrMap.length; i < l; i++) {
			var thisAttr = attrMap[i];
			if (thisAttr.nodeName.indexOf('xmlns:') === 0) {
				var prefix = thisAttr.nodeName.slice(6).toLowerCase();
				this.addOutputNamespace(prefix, thisAttr.nodeValue);
			}
		}
	},
	/**
	 Searches searchNode for descendents
	 that have a tagName that matches elementName, and
	 that are in the namespace namespaceURI
	 @param searchNode {Node} topmost node (document or element) to look in to find the desired nodes.
	 @param namespaceURI {String} namespace URI to match
	 @param elementName {String}  element name to match
	 @returns an array of nodes that match the given criteria
	 */
	getElementsByTagNameNS: UX.isXHTML ? function(searchNode, namespaceURI, elementName) {//xhtml
		return searchNode.getElementsByTagNameNS(namespaceURI, elementName);
	} : (document.namespaces ? 	function(searchNode, namespaceURI, elementName) {//ie
		var retVal = [];
		var tags = searchNode.getElementsByTagName(elementName);
		for (var i = 0, l = tags.length; i < l; ++i) {
			if (tags[i].scopeName !== "HTML") {
				if (namespaceURI && tags[i].tagUrn == namespaceURI) {
					retVal.push(tags[i]);
				} else if (this.outputNamespaceURIs[tags[i].scopeName] == namespaceURI) {
					retVal.push(tags[i]);
				}
			} else if (namespaceURI == "") {
				retVal.push(tags[i]);
			}
		}
		return retVal;
	} : function(searchNode, namespaceURI, elementName) {//not ie html mode
		var retVal = [];
		var i, j, l, m;
		if (namespaceURI === "") {
			var elementsWithNoPrefix = searchNode.getElementsByTagName(elementName);
			for (i = 0, l = elementsWithNoPrefix.length; i < l; i++) {
				retVal.push(elementsWithNoPrefix[i]);
			}
		} else {
			var prefixes = this.outputNamespaces[namespaceURI];
			if (prefixes) {
				for (i = 0, l = prefixes.length; i < l; i++) {
					var elementsWithThisPrefix = searchNode.getElementsByTagName(prefixes[i] + ":" + elementName);
					for (j = 0, m = elementsWithThisPrefix.length; j < m; j++) {
						retVal.push(elementsWithThisPrefix[j]);
					}
				}
			}
		}
		return retVal;
	}),

	getNamespaceURIForPrefix: function(prefix) {
		return (prefix) ? this.outputNamespaceURIs[prefix] : "";
	}

};
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 @fileoverview
 Contains functions used in the decoration of elements and objects. Along with the mechanism for
 setting up decoration.

 */

/*global document, UX, NamespaceManager, g_bDocumentLoaded, g_sBehaviourDirectory, navigator, alert, window, YAHOO, spawn  */





var DECORATOR = {

	rules: {},

	handlersToCallOnLoad: [],

	inSuspension: [],

	suspended: 0,

	elements: {},

	uid: 0,

	objects: {},

	getElement: function(uid){
		return this.elements[uid];
	},

	getObject: function(element){
		return this.objects[element.ux_uid || element];
	},

	getBehaviour: function(element){
		if(!element) return null;
		var object = this.objects[element.ux_uid || element];
		if(!object) return null;
		return object.behaviour;
	},

	/**
	 Extends the functionality of the destination object with the members of source
	 @param {Object} destination object to be extended
	 @param {Object} source source of new members for destination.
	 */
	extend: function (dst, src, executeNow) {
		for (var p in src) {
			switch (p) {
			case "ctor":
			case "onContentReady":
				if (executeNow) {
					dst[p] = src[p];
				} else {
					this._addFunction(dst, p, src[p]);
				}
				break;
			case "onDocumentReady":
				if (g_bDocumentLoaded && executeNow) {
					dst[p] = src[p];
				} else {
					this._addFunction(dst, p, src[p]);
				}
				break;
			default: //	Otherwise, create this member anew, or override any existing homonymous member.
				dst[p] = src[p];
			}
		}

		if (executeNow) {
			var props = ["ctor", "onContentReady", "onDocumentReady"];
			for(var i = 0; i < 3; i++){
				if(props[i] == "onDocumentReady" && !g_bDocumentLoaded) continue;
				if(dst[props[i]]) dst[props[i]]();
			}
		}
		return dst;
	},

	/**
	 Adds a function (func) to a named list of functions within an object (dest)
	 If a list with that name does not exist, creates the list.
	 The purpose of this mechanism of extension, is for functions such as constructors and
	 event handlers, which are cumulative, rather than overriding.
	 @param {Object} dst object that contains the named list
	 @param {String} name of the list property within dest that func should be appended to.
	 @param {Object} func function to add to the list
	 */
	_addFunction: function(dst, name, func) {
		if (!dst[name]) {
			dst[name] = [];
		}
		return dst[name].push(func);
	},

	/**
	 Adds rules to the document's stylesheet cascade that cause the decoration of elements in the appropriate browser.
	 @param {Array} defs decorator definitions
	 @see (somewhere else)
	 */
	setupDecorator: function(defs, ns) {
		var isLoaded = g_bDocumentLoaded;
		g_bDocumentLoaded = false;
		NamespaceManager.readOutputNamespacesFromDocument();
		for (var i = 0; i < defs.length; ++i) {
			defs[i].selector = NamespaceManager.translateCSSSelector(defs[i].selector);
		}
		this._setupDecorator(defs, ns);
		if (isLoaded) {
			spawn(this.callDocumentReadyHandlers);
		}
	},

	_setupDecorator: UX.isIE ? function(defs) {//ie
		if(!UX.hasDecorationSupport) return;
		/**
		 Adds rules to the document's stylesheet cascade that cause the decoration of elements in IE.
		 @param {Array} defs decorator definitions
		 @see (somewhere else)
		 */
		var isLoaded = g_bDocumentLoaded;
		g_bDocumentLoaded = false;
		var sheet = document.createStyleSheet("", 0);

		var behaviourRule = "\nbehavior: " + "url(" + g_sBehaviourDirectory + "decorate.htc);";

		for (var i = 0; i < defs.length; ++i) {
			var rule = "";
			if (defs[i].objects != undefined) {
				rule += this._generateMozBindingStyle(defs[i].objects) + behaviourRule;
			}
			rule += (defs[i].cssText || "");

			defs[i].selector = defs[i].selector.replace(/>/g, '');
			var alternateSelectors = defs[i].selector.split(",");
			for (var j = 0; j < alternateSelectors.length; ++j) {
				sheet.addRule(alternateSelectors[j], rule);
			}
		}
		g_bDocumentLoaded = isLoaded;
		if (isLoaded) {
			this.callDocumentReadyHandlers();
		}

	} : (UX.isXHTML ? function(defs) {//ff xhtml
		var head = document.getElementsByTagName("head")[0];

		var htmlPrefix = "h";
		var htmlNamespaceURI = "http://www.w3.org/1999/xhtml";
		var xformsPrefix = "xf";
		var xformsNamespaceURI = "http://www.w3.org/2002/xforms";

		var anHTMLPrefix = NamespaceManager.getOutputPrefixesFromURI(htmlNamespaceURI);
		if (anHTMLPrefix) {
			htmlPrefix = anHTMLPrefix[0];
		}
		var aXFormsPrefix = NamespaceManager.getOutputPrefixesFromURI(xformsNamespaceURI);
		if (aXFormsPrefix) {
			xformsPrefix = aXFormsPrefix[0];
		}

		var style = document.createElement('style');
		style.setAttribute("type", "text/css");
		var s = "";
		s += "@namespace smil url(http://www.w3.org/2005/SMIL21/BasicAnimation);";
		s += "@namespace" + " " + xformsPrefix + " " + "url(" + xformsNamespaceURI + ");";
		s += "@namespace" + " " + htmlPrefix + " " + "url(" + htmlNamespaceURI + ");";

		for (var i = 0; i < defs.length; ++i) {
			defs[i].selector = defs[i].selector.replace(/\\:/g, "|");
			s += defs[i].selector + "{" +
				this._generateMozBindingStyle(defs[i].objects) + (defs[i].cssText || "") +
			"}";
		}
		style.innerHTML = s;
		head.insertBefore(style, null);

	} : function(defs, ns) {//ff
		/**
		 Adds rules to the document's stylesheet cascade that cause the decoration of elements in Firefox.
		 @param {Array} defs decorator definitions
		 @see (somewhere else)
		*/

		if(UX.isFF3) return;

		var head = document.getElementsByTagName("head")[0];
		var style = document.createElement("style");
		style.setAttribute("type", "text/css");

		var s = "";
		for (var i = 0; i < defs.length; ++i) {
			s += defs[i].selector + "{" +
				this._generateMozBindingStyle(defs[i].objects) + (defs[i].cssText || "") +
			"}";
		}
		style.appendChild(document.createTextNode(s));
		head.insertBefore(style, null);

	}),

	/**
	 creates a CSS style declaration that causes the decoration of its referent with the objects in objects
	 @param {Array} objs array of strings specifying the names of objects to be used in decorating an element.
	 @returns String representation of the appropriate -moz-binding declaration.
	 */
	_generateMozBindingStyle: function(objects) {
		if(!objects) return "";
		return "-moz-binding: url(\"" + g_sBehaviourDirectory + "decorator.xml" + (objects.length > 0 ? "?" + objects.join("&") : "") + "#decorator\");";
	},

	attachDecoration: function(element, handleContentReady, handleDocumentReady) {
		if (!UX.hasDecorationSupport && element.ux_uid) return false;//quit if already manually decorated

		if (element.getAttribute("tabindex") == 0) {
			element.tabIndex = 1;
		}

		var behaviour = this._getBehaviour(element);
		if(!behaviour) return false;
		UX.extend(element, new EventTarget(element));
		this.addBehaviour(element, new behaviour(element));

		if (this.suspended) {
			this.inSuspension.push(element);
			return false;
		}
		this._callConstructionFunctions(element, handleContentReady, handleDocumentReady);
		return true;
	},

	addBehaviour: function(element, behaviour) {
		element.ux_uid = ++this.uid;
		this.elements[this.uid] = element;
		this.objects[this.uid] = {};
		this.objects[this.uid].behaviour = behaviour;
	},

	_getBehaviour: function(element) {
		/*if (sBehaviours && sBehaviours.indexOf('?') !== -1) {
			sBehaviours = sBehaviours.substring(sBehaviours.indexOf('?') + 1, sBehaviours.lastIndexOf('#'));
			arrBehaviours = sBehaviours.split("&");
		}*/

		var nsURI = NamespaceManager.getNamespaceURI(element);
		var localName = NamespaceManager.getLowerCaseLocalName(element);

		var rules;
		if (this.rules[nsURI]) {
			rules = this.rules[nsURI][localName];
		}
		if (localName == "pe-value") {// <pe-value> is a special case, since its not in the XForms namespace
			rules = this.rules["http://www.w3.org/2002/xforms"][localName];
		}

		var behaviour;
		for(var i = 0; i < rules.length; i++) {
			if (!rules[i].match || rules[i].match(element)) {
				behaviour = rules[i]["apply"]();
			}
		}
		return behaviour;
	},

	_getCustomCSSProperty: UX.isIE ?  function(element, property) {//ie
		var value = element.currentStyle[property];
		if(value != undefined) return value;
		if (property.charAt(0) == '-') {
			property = property.slice(1);//if the requested property name begins with '-', chop it off
		} else {
			property = "-" + property;// if '-' was omitted, prepend it.
		}
		value = element.currentStyle[property];

		return value;

	} : function(element, property) {//ff

		return window.getComputedStyle(element, "").getPropertyValue(property);

	},

	_callConstructionFunctions: function(element, handleContentReady, handleDocumentReady) {
		if (handleContentReady) {
			if(this.getBehaviour(element).onContentReady) this.getBehaviour(element).onContentReady();
		}
		if (handleDocumentReady) {
			this._registerForOnloadOrCallNow(this.getObject(element).behaviour);
		}
	},

	/**
	 Called by implementations that do not natively support a documentReady event.
	 If the document has already loaded, handlers passed into this function
	 will execute immediately, otherwise, they will be appended to the list of
	 handlers waiting to be called on load.
	 */
	_registerForOnloadOrCallNow: function(behaviour) {
		if (g_bDocumentLoaded) {
			if(behaviour.onDocumentReady) behaviour.onDocumentReady();
		} else {
			this.handlersToCallOnLoad.push(behaviour);
		}
	},

	decorate: function(element) {
		if (element.ux_uid) return;
		var s = this._getCustomCSSProperty(element, "-binding-ignore");
		if (s == undefined || s == "false") {
			if(UX.isIE) {
				UX.extend(element, new EventTarget(element));
			}
			DECORATOR.attachDecoration(element, true, true);
		}
	},

	/**
	 Called by implementations that do not natively support a documentReady event.
	 on document load, this function calls any documentready handlers that have
	 been registered so far, then sets the g_bDocumentLoaded flag to true, so that
	 any documentready handlers that attempt to register later can execute immediately.
	 Now that all the scripts are loaded after the rest of the document, this is also required
	 by IE, to call the handlers at the end of processing.
	 */
	callDocumentReadyHandlers: function() {
		var behaviour = DECORATOR.handlersToCallOnLoad.pop();
		while (behaviour) {
			if(behaviour.onDocumentReady) behaviour.onDocumentReady();
			behaviour = DECORATOR.handlersToCallOnLoad.pop();
		}
		g_bDocumentLoaded = true;
	},

	addRules: function(rules) {
		if (rules.namespaceURI && rules.rules) {
			this._addDecorationRulesForNamespace(rules.namespaceURI, rules.rules);
		} else if (rules.rules) {
			this._addDecorationRulesForNamespace("*", rules.rules);
		}
	},

	_addDecorationRulesForNamespace: function(namespaceURI, rules) {
		if (this.rules[namespaceURI]) {
			for (var key in rules) {
				if (this.rules[namespaceURI][key]) {
					this.rules[namespaceURI][key] = this.rules[namespaceURI][key].concat(rules[key]);
				} else {
					this.rules[namespaceURI][key] = rules[key];
				}
			}
		} else {
			this.rules[namespaceURI] = rules;
		}
	},

	/**
	 * Apply current decoration rules to the document. Logically, we:
	 * (a) select elements having QNames that have rules registered against them,
	 *     one QName at a time, and
	 * (b) apply decoration rules to each of the elements selected
	 *
	 * Currently a single pass operation, this does not support repeats and other
	 * dynamic operations.
	 *
	 * @param {Document} doc The optional document object
	 *                       (<code>document</code> is used if not provided)
	 */
	applyRules: function(doc) {
		var currentDocument = doc || document, i, l;
		if (UX.hasDecorationSupport) return;

		for (var nsURI in this.rules) {
			if (nsURI == "*") {
				continue;
			}
			var nsRules = this.rules[nsURI];
			var elements;
			for (var name in nsRules) {
				if (name === "*" || name === "pe-value") {
					continue;
				}
				elements = NamespaceManager.getElementsByTagNameNS(currentDocument, nsURI, name);
				for (i = 0, l = elements.length; i < l; i++) {
					DECORATOR.attachDecoration(elements[i], true, true);
					if (nsURI == "http://www.w3.org/2002/xforms" && (name == "repeat" || name == "case" || name == "header")) {
						DECORATOR.applyRules(elements[i]);
					}
				}
			}
		}
		elements = currentDocument.getElementsByTagName("pe-value");
		for (i = 0, l = elements.length; i < l; i++) {
			this.attachDecoration(elements[i], true, true);
		}
		if (!doc) {
			this.callDocumentReadyHandlers();
		}
	},

	onAllBindingsAttached: function(obj) {
		obj.parentNode.removeChild(obj);
		this.callDocumentReadyHandlers();
	},

	suspend: function() {
		++this.suspended;
	},

	resume: function() {
		var element;
		var isInDocument = function(element) {
			var parent = element.parentNode;
			while (parent) {
				if (parent === document) {
					return true;
				}
				parent = parent.parentNode;
			}
			return false;
		};
		if (!--this.suspended) {
			while (this.inSuspension[0]) {
				element = this.inSuspension.pop();
				if (isInDocument(element)) {
					this._callConstructionFunctions(element, true, true);
				}
			}
		}
	}

};


YAHOO.util.Event.onDOMReady(function() {

	DECORATOR.applyRules();
	window.status = "ready";

});

function xpathLog(msg) {};
function xsltLog(msg) {};
function xsltLogXml(msg) {};

var ajaxsltIsIE6 = navigator.appVersion.match(/MSIE 6.0/);

function assert(b) {
  if (!b) {
    throw "Assertion failed";
  }
}

function stringSplit(s, c) {
  var a = s.indexOf(c);
  if (a == -1) {
    return [ s ];
  }
  var parts = [];
  parts.push(s.substr(0,a));
  while (a != -1) {
    var a1 = s.indexOf(c, a + 1);
    if (a1 != -1) {
      parts.push(s.substr(a + 1, a1 - a - 1));
    } else {
      parts.push(s.substr(a + 1));
    }
    a = a1;
  }
  return parts;
}

function xmlImportNode(doc, node) {
  if (node.nodeType == DOM_TEXT_NODE) {
    return domCreateTextNode(doc, node.nodeValue);

  } else if (node.nodeType == DOM_CDATA_SECTION_NODE) {
    return domCreateCDATASection(doc, node.nodeValue);

  } else if (node.nodeType == DOM_ELEMENT_NODE) {
    var newNode = domCreateElement(doc, node.nodeName);
    for (var i = 0; i < node.attributes.length; ++i) {
      var an = node.attributes[i];
      var name = an.nodeName;
      var value = an.nodeValue;
      domSetAttribute(newNode, name, value);
    }

    for (var c = node.firstChild; c; c = c.nextSibling) {
      var cn = arguments.callee(doc, c);
      domAppendChild(newNode, cn);
    }

    return newNode;

  } else {
    return domCreateComment(doc, node.nodeName);
  }
}

function Set() {
  this.keys = [];
}

Set.prototype.size = function() {
  return this.keys.length;
}

Set.prototype.add = function(key, opt_value) {
  var value = opt_value || 1;
  if (!this.contains(key)) {
    this[':' + key] = value;
    this.keys.push(key);
  }
}

Set.prototype.set = function(key, opt_value) {
  var value = opt_value || 1;
  if (!this.contains(key)) {
    this[':' + key] = value;
    this.keys.push(key);
  } else {
    this[':' + key] = value;
  }
}

Set.prototype.inc = function(key) {
  if (!this.contains(key)) {
    this[':' + key] = 1;
    this.keys.push(key);
  } else {
    this[':' + key]++;
  }
}

Set.prototype.get = function(key) {
  if (this.contains(key)) {
    return this[':' + key];
  } else {
    var undefined;
    return undefined;
  }
}

Set.prototype.remove = function(key) {
  if (this.contains(key)) {
    delete this[':' + key];
    removeFromArray(this.keys, key, true);
  }
}

Set.prototype.contains = function(entry) {
  return typeof this[':' + entry] != 'undefined';
}

Set.prototype.items = function() {
  var list = [];
  for (var i = 0; i < this.keys.length; ++i) {
    var k = this.keys[i];
    var v = this[':' + k];
    list.push(v);
  }
  return list;
}


Set.prototype.map = function(f) {
  for (var i = 0; i < this.keys.length; ++i) {
    var k = this.keys[i];
    f.call(this, k, this[':' + k]);
  }
}

Set.prototype.clear = function() {
  for (var i = 0; i < this.keys.length; ++i) {
    delete this[':' + this.keys[i]];
  }
  this.keys.length = 0;
}


function mapExec(array, func) {
  for (var i = 0; i < array.length; ++i) {
    func.call(this, array[i], i);
  }
}

function mapExpr(array, func) {
  var ret = [];
  for (var i = 0; i < array.length; ++i) {
    ret.push(func(array[i]));
  }
  return ret;
};

function reverseInplace(array) {
  for (var i = 0; i < array.length / 2; ++i) {
    var h = array[i];
    var ii = array.length - i - 1;
    array[i] = array[ii];
    array[ii] = h;
  }
}

function removeFromArray(array, value, opt_notype) {
  var shift = 0;
  for (var i = 0; i < array.length; ++i) {
    if (array[i] === value || (opt_notype && array[i] == value)) {
      array.splice(i--, 1);
      shift++;
    }
  }
  return shift;
}

function copyArray(dst, src) {
  if (!src) return;
  var dstLength = dst.length;
  for (var i = src.length - 1; i >= 0; --i) {
    dst[i+dstLength] = src[i];
  }
}

/**
 * This is an optimization for copying attribute lists in IE. IE includes many
 * extraneous properties in its DOM attribute lists, which take require
 * significant extra processing when evaluating attribute steps. With this
 * function, we ignore any such attributes that has an empty string value.
 */
function copyArrayIgnoringAttributesWithoutValue(dst, src)
{
  if (!src) return;
  for (var i = src.length - 1; i >= 0; --i) {
    if (src[i].nodeValue) {
      dst.push(src[i]);
    }
  }
}

function xmlValue(node) {
  if (!node) {
    return '';
  }

  var ret = '';
  if (node.nodeType == DOM_TEXT_NODE ||
      node.nodeType == DOM_CDATA_SECTION_NODE) {
    ret += node.nodeValue;

  } else if (node.nodeType == DOM_ATTRIBUTE_NODE) {
    if (ajaxsltIsIE6) {
      ret += xmlValueIE6Hack(node);
    } else {
      ret += node.nodeValue;
    }
  } else if (node.nodeType == DOM_ELEMENT_NODE ||
             node.nodeType == DOM_DOCUMENT_NODE ||
             node.nodeType == DOM_DOCUMENT_FRAGMENT_NODE) {
    for (var i = 0; i < node.childNodes.length; ++i) {
      ret += arguments.callee(node.childNodes[i]);
    }
  }
  return ret;
}

function xmlValueIE6Hack(node) {
    var nodeName = node.nodeName;
    var nodeValue = node.nodeValue;
    if (nodeName.length != 4) return nodeValue;
    if (!/^href$/i.test(nodeName)) return nodeValue;
    if (!(/^javascript:/).test(nodeValue)) return nodeValue;
    return unescape(nodeValue);
}

function xmlText(node, opt_cdata) {
  var buf = [];
  xmlTextR(node, buf, opt_cdata);
  return buf.join('');
}

function xmlTextR(node, buf, cdata) {
  if (node.nodeType == DOM_TEXT_NODE) {
    buf.push(xmlEscapeText(node.nodeValue));

  } else if (node.nodeType == DOM_CDATA_SECTION_NODE) {
    if (cdata) {
      buf.push(node.nodeValue);
    } else {
      buf.push('<![CDATA[' + node.nodeValue + ']]>');
    }

  } else if (node.nodeType == DOM_COMMENT_NODE) {
    buf.push('<!--' + node.nodeValue + '-->');

  } else if (node.nodeType == DOM_ELEMENT_NODE) {
    buf.push('<' + xmlFullNodeName(node));
    for (var i = 0; i < node.attributes.length; ++i) {
      var a = node.attributes[i];
      if (a && a.nodeName && a.nodeValue) {
        buf.push(' ' + xmlFullNodeName(a) + '="' +
                 xmlEscapeAttr(a.nodeValue) + '"');
      }
    }

    if (node.childNodes.length == 0) {
      buf.push('/>');
    } else {
      buf.push('>');
      for (var i = 0; i < node.childNodes.length; ++i) {
        arguments.callee(node.childNodes[i], buf, cdata);
      }
      buf.push('</' + xmlFullNodeName(node) + '>');
    }

  } else if (node.nodeType == DOM_DOCUMENT_NODE ||
             node.nodeType == DOM_DOCUMENT_FRAGMENT_NODE) {
    for (var i = 0; i < node.childNodes.length; ++i) {
      arguments.callee(node.childNodes[i], buf, cdata);
    }
  }
}

function xmlFullNodeName(n) {
  if (n.prefix && n.nodeName.indexOf(n.prefix + ':') != 0) {
    return n.prefix + ':' + n.nodeName;
  } else {
    return n.nodeName;
  }
}

function xmlEscapeText(s) {
  return ('' + s).replace(/&/g, '&amp;').replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}

function xmlEscapeAttr(s) {
  return xmlEscapeText(s).replace(/\"/g, '&quot;');
}

function xmlEscapeTags(s) {
  return s.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/**
 * Wrapper function to access the owner document uniformly for document
 * and other nodes: for the document node, the owner document is the
 * node itself, for all others it's the ownerDocument property.
 *
 * @param {Node} node
 * @return {Document}
 */
function xmlOwnerDocument(node) {
  if (node.nodeType == DOM_DOCUMENT_NODE) {
    return node;
  } else {
    return node.ownerDocument;
  }
}

function domGetAttribute(node, name) {
  return node.getAttribute(name);
}

function domSetAttribute(node, name, value) {
  return node.setAttribute(name, value);
}

function domRemoveAttribute(node, name) {
  return node.removeAttribute(name);
}

function domAppendChild(node, child) {
  return node.appendChild(child);
}

function domRemoveChild(node, child) {
  return node.removeChild(child);
}

function domReplaceChild(node, newChild, oldChild) {
  return node.replaceChild(newChild, oldChild);
}

function domInsertBefore(node, newChild, oldChild) {
  return node.insertBefore(newChild, oldChild);
}

function domRemoveNode(node) {
  return domRemoveChild(node.parentNode, node);
}

function domCreateTextNode(doc, text) {
  return doc.createTextNode(text);
}

function domCreateElement(doc, name) {
  return doc.createElement(name);
}

function domCreateAttribute(doc, name) {
  return doc.createAttribute(name);
}

function domCreateCDATASection(doc, data) {
  return doc.createCDATASection(data);
}

function domCreateComment(doc, text) {
  return doc.createComment(text);
}

function domCreateDocumentFragment(doc) {
  return doc.createDocumentFragment();
}

function domGetElementById(doc, id) {
  return doc.getElementById(id);
}

function windowSetInterval(win, fun, time) {
  return win.setInterval(fun, time);
}

function windowClearInterval(win, id) {
  return win.clearInterval(id);
}


var REGEXP_UNICODE = function() {
  var tests = [' ', '\u0120', -1,  // Konquerer 3.4.0 fails here.
               '!', '\u0120', -1,
               '\u0120', '\u0120', 0,
               '\u0121', '\u0120', -1,
               '\u0121', '\u0120|\u0121', 0,
               '\u0122', '\u0120|\u0121', -1,
               '\u0120', '[\u0120]', 0,  // Safari 2.0.3 fails here.
               '\u0121', '[\u0120]', -1,
               '\u0121', '[\u0120\u0121]', 0,  // Safari 2.0.3 fails here.
               '\u0122', '[\u0120\u0121]', -1,
               '\u0121', '[\u0120-\u0121]', 0,  // Safari 2.0.3 fails here.
               '\u0122', '[\u0120-\u0121]', -1];
  for (var i = 0; i < tests.length; i += 3) {
    if (tests[i].search(new RegExp(tests[i + 1])) != tests[i + 2]) {
      return false;
    }
  }
  return true;
}();


var XML_S = '[ \t\r\n]+';
var XML_EQ = '(' + XML_S + ')?=(' + XML_S + ')?';
var XML_CHAR_REF = '&#[0-9]+;|&#x[0-9a-fA-F]+;';


var XML10_VERSION_INFO = XML_S + 'version' + XML_EQ + '("1\\.0"|' + "'1\\.0')";
var XML10_BASE_CHAR = (REGEXP_UNICODE) ?
  '\u0041-\u005a\u0061-\u007a\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' +
  '\u0100-\u0131\u0134-\u013e\u0141-\u0148\u014a-\u017e\u0180-\u01c3' +
  '\u01cd-\u01f0\u01f4-\u01f5\u01fa-\u0217\u0250-\u02a8\u02bb-\u02c1\u0386' +
  '\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03ce\u03d0-\u03d6\u03da\u03dc' +
  '\u03de\u03e0\u03e2-\u03f3\u0401-\u040c\u040e-\u044f\u0451-\u045c' +
  '\u045e-\u0481\u0490-\u04c4\u04c7-\u04c8\u04cb-\u04cc\u04d0-\u04eb' +
  '\u04ee-\u04f5\u04f8-\u04f9\u0531-\u0556\u0559\u0561-\u0586\u05d0-\u05ea' +
  '\u05f0-\u05f2\u0621-\u063a\u0641-\u064a\u0671-\u06b7\u06ba-\u06be' +
  '\u06c0-\u06ce\u06d0-\u06d3\u06d5\u06e5-\u06e6\u0905-\u0939\u093d' +
  '\u0958-\u0961\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2' +
  '\u09b6-\u09b9\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u0a05-\u0a0a' +
  '\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36' +
  '\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8b\u0a8d' +
  '\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9' +
  '\u0abd\u0ae0\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30' +
  '\u0b32-\u0b33\u0b36-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b85-\u0b8a' +
  '\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4' +
  '\u0ba8-\u0baa\u0bae-\u0bb5\u0bb7-\u0bb9\u0c05-\u0c0c\u0c0e-\u0c10' +
  '\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c60-\u0c61\u0c85-\u0c8c' +
  '\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cde\u0ce0-\u0ce1' +
  '\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d60-\u0d61' +
  '\u0e01-\u0e2e\u0e30\u0e32-\u0e33\u0e40-\u0e45\u0e81-\u0e82\u0e84' +
  '\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5' +
  '\u0ea7\u0eaa-\u0eab\u0ead-\u0eae\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4' +
  '\u0f40-\u0f47\u0f49-\u0f69\u10a0-\u10c5\u10d0-\u10f6\u1100\u1102-\u1103' +
  '\u1105-\u1107\u1109\u110b-\u110c\u110e-\u1112\u113c\u113e\u1140\u114c' +
  '\u114e\u1150\u1154-\u1155\u1159\u115f-\u1161\u1163\u1165\u1167\u1169' +
  '\u116d-\u116e\u1172-\u1173\u1175\u119e\u11a8\u11ab\u11ae-\u11af' +
  '\u11b7-\u11b8\u11ba\u11bc-\u11c2\u11eb\u11f0\u11f9\u1e00-\u1e9b' +
  '\u1ea0-\u1ef9\u1f00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d' +
  '\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc' +
  '\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec' +
  '\u1ff2-\u1ff4\u1ff6-\u1ffc\u2126\u212a-\u212b\u212e\u2180-\u2182' +
  '\u3041-\u3094\u30a1-\u30fa\u3105-\u312c\uac00-\ud7a3' :
  'A-Za-z';
var XML10_IDEOGRAPHIC = (REGEXP_UNICODE) ?
  '\u4e00-\u9fa5\u3007\u3021-\u3029' :
  '';
var XML10_COMBINING_CHAR = (REGEXP_UNICODE) ?
  '\u0300-\u0345\u0360-\u0361\u0483-\u0486\u0591-\u05a1\u05a3-\u05b9' +
  '\u05bb-\u05bd\u05bf\u05c1-\u05c2\u05c4\u064b-\u0652\u0670\u06d6-\u06dc' +
  '\u06dd-\u06df\u06e0-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0901-\u0903\u093c' +
  '\u093e-\u094c\u094d\u0951-\u0954\u0962-\u0963\u0981-\u0983\u09bc\u09be' +
  '\u09bf\u09c0-\u09c4\u09c7-\u09c8\u09cb-\u09cd\u09d7\u09e2-\u09e3\u0a02' +
  '\u0a3c\u0a3e\u0a3f\u0a40-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a70-\u0a71' +
  '\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0b01-\u0b03' +
  '\u0b3c\u0b3e-\u0b43\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b82-\u0b83' +
  '\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0c01-\u0c03\u0c3e-\u0c44' +
  '\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c82-\u0c83\u0cbe-\u0cc4' +
  '\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0d02-\u0d03\u0d3e-\u0d43' +
  '\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1' +
  '\u0eb4-\u0eb9\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39' +
  '\u0f3e\u0f3f\u0f71-\u0f84\u0f86-\u0f8b\u0f90-\u0f95\u0f97\u0f99-\u0fad' +
  '\u0fb1-\u0fb7\u0fb9\u20d0-\u20dc\u20e1\u302a-\u302f\u3099\u309a' :
  '';
var XML10_DIGIT = (REGEXP_UNICODE) ?
  '\u0030-\u0039\u0660-\u0669\u06f0-\u06f9\u0966-\u096f\u09e6-\u09ef' +
  '\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be7-\u0bef\u0c66-\u0c6f' +
  '\u0ce6-\u0cef\u0d66-\u0d6f\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29' :
  '0-9';
var XML10_EXTENDER = (REGEXP_UNICODE) ?
  '\u00b7\u02d0\u02d1\u0387\u0640\u0e46\u0ec6\u3005\u3031-\u3035' +
  '\u309d-\u309e\u30fc-\u30fe' :
  '';
var XML10_LETTER = XML10_BASE_CHAR + XML10_IDEOGRAPHIC;
var XML10_NAME_CHAR = XML10_LETTER + XML10_DIGIT + '\\._:' +
                      XML10_COMBINING_CHAR + XML10_EXTENDER + '-';
var XML10_NAME = '[' + XML10_LETTER + '_:][' + XML10_NAME_CHAR + ']*';

var XML10_ENTITY_REF = '&' + XML10_NAME + ';';
var XML10_REFERENCE = XML10_ENTITY_REF + '|' + XML_CHAR_REF;
var XML10_ATT_VALUE = '"(([^<&"]|' + XML10_REFERENCE + ')*)"|' +
                      "'(([^<&']|" + XML10_REFERENCE + ")*)'";
var XML10_ATTRIBUTE =
  '(' + XML10_NAME + ')' + XML_EQ + '(' + XML10_ATT_VALUE + ')';


var XML11_VERSION_INFO = XML_S + 'version' + XML_EQ + '("1\\.1"|' + "'1\\.1')";
var XML11_NAME_START_CHAR = (REGEXP_UNICODE) ?
  ':A-Z_a-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02ff\u0370-\u037d' +
  '\u037f-\u1fff\u200c-\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff' +
  '\uf900-\ufdcf\ufdf0-\ufffd' :
  ':A-Z_a-z';
var XML11_NAME_CHAR = XML11_NAME_START_CHAR +
  ((REGEXP_UNICODE) ? '\\.0-9\u00b7\u0300-\u036f\u203f-\u2040-' : '\\.0-9-');
var XML11_NAME = '[' + XML11_NAME_START_CHAR + '][' + XML11_NAME_CHAR + ']*';

var XML11_ENTITY_REF = '&' + XML11_NAME + ';';
var XML11_REFERENCE = XML11_ENTITY_REF + '|' + XML_CHAR_REF;
var XML11_ATT_VALUE = '"(([^<&"]|' + XML11_REFERENCE + ')*)"|' +
                      "'(([^<&']|" + XML11_REFERENCE + ")*)'";
var XML11_ATTRIBUTE =
  '(' + XML11_NAME + ')' + XML_EQ + '(' + XML11_ATT_VALUE + ')';


var XML_NC_NAME_CHAR = XML10_LETTER + XML10_DIGIT + '\\._' +
                       XML10_COMBINING_CHAR + XML10_EXTENDER + '-';
var XML_NC_NAME = '[' + XML10_LETTER + '_][' + XML_NC_NAME_CHAR + ']*';


function xmlResolveEntities(s) {

  var parts = stringSplit(s, '&');

  var ret = parts[0];
  for (var i = 1; i < parts.length; ++i) {
    var rp = parts[i].indexOf(';');
    if (rp == -1) {
      ret += parts[i];
      continue;
    }

    var entityName = parts[i].substring(0, rp);
    var remainderText = parts[i].substring(rp + 1);

    var ch;
    switch (entityName) {
      case 'lt':
        ch = '<';
        break;
      case 'gt':
        ch = '>';
        break;
      case 'amp':
        ch = '&';
        break;
      case 'quot':
        ch = '"';
        break;
      case 'apos':
        ch = '\'';
        break;
      case 'nbsp':
        ch = String.fromCharCode(160);
        break;
      default:
        var span = domCreateElement(window.document, 'span');
        span.innerHTML = '&' + entityName + '; ';
        ch = span.childNodes[0].nodeValue.charAt(0);
    }
    ret += ch + remainderText;
  }

  return ret;
}

var XML10_TAGNAME_REGEXP = new RegExp('^(' + XML10_NAME + ')');
var XML10_ATTRIBUTE_REGEXP = new RegExp(XML10_ATTRIBUTE, 'g');

var XML11_TAGNAME_REGEXP = new RegExp('^(' + XML11_NAME + ')');
var XML11_ATTRIBUTE_REGEXP = new RegExp(XML11_ATTRIBUTE, 'g');

function xmlParse(xml) {
  var regex_empty = /\/$/;

  var regex_tagname;
  var regex_attribute;
  if (xml.match(/^<\?xml/)) {
    if (xml.search(new RegExp(XML10_VERSION_INFO)) == 5) {
      regex_tagname = XML10_TAGNAME_REGEXP;
      regex_attribute = XML10_ATTRIBUTE_REGEXP;
    } else if (xml.search(new RegExp(XML11_VERSION_INFO)) == 5) {
      regex_tagname = XML11_TAGNAME_REGEXP;
      regex_attribute = XML11_ATTRIBUTE_REGEXP;
    } else {
      alert('VersionInfo is missing, or unknown version number.');
    }
  } else {
    regex_tagname = XML10_TAGNAME_REGEXP;
    regex_attribute = XML10_ATTRIBUTE_REGEXP;
  }

  var xmldoc = new XDocument();
  var root = xmldoc;


  var stack = [];

  var parent = root;
  stack.push(parent);

  var slurp = '';

  var x = stringSplit(xml, '<');
  for (var i = 1; i < x.length; ++i) {
    var xx = stringSplit(x[i], '>');
    var tag = xx[0];
    var text = xmlResolveEntities(xx[1] || '');

    if (slurp) {
      var end = x[i].indexOf(slurp);
      if (end != -1) {
        var data = x[i].substring(0, end);
        parent.nodeValue += '<' + data;
        stack.pop();
        parent = stack[stack.length-1];
        text = x[i].substring(end + slurp.length);
        slurp = '';
      } else {
        parent.nodeValue += '<' + x[i];
        text = null;
      }

    } else if (tag.indexOf('![CDATA[') == 0) {
      var start = '![CDATA['.length;
      var end = x[i].indexOf(']]>');
      if (end != -1) {
        var data = x[i].substring(start, end);
        var node = domCreateCDATASection(xmldoc, data);
        domAppendChild(parent, node);
      } else {
        var data = x[i].substring(start);
        text = null;
        var node = domCreateCDATASection(xmldoc, data);
        domAppendChild(parent, node);
        parent = node;
        stack.push(node);
        slurp = ']]>';
      }

    } else if (tag.indexOf('!--') == 0) {
      var start = '!--'.length;
      var end = x[i].indexOf('-->');
      if (end != -1) {
        var data = x[i].substring(start, end);
        var node = domCreateComment(xmldoc, data);
        domAppendChild(parent, node);
      } else {
        var data = x[i].substring(start);
        text = null;
        var node = domCreateComment(xmldoc, data);
        domAppendChild(parent, node);
        parent = node;
        stack.push(node);
        slurp = '-->';
      }

    } else if (tag.charAt(0) == '/') {
      stack.pop();
      parent = stack[stack.length-1];

    } else if (tag.charAt(0) == '?') {
    } else if (tag.charAt(0) == '!') {
    } else {
      var empty = tag.match(regex_empty);
      var tagname = regex_tagname.exec(tag)[1];
      var node = domCreateElement(xmldoc, tagname);

      var att;
      while (att = regex_attribute.exec(tag)) {
        var val = xmlResolveEntities(att[5] || att[7] || '');
        domSetAttribute(node, att[1], val);
      }

      domAppendChild(parent, node);
      if (!empty) {
        parent = node;
        stack.push(node);
      }
    }

    if (text && parent != root) {
      domAppendChild(parent, domCreateTextNode(xmldoc, text));
    }
  }

  return root;
}

var DOM_ELEMENT_NODE = 1;
var DOM_ATTRIBUTE_NODE = 2;
var DOM_TEXT_NODE = 3;
var DOM_CDATA_SECTION_NODE = 4;
var DOM_ENTITY_REFERENCE_NODE = 5;
var DOM_ENTITY_NODE = 6;
var DOM_PROCESSING_INSTRUCTION_NODE = 7;
var DOM_COMMENT_NODE = 8;
var DOM_DOCUMENT_NODE = 9;
var DOM_DOCUMENT_TYPE_NODE = 10;
var DOM_DOCUMENT_FRAGMENT_NODE = 11;
var DOM_NOTATION_NODE = 12;

function domTraverseElements(node, opt_pre, opt_post) {
  var ret;
  if (opt_pre) {
    ret = opt_pre.call(null, node);
    if (typeof ret == 'boolean' && !ret) {
      return false;
    }
  }

  for (var c = node.firstChild; c; c = c.nextSibling) {
    if (c.nodeType == DOM_ELEMENT_NODE) {
      ret = arguments.callee.call(this, c, opt_pre, opt_post);
      if (typeof ret == 'boolean' && !ret) {
        return false;
      }
    }
  }

  if (opt_post) {
    ret = opt_post.call(null, node);
    if (typeof ret == 'boolean' && !ret) {
      return false;
    }
  }
}

function XNode(type, name, opt_value, opt_owner) {
  this.attributes = [];
  this.childNodes = [];

  XNode.init.call(this, type, name, opt_value, opt_owner);
}

XNode.init = function(type, name, value, owner) {
  this.nodeType = type - 0;
  this.nodeName = '' + name;
  this.nodeValue = '' + value;
  this.ownerDocument = owner;

  this.firstChild = null;
  this.lastChild = null;
  this.nextSibling = null;
  this.previousSibling = null;
  this.parentNode = null;
}

XNode.unused_ = [];

XNode.recycle = function(node) {
  if (!node) {
    return;
  }

  if (node.constructor == XDocument) {
    XNode.recycle(node.documentElement);
    return;
  }

  if (node.constructor != this) {
    return;
  }

  XNode.unused_.push(node);
  for (var a = 0; a < node.attributes.length; ++a) {
    XNode.recycle(node.attributes[a]);
  }
  for (var c = 0; c < node.childNodes.length; ++c) {
    XNode.recycle(node.childNodes[c]);
  }
  node.attributes.length = 0;
  node.childNodes.length = 0;
  XNode.init.call(node, 0, '', '', null);
}

XNode.create = function(type, name, value, owner) {
  if (XNode.unused_.length > 0) {
    var node = XNode.unused_.pop();
    XNode.init.call(node, type, name, value, owner);
    return node;
  } else {
    return new XNode(type, name, value, owner);
  }
}

XNode.prototype.appendChild = function(node) {
  if (this.childNodes.length == 0) {
    this.firstChild = node;
  }

  node.previousSibling = this.lastChild;

  node.nextSibling = null;
  if (this.lastChild) {
    this.lastChild.nextSibling = node;
  }

  node.parentNode = this;

  this.lastChild = node;

  this.childNodes.push(node);
}


XNode.prototype.replaceChild = function(newNode, oldNode) {
  if (oldNode == newNode) {
    return;
  }

  for (var i = 0; i < this.childNodes.length; ++i) {
    if (this.childNodes[i] == oldNode) {
      this.childNodes[i] = newNode;

      var p = oldNode.parentNode;
      oldNode.parentNode = null;
      newNode.parentNode = p;

      p = oldNode.previousSibling;
      oldNode.previousSibling = null;
      newNode.previousSibling = p;
      if (newNode.previousSibling) {
        newNode.previousSibling.nextSibling = newNode;
      }

      p = oldNode.nextSibling;
      oldNode.nextSibling = null;
      newNode.nextSibling = p;
      if (newNode.nextSibling) {
        newNode.nextSibling.previousSibling = newNode;
      }

      if (this.firstChild == oldNode) {
        this.firstChild = newNode;
      }

      if (this.lastChild == oldNode) {
        this.lastChild = newNode;
      }

      break;
    }
  }
}


XNode.prototype.insertBefore = function(newNode, oldNode) {
  if (oldNode == newNode) {
    return;
  }

  if (oldNode.parentNode != this) {
    return;
  }

  if (newNode.parentNode) {
    newNode.parentNode.removeChild(newNode);
  }

  var newChildren = [];
  for (var i = 0; i < this.childNodes.length; ++i) {
    var c = this.childNodes[i];
    if (c == oldNode) {
      newChildren.push(newNode);

      newNode.parentNode = this;

      newNode.previousSibling = oldNode.previousSibling;
      oldNode.previousSibling = newNode;
      if (newNode.previousSibling) {
        newNode.previousSibling.nextSibling = newNode;
      }

      newNode.nextSibling = oldNode;

      if (this.firstChild == oldNode) {
        this.firstChild = newNode;
      }
    }
    newChildren.push(c);
  }
  this.childNodes = newChildren;
}


XNode.prototype.removeChild = function(node) {
  var newChildren = [];
  for (var i = 0; i < this.childNodes.length; ++i) {
    var c = this.childNodes[i];
    if (c != node) {
      newChildren.push(c);
    } else {
      if (c.previousSibling) {
        c.previousSibling.nextSibling = c.nextSibling;
      }
      if (c.nextSibling) {
        c.nextSibling.previousSibling = c.previousSibling;
      }
      if (this.firstChild == c) {
        this.firstChild = c.nextSibling;
      }
      if (this.lastChild == c) {
        this.lastChild = c.previousSibling;
      }
    }
  }
  this.childNodes = newChildren;
}


XNode.prototype.hasAttributes = function() {
  return this.attributes.length > 0;
}


XNode.prototype.setAttribute = function(name, value) {
  for (var i = 0; i < this.attributes.length; ++i) {
    if (this.attributes[i].nodeName == name) {
      this.attributes[i].nodeValue = '' + value;
      return;
    }
  }
  this.attributes.push(XNode.create(DOM_ATTRIBUTE_NODE, name, value, this));
}


XNode.prototype.getAttribute = function(name) {
  for (var i = 0; i < this.attributes.length; ++i) {
    if (this.attributes[i].nodeName == name) {
      return this.attributes[i].nodeValue;
    }
  }
  return null;
}


XNode.prototype.removeAttribute = function(name) {
  var a = [];
  for (var i = 0; i < this.attributes.length; ++i) {
    if (this.attributes[i].nodeName != name) {
      a.push(this.attributes[i]);
    }
  }
  this.attributes = a;
}


XNode.prototype.getElementsByTagName = function(name) {
  var ret = [];
  var self = this;
  if ("*" == name) {
    domTraverseElements(this, function(node) {
      if (self == node) return;
      ret.push(node);
    }, null);
  } else {
    domTraverseElements(this, function(node) {
      if (self == node) return;
      if (node.nodeName == name) {
        ret.push(node);
      }
    }, null);
  }
  return ret;
}


XNode.prototype.getElementById = function(id) {
  var ret = null;
  domTraverseElements(this, function(node) {
    if (node.getAttribute('id') == id) {
      ret = node;
      return false;
    }
  }, null);
  return ret;
}


function XDocument() {
  XNode.call(this, DOM_DOCUMENT_NODE, '#document', null, null);
  this.documentElement = null;
}

XDocument.prototype = new XNode(DOM_DOCUMENT_NODE, '#document');

XDocument.prototype.clear = function() {
  XNode.recycle(this.documentElement);
  this.documentElement = null;
}

XDocument.prototype.appendChild = function(node) {
  XNode.prototype.appendChild.call(this, node);
  this.documentElement = this.childNodes[0];
}

XDocument.prototype.createElement = function(name) {
  return XNode.create(DOM_ELEMENT_NODE, name, null, this);
}

XDocument.prototype.createDocumentFragment = function() {
  return XNode.create(DOM_DOCUMENT_FRAGMENT_NODE, '#document-fragment',
                    null, this);
}

XDocument.prototype.createTextNode = function(value) {
  return XNode.create(DOM_TEXT_NODE, '#text', value, this);
}

XDocument.prototype.createAttribute = function(name) {
  return XNode.create(DOM_ATTRIBUTE_NODE, name, null, this);
}

XDocument.prototype.createComment = function(data) {
  return XNode.create(DOM_COMMENT_NODE, '#comment', data, this);
}

XDocument.prototype.createCDATASection = function(data) {
  return XNode.create(DOM_CDATA_SECTION_NODE, '#cdata-section', data, this);
}



function xpathParse(expr) {
  xpathLog('parse ' + expr);
  xpathParseInit();

  var cached = xpathCacheLookup(expr);
  if (cached) {
    xpathLog(' ... cached');
    return cached;
  }


  if (expr.match(/^(\$|@)?\w+$/i)) {
    var ret = makeSimpleExpr(expr);
    xpathParseCache[expr] = ret;
    xpathLog(' ... simple');
    return ret;
  }

  if (expr.match(/^\w+(\/\w+)*$/i)) {
    var ret = makeSimpleExpr2(expr);
    xpathParseCache[expr] = ret;
    xpathLog(' ... simple 2');
    return ret;
  }

  var cachekey = expr; // expr is modified during parse

  var stack = [];
  var ahead = null;
  var previous = null;
  var done = false;

  var parse_count = 0;
  var lexer_count = 0;
  var reduce_count = 0;

  while (!done) {
    parse_count++;
    expr = expr.replace(/^\s*/, '');
    previous = ahead;
    ahead = null;

    var rule = null;
    var match = '';
    for (var i = 0; i < xpathTokenRules.length; ++i) {
      var result = xpathTokenRules[i].re.exec(expr);
      lexer_count++;
      if (result && result.length > 0 && result[0].length > match.length) {
        rule = xpathTokenRules[i];
        match = result[0];
        break;
      }
    }



    if (rule &&
        (rule == TOK_DIV ||
         rule == TOK_MOD ||
         rule == TOK_AND ||
         rule == TOK_OR) &&
        (!previous ||
         previous.tag == TOK_AT ||
         previous.tag == TOK_DSLASH ||
         previous.tag == TOK_SLASH ||
         previous.tag == TOK_AXIS ||
         previous.tag == TOK_DOLLAR)) {
      rule = TOK_QNAME;
    }

    if (rule) {
      expr = expr.substr(match.length);
      xpathLog('token: ' + match + ' -- ' + rule.label);
      ahead = {
        tag: rule,
        match: match,
        prec: rule.prec ?  rule.prec : 0, // || 0 is removed by the compiler
        expr: makeTokenExpr(match)
      };

    } else {
      xpathLog('DONE');
      done = true;
    }

    while (xpathReduce(stack, ahead)) {
      reduce_count++;
      xpathLog('stack: ' + stackToString(stack));
    }
  }

  xpathLog('stack: ' + stackToString(stack));

  if (stack.length != 1) {
    throw 'XPath parse error ' + cachekey + ':\n' + stackToString(stack);
  }

  var result = stack[0].expr;
  xpathParseCache[cachekey] = result;

  xpathLog('XPath parse: ' + parse_count + ' / ' +
           lexer_count + ' / ' + reduce_count);

  return result;
}

var xpathParseCache = {};

function xpathCacheLookup(expr) {
  return xpathParseCache[expr];
}

/*DGF xpathReduce is where the magic happens in this parser.
Skim down to the bottom of this file to find the table of
grammatical rules and precedence numbers, "The productions of the grammar".

The idea here
is that we want to take a stack of tokens and apply
grammatical rules to them, "reducing" them to higher-level
tokens.  Ultimately, any valid XPath should reduce to exactly one
"Expr" token.

Reduce too early or too late and you'll have two tokens that can't reduce
to single Expr.  For example, you may hastily reduce a qname that
should name a function, incorrectly treating it as a tag name.
Or you may reduce too late, accidentally reducing the last part of the
XPath into a top-level "Expr" that won't reduce with earlier parts of
the XPath.

A "cand" is a grammatical rule candidate, with a given precedence
number.  "ahead" is the upcoming token, which also has a precedence
number.  If the token has a higher precedence number than
the rule candidate, we'll "shift" the token onto the token stack,
instead of immediately applying the rule candidate.

Some tokens have left associativity, in which case we shift when they
have LOWER precedence than the candidate.
*/
function xpathReduce(stack, ahead) {
  var cand = null;

  if (stack.length > 0) {
    var top = stack[stack.length-1];
    var ruleset = xpathRules[top.tag.key];

    if (ruleset) {
      for (var i = 0; i < ruleset.length; ++i) {
        var rule = ruleset[i];
        var match = xpathMatchStack(stack, rule[1]);
        if (match.length) {
          cand = {
            tag: rule[0],
            rule: rule,
            match: match
          };
          cand.prec = xpathGrammarPrecedence(cand);
          break;
        }
      }
    }
  }

  var ret;
  if (cand && (!ahead || cand.prec > ahead.prec ||
               (ahead.tag.left && cand.prec >= ahead.prec))) {
    for (var i = 0; i < cand.match.matchlength; ++i) {
      stack.pop();
    }

    xpathLog('reduce ' + cand.tag.label + ' ' + cand.prec +
             ' ahead ' + (ahead ? ahead.tag.label + ' ' + ahead.prec +
                          (ahead.tag.left ? ' left' : '')
                          : ' none '));

    var matchexpr = mapExpr(cand.match, function(m) { return m.expr; });
    xpathLog('going to apply ' + cand.rule[3].toString());
    cand.expr = cand.rule[3].apply(null, matchexpr);

    stack.push(cand);
    ret = true;

  } else {
    if (ahead) {
      xpathLog('shift ' + ahead.tag.label + ' ' + ahead.prec +
               (ahead.tag.left ? ' left' : '') +
               ' over ' + (cand ? cand.tag.label + ' ' +
                           cand.prec : ' none'));
      stack.push(ahead);
    }
    ret = false;
  }
  return ret;
}

function xpathMatchStack(stack, pattern) {


  var S = stack.length;
  var P = pattern.length;
  var p, s;
  var match = [];
  match.matchlength = 0;
  var ds = 0;
  for (p = P - 1, s = S - 1; p >= 0 && s >= 0; --p, s -= ds) {
    ds = 0;
    var qmatch = [];
    if (pattern[p] == Q_MM) {
      p -= 1;
      match.push(qmatch);
      while (s - ds >= 0 && stack[s - ds].tag == pattern[p]) {
        qmatch.push(stack[s - ds]);
        ds += 1;
        match.matchlength += 1;
      }

    } else if (pattern[p] == Q_01) {
      p -= 1;
      match.push(qmatch);
      while (s - ds >= 0 && ds < 2 && stack[s - ds].tag == pattern[p]) {
        qmatch.push(stack[s - ds]);
        ds += 1;
        match.matchlength += 1;
      }

    } else if (pattern[p] == Q_1M) {
      p -= 1;
      match.push(qmatch);
      if (stack[s].tag == pattern[p]) {
        while (s - ds >= 0 && stack[s - ds].tag == pattern[p]) {
          qmatch.push(stack[s - ds]);
          ds += 1;
          match.matchlength += 1;
        }
      } else {
        return [];
      }

    } else if (stack[s].tag == pattern[p]) {
      match.push(stack[s]);
      ds += 1;
      match.matchlength += 1;

    } else {
      return [];
    }

    reverseInplace(qmatch);
    qmatch.expr = mapExpr(qmatch, function(m) { return m.expr; });
  }

  reverseInplace(match);

  if (p == -1) {
    return match;

  } else {
    return [];
  }
}

function xpathTokenPrecedence(tag) {
  return tag.prec || 2;
}

function xpathGrammarPrecedence(frame) {
  var ret = 0;

  if (frame.rule) { /* normal reduce */
    if (frame.rule.length >= 3 && frame.rule[2] >= 0) {
      ret = frame.rule[2];

    } else {
      for (var i = 0; i < frame.rule[1].length; ++i) {
        var p = xpathTokenPrecedence(frame.rule[1][i]);
        ret = Math.max(ret, p);
      }
    }
  } else if (frame.tag) { /* TOKEN match */
    ret = xpathTokenPrecedence(frame.tag);

  } else if (frame.length) { /* Q_ match */
    for (var j = 0; j < frame.length; ++j) {
      var p = xpathGrammarPrecedence(frame[j]);
      ret = Math.max(ret, p);
    }
  }

  return ret;
}

function stackToString(stack) {
  var ret = '';
  for (var i = 0; i < stack.length; ++i) {
    if (ret) {
      ret += '\n';
    }
    ret += stack[i].tag.label;
  }
  return ret;
}



function ExprContext(node, opt_position, opt_nodelist, opt_parent, opt_caseInsensitive, opt_ignoreAttributesWithoutValue) {
  this.node = node;
  this.position = opt_position || 0;
  this.nodelist = opt_nodelist || [ node ];
  this.variables = {};
  this.parent = opt_parent || null;
  this.caseInsensitive = opt_caseInsensitive || false;
  this.ignoreAttributesWithoutValue = opt_ignoreAttributesWithoutValue || false;
  if (opt_parent) {
    this.root = opt_parent.root;
  } else if (this.node.nodeType == DOM_DOCUMENT_NODE) {
    this.root = node;
  } else {
    this.root = node.ownerDocument;
  }
}

ExprContext.prototype.clone = function(opt_node, opt_position, opt_nodelist) {
  return new ExprContext(
      opt_node || this.node,
      typeof opt_position != 'undefined' ? opt_position : this.position,
      opt_nodelist || this.nodelist, this, this.caseInsensitive,
      this.ignoreAttributesWithoutValue);
};

ExprContext.prototype.setVariable = function(name, value) {
  if (value instanceof StringValue || value instanceof BooleanValue ||
    value instanceof NumberValue || value instanceof NodeSetValue) {
    this.variables[name] = value;
    return;
  }
  if ('true' === value) {
    this.variables[name] = new BooleanValue(true);
  } else if ('false' === value) {
    this.variables[name] = new BooleanValue(false);
  } else if (TOK_NUMBER.re.test(value)) {
    this.variables[name] = new NumberValue(value);
  } else {
    this.variables[name] = new StringValue(value);
  }
};

ExprContext.prototype.getVariable = function(name) {
  if (typeof this.variables[name] != 'undefined') {
    return this.variables[name];

  } else if (this.parent) {
    return this.parent.getVariable(name);

  } else {
    return null;
  }
};

ExprContext.prototype.setNode = function(position) {
  this.node = this.nodelist[position];
  this.position = position;
};

ExprContext.prototype.contextSize = function() {
  return this.nodelist.length;
};

ExprContext.prototype.isCaseInsensitive = function() {
  return this.caseInsensitive;
};

ExprContext.prototype.setCaseInsensitive = function(caseInsensitive) {
  return this.caseInsensitive = caseInsensitive;
};

ExprContext.prototype.isIgnoreAttributesWithoutValue = function() {
  return this.ignoreAttributesWithoutValue;
};

ExprContext.prototype.setIgnoreAttributesWithoutValue = function(ignore) {
  return this.ignoreAttributesWithoutValue = ignore;
};


function StringValue(value) {
  this.value = value;
  this.type = 'string';
}

StringValue.prototype.stringValue = function() {
  return this.value;
}

StringValue.prototype.booleanValue = function() {
  return this.value.length > 0;
}

StringValue.prototype.numberValue = function() {
  return this.value - 0;
}

StringValue.prototype.nodeSetValue = function() {
  throw this;
}

function BooleanValue(value) {
  this.value = value;
  this.type = 'boolean';
}

BooleanValue.prototype.stringValue = function() {
  return '' + this.value;
}

BooleanValue.prototype.booleanValue = function() {
  return this.value;
}

BooleanValue.prototype.numberValue = function() {
  return this.value ? 1 : 0;
}

BooleanValue.prototype.nodeSetValue = function() {
  throw this;
}

function NumberValue(value) {
  this.value = value;
  this.type = 'number';
}

NumberValue.prototype.stringValue = function() {
  return '' + this.value;
}

NumberValue.prototype.booleanValue = function() {
  return !!this.value;
}

NumberValue.prototype.numberValue = function() {
  return this.value - 0;
}

NumberValue.prototype.nodeSetValue = function() {
  throw this;
}

function NodeSetValue(value) {
  this.value = value;
  this.type = 'node-set';
}

NodeSetValue.prototype.stringValue = function() {
  if (this.value.length == 0) {
    return '';
  } else {
    return xmlValue(this.value[0]);
  }
}

NodeSetValue.prototype.booleanValue = function() {
  return this.value.length > 0;
}

NodeSetValue.prototype.numberValue = function() {
  return this.stringValue() - 0;
}

NodeSetValue.prototype.nodeSetValue = function() {
  return this.value;
};


function TokenExpr(m) {
  this.value = m;
}

TokenExpr.prototype.evaluate = function() {
  return new StringValue(this.value);
};

function LocationExpr() {
  this.absolute = false;
  this.steps = [];
}

LocationExpr.prototype.appendStep = function(s) {
  var combinedStep = this._combineSteps(this.steps[this.steps.length-1], s);
  if (combinedStep) {
    this.steps[this.steps.length-1] = combinedStep;
  } else {
    this.steps.push(s);
  }
}

LocationExpr.prototype.prependStep = function(s) {
  var combinedStep = this._combineSteps(s, this.steps[0]);
  if (combinedStep) {
    this.steps[0] = combinedStep;
  } else {
    this.steps.unshift(s);
  }
};

LocationExpr.prototype._combineSteps = function(prevStep, nextStep) {
  if (!prevStep) return null;
  if (!nextStep) return null;
  var hasPredicates = (prevStep.predicates && prevStep.predicates.length > 0);
  if (prevStep.nodetest instanceof NodeTestAny && !hasPredicates) {
    if (prevStep.axis == xpathAxis.DESCENDANT_OR_SELF) {
      if (nextStep.axis == xpathAxis.CHILD) {
        nextStep.axis = xpathAxis.DESCENDANT;
        return nextStep;
      } else if (nextStep.axis == xpathAxis.SELF) {
        nextStep.axis = xpathAxis.DESCENDANT_OR_SELF;
        return nextStep;
      }
    } else if (prevStep.axis == xpathAxis.DESCENDANT) {
      if (nextStep.axis == xpathAxis.SELF) {
        nextStep.axis = xpathAxis.DESCENDANT;
        return nextStep;
      }
    }
  }
  return null;
}

LocationExpr.prototype.evaluate = function(ctx) {
  var start;
  if (this.absolute) {
    start = ctx.root;

  } else {
    start = ctx.node;
  }

  var nodes = [];
  xPathStep(nodes, this.steps, 0, start, ctx);
  return new NodeSetValue(nodes);
};

function xPathStep(nodes, steps, step, input, ctx) {
  var s = steps[step];
  var ctx2 = ctx.clone(input);
  var nodelist = s.evaluate(ctx2).nodeSetValue();

  for (var i = 0; i < nodelist.length; ++i) {
    if (step == steps.length - 1) {
      nodes.push(nodelist[i]);
    } else {
      xPathStep(nodes, steps, step + 1, nodelist[i], ctx);
    }
  }
}

function StepExpr(axis, nodetest, opt_predicate) {
  this.axis = axis;
  this.nodetest = nodetest;
  this.predicate = opt_predicate || [];
}

StepExpr.prototype.appendPredicate = function(p) {
  this.predicate.push(p);
}

StepExpr.prototype.evaluate = function(ctx) {
  var input = ctx.node;
  var nodelist = [];
  var skipNodeTest = false;

  if (this.nodetest instanceof NodeTestAny) {
    skipNodeTest = true;
  }


  if (this.axis ==  xpathAxis.ANCESTOR_OR_SELF) {
    nodelist.push(input);
    for (var n = input.parentNode; n; n = n.parentNode) {
      nodelist.push(n);
    }

  } else if (this.axis == xpathAxis.ANCESTOR) {
    for (var n = input.parentNode; n; n = n.parentNode) {
      nodelist.push(n);
    }

  } else if (this.axis == xpathAxis.ATTRIBUTE) {
    if (ctx.ignoreAttributesWithoutValue) {
      copyArrayIgnoringAttributesWithoutValue(nodelist, input.attributes);
    }
    else {
      copyArray(nodelist, input.attributes);
    }

  } else if (this.axis == xpathAxis.CHILD) {
    copyArray(nodelist, input.childNodes);

  } else if (this.axis == xpathAxis.DESCENDANT_OR_SELF) {
    if (this.nodetest.evaluate(ctx).booleanValue()) {
      nodelist.push(input);
    }
    var tagName = xpathExtractTagNameFromNodeTest(this.nodetest);
    xpathCollectDescendants(nodelist, input, tagName);
    if (tagName) skipNodeTest = true;

  } else if (this.axis == xpathAxis.DESCENDANT) {
    var tagName = xpathExtractTagNameFromNodeTest(this.nodetest);
    xpathCollectDescendants(nodelist, input, tagName);
    if (tagName) skipNodeTest = true;

  } else if (this.axis == xpathAxis.FOLLOWING) {
    for (var n = input; n; n = n.parentNode) {
      for (var nn = n.nextSibling; nn; nn = nn.nextSibling) {
        nodelist.push(nn);
        xpathCollectDescendants(nodelist, nn);
      }
    }

  } else if (this.axis == xpathAxis.FOLLOWING_SIBLING) {
    for (var n = input.nextSibling; n; n = n.nextSibling) {
      nodelist.push(n);
    }

  } else if (this.axis == xpathAxis.NAMESPACE) {
    alert('not implemented: axis namespace');

  } else if (this.axis == xpathAxis.PARENT) {
    if (input.parentNode) {
      nodelist.push(input.parentNode);
    }

  } else if (this.axis == xpathAxis.PRECEDING) {
    for (var n = input; n; n = n.parentNode) {
      for (var nn = n.previousSibling; nn; nn = nn.previousSibling) {
        nodelist.push(nn);
        xpathCollectDescendantsReverse(nodelist, nn);
      }
    }

  } else if (this.axis == xpathAxis.PRECEDING_SIBLING) {
    for (var n = input.previousSibling; n; n = n.previousSibling) {
      nodelist.push(n);
    }

  } else if (this.axis == xpathAxis.SELF) {
    nodelist.push(input);

  } else {
    throw 'ERROR -- NO SUCH AXIS: ' + this.axis;
  }

  if (!skipNodeTest) {
    var nodelist0 = nodelist;
    nodelist = [];
    for (var i = 0; i < nodelist0.length; ++i) {
      var n = nodelist0[i];
      if (this.nodetest.evaluate(ctx.clone(n, i, nodelist0)).booleanValue()) {
        nodelist.push(n);
      }
    }
  }

  for (var i = 0; i < this.predicate.length; ++i) {
    var nodelist0 = nodelist;
    nodelist = [];
    for (var ii = 0; ii < nodelist0.length; ++ii) {
      var n = nodelist0[ii];
      if (this.predicate[i].evaluate(ctx.clone(n, ii, nodelist0)).booleanValue()) {
        nodelist.push(n);
      }
    }
  }

  return new NodeSetValue(nodelist);
};

function NodeTestAny() {
  this.value = new BooleanValue(true);
}

NodeTestAny.prototype.evaluate = function(ctx) {
  return this.value;
};

function NodeTestElementOrAttribute() {}

NodeTestElementOrAttribute.prototype.evaluate = function(ctx) {
  return new BooleanValue(
      ctx.node.nodeType == DOM_ELEMENT_NODE ||
      ctx.node.nodeType == DOM_ATTRIBUTE_NODE);
}

function NodeTestText() {}

NodeTestText.prototype.evaluate = function(ctx) {
  return new BooleanValue(ctx.node.nodeType == DOM_TEXT_NODE);
}

function NodeTestComment() {}

NodeTestComment.prototype.evaluate = function(ctx) {
  return new BooleanValue(ctx.node.nodeType == DOM_COMMENT_NODE);
}

function NodeTestPI(target) {
  this.target = target;
}

NodeTestPI.prototype.evaluate = function(ctx) {
  return new
  BooleanValue(ctx.node.nodeType == DOM_PROCESSING_INSTRUCTION_NODE &&
               (!this.target || ctx.node.nodeName == this.target));
}

function NodeTestNC(nsprefix) {
  this.regex = new RegExp("^" + nsprefix + ":");
  this.nsprefix = nsprefix;
}

NodeTestNC.prototype.evaluate = function(ctx) {
  var n = ctx.node;
  return new BooleanValue(this.regex.match(n.nodeName));
}

function NodeTestName(name) {
  this.name = name;
  this.re = new RegExp('^' + name + '$', "i");
}

NodeTestName.prototype.evaluate = function(ctx) {
  var n = ctx.node;
  if (ctx.caseInsensitive) {
    if (n.nodeName.length != this.name.length) return new BooleanValue(false);
    return new BooleanValue(this.re.test(n.nodeName));
  } else {
    return new BooleanValue(n.nodeName == this.name);
  }
}

function PredicateExpr(expr) {
  this.expr = expr;
}

PredicateExpr.prototype.evaluate = function(ctx) {
  var v = this.expr.evaluate(ctx);
  if (v.type == 'number') {
    return new BooleanValue(ctx.position == v.numberValue() - 1);
  } else {
    return new BooleanValue(v.booleanValue());
  }
};

function FunctionCallExpr(name) {
  this.name = name;
  this.args = [];
}

FunctionCallExpr.prototype.appendArg = function(arg) {
  this.args.push(arg);
};

FunctionCallExpr.prototype.evaluate = function(ctx) {
  var fn = '' + this.name.value;
  var f = this.xpathfunctions[fn];
  if (f) {
    return f.call(this, ctx);
  } else {
    xpathLog('XPath NO SUCH FUNCTION ' + fn);
    return new BooleanValue(false);
  }
};

FunctionCallExpr.prototype.xpathfunctions = {
  'last': function(ctx) {
    assert(this.args.length == 0);
    return new NumberValue(ctx.contextSize());
  },

  'position': function(ctx) {
    assert(this.args.length == 0);
    return new NumberValue(ctx.position + 1);
  },

  'count': function(ctx) {
    assert(this.args.length == 1);
    var v = this.args[0].evaluate(ctx);
    return new NumberValue(v.nodeSetValue().length);
  },

  'id': function(ctx) {
    assert(this.args.length == 1);
    var e = this.args[0].evaluate(ctx);
    var ret = [];
    var ids;
    if (e.type == 'node-set') {
      ids = [];
      var en = e.nodeSetValue();
      for (var i = 0; i < en.length; ++i) {
        var v = xmlValue(en[i]).split(/\s+/);
        for (var ii = 0; ii < v.length; ++ii) {
          ids.push(v[ii]);
        }
      }
    } else {
      ids = e.stringValue().split(/\s+/);
    }
    var d = ctx.root;
    for (var i = 0; i < ids.length; ++i) {
      var n = d.getElementById(ids[i]);
      if (n) {
        ret.push(n);
      }
    }
    return new NodeSetValue(ret);
  },

  'local-name': function(ctx) {
    alert('not implmented yet: XPath function local-name()');
  },

  'namespace-uri': function(ctx) {
    alert('not implmented yet: XPath function namespace-uri()');
  },

  'name': function(ctx) {
    assert(this.args.length == 1 || this.args.length == 0);
    var n;
    if (this.args.length == 0) {
      n = [ ctx.node ];
    } else {
      n = this.args[0].evaluate(ctx).nodeSetValue();
    }

    if (n.length == 0) {
      return new StringValue('');
    } else {
      return new StringValue(n[0].nodeName);
    }
  },

  'string':  function(ctx) {
    assert(this.args.length == 1 || this.args.length == 0);
    if (this.args.length == 0) {
      return new StringValue(new NodeSetValue([ ctx.node ]).stringValue());
    } else {
      return new StringValue(this.args[0].evaluate(ctx).stringValue());
    }
  },

  'concat': function(ctx) {
    var ret = '';
    for (var i = 0; i < this.args.length; ++i) {
      ret += this.args[i].evaluate(ctx).stringValue();
    }
    return new StringValue(ret);
  },

  'starts-with': function(ctx) {
    assert(this.args.length == 2);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).stringValue();
    return new BooleanValue(s0.indexOf(s1) == 0);
  },

  'contains': function(ctx) {
    assert(this.args.length == 2);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).stringValue();
    return new BooleanValue(s0.indexOf(s1) != -1);
  },

  'substring-before': function(ctx) {
    assert(this.args.length == 2);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).stringValue();
    var i = s0.indexOf(s1);
    var ret;
    if (i == -1) {
      ret = '';
    } else {
      ret = s0.substr(0,i);
    }
    return new StringValue(ret);
  },

  'substring-after': function(ctx) {
    assert(this.args.length == 2);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).stringValue();
    var i = s0.indexOf(s1);
    var ret;
    if (i == -1) {
      ret = '';
    } else {
      ret = s0.substr(i + s1.length);
    }
    return new StringValue(ret);
  },

  'substring': function(ctx) {
    assert(this.args.length == 2 || this.args.length == 3);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).numberValue();
    var ret;
    if (this.args.length == 2) {
      var i1 = Math.max(0, Math.round(s1) - 1);
      ret = s0.substr(i1);

    } else {
      var s2 = this.args[2].evaluate(ctx).numberValue();
      var i0 = Math.round(s1) - 1;
      var i1 = Math.max(0, i0);
      var i2 = Math.round(s2) - Math.max(0, -i0);
      ret = s0.substr(i1, i2);
    }
    return new StringValue(ret);
  },

  'string-length': function(ctx) {
    var s;
    if (this.args.length > 0) {
      s = this.args[0].evaluate(ctx).stringValue();
    } else {
      s = new NodeSetValue([ ctx.node ]).stringValue();
    }
    return new NumberValue(s.length);
  },

  'normalize-space': function(ctx) {
    var s;
    if (this.args.length > 0) {
      s = this.args[0].evaluate(ctx).stringValue();
    } else {
      s = new NodeSetValue([ ctx.node ]).stringValue();
    }
    s = s.replace(/^\s*/,'').replace(/\s*$/,'').replace(/\s+/g, ' ');
    return new StringValue(s);
  },

  'translate': function(ctx) {
    assert(this.args.length == 3);
    var s0 = this.args[0].evaluate(ctx).stringValue();
    var s1 = this.args[1].evaluate(ctx).stringValue();
    var s2 = this.args[2].evaluate(ctx).stringValue();

    for (var i = 0; i < s1.length; ++i) {
      s0 = s0.replace(new RegExp(s1.charAt(i), 'g'), s2.charAt(i));
    }
    return new StringValue(s0);
  },

  'boolean': function(ctx) {
    assert(this.args.length == 1);
    return new BooleanValue(this.args[0].evaluate(ctx).booleanValue());
  },

  'not': function(ctx) {
    assert(this.args.length == 1);
    var ret = !this.args[0].evaluate(ctx).booleanValue();
    return new BooleanValue(ret);
  },

  'true': function(ctx) {
    assert(this.args.length == 0);
    return new BooleanValue(true);
  },

  'false': function(ctx) {
    assert(this.args.length == 0);
    return new BooleanValue(false);
  },

  'lang': function(ctx) {
    assert(this.args.length == 1);
    var lang = this.args[0].evaluate(ctx).stringValue();
    var xmllang;
    var n = ctx.node;
    while (n && n != n.parentNode /* just in case ... */) {
      xmllang = n.getAttribute('xml:lang');
      if (xmllang) {
        break;
      }
      n = n.parentNode;
    }
    if (!xmllang) {
      return new BooleanValue(false);
    } else {
      var re = new RegExp('^' + lang + '$', 'i');
      return new BooleanValue(xmllang.match(re) ||
                              xmllang.replace(/_.*$/,'').match(re));
    }
  },

  'number': function(ctx) {
    assert(this.args.length == 1 || this.args.length == 0);

    if (this.args.length == 1) {
      return new NumberValue(this.args[0].evaluate(ctx).numberValue());
    } else {
      return new NumberValue(new NodeSetValue([ ctx.node ]).numberValue());
    }
  },

  'sum': function(ctx) {
    assert(this.args.length == 1);
    var n = this.args[0].evaluate(ctx).nodeSetValue();
    var sum = 0;
    for (var i = 0; i < n.length; ++i) {
      sum += xmlValue(n[i]) - 0;
    }
    return new NumberValue(sum);
  },

  'floor': function(ctx) {
    assert(this.args.length == 1);
    var num = this.args[0].evaluate(ctx).numberValue();
    return new NumberValue(Math.floor(num));
  },

  'ceiling': function(ctx) {
    assert(this.args.length == 1);
    var num = this.args[0].evaluate(ctx).numberValue();
    return new NumberValue(Math.ceil(num));
  },

  'round': function(ctx) {
    assert(this.args.length == 1);
    var num = this.args[0].evaluate(ctx).numberValue();
    return new NumberValue(Math.round(num));
  },


  'ext-join': function(ctx) {
    assert(this.args.length == 2);
    var nodes = this.args[0].evaluate(ctx).nodeSetValue();
    var delim = this.args[1].evaluate(ctx).stringValue();
    var ret = '';
    for (var i = 0; i < nodes.length; ++i) {
      if (ret) {
        ret += delim;
      }
      ret += xmlValue(nodes[i]);
    }
    return new StringValue(ret);
  },


  'ext-if': function(ctx) {
    assert(this.args.length == 3);
    if (this.args[0].evaluate(ctx).booleanValue()) {
      return this.args[1].evaluate(ctx);
    } else {
      return this.args[2].evaluate(ctx);
    }
  },


  'ext-cardinal': function(ctx) {
    assert(this.args.length >= 1);
    var c = this.args[0].evaluate(ctx).numberValue();
    var ret = [];
    for (var i = 0; i < c; ++i) {
      ret.push(ctx.node);
    }
    return new NodeSetValue(ret);
  }
};

function UnionExpr(expr1, expr2) {
  this.expr1 = expr1;
  this.expr2 = expr2;
}

UnionExpr.prototype.evaluate = function(ctx) {
  var nodes1 = this.expr1.evaluate(ctx).nodeSetValue();
  var nodes2 = this.expr2.evaluate(ctx).nodeSetValue();
  var I1 = nodes1.length;
  for (var i2 = 0; i2 < nodes2.length; ++i2) {
    var n = nodes2[i2];
    var inBoth = false;
    for (var i1 = 0; i1 < I1; ++i1) {
      if (nodes1[i1] == n) {
        inBoth = true;
        i1 = I1; // break inner loop
      }
    }
    if (!inBoth) {
      nodes1.push(n);
    }
  }
  return new NodeSetValue(nodes1);
};

function PathExpr(filter, rel) {
  this.filter = filter;
  this.rel = rel;
}

PathExpr.prototype.evaluate = function(ctx) {
  var nodes = this.filter.evaluate(ctx).nodeSetValue();
  var nodes1 = [];
  for (var i = 0; i < nodes.length; ++i) {
    var nodes0 = this.rel.evaluate(ctx.clone(nodes[i], i, nodes)).nodeSetValue();
    for (var ii = 0; ii < nodes0.length; ++ii) {
      nodes1.push(nodes0[ii]);
    }
  }
  return new NodeSetValue(nodes1);
};

function FilterExpr(expr, predicate) {
  this.expr = expr;
  this.predicate = predicate;
}

FilterExpr.prototype.evaluate = function(ctx) {
  var nodes = this.expr.evaluate(ctx).nodeSetValue();
  for (var i = 0; i < this.predicate.length; ++i) {
    var nodes0 = nodes;
    nodes = [];
    for (var j = 0; j < nodes0.length; ++j) {
      var n = nodes0[j];
      if (this.predicate[i].evaluate(ctx.clone(n, j, nodes0)).booleanValue()) {
        nodes.push(n);
      }
    }
  }

  return new NodeSetValue(nodes);
}

function UnaryMinusExpr(expr) {
  this.expr = expr;
}

UnaryMinusExpr.prototype.evaluate = function(ctx) {
  return new NumberValue(-this.expr.evaluate(ctx).numberValue());
};

function BinaryExpr(expr1, op, expr2) {
  this.expr1 = expr1;
  this.expr2 = expr2;
  this.op = op;
}

BinaryExpr.prototype.evaluate = function(ctx) {
  var ret;
  switch (this.op.value) {
    case 'or':
      ret = new BooleanValue(this.expr1.evaluate(ctx).booleanValue() ||
                             this.expr2.evaluate(ctx).booleanValue());
      break;

    case 'and':
      ret = new BooleanValue(this.expr1.evaluate(ctx).booleanValue() &&
                             this.expr2.evaluate(ctx).booleanValue());
      break;

    case '+':
      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() +
                            this.expr2.evaluate(ctx).numberValue());
      break;

    case '-':
      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() -
                            this.expr2.evaluate(ctx).numberValue());
      break;

    case '*':
      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() *
                            this.expr2.evaluate(ctx).numberValue());
      break;

    case 'mod':
      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() %
                            this.expr2.evaluate(ctx).numberValue());
      break;

    case 'div':
      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() /
                            this.expr2.evaluate(ctx).numberValue());
      break;

    case '=':
      ret = this.compare(ctx, function(x1, x2) { return x1 == x2; });
      break;

    case '!=':
      ret = this.compare(ctx, function(x1, x2) { return x1 != x2; });
      break;

    case '<':
      ret = this.compare(ctx, function(x1, x2) { return x1 < x2; });
      break;

    case '<=':
      ret = this.compare(ctx, function(x1, x2) { return x1 <= x2; });
      break;

    case '>':
      ret = this.compare(ctx, function(x1, x2) { return x1 > x2; });
      break;

    case '>=':
      ret = this.compare(ctx, function(x1, x2) { return x1 >= x2; });
      break;

    default:
      alert('BinaryExpr.evaluate: ' + this.op.value);
  }
  return ret;
};

BinaryExpr.prototype.compare = function(ctx, cmp) {
  var v1 = this.expr1.evaluate(ctx);
  var v2 = this.expr2.evaluate(ctx);

  var ret;
  if (v1.type == 'node-set' && v2.type == 'node-set') {
    var n1 = v1.nodeSetValue();
    var n2 = v2.nodeSetValue();
    ret = false;
    for (var i1 = 0; i1 < n1.length; ++i1) {
      for (var i2 = 0; i2 < n2.length; ++i2) {
        if (cmp(xmlValue(n1[i1]), xmlValue(n2[i2]))) {
          ret = true;
          i2 = n2.length;
          i1 = n1.length;
        }
      }
    }

  } else if (v1.type == 'node-set' || v2.type == 'node-set') {

    if (v1.type == 'number') {
      var s = v1.numberValue();
      var n = v2.nodeSetValue();

      ret = false;
      for (var i = 0;  i < n.length; ++i) {
        var nn = xmlValue(n[i]) - 0;
        if (cmp(s, nn)) {
          ret = true;
          break;
        }
      }

    } else if (v2.type == 'number') {
      var n = v1.nodeSetValue();
      var s = v2.numberValue();

      ret = false;
      for (var i = 0;  i < n.length; ++i) {
        var nn = xmlValue(n[i]) - 0;
        if (cmp(nn, s)) {
          ret = true;
          break;
        }
      }

    } else if (v1.type == 'string') {
      var s = v1.stringValue();
      var n = v2.nodeSetValue();

      ret = false;
      for (var i = 0;  i < n.length; ++i) {
        var nn = xmlValue(n[i]);
        if (cmp(s, nn)) {
          ret = true;
          break;
        }
      }

    } else if (v2.type == 'string') {
      var n = v1.nodeSetValue();
      var s = v2.stringValue();

      ret = false;
      for (var i = 0;  i < n.length; ++i) {
        var nn = xmlValue(n[i]);
        if (cmp(nn, s)) {
          ret = true;
          break;
        }
      }

    } else {
      ret = cmp(v1.booleanValue(), v2.booleanValue());
    }

  } else if (v1.type == 'boolean' || v2.type == 'boolean') {
    ret = cmp(v1.booleanValue(), v2.booleanValue());

  } else if (v1.type == 'number' || v2.type == 'number') {
    ret = cmp(v1.numberValue(), v2.numberValue());

  } else {
    ret = cmp(v1.stringValue(), v2.stringValue());
  }

  return new BooleanValue(ret);
}

function LiteralExpr(value) {
  this.value = value;
}

LiteralExpr.prototype.evaluate = function(ctx) {
  return new StringValue(this.value);
};

function NumberExpr(value) {
  this.value = value;
}

NumberExpr.prototype.evaluate = function(ctx) {
  return new NumberValue(this.value);
};

function VariableExpr(name) {
  this.name = name;
}

VariableExpr.prototype.evaluate = function(ctx) {
  return ctx.getVariable(this.name);
}


function makeTokenExpr(m) {
  return new TokenExpr(m);
}

function passExpr(e) {
  return e;
}

function makeLocationExpr1(slash, rel) {
  rel.absolute = true;
  return rel;
}

function makeLocationExpr2(dslash, rel) {
  rel.absolute = true;
  rel.prependStep(makeAbbrevStep(dslash.value));
  return rel;
}

function makeLocationExpr3(slash) {
  var ret = new LocationExpr();
  ret.appendStep(makeAbbrevStep('.'));
  ret.absolute = true;
  return ret;
}

function makeLocationExpr4(dslash) {
  var ret = new LocationExpr();
  ret.absolute = true;
  ret.appendStep(makeAbbrevStep(dslash.value));
  return ret;
}

function makeLocationExpr5(step) {
  var ret = new LocationExpr();
  ret.appendStep(step);
  return ret;
}

function makeLocationExpr6(rel, slash, step) {
  rel.appendStep(step);
  return rel;
}

function makeLocationExpr7(rel, dslash, step) {
  rel.appendStep(makeAbbrevStep(dslash.value));
  rel.appendStep(step);
  return rel;
}

function makeStepExpr1(dot) {
  return makeAbbrevStep(dot.value);
}

function makeStepExpr2(ddot) {
  return makeAbbrevStep(ddot.value);
}

function makeStepExpr3(axisname, axis, nodetest) {
  return new StepExpr(axisname.value, nodetest);
}

function makeStepExpr4(at, nodetest) {
  return new StepExpr('attribute', nodetest);
}

function makeStepExpr5(nodetest) {
  return new StepExpr('child', nodetest);
}

function makeStepExpr6(step, predicate) {
  step.appendPredicate(predicate);
  return step;
}

function makeAbbrevStep(abbrev) {
  switch (abbrev) {
  case '//':
    return new StepExpr('descendant-or-self', new NodeTestAny);

  case '.':
    return new StepExpr('self', new NodeTestAny);

  case '..':
    return new StepExpr('parent', new NodeTestAny);
  }
}

function makeNodeTestExpr1(asterisk) {
  return new NodeTestElementOrAttribute;
}

function makeNodeTestExpr2(ncname, colon, asterisk) {
  return new NodeTestNC(ncname.value);
}

function makeNodeTestExpr3(qname) {
  return new NodeTestName(qname.value);
}

function makeNodeTestExpr4(typeo, parenc) {
  var type = typeo.value.replace(/\s*\($/, '');
  switch(type) {
  case 'node':
    return new NodeTestAny;

  case 'text':
    return new NodeTestText;

  case 'comment':
    return new NodeTestComment;

  case 'processing-instruction':
    return new NodeTestPI('');
  }
}

function makeNodeTestExpr5(typeo, target, parenc) {
  var type = typeo.replace(/\s*\($/, '');
  if (type != 'processing-instruction') {
    throw type;
  }
  return new NodeTestPI(target.value);
}

function makePredicateExpr(pareno, expr, parenc) {
  return new PredicateExpr(expr);
}

function makePrimaryExpr(pareno, expr, parenc) {
  return expr;
}

function makeFunctionCallExpr1(name, pareno, parenc) {
  return new FunctionCallExpr(name);
}

function makeFunctionCallExpr2(name, pareno, arg1, args, parenc) {
  var ret = new FunctionCallExpr(name);
  ret.appendArg(arg1);
  for (var i = 0; i < args.length; ++i) {
    ret.appendArg(args[i]);
  }
  return ret;
}

function makeArgumentExpr(comma, expr) {
  return expr;
}

function makeUnionExpr(expr1, pipe, expr2) {
  return new UnionExpr(expr1, expr2);
}

function makePathExpr1(filter, slash, rel) {
  return new PathExpr(filter, rel);
}

function makePathExpr2(filter, dslash, rel) {
  rel.prependStep(makeAbbrevStep(dslash.value));
  return new PathExpr(filter, rel);
}

function makeFilterExpr(expr, predicates) {
  if (predicates.length > 0) {
    return new FilterExpr(expr, predicates);
  } else {
    return expr;
  }
}

function makeUnaryMinusExpr(minus, expr) {
  return new UnaryMinusExpr(expr);
}

function makeBinaryExpr(expr1, op, expr2) {
  return new BinaryExpr(expr1, op, expr2);
}

function makeLiteralExpr(token) {
  var value = token.value.substring(1, token.value.length - 1);
  return new LiteralExpr(value);
}

function makeNumberExpr(token) {
  return new NumberExpr(token.value);
}

function makeVariableReference(dollar, name) {
  return new VariableExpr(name.value);
}

function makeSimpleExpr(expr) {
  if (expr.charAt(0) == '$') {
    return new VariableExpr(expr.substr(1));
  } else if (expr.charAt(0) == '@') {
    var a = new NodeTestName(expr.substr(1));
    var b = new StepExpr('attribute', a);
    var c = new LocationExpr();
    c.appendStep(b);
    return c;
  } else if (expr.match(/^[0-9]+$/)) {
    return new NumberExpr(expr);
  } else {
    var a = new NodeTestName(expr);
    var b = new StepExpr('child', a);
    var c = new LocationExpr();
    c.appendStep(b);
    return c;
  }
}

function makeSimpleExpr2(expr) {
  var steps = stringSplit(expr, '/');
  var c = new LocationExpr();
  for (var i = 0; i < steps.length; ++i) {
    var a = new NodeTestName(steps[i]);
    var b = new StepExpr('child', a);
    c.appendStep(b);
  }
  return c;
}


var xpathAxis = {
  ANCESTOR_OR_SELF: 'ancestor-or-self',
  ANCESTOR: 'ancestor',
  ATTRIBUTE: 'attribute',
  CHILD: 'child',
  DESCENDANT_OR_SELF: 'descendant-or-self',
  DESCENDANT: 'descendant',
  FOLLOWING_SIBLING: 'following-sibling',
  FOLLOWING: 'following',
  NAMESPACE: 'namespace',
  PARENT: 'parent',
  PRECEDING_SIBLING: 'preceding-sibling',
  PRECEDING: 'preceding',
  SELF: 'self'
};

var xpathAxesRe = [
    xpathAxis.ANCESTOR_OR_SELF,
    xpathAxis.ANCESTOR,
    xpathAxis.ATTRIBUTE,
    xpathAxis.CHILD,
    xpathAxis.DESCENDANT_OR_SELF,
    xpathAxis.DESCENDANT,
    xpathAxis.FOLLOWING_SIBLING,
    xpathAxis.FOLLOWING,
    xpathAxis.NAMESPACE,
    xpathAxis.PARENT,
    xpathAxis.PRECEDING_SIBLING,
    xpathAxis.PRECEDING,
    xpathAxis.SELF
].join('|');




var TOK_PIPE =   { label: "|",   prec:   17, re: new RegExp("^\\|") };
var TOK_DSLASH = { label: "//",  prec:   19, re: new RegExp("^//")  };
var TOK_SLASH =  { label: "/",   prec:   30, re: new RegExp("^/")   };
var TOK_AXIS =   { label: "::",  prec:   20, re: new RegExp("^::")  };
var TOK_COLON =  { label: ":",   prec: 1000, re: new RegExp("^:")  };
var TOK_AXISNAME = { label: "[axis]", re: new RegExp('^(' + xpathAxesRe + ')') };
var TOK_PARENO = { label: "(",   prec:   34, re: new RegExp("^\\(") };
var TOK_PARENC = { label: ")",               re: new RegExp("^\\)") };
var TOK_DDOT =   { label: "..",  prec:   34, re: new RegExp("^\\.\\.") };
var TOK_DOT =    { label: ".",   prec:   34, re: new RegExp("^\\.") };
var TOK_AT =     { label: "@",   prec:   34, re: new RegExp("^@")   };

var TOK_COMMA =  { label: ",",               re: new RegExp("^,") };

var TOK_OR =     { label: "or",  prec:   10, re: new RegExp("^or\\b") };
var TOK_AND =    { label: "and", prec:   11, re: new RegExp("^and\\b") };
var TOK_EQ =     { label: "=",   prec:   12, re: new RegExp("^=")   };
var TOK_NEQ =    { label: "!=",  prec:   12, re: new RegExp("^!=")  };
var TOK_GE =     { label: ">=",  prec:   13, re: new RegExp("^>=")  };
var TOK_GT =     { label: ">",   prec:   13, re: new RegExp("^>")   };
var TOK_LE =     { label: "<=",  prec:   13, re: new RegExp("^<=")  };
var TOK_LT =     { label: "<",   prec:   13, re: new RegExp("^<")   };
var TOK_PLUS =   { label: "+",   prec:   14, re: new RegExp("^\\+"), left: true };
var TOK_MINUS =  { label: "-",   prec:   14, re: new RegExp("^\\-"), left: true };
var TOK_DIV =    { label: "div", prec:   15, re: new RegExp("^div\\b"), left: true };
var TOK_MOD =    { label: "mod", prec:   15, re: new RegExp("^mod\\b"), left: true };

var TOK_BRACKO = { label: "[",   prec:   32, re: new RegExp("^\\[") };
var TOK_BRACKC = { label: "]",               re: new RegExp("^\\]") };
var TOK_DOLLAR = { label: "$",               re: new RegExp("^\\$") };

var TOK_NCNAME = { label: "[ncname]", re: new RegExp('^' + XML_NC_NAME) };

var TOK_ASTERISK = { label: "*", prec: 15, re: new RegExp("^\\*"), left: true };
var TOK_LITERALQ = { label: "[litq]", prec: 20, re: new RegExp("^'[^\\']*'") };
var TOK_LITERALQQ = {
  label: "[litqq]",
  prec: 20,
  re: new RegExp('^"[^\\"]*"')
};

var TOK_NUMBER  = {
  label: "[number]",
  prec: 35,
  re: new RegExp('^\\d+(\\.\\d*)?') };

var TOK_QNAME = {
  label: "[qname]",
  re: new RegExp('^(' + XML_NC_NAME + ':)?' + XML_NC_NAME)
};

var TOK_NODEO = {
  label: "[nodetest-start]",
  re: new RegExp('^(processing-instruction|comment|text|node)\\(')
};


var xpathTokenRules = [
    TOK_DSLASH,
    TOK_SLASH,
    TOK_DDOT,
    TOK_DOT,
    TOK_AXIS,
    TOK_COLON,
    TOK_AXISNAME,
    TOK_NODEO,
    TOK_PARENO,
    TOK_PARENC,
    TOK_BRACKO,
    TOK_BRACKC,
    TOK_AT,
    TOK_COMMA,
    TOK_OR,
    TOK_AND,
    TOK_NEQ,
    TOK_EQ,
    TOK_GE,
    TOK_GT,
    TOK_LE,
    TOK_LT,
    TOK_PLUS,
    TOK_MINUS,
    TOK_ASTERISK,
    TOK_PIPE,
    TOK_MOD,
    TOK_DIV,
    TOK_LITERALQ,
    TOK_LITERALQQ,
    TOK_NUMBER,
    TOK_QNAME,
    TOK_NCNAME,
    TOK_DOLLAR
];

var XPathLocationPath = { label: "LocationPath" };
var XPathRelativeLocationPath = { label: "RelativeLocationPath" };
var XPathAbsoluteLocationPath = { label: "AbsoluteLocationPath" };
var XPathStep = { label: "Step" };
var XPathNodeTest = { label: "NodeTest" };
var XPathPredicate = { label: "Predicate" };
var XPathLiteral = { label: "Literal" };
var XPathExpr = { label: "Expr" };
var XPathPrimaryExpr = { label: "PrimaryExpr" };
var XPathVariableReference = { label: "Variablereference" };
var XPathNumber = { label: "Number" };
var XPathFunctionCall = { label: "FunctionCall" };
var XPathArgumentRemainder = { label: "ArgumentRemainder" };
var XPathPathExpr = { label: "PathExpr" };
var XPathUnionExpr = { label: "UnionExpr" };
var XPathFilterExpr = { label: "FilterExpr" };
var XPathDigits = { label: "Digits" };

var xpathNonTerminals = [
    XPathLocationPath,
    XPathRelativeLocationPath,
    XPathAbsoluteLocationPath,
    XPathStep,
    XPathNodeTest,
    XPathPredicate,
    XPathLiteral,
    XPathExpr,
    XPathPrimaryExpr,
    XPathVariableReference,
    XPathNumber,
    XPathFunctionCall,
    XPathArgumentRemainder,
    XPathPathExpr,
    XPathUnionExpr,
    XPathFilterExpr,
    XPathDigits
];

var Q_01 = { label: "?" };
var Q_MM = { label: "*" };
var Q_1M = { label: "+" };

var ASSOC_LEFT = true;



var xpathGrammarRules =
  [
   [ XPathLocationPath, [ XPathRelativeLocationPath ], 18,
     passExpr ],
   [ XPathLocationPath, [ XPathAbsoluteLocationPath ], 18,
     passExpr ],

   [ XPathAbsoluteLocationPath, [ TOK_SLASH, XPathRelativeLocationPath ], 18,
     makeLocationExpr1 ],
   [ XPathAbsoluteLocationPath, [ TOK_DSLASH, XPathRelativeLocationPath ], 18,
     makeLocationExpr2 ],

   [ XPathAbsoluteLocationPath, [ TOK_SLASH ], 0,
     makeLocationExpr3 ],
   [ XPathAbsoluteLocationPath, [ TOK_DSLASH ], 0,
     makeLocationExpr4 ],

   [ XPathRelativeLocationPath, [ XPathStep ], 31,
     makeLocationExpr5 ],
   [ XPathRelativeLocationPath,
     [ XPathRelativeLocationPath, TOK_SLASH, XPathStep ], 31,
     makeLocationExpr6 ],
   [ XPathRelativeLocationPath,
     [ XPathRelativeLocationPath, TOK_DSLASH, XPathStep ], 31,
     makeLocationExpr7 ],

   [ XPathStep, [ TOK_DOT ], 33,
     makeStepExpr1 ],
   [ XPathStep, [ TOK_DDOT ], 33,
     makeStepExpr2 ],
   [ XPathStep,
     [ TOK_AXISNAME, TOK_AXIS, XPathNodeTest ], 33,
     makeStepExpr3 ],
   [ XPathStep, [ TOK_AT, XPathNodeTest ], 33,
     makeStepExpr4 ],
   [ XPathStep, [ XPathNodeTest ], 33,
     makeStepExpr5 ],
   [ XPathStep, [ XPathStep, XPathPredicate ], 33,
     makeStepExpr6 ],

   [ XPathNodeTest, [ TOK_ASTERISK ], 33,
     makeNodeTestExpr1 ],
   [ XPathNodeTest, [ TOK_NCNAME, TOK_COLON, TOK_ASTERISK ], 33,
     makeNodeTestExpr2 ],
   [ XPathNodeTest, [ TOK_QNAME ], 33,
     makeNodeTestExpr3 ],
   [ XPathNodeTest, [ TOK_NODEO, TOK_PARENC ], 33,
     makeNodeTestExpr4 ],
   [ XPathNodeTest, [ TOK_NODEO, XPathLiteral, TOK_PARENC ], 33,
     makeNodeTestExpr5 ],

   [ XPathPredicate, [ TOK_BRACKO, XPathExpr, TOK_BRACKC ], 33,
     makePredicateExpr ],

   [ XPathPrimaryExpr, [ XPathVariableReference ], 33,
     passExpr ],
   [ XPathPrimaryExpr, [ TOK_PARENO, XPathExpr, TOK_PARENC ], 33,
     makePrimaryExpr ],
   [ XPathPrimaryExpr, [ XPathLiteral ], 30,
     passExpr ],
   [ XPathPrimaryExpr, [ XPathNumber ], 30,
     passExpr ],
   [ XPathPrimaryExpr, [ XPathFunctionCall ], 31,
     passExpr ],

   [ XPathFunctionCall, [ TOK_QNAME, TOK_PARENO, TOK_PARENC ], -1,
     makeFunctionCallExpr1 ],
   [ XPathFunctionCall,
     [ TOK_QNAME, TOK_PARENO, XPathExpr, XPathArgumentRemainder, Q_MM,
       TOK_PARENC ], -1,
     makeFunctionCallExpr2 ],
   [ XPathArgumentRemainder, [ TOK_COMMA, XPathExpr ], -1,
     makeArgumentExpr ],

   [ XPathUnionExpr, [ XPathPathExpr ], 20,
     passExpr ],
   [ XPathUnionExpr, [ XPathUnionExpr, TOK_PIPE, XPathPathExpr ], 20,
     makeUnionExpr ],

   [ XPathPathExpr, [ XPathLocationPath ], 20,
     passExpr ],
   [ XPathPathExpr, [ XPathFilterExpr ], 19,
     passExpr ],
   [ XPathPathExpr,
     [ XPathFilterExpr, TOK_SLASH, XPathRelativeLocationPath ], 19,
     makePathExpr1 ],
   [ XPathPathExpr,
     [ XPathFilterExpr, TOK_DSLASH, XPathRelativeLocationPath ], 19,
     makePathExpr2 ],

   [ XPathFilterExpr, [ XPathPrimaryExpr, XPathPredicate, Q_MM ], 31,
     makeFilterExpr ],

   [ XPathExpr, [ XPathPrimaryExpr ], 16,
     passExpr ],
   [ XPathExpr, [ XPathUnionExpr ], 16,
     passExpr ],

   [ XPathExpr, [ TOK_MINUS, XPathExpr ], -1,
     makeUnaryMinusExpr ],

   [ XPathExpr, [ XPathExpr, TOK_OR, XPathExpr ], -1,
     makeBinaryExpr ],
   [ XPathExpr, [ XPathExpr, TOK_AND, XPathExpr ], -1,
     makeBinaryExpr ],

   [ XPathExpr, [ XPathExpr, TOK_EQ, XPathExpr ], -1,
     makeBinaryExpr ],
   [ XPathExpr, [ XPathExpr, TOK_NEQ, XPathExpr ], -1,
     makeBinaryExpr ],

   [ XPathExpr, [ XPathExpr, TOK_LT, XPathExpr ], -1,
     makeBinaryExpr ],
   [ XPathExpr, [ XPathExpr, TOK_LE, XPathExpr ], -1,
     makeBinaryExpr ],
   [ XPathExpr, [ XPathExpr, TOK_GT, XPathExpr ], -1,
     makeBinaryExpr ],
   [ XPathExpr, [ XPathExpr, TOK_GE, XPathExpr ], -1,
     makeBinaryExpr ],

   [ XPathExpr, [ XPathExpr, TOK_PLUS, XPathExpr ], -1,
     makeBinaryExpr, ASSOC_LEFT ],
   [ XPathExpr, [ XPathExpr, TOK_MINUS, XPathExpr ], -1,
     makeBinaryExpr, ASSOC_LEFT ],

    [ XPathExpr, [ XPathExpr, TOK_ASTERISK], 0,
      passExpr, ASSOC_LEFT ],
   [ XPathExpr, [ XPathExpr, TOK_ASTERISK, XPathExpr ], -1,
     makeBinaryExpr, ASSOC_LEFT ],
   [ XPathExpr, [ XPathExpr, TOK_DIV, XPathExpr ], -1,
     makeBinaryExpr, ASSOC_LEFT ],
   [ XPathExpr, [ XPathExpr, TOK_MOD, XPathExpr ], -1,
     makeBinaryExpr, ASSOC_LEFT ],

   [ XPathLiteral, [ TOK_LITERALQ ], -1,
     makeLiteralExpr ],
   [ XPathLiteral, [ TOK_LITERALQQ ], -1,
     makeLiteralExpr ],

   [ XPathNumber, [ TOK_NUMBER ], -1,
     makeNumberExpr ],

   [ XPathVariableReference, [ TOK_DOLLAR, TOK_QNAME ], 200,
     makeVariableReference ]
   ];


var xpathRules = [];

function xpathParseInit() {
  if (xpathRules.length) {
    return;
  }


  xpathGrammarRules.sort(function(a,b) {
    var la = a[1].length;
    var lb = b[1].length;
    if (la < lb) {
      return 1;
    } else if (la > lb) {
      return -1;
    } else {
      return 0;
    }
  });

  var k = 1;
  for (var i = 0; i < xpathNonTerminals.length; ++i) {
    xpathNonTerminals[i].key = k++;
  }

  for (i = 0; i < xpathTokenRules.length; ++i) {
    xpathTokenRules[i].key = k++;
  }

  xpathLog('XPath parse INIT: ' + k + ' rules');


  function push_(array, position, element) {
    if (!array[position]) {
      array[position] = [];
    }
    array[position].push(element);
  }

  for (i = 0; i < xpathGrammarRules.length; ++i) {
    var rule = xpathGrammarRules[i];
    var pattern = rule[1];

    for (var j = pattern.length - 1; j >= 0; --j) {
      if (pattern[j] == Q_1M) {
        push_(xpathRules, pattern[j-1].key, rule);
        break;

      } else if (pattern[j] == Q_MM || pattern[j] == Q_01) {
        push_(xpathRules, pattern[j-1].key, rule);
        --j;

      } else {
        push_(xpathRules, pattern[j].key, rule);
        break;
      }
    }
  }

  xpathLog('XPath parse INIT: ' + xpathRules.length + ' rule bins');

  var sum = 0;
  mapExec(xpathRules, function(i) {
    if (i) {
      sum += i.length;
    }
  });

  xpathLog('XPath parse INIT: ' + (sum / xpathRules.length) +
           ' average bin size');
}


function xpathCollectDescendants(nodelist, node, opt_tagName) {
  if (opt_tagName && node.getElementsByTagName) {
    copyArray(nodelist, node.getElementsByTagName(opt_tagName));
    return;
  }
  for (var n = node.firstChild; n; n = n.nextSibling) {
    nodelist.push(n);
    xpathCollectDescendants(nodelist, n);
  }
}

function xpathExtractTagNameFromNodeTest(nodetest) {
  if (nodetest instanceof NodeTestName) {
    return nodetest.name;
  } else if (nodetest instanceof NodeTestAny || nodetest instanceof NodeTestElementOrAttribute) {
    return "*";
  }
}

function xpathCollectDescendantsReverse(nodelist, node) {
  for (var n = node.lastChild; n; n = n.previousSibling) {
    nodelist.push(n);
    xpathCollectDescendantsReverse(nodelist, n);
  }
}


function xpathDomEval(expr, node) {
  var expr1 = xpathParse(expr);
  var ret = expr1.evaluate(new ExprContext(node));
  return ret;
}

function xpathSort(input, sort) {
  if (sort.length == 0) {
    return;
  }

  var sortlist = [];

  for (var i = 0; i < input.contextSize(); ++i) {
    var node = input.nodelist[i];
    var sortitem = { node: node, key: [] };
    var context = input.clone(node, 0, [ node ]);

    for (var j = 0; j < sort.length; ++j) {
      var s = sort[j];
      var value = s.expr.evaluate(context);

      var evalue;
      if (s.type == 'text') {
        evalue = value.stringValue();
      } else if (s.type == 'number') {
        evalue = value.numberValue();
      }
      sortitem.key.push({ value: evalue, order: s.order });
    }

    sortitem.key.push({ value: i, order: 'ascending' });

    sortlist.push(sortitem);
  }

  sortlist.sort(xpathSortByKey);

  var nodes = [];
  for (var i = 0; i < sortlist.length; ++i) {
    nodes.push(sortlist[i].node);
  }
  input.nodelist = nodes;
  input.setNode(0);
}


function xpathSortByKey(v1, v2) {

  for (var i = 0; i < v1.key.length; ++i) {
    var o = v1.key[i].order == 'descending' ? -1 : 1;
    if (v1.key[i].value > v2.key[i].value) {
      return +1 * o;
    } else if (v1.key[i].value < v2.key[i].value) {
      return -1 * o;
    }
  }

  return 0;
}


function xpathEval(select, context) {
  var expr = xpathParse(select);
  var ret = expr.evaluate(context);
  return ret;
}
/**@fileoverview
 implements the xforms-core function library as defined in http://www.w3.org/TR/xforms11/#expr-lib
 for Ubiquity XForms using the Google AJAXSLT XPath processor
 @requires FunctionCallExpr  defined in ajaxslt/xpath.js
 */

/**@addon
 trim is required by some of these XPath functions to produce a correct response.
 */
String.prototype.trim = function() {
	return this.replace(/^\s*|\s*$/g, '');
};

Date.prototype.setTimeInSeconds = function(seconds) {
	this.setTime(seconds * 1000);
};

Date.prototype.setTimeInMinutes = function(minutes) {
	this.setTimeInSeconds(minutes * 60);
};

Date.prototype.setTimeInHours = function(hours) {
	this.setTimeInMinutes(hours * 60);
};

Date.prototype.setTimeInDays = function(days) {
	this.setTimeInHours(days * 24);
};



function ThrowNotImpl(ctx) {
	throw "Not Implemented";
}

/**
 Retrieves the current date and time.

 @param {Object} oDate, a Javascript Date object.
 @param {boolean} bUTC, if true use UTC time; otherwise, local time.
 @returns {string} Date and time in xsd:dateTime format.
 */
function getDateTime(oDate, bUTC) {
	var s = "";
	var year, month, day, hours, minutes, seconds;

	if (bUTC) {
		year = oDate.getUTCFullYear();
		month = oDate.getUTCMonth() + 1;
		day = oDate.getUTCDate();
		hours = oDate.getUTCHours();
		minutes = oDate.getUTCMinutes();
		seconds = oDate.getUTCSeconds();
	} else {
		year = oDate.getFullYear();
		month = oDate.getMonth() + 1;
		day = oDate.getDate();
		hours = oDate.getHours();
		minutes = oDate.getMinutes();
		seconds = oDate.getSeconds();
	}

	/*
	 * Put the year first.
	 */
	s += year + "-";

	if (month < 10) month = "0" + month;
	s += month + "-";

	if (day < 10) day = "0" + day;
	s += day;

	s += "T";

	if (hours < 10) {
		hours = "0" + hours;
	}
	s += hours + ":";

	if (minutes < 10) {
		minutes = "0" + minutes;
	}
	s += minutes + ":";

	if (seconds < 10) {
		seconds = "0" + seconds;
	}
	s += seconds;

	if (bUTC) {
		s += "Z";
	}

	return s;
}

/**
 Calculates the local time zone offset from UTC time.

 @param {Object} oDate, a Javascript Date object.
 @returns {string} Time zone offset in (('+' | '-') hh ':' mm) format.
 */
function getTZOffset(oDate) {
	var s = "";
	var tz = oDate.getTimezoneOffset();

	if (tz < 0) {
		s += "+";
		tz *= -1;
	} else {
		s += "-";
	}

	var hours = tz / 60;
	if (hours < 10) {
		hours = "0" + hours;
	}
	s += hours + ":";

	var minutes = tz % 60;
	if (minutes < 10) {
		minutes = "0" + minutes;
	}
	s += minutes;

	return s;
}

/**@addon
 http://www.w3.org/TR/xforms11/#fn-boolean-from-string
 */
FunctionCallExpr.prototype.xpathfunctions["boolean-from-string"] = function(ctx) {
	var s = this.args[0].evaluate(ctx).stringValue();

	s = s.trim();
	return new BooleanValue((s.toLowerCase() === "true") || (s === "1"));
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-is-card-number
 */
FunctionCallExpr.prototype.xpathfunctions["is-card-number"] = function(ctx) {
	var sCardNum = "";
	if (!this.args || this.args.length == 0) {
		sCardNum = xmlValue(ctx.node);
	} else {
		sCardNum = this.args[0].evaluate(ctx).stringValue();
	}
	sCardNum = sCardNum.trim();

	var sum = 0;
	var alt = false;

	for (var i = sCardNum.length - 1; i >= 0; --i) {
		var currentChar = sCardNum.charAt(i);
		if (currentChar < '0' || currentChar > '9') {
			return new BooleanValue(false);
		}
		var digit = currentChar - '0';

		if (alt) {
			digit *= 2;
			if (digit > 9) {
				digit -= 9;
			}
		}
		sum += digit;
		alt = !alt;
	}

	return new BooleanValue(sum % 10 == 0);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-avg
 */
FunctionCallExpr.prototype.xpathfunctions["avg"] = function(ctx) {
	if (!this.args || this.args.length == 0) {
		return new NumberValue(NaN);
	}

	var n = this.args[0].evaluate(ctx).nodeSetValue();
	if (n.length == 0) {
		return new NumberValue(NaN);
	}

	var sum = 0;
	for (var i = 0; i < n.length; ++i) {
		var num = xmlValue(n[i]) - 0;
		if (isNaN(num)) {
			return new NumberValue(NaN);
		}
		sum += num;
	}
	return new NumberValue(sum / n.length);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-min
 */
FunctionCallExpr.prototype.xpathfunctions["min"] = function(ctx) {
	if (!this.args || this.args.length == 0) {
		return new NumberValue(NaN);
	}

	var n = this.args[0].evaluate(ctx).nodeSetValue();
	if (n.length == 0) {
		return new NumberValue(NaN);
	}

	var min = xmlValue(n[0]) - 0;
	for (var i = 0; i < n.length; ++i) {
		var num = xmlValue(n[i]) - 0;
		if (isNaN(num)) {
			return new NumberValue(NaN);
		}

		if (num < min) {
			min = num;
		}
	}
	return new NumberValue(min);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-max
 */
FunctionCallExpr.prototype.xpathfunctions["max"] = function(ctx) {
	if (!this.args || this.args.length == 0) {
		return new NumberValue(NaN);
	}

	var n = this.args[0].evaluate(ctx).nodeSetValue();
	if (n.length == 0) {
		return new NumberValue(NaN);
	}

	var max = xmlValue(n[0]) - 0;
	for (var i = 0; i < n.length; ++i) {
		var num = xmlValue(n[i]) - 0;
		if (isNaN(num)) {
			return new NumberValue(NaN);
		}

		if (max < num) {
			max = num;
		}
	}
	return new NumberValue(max);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-count-non-empty
 */
FunctionCallExpr.prototype.xpathfunctions["count-non-empty"] = function(ctx) {
	if (!this.args || this.args.length == 0) {
		return new NumberValue(0);
	}

	var n = this.args[0].evaluate(ctx).nodeSetValue();
	if (n.length == 0) {
		return new NumberValue(0);
	}

	var count = 0;
	for (var i = 0; i < n.length; ++i) {
		var value = xmlValue(n[i]);
		if (value.length > 0) {
			count++;
		}
	}

	return new NumberValue(count);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-index
 */
FunctionCallExpr.prototype.xpathfunctions["index"] = function(ctx) {
	var s = this.args[0].evaluate(ctx).stringValue();
	var oRpt = DECORATOR.getBehaviour(FormsProcessor.getElementById(s, ctx.resolverElement));
	if (oRpt && oRpt.getIndex) {
		return new NumberValue(oRpt.getIndex());
	}

	return new NumberValue(NaN);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-power
 */
FunctionCallExpr.prototype.xpathfunctions["power"] = function(ctx) {
	if (!this.args || (this.args.length != 2)) {
		return new NumberValue(NaN);
	}

	return new NumberValue(
	Math.pow(
	this.args[0].evaluate(ctx).numberValue(), this.args[1].evaluate(ctx).numberValue()));
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-random
 */
FunctionCallExpr.prototype.xpathfunctions["random"] = function(ctx) {
	return new NumberValue(Math.random());
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-compare
 */
FunctionCallExpr.prototype.xpathfunctions["compare"] = function(ctx) {
	var result = NaN;
	if (this.args.length == 2) {
		var s1 = this.args[0].evaluate(ctx).stringValue();
		var s2 = this.args[1].evaluate(ctx).stringValue();

		if (s1 == s2) {
			result = 0;
		} else if (s1 > s2) {
			result = 1;
		} else {
			result = -1;
		}
	}
	return new NumberValue(result);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-if
 */
FunctionCallExpr.prototype.xpathfunctions["if"] = function(ctx) {
	var bIf = this.args[0].evaluate(ctx).booleanValue();
	if (bIf) {
		return new StringValue(this.args[1].evaluate(ctx).stringValue());
	} else {
		return new StringValue(this.args[2].evaluate(ctx).stringValue());
	}
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-property
 */
FunctionCallExpr.prototype.xpathfunctions["property"] = function(ctx) {
	if (!this.args || (this.args.length != 1)) {
		return new StringValue("");
	}

	var property = this.args[0].evaluate(ctx).stringValue();

	var ret = "";
	if (property == "version") {
		ret = "1.1";
	} else if (property == "conformance-level") {
		ret = "basic";
	} else {
		var match = property.match(/^[_a-z][\w\.\-]*/i);
		if (match && match[0] == property && document.defaultModel) {
			this.dispatchExceptionEvent(ctx);
		}
	}

	return new StringValue(ret);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-digest
 */
FunctionCallExpr.prototype.xpathfunctions["digest"] = function(ctx) {
	if (!this.args || this.args.length < 2 || this.args.length > 3) {
		return new StringValue("");
	}

	var digest = "",
		shaCrypt;
	var data = this.args[0].evaluate(ctx).stringValue();
	var algorithm = this.args[1].evaluate(ctx).stringValue();
	var encoding = (this.args.length === 3) ? this.args[2].evaluate(ctx).stringValue() : "base64";

	if (encoding === "hex" || encoding === "base64") {
		switch (algorithm) {
		case "MD5":
			if (encoding === "base64") {
				digest = MD5.b64_md5(data);
			} else if (encoding === "hex") {
				digest = MD5.hex_md5(data);
			}
			break;
		case "SHA-1":
		case "SHA-256":
		case "SHA-384":
		case "SHA-512":
			shaCrypt = new jsSHA(data);
			digest = shaCrypt.getHash(algorithm, encoding === "hex" ? "HEX" : "B64");
			break;
		default:
			this.dispatchExceptionEvent(ctx);
			break;
		}
	} else {
		this.dispatchExceptionEvent(ctx);
	}

	return new StringValue(digest);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-local-date
 */
FunctionCallExpr.prototype.xpathfunctions["local-date"] = function(ctx) {
	var d = new Date();
	var s = getDateTime(d, false);

	s = s.substring(0, 10);
	s += getTZOffset(d);

	return new StringValue(s);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-local-dateTime
 */
FunctionCallExpr.prototype.xpathfunctions["local-dateTime"] = function(ctx) {
	var d = new Date();
	var s = getDateTime(d, false);

	s += getTZOffset(d);

	return new StringValue(s);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-now
 */
FunctionCallExpr.prototype.xpathfunctions["now"] = function(ctx) {
	var d = new Date();
	var s = getDateTime(d, true);

	return new StringValue(s);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-days-from-date
 */
FunctionCallExpr.prototype.xpathfunctions["days-from-date"] = function(ctx) {
	var dDate, dBase;
	var dOrigin;

	if (!this.args || (this.args.length != 1)) {
		return new NumberValue(NaN);
	}

	var res = FunctionCallExpr.prototype.xpathfunctions.expr.xsdDateTime.exec(
	this.args[0].evaluate(ctx).stringValue());

	if (!res) {
		res = FunctionCallExpr.prototype.xpathfunctions.expr.xsdDate.exec(
		this.args[0].evaluate(ctx).stringValue());
		if (!res) {
			return new NumberValue(NaN);
		}
	}

	dDate = new Date(res[1], res[2] - 1, res[3]);

	dDate.setMinutes(dDate.getMinutes() + dDate.getTimezoneOffset());

	dBase = new Date(1970, 0, 1);
	dBase.setMinutes(dBase.getMinutes() + dBase.getTimezoneOffset());

	return new NumberValue(Math.round((dDate.getTime() - dBase.getTime()) / (1000 * 60 * 60 * 24)));
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-days-to-date
 */
FunctionCallExpr.prototype.xpathfunctions["days-to-date"] = function(ctx) {
	var month;
	var date;
	var days;
	var d;

	if (!this.args || (this.args.length != 1)) {
		return new StringValue("");
	}

	var number = this.args[0].evaluate(ctx).numberValue();

	if (isNaN(number)) return new StringValue("");

	d = new Date();
	d.setTimeInDays(Math.round(number));

	month = d.getUTCMonth() + 1;
	if (month < 10) month = "0" + month;

	date = d.getUTCDate();
	if (date < 10) date = "0" + date;

	return new StringValue(d.getUTCFullYear() + "-" + month + "-" + date);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-seconds-from-dateTime
 */
FunctionCallExpr.prototype.xpathfunctions["seconds-from-dateTime"] = function(ctx) {
	var dDate;
	var dBase;
	var tzOffset;
	var seconds;

	if (!this.args || (this.args.length != 1)) {
		return new NumberValue(NaN);
	}

	var res = FunctionCallExpr.prototype.xpathfunctions.expr.xsdDateTime.exec(
	this.args[0].evaluate(ctx).stringValue());

	if (!res) {
		return new NumberValue(NaN);
	}

	dDate = new Date(Date.UTC(res[1], res[2] - 1, res[3], res[4], res[5], res[6]));
	if (!res[8] || (res[8] === "Z")) {
		tzOffset = 0;
	} else {
		tzOffset = ((Number(res[11]) * 60) + Number(res[12])) *
		/* number of minutes */
		((res[10] === "-") ? -1 : 1);
		/* take into account the sign of the timezone */
	}

	dDate.setUTCMinutes(dDate.getUTCMinutes() + tzOffset);

	dBase = new Date(Date.UTC(1970, 0, 1));
	seconds = Math.round((dDate.getTime() - dBase.getTime()) / (1000));
	if (res[7]) {
		seconds += res[7] - 0;
	}
	return new NumberValue(seconds);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-seconds-to-dateTime
 */
FunctionCallExpr.prototype.xpathfunctions["seconds-to-dateTime"] = function(ctx) {
	var d, number;

	if (!this.args || (this.args.length != 1)) {
		return new StringValue("");
	}

	number = this.args[0].evaluate(ctx).numberValue();

	if (isNaN(number)) return new StringValue("");

	d = new Date();
	d.setTimeInSeconds(number);

	return new StringValue(getDateTime(d, true));
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-adjust-dateTime-to-timezone
 */
FunctionCallExpr.prototype.xpathfunctions["expr"] = {
	xsdDate: /^([0-9]{4})\-([0-9]{2})\-([0-9]{2})(((([+-])([0-9]{2})\:([0-9]{2}))|(\Z))?)$/,
	xsdDateTime: /^([0-9]{4})\-([0-9]{2})\-([0-9]{2})\T([0-9]{2})\:([0-9]{2})\:([0-9]{2}(\.[0-9]*)?)((([+-])([0-9]{2})\:([0-9]{2}))|(\Z)?)$/
};

FunctionCallExpr.prototype.xpathfunctions["adjust-dateTime-to-timezone"] = function(ctx) {
	if (!this.args || (this.args.length != 1)) {
		return new StringValue("");
	}

	var res = FunctionCallExpr.prototype.xpathfunctions.expr.xsdDateTime.exec(
	this.args[0].evaluate(ctx).stringValue());

	if (!res) {
		return new StringValue("");
	}

	var dDate = new Date(res[1], res[2] - 1, res[3], res[4], res[5], res[6]);

	var localDate = new Date(res[1], res[2] - 1, res[3], res[4], res[5], res[6]);
	var tzOffset;

	if (!res[8]) {
		tzOffset = 0;
	} else {
		tzOffset = -localDate.getTimezoneOffset();

		if (res[8] === "Z") {
			tzOffset += 0;
		} else {

			tzOffset += ((Number(res[11]) * 60) + Number(res[12])) *
			/* number of minutes */
			((res[10] === "-") ? 1 : -1);
			/* take into account the sign of the timezone */
		}
	}

	dDate.setMinutes(dDate.getMinutes() + tzOffset);

	var s = getDateTime(dDate, false);

	s += getTZOffset(localDate);

	return new StringValue(s);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-seconds
 */
FunctionCallExpr.prototype.xpathfunctions["seconds"] = function(ctx) {
	if (!this.args || (this.args.length != 1)) {
		return new NumberValue(NaN);
	}

	var duration = this.args[0].evaluate(ctx).stringValue();
	var totalSeconds = 0;
	var index = 0;
	var endingIndex = 0;
	var length = 0;
	var durationIsNegative = false;

	if (!duration.match(/^P|\-P/)) {
		return new NumberValue(NaN);
	}
	if (duration.match(/^\-/)) {
		durationIsNegative = true;
		index++;
	}
	if (duration.match(/D/)) {
		if (duration.indexOf("Y") > 0 && duration.indexOf("Y") < duration.indexOf("D")) index = duration.indexOf("Y");
		if (duration.indexOf("M") > 0 && duration.indexOf("M") < duration.indexOf("D")) index = duration.indexOf("M");
		endingIndex = duration.indexOf("D");
		length = endingIndex - index - 1;
		var days = duration.substr(index + 1, length);
		totalSeconds = totalSeconds + 60 * 60 * 24 * parseFloat(days);
		index = endingIndex;
	}
	if (duration.indexOf("T") != -1) {
		index = 0;
		duration = duration.substr(duration.indexOf("T"));
	}
	if (duration.match(/H/)) {
		endingIndex = duration.indexOf("H");
		length = endingIndex - index - 1;
		var hours = duration.substr(index + 1, length);
		totalSeconds = totalSeconds + 60 * 60 * parseFloat(hours);
		index = endingIndex;
	}
	if (duration.match(/M/) && duration.indexOf("T") == 0) {
		endingIndex = duration.indexOf("M");
		length = endingIndex - index - 1;
		var minutes = duration.substr(index + 1, length);
		totalSeconds = totalSeconds + 60 * parseFloat(minutes);
		index = endingIndex;
	}
	if (duration.match(/S/)) {
		endingIndex = duration.indexOf("S");
		length = endingIndex - index - 1;
		var seconds = duration.substr(index + 1, length);
		totalSeconds = totalSeconds + parseFloat(seconds);
		index = endingIndex;
	}
	if (durationIsNegative) {
		totalSeconds = totalSeconds * -1;
	}

	return new NumberValue(totalSeconds);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-months
 */
FunctionCallExpr.prototype.xpathfunctions["months"] = function(ctx) {
	if (!this.args || (this.args.length != 1)) {
		return new NumberValue(NaN);
	}

	var duration = this.args[0].evaluate(ctx).stringValue();
	var totalMonths = 0;
	var index = 0;
	var endingIndex = 0;
	var length = 0;
	var durationIsNegative = false;

	if (!duration.match(/^P|\-P/)) {
		return new NumberValue(NaN);
	}
	if (duration.match(/^\-/)) {
		durationIsNegative = true;
		index++;
	}
	if (duration.match(/Y/)) {
		endingIndex = duration.indexOf("Y");
		length = endingIndex - index - 1;
		var years = duration.substr(index + 1, length);
		totalMonths = totalMonths + 12 * parseFloat(years);
		index = endingIndex;
	}
	if (duration.match(/M/)) {
		endingIndex = duration.indexOf("M");
		length = endingIndex - index - 1;
		var months = duration.substr(index + 1, length);
		if (duration.indexOf("T") < 0 || duration.indexOf("T") > endingIndex) totalMonths = totalMonths + parseFloat(months);
		index = endingIndex;
	}
	if (durationIsNegative) {
		totalMonths = totalMonths * -1;
	}

	return new NumberValue(totalMonths);
};

/**
 @addon
 http://www.w3.org/TR/xforms11/#fn-instance
 @throws String if the first instance with the given id in document order is not inside the context model.
 */
FunctionCallExpr.prototype.xpathfunctions["instance"] = function(ctx) {
	var ret = null;

	if (ctx.currentModel) {
		try {
			var sInstance = "";
			if (this.args[0]) {
				sInstance = this.args[0].evaluate(ctx).stringValue();
			}
			var oDom = ctx.currentModel.getInstanceDocument(sInstance);
			var oDE = oDom.documentElement;
			ret = new Array(oDE);
		} catch(e) {
			throw ("XPath function: instance(" + sInstance + ") is not a member of  model " + ctx.currentModel.element.id);
		}
	} else {
		throw ("instance() executed without a current model");
	}

	if (this.args[1]) {
		alert(this.args.join('\n'));
	}

	return new NodeSetValue(ret);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-current
 */

FunctionCallExpr.prototype.xpathfunctions["current"] = function(ctx) {
	return new NodeSetValue([ctx.outermostContextNode]);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-id
 */
FunctionCallExpr.prototype.xpathfunctions["id"] = function(ctx) {
	var evalCtx;
	var ret = [];
	var ids;
	var nodeSet;
	var nodeValue;
	var oNodes;
	var ctxNodes = [];
	var i, j, k;

	if (!this.args || (this.args.length === 0) || (this.args.length > 2)) {
		return new NodeSetValue([]);
	}

	evalCtx = this.args[0].evaluate(ctx);

	if (evalCtx.type === 'node-set') {
		ids = [];
		nodeSet = evalCtx.nodeSetValue();
		for (i = 0; i < nodeSet.length; ++i) {
			nodeValue = xmlValue(nodeSet[i]).split(/\s+/);
			for (j = 0; j < nodeValue.length; ++j) {
				ids.push(nodeValue[j]);
			}
		}
	} else {
		ids = evalCtx.stringValue().split(/\s+/);
	}

	ctxNodes.push(ctx.resolverElement ? ctx.resolverElement.getEvaluationContext().node : ctx.node);

	if (this.args.length === 2) {
		evalCtx = this.args[1].evaluate(ctx);

		if ((evalCtx.type === 'node-set') && (evalCtx.nodeSetValue().length > 0)) {
			ctxNodes = evalCtx.nodeSetValue();
		}
	}

	for (j = 0; j < ctxNodes.length; ++j) {
		for (k = 0; k < ids.length; ++k) {
			oNodes = UX.getElementsById(ctxNodes[j], ids[k]);
			if (oNodes) {
				for (i = 0; i < oNodes.length; ++i) {
					ret.push(oNodes[i]);
				}
			}
		}
	}

	return new NodeSetValue(ret);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-context
 */
FunctionCallExpr.prototype.xpathfunctions["context"] = function(ctx) {
	var ctxNode = ctx.resolverElement ? DECORATOR.getBehaviour(ctx.resolverElement).getEvaluationContext().node : ctx.node;

	return new NodeSetValue([ctxNode]);
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-choose
 */
FunctionCallExpr.prototype.xpathfunctions["choose"] = function(ctx) {
	if (!this.args || this.args.length != 3) {
		return null;
	}

	var p1 = this.args[1].evaluate(ctx);
	var p2 = this.args[2].evaluate(ctx);
	var result = (this.args[0].evaluate(ctx).booleanValue()) ? p1 : p2;
	var ret;

	switch (result.type) {
	case "string":
		ret = new StringValue(result.stringValue());
		break;

	case "number":
		ret = new NumberValue(result.numberValue());
		break;

	case "boolean":
		ret = new BooleanValue(result.booleanValue());
		break;

	case "node-set":
		ret = new NodeSetValue(result.nodeSetValue());
		break;

	default:
		throw "Unrecognised type in choose()";
		break;
	}
	return ret;
};

/**@addon
 http://www.w3.org/TR/xforms11/#fn-event
 */
FunctionCallExpr.prototype.xpathfunctions["event"] = function(ctx) {
	var sProperty = this.args[0].evaluate(ctx).stringValue();
	var oEvent = FormsProcessor.getCurrentEvent();
	var contextInfo, ret;

	if (oEvent && oEvent.context) {
		contextInfo = oEvent.context[sProperty];

		switch (typeof contextInfo) {
		case "string":
			ret = new StringValue(contextInfo);
			break;

		case "number":
			ret = new NumberValue(contextInfo);
			break;

		case "boolean":
			ret = new BooleanValue(contextInfo);
			break;

		case "object":
			ret = new NodeSetValue(contextInfo);
			break;

		case "undefined":
			ret = new NodeSetValue([]);
			break;

		default:
			throw "Unrecognised type in event()";
			break;
		}
	} else {
		ret = new StringValue("");
	}
	return ret;
};

/**
 This is a formsPlayer specific function to return any instance, regardless of the in-scope model,
 not part of the core function library
 @addon*/
FunctionCallExpr.prototype.xpathfunctions["globalInstance"] = function(ctx) {
	var sInstance = this.args[0].evaluate(ctx).stringValue();
	var oInst = DECORATOR.getBehaviour(FormsProcessor.getElementById(sInstance, ctx.resolverElement));
	var ret = null;
	if (oInst) {
		ret = new Array(oInst.getDocument().documentElement);
	}
	return new NodeSetValue(ret);
};

FunctionCallExpr.prototype.dispatchExceptionEvent = function(context) {
	if (NamespaceManager.compareFullName(context.resolverElement, "bind", "http://www.w3.org/2002/xforms")) {
		UX.dispatchEvent(context.currentModel || document.defaultModel, "xforms-compute-exception", true, false, false);
	} else {
		UX.dispatchEvent(context.resolverElement, "xforms-binding-exception", true, false, false);
	}
};
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 @fileoverview
 The subset of the DOM implemented by Google's AJAXSLT is insufficent for the purpose of  implementing xforms through ajaxslt
 This file contains the methods required by ajaxfp in order to work
 */

var g_bSaveDependencies = false;

var HIERARCHY_REQUEST_ERR = 3;

/**
 The entry point for the library: match an expression against a DOM node.
 An expression and a full context object are received.  The context object
 contains "node", "model", "position" and "size" (when "node" comes from
 a nodeset a.k.a. nodelist), and "resolverElement" (the node containing
 the XPath expression).
 For backwards compatibility with the xpathDomEval in ajaxslt, the code
 tests if oContext.node exists, and if not it uses oContext as the node.
 Returns then XPath expression result.

 @addon
 */
function xpathDomEval(expr, oContext) {
	var expr1 = xpathParse(expr);
	var ctx = new ExprContext(oContext.node ? oContext.node : oContext, oContext.position);
	ctx["size"] = oContext.size ? oContext.size : (ctx.node ? 1 : 0);
	ctx["currentModel"] = oContext.model;
	ctx["outermostContextNode"] = ctx.node;
	ctx["resolverElement"] = oContext.resolverElement;
	ctx.setCaseInsensitive(!UX.isXHTML && (UX.isFF || UX.isChrome || UX.isSafari));
	var ret = expr1.evaluate(ctx);
	return ret;
}

FunctionCallExpr.prototype.xpathfunctions["last"] = function(ctx) {
	if (ctx.size && ctx.nodelist && ctx.nodelist.length === 1 && ctx.nodelist[0] === ctx.outermostContextNode) {
		return new NumberValue(ctx.size);
	}
	return new NumberValue(ctx.contextSize());
};

ExprContext.prototype.clone = function(opt_node, opt_position, opt_nodelist) {
	var oRet = new ExprContext(
	opt_node || this.node, typeof opt_position != 'undefined' ? opt_position : this.position, opt_nodelist || this.nodelist, this, this.caseInsensitive, this.ignoreAttributesWithoutValue);
	oRet.size = this.size;
	oRet.currentModel = this.currentModel;
	oRet.outermostContextNode = this.outermostContextNode;
	oRet.resolverElement = this.resolverElement;
	return oRet;
};

/**
 The AJAXSLT XNode does not support cloneNode
 @addon
 @param {bool} bDeep Whether to run a deep (everything) or shallow (just the tag and attributes, no children) clone
 */

XNode.prototype.cloneNode = function(bDeep) {
	var newNode, i;

	if (bDeep) {
		if (this.nodeType === DOM_DOCUMENT_NODE || this.nodeType === DOM_ELEMENT_NODE || this.nodeType === DOM_DOCUMENT_FRAGMENT_NODE) {
			newNode = this.cloneNode(false);

			for (i = 0; i < this.childNodes.length; i++) {
				newNode.appendChild(this.childNodes[i].cloneNode(true));
			}
		} else {
			bDeep = false;
		}
	}

	if (!bDeep) {
		if (this.nodeType === DOM_DOCUMENT_NODE) {
			newNode = new XDocument();
		} else if (this.nodeType === DOM_ELEMENT_NODE) {
			newNode = XNode.create(DOM_ELEMENT_NODE, this.nodeName, null, new XDocument());
			for (i = 0; i < this.attributes.length; i++) {
				newNode.setAttribute(this.attributes[i].nodeName, this.attributes[i].nodeValue);
			}
		} else {
			newNode = XNode.create(this.nodeType, this.nodeName, this.nodeValue, new XDocument());
		}
	}

	return newNode;
};

/** A shallow clone of an element includes its tag and its attributes.
 If you need a "very" shallow clone of just the tag, then you can
 invoke cloneNode() and then call this function on the resulting node.
 @addon
 */
XNode.prototype.removeAttributeList = function() {
	while (this.attributes.length > 0) {
		this.removeAttribute(this.attributes[0].nodeName);
	}
};

/**@addon
 */

FunctionCallExpr.prototype.xpathfunctions["local-name"] = function(ctx) {
	assert(this.args.length === 1 || this.args.length === 0);
	var n, ix;
	var name = "";
	if (this.args.length === 0) {
		n = [ctx.node];
	} else {
		n = this.args[0].evaluate(ctx).nodeSetValue();
	}

	if (n.length === 0) {} else {
		name = n[0].nodeName;
	}

	ix = name.indexOf(":");
	if (ix > -1) {
		name = name.substr(ix + 1);
	}
	return new StringValue(name);
};

/**@addon
 */

FunctionCallExpr.prototype.xpathfunctions["namespace-uri"] = function(ctx) {
	alert('not IMPLEMENTED yet: XPath function namespace-uri()');
};

/**@addon
 */

FunctionCallExpr.prototype.evaluate = function(ctx) {
	var f = this.getFunction();
	var i, nodes, retval;

	if (f) {
		retval = f.call(this, ctx);
		if (g_bSaveDependencies && retval.type == 'node-set') {
			nodes = retval.nodeSetValue();
			for (i = 0; i < nodes.length; ++i) {
				g_arrSavedDependencies.push(nodes[i]);
			}
		}
	} else {
		xpathLog('XPath NO SUCH FUNCTION ' + this.name.value);
		retval = new BooleanValue(false);
	}

	return retval;
};

FunctionCallExpr.prototype.getFunction = function() {

	var segments, prefix, localName;
	var prefixes;
	var i;
	var allowBridge = false;
	var retval;

	segments = this.name.value.split(':');
	if (segments.length == 1) {
		localName = segments[0];
	} else {
		prefix = segments[0];
		localName = segments[1];
	}

	if (!prefix) {
		retval = this.xpathfunctions[localName];
	} else {
		prefixes = NamespaceManager.getOutputPrefixesFromURI("http://www.w3.org/2002/xforms#inline");

		if (prefixes === undefined || prefixes === null) return null;

		for (i = 0; i < prefixes.length; i++) {
			if (prefix === prefixes[i] && UX.global[localName]) {
				retval = function(ctx) {
					var f;
					var marshalledArgs = [];
					var i, c;
					var arg;
					var retval;

					f = UX.global[localName];
					if (!f) {
						return null;
					}

					c = this.args.length;
					for (i = 0; i < c; i++) {
						arg = this.args[i];
						while (arg && typeof(arg.evaluate) === 'function')
						arg = arg.evaluate(ctx);

						if (arg.type === 'boolean') {
							marshalledArgs.push(arg.booleanValue());
						} else if (arg.type === 'string') {
							marshalledArgs.push(arg.stringValue());
						} else if (arg.type === 'number') {
							marshalledArgs.push(arg.numberValue());
						} else if (arg.type === 'node-set' && arg.nodeSetValue().length <= 1) {
							marshalledArgs.push(arg.stringValue());
						} else {
							xpathLog('Non-primitive passed to bridged function "' + localName + '".');
							return new BooleanValue(false);
						}

					}

					retval = f.apply(null, marshalledArgs);

					if (retval === null) return new BooleanValue(false);

					switch (UX.type(retval)) {
					case 'boolean':
						return new BooleanValue(retval);
					case 'string':
						return new StringValue(retval);
					case 'number':
						return new NumberValue(retval);
					default:
						xpathLog('Bridged function "' + localName + '" returned non-primitive value.');
						return new BooleanValue(false);
					}
				};
				break;
			}
		}
	}

	return retval;
};

/**@addon
 */

LocationExpr.prototype.evaluate = function(ctx) {
	var start, i, retval;
	var nodes = [];
	if (this.absolute) {
		start = ctx.root;

	} else {
		start = ctx.node;
	}

	xPathStep(nodes, this.steps, 0, start, ctx);
	retval = new NodeSetValue(nodes);
	if (g_bSaveDependencies) {
		for (i = 0; i < nodes.length; ++i) {
			g_arrSavedDependencies.push(nodes[i]);
		}
	}
	return retval;
};

XNode.prototype.setOwnerDocument = function(owner, bDeep) {
	var i;

	if (this.nodeType === DOM_DOCUMENT_NODE) {
		this.ownerDocument = null;
	} else {
		this.ownerDocument = owner;
	}

	if (bDeep) {
		for (i = 0; i < this.attributes.length; i++) {
			this.attributes[i].setOwnerDocument(owner);
		}
		for (i = 0; i < this.childNodes.length; i++) {
			this.childNodes[i].setOwnerDocument(owner, true);
		}
	}
};

XDocument.prototype.appendChild = function(node) {
	if (node.nodeType === DOM_TEXT_NODE) {
		throw {
			code: HIERARCHY_REQUEST_ERR,
			message: "Text Nodes are not allowed at the top level of a document"
		};
	} else if (node.nodeType === DOM_ELEMENT_NODE) {
		if (this.documentElement) {
			throw {
				code: HIERARCHY_REQUEST_ERR,
				message: "Only one top level element is allowed in an XML document."
			};
		} else {
			this.documentElement = XNode.prototype.appendChild.call(this, node);
			return this.documentElement;
		}
	} else {
		return XNode.prototype.appendChild.call(this, node);
	}
};

XDocument.prototype.removeChild = function(node) {
	if (node === this.documentElement) {
		this.documentElement = null;
	}
	XNode.prototype.removeChild.call(this, node);
};

(function() {

	var xnodeCount = 0;

	/**
	 * This version adds a unique id (xnodeId) to each XNode created.
	 *
	 * This id is used elsewhere as an index when doing node comparisons
	 *
	 * @param {Number} type Sets XNode.nodeType (constant)
	 *     Based on <http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247>
	 * @param {String} name Sets XNode.nodeName
	 * @param {String} value Sets XNode.nodeValue
	 * @param {XDocument} owner Sets XNode.ownerDocument
	 * @returns A new XNode
	 */
	 XNode.create = function(type, name, value, owner) {
		var node;
		if (XNode.unused_.length > 0) {
			node = XNode.unused_.pop();
			XNode.init.call(node, type, name, value, owner);
		} else {
			if (typeof owner == 'object' && !owner.xnodeId) {
				owner.xnodeId = ++xnodeCount;
			}
			node = new XNode(type, name, value, owner);
		}
		node.xnodeId = ++xnodeCount;
		return node;
	};

})();

XNode.prototype.appendChild = function(node) {

	if (node.ownerDocument !== this.ownerDocument) {
		node.setOwnerDocument(this.nodeType === DOM_DOCUMENT_NODE ? this : this.ownerDocument, true);
	}

	if (this.childNodes.length == 0) {
		this.firstChild = node;
	}

	node.previousSibling = this.lastChild;

	node.nextSibling = null;
	if (this.lastChild) {
		this.lastChild.nextSibling = node;
	}

	node.parentNode = this;

	this.lastChild = node;

	this.childNodes.push(node);
	return node;
};

XNode.prototype.replaceChild = function(newNode, oldNode) {
	if (oldNode == newNode) {
		return;
	}

	for (var i = 0; i < this.childNodes.length; ++i) {
		if (this.childNodes[i] == oldNode) {
			if (newNode.ownerDocument !== oldNode.ownerDocument) {
				newNode.setOwnerDocument(oldNode.ownerDocument, true);
			}

			this.childNodes[i] = newNode;

			var p = oldNode.parentNode;
			oldNode.parentNode = null;
			newNode.parentNode = p;

			p = oldNode.previousSibling;
			oldNode.previousSibling = null;
			newNode.previousSibling = p;
			if (newNode.previousSibling) {
				newNode.previousSibling.nextSibling = newNode;
			}

			p = oldNode.nextSibling;
			oldNode.nextSibling = null;
			newNode.nextSibling = p;
			if (newNode.nextSibling) {
				newNode.nextSibling.previousSibling = newNode;
			}

			if (this.firstChild == oldNode) {
				this.firstChild = newNode;
			}

			if (this.lastChild == oldNode) {
				this.lastChild = newNode;
			}

			break;
		}
	}
};

XNode.prototype.insertBefore = function(newNode, oldNode) {
	var i, c, newChildren = [],
		oRet = newNode;

	if (!oldNode) {
		if (newNode.parentNode) {
			newNode.parentNode.removeChild(newNode);
		}
		this.appendChild(newNode);

	} else if ((oldNode !== newNode) && (oldNode.parentNode === this)) {
		if (newNode.parentNode) {
			newNode.parentNode.removeChild(newNode);
		}

		if (newNode.ownerDocument !== oldNode.ownerDocument) {
			newNode.setOwnerDocument(oldNode.ownerDocument, true);
		}

		for (i = 0; i < this.childNodes.length; ++i) {
			c = this.childNodes[i];
			if (c === oldNode) {
				newChildren.push(newNode);

				newNode.parentNode = this;

				newNode.previousSibling = oldNode.previousSibling;
				oldNode.previousSibling = newNode;
				if (newNode.previousSibling) {
					newNode.previousSibling.nextSibling = newNode;
				}

				newNode.nextSibling = oldNode;

				if (this.firstChild === oldNode) {
					this.firstChild = newNode;
				}
			}
			newChildren.push(c);
		}
		this.childNodes = newChildren;
	}

	return oRet;
};

/**
 The AJAXSLT XNode does not support @xml:id or @xsi:type="xsd:ID",
 so this function does support these attributes.

 This function was expanded from the original getElementById() xpath function in AJAXSLT.
 This function returns an array of nodes.
 @addon
 */
XNode.prototype.getElementsById = function(id) {
	var ret = [];
	var oID = null;
	domTraverseElements(this, function(node) {
		oID = node.getAttribute('id');
		if (!oID) {
			oID = node.getAttribute('xml:id');

			if (!oID && node.getAttribute('xsi:type') === 'xsd:ID') {
				oID = node.firstChild.nodeValue.trim();
			}
		}

		if (oID === id) {
			ret.push(node);
		}
	},
	null);
	return ret;
};

XNode.prototype.setAttribute = function(name, value) {
	if (this.nodeType !== DOM_ELEMENT_NODE) {
		return;
	}
	for (var i = 0; i < this.attributes.length; ++i) {
		if (this.attributes[i].nodeName == name) {
			this.attributes[i].nodeValue = '' + value;
			return;
		}
	}
	var newAttr = XNode.create(DOM_ATTRIBUTE_NODE, name, value, this);
	this.attributes.push(newAttr);
	newAttr.parentNode = this;
};

XNode.prototype.setAttributeNode = function(newAttr) {
	if ((this.nodeType !== DOM_ELEMENT_NODE) || (newAttr.nodeType !== DOM_ATTRIBUTE_NODE)) {
		return;
	}
	var i;
	for (i = 0; i < this.attributes.length; ++i) {
		if (this.attributes[i].nodeName === newAttr.nodeName) {
			break;
		}
	}

	if (i < this.attributes.length) {
		this.attributes[i] = newAttr;
	} else {
		this.attributes.push(newAttr);
	}
	newAttr.parentNode = this;
};

XDocument.prototype.createProcessingInstruction = function(target, data) {
	return XNode.create(DOM_PROCESSING_INSTRUCTION_NODE, '#processing-instruction', target + " " + data.replace(/^\s\s*/, '').replace(/\s\s*$/, ''), this);
};



function xmlText(node, opt_cdata, opt_includenamespaceprefixes) {
	var buf = [];
	xmlTextR(node, buf, opt_cdata, opt_includenamespaceprefixes);
	return buf.join('');
}



function xmlTextR(node, buf, cdata, includeNamespacePrefixes) {
	var i, parentNodeName, elementContainsCDATA, a, prefix, j;

	if (node.nodeType == DOM_TEXT_NODE) {
		elementContainsCDATA = false;
		if (cdata && typeof cdata === 'object' && typeof cdata.length === 'number' && typeof cdata.splice === 'function' && !cdata.propertyIsEnumerable('length')) {
			parentNodeName = xmlFullNodeName(node.parentNode);
			for (i = 0; i < cdata.length; ++i) {
				if (parentNodeName === cdata[i]) {
					elementContainsCDATA = true;
					break;
				}
			}
		}

		if (elementContainsCDATA) {
			buf.push('<![CDATA[' + xmlEscapeText(node.nodeValue) + ']]>');
		} else {
			buf.push(xmlEscapeText(node.nodeValue));
		}

	} else if (node.nodeType == DOM_CDATA_SECTION_NODE) {
		if (cdata) {
			buf.push(node.nodeValue);
		} else {
			buf.push('<![CDATA[' + node.nodeValue + ']]>');
		}

	} else if (node.nodeType == DOM_COMMENT_NODE) {
		buf.push('<!--' + node.nodeValue + '-->');

	} else if (node.nodeType == DOM_ELEMENT_NODE) {
		buf.push('<' + xmlFullNodeName(node));
		for (i = 0; i < node.attributes.length; ++i) {
			a = node.attributes[i];
			if (a && a.nodeName) {

				if (a.nodeName.indexOf('xmlns') === 0 && includeNamespacePrefixes) {
					prefix = a.nodeName.split(':')[1];
					for (j = 0; j < includeNamespacePrefixes.length; j++) {
						if (prefix === includeNamespacePrefixes[j] || (prefix === '' && includeNamespacePrefixes[j] === '#default')) {
							buf.push(' ' + xmlFullNodeName(a) + '="' + xmlEscapeAttr(a.nodeValue) + '"');
							break;
						}
					}
				} else {
					buf.push(' ' + xmlFullNodeName(a) + '="' + xmlEscapeAttr(a.nodeValue) + '"');
				}
			}
		}

		if (!node.childNodes.length) {
			buf.push('/>');
		} else {
			buf.push('>');
			for (i = 0; i < node.childNodes.length; ++i) {
				arguments.callee(node.childNodes[i], buf, cdata, includeNamespacePrefixes);
			}
			buf.push('</' + xmlFullNodeName(node) + '>');
		}

	} else if (node.nodeType == DOM_DOCUMENT_NODE || node.nodeType == DOM_DOCUMENT_FRAGMENT_NODE) {
		for (i = 0; i < node.childNodes.length; ++i) {
			arguments.callee(node.childNodes[i], buf, cdata, includeNamespacePrefixes);
		}
	} else if (node.nodeType == DOM_PROCESSING_INSTRUCTION_NODE) {
		buf.push('<?' + node.nodeValue.trim() + '?>');
	}
}
/* A JavaScript implementation of the SHA family of hashes, as defined in FIPS PUB 180-2
 * Version 1.11 Copyright Brian Turek 2008
 * Distributed under the BSD License
 * See http://jssha.sourceforge.net/ for more information
 *
 * Several functions taken from Paul Johnson
 */

/*
 * Int_64 is a object/container for 2 32-bit numbers emulating a 64-bit number
 *
 * @constructor
 * @param {Number} msint_32 The most significant 32-bits of a 64-bit number
 * @param {Number} lsint_32 The least significant 32-bits of a 64-bit number
 */
function Int_64(msint_32, lsint_32) {
	this.highOrder = msint_32;
	this.lowOrder = lsint_32;
}

/*
 * jsSHA is the workhorse of the library.  Instantiate it with the string to be hashed
 * as the parameter
 *
 * @constructor
 * @param {String} srcString The string to be hashed
 */
function jsSHA(srcString) {

	/*
	 * Configurable variables. Defaults typically work
	 */
	jsSHA.charSize = 8; /* Number of Bits Per character (8 for ASCII, 16 for Unicode)	  */
	jsSHA.b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
	jsSHA.hexCase = 0; /* hex output format. 0 - lowercase; 1 - uppercase		*/

	var sha1 = null;
	var sha224 = null;
	var sha256 = null;
	var sha384 = null;
	var sha512 = null;

	/*
	 * Convert a string to an array of big-endian words
	 * If charSize is ASCII, characters >255 have their hi-byte silently ignored.
	 *
	 * @param {String} str String to be converted to binary representation
	 * @return Integer array representation of the parameter
	 */
	var str2binb = function (str) {
		var bin = [];
		var mask = (1 << jsSHA.charSize) - 1;
		var length = str.length * jsSHA.charSize;

		for (var i = 0; i < str.length * jsSHA.charSize; i += jsSHA.charSize) {
			bin[i >> 5] |= (str.charCodeAt(i / jsSHA.charSize) & mask) << (32 - jsSHA.charSize - i % 32);
		}

		return bin;
	};

	var binb2str = function (bin)
	{
		var str = "";
		var mask = (1 << jsSHA.charSize) - 1;
		var length = bin.length * 32;

		for(var i = 0; i < length; i += jsSHA.charSize) {
			str += String.fromCharCode((bin[i >> 5] >>> (32 - jsSHA.charSize - i % 32)) & mask);
		}

		return str;
	};

    var strBinLen = srcString.length * jsSHA.charSize;
	var strToHash = str2binb(srcString);

	/*
	 * Convert an array of big-endian words to a hex string.
	 *
	 * @private
	 * @param {Array} binarray Array of integers to be converted to hexidecimal representation
	 * @return Hexidecimal representation of the parameter in String form
	 */
	var binb2hex = function (binarray) {
		var hex_tab = jsSHA.hexCase ? "0123456789ABCDEF" : "0123456789abcdef";
		var str = "";
		var length = binarray.length * 4;

		for (var i = 0; i < length; i++) {
			str += hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 0xF) + hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8)) & 0xF);
		}

		return str;
	};

	/*
	 * Convert an array of big-endian words to a base-64 string
	 *
	 * @private
	 * @param {Array} binarray Array of integers to be converted to base-64 representation
	 * @return Base-64 encoded representation of the parameter in String form
	 */
	var binb2b64 = function (binarray) {
		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var str = "";
		var length = binarray.length * 4;
		for (var i = 0; i < length; i += 3)
		{
			var triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
			for (var j = 0; j < 4; j++) {
				if (i * 8 + j * 6 > binarray.length * 32) {
					str += jsSHA.b64pad;
				} else {
					str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
				}
			}
		}
		return str;
	};

	var binb2binb = function (binarray) {
		return binarray;
	};

	/*
	 * The 32-bit implementation of circular rotate left
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @param {Number} n The number of bits to shift
	 * @return The x shifted circularly by n bits
	 */
	var rotl_32 = function (x, n) {
		if (n < 32) {
			return (x <<  n) | (x >>> (32 - n));
		} else {
			return x;
		}
	};

	/*
	 * The 32-bit implementation of circular rotate right
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @param {Number} n The number of bits to shift
	 * @return The x shifted circularly by n bits
	 */
	var rotr_32 = function (x, n) {
		if (n < 32) {
			return (x >>> n) | (x << (32 - n));
		} else {
			return x;
		}
	};

	/*
	 * The 64-bit implementation of circular rotate right
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @param {Number} n The number of bits to shift
	 * @return The x shifted circularly by n bits
	 */
	var rotr_64 = function (x, n) {
		if (n < 32) {
			return new Int_64(
					(x.highOrder >>> n) | (x.lowOrder << (32 - n)),
					(x.lowOrder >>> n) | (x.highOrder << (32 - n))
				);
		} else if (n === 32) { // Apparently in JS, shifting a 32-bit value by 32 yields original value
			return new Int_64(x.lowOrder, x.highOrder);
		} else {
			return rotr_64(rotr_64(x, 32), n - 32);
		}
	};

	/*
	 * The 32-bit implementation of shift right
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @param {Number} n The number of bits to shift
	 * @return The x shifted by n bits
	 */
	var shr_32 = function (x, n) {
		if (n < 32) {
			return x >>> n;
		} else {
			return 0;
		}
	};

	/*
	 * The 64-bit implementation of shift right
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @param {Number} n The number of bits to shift
	 * @return The x shifted by n bits
	 */
	var shr_64 = function (x, n) {
		if (n < 32) {
			return new Int_64(
					x.highOrder >>> n,
					x.lowOrder >>> n | (x.highOrder << (32 - n))
				);
		} else if (n === 32) { // Apparently in JS, shifting a 32-bit value by 32 yields original value
			return new Int_64(0, x.highOrder);
		} else {
			return shr_64(shr_64(x, 32), n - 32);
		}
	};

	/*
	 * The 32-bit implementation of the NIST specified Parity function
	 *
	 * @private
	 * @param {Number} x The first 32-bit integer argument
	 * @param {Number} y The second 32-bit integer argument
	 * @param {Number} z The third 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var parity_32 = function (x, y, z) {
		return x ^ y ^ z;
	};

	/*
	 * The 32-bit implementation of the NIST specified Ch function
	 *
	 * @private
	 * @param {Number} x The first 32-bit integer argument
	 * @param {Number} y The second 32-bit integer argument
	 * @param {Number} z The third 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var ch_32 = function (x, y, z) {
		return (x & y) ^ (~x & z);
	};

	/*
	 * The 64-bit implementation of the NIST specified Ch function
	 *
	 * @private
	 * @param {Int_64} x The first 64-bit integer argument
	 * @param {Int_64} y The second 64-bit integer argument
	 * @param {Int_64} z The third 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var ch_64 = function (x, y, z) {
		return new Int_64(
				(x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),
				(x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)
			);
	};

	/*
	 * The 32-bit implementation of the NIST specified Maj function
	 *
	 * @private
	 * @param {Number} x The first 32-bit integer argument
	 * @param {Number} y The second 32-bit integer argument
	 * @param {Number} z The third 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var maj_32 = function (x, y, z) {
		return (x & y) ^ (x & z) ^ (y & z);
	};

	/*
	 * The 64-bit implementation of the NIST specified Maj function
	 *
	 * @private
	 * @param {Int_64} x The first 64-bit integer argument
	 * @param {Int_64} y The second 64-bit integer argument
	 * @param {Int_64} z The third 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var maj_64 = function (x, y, z) {
		return new Int_64(
				(x.highOrder & y.highOrder) ^ (x.highOrder & z.highOrder) ^ (y.highOrder & z.highOrder),
				(x.lowOrder & y.lowOrder) ^ (x.lowOrder & z.lowOrder) ^ (y.lowOrder & z.lowOrder)
			);
	};

	/*
	 * The 32-bit implementation of the NIST specified Sigma0 function
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var sigma0_32 = function (x) {
		return rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);
	};

	/*
	 * The 64-bit implementation of the NIST specified Sigma0 function
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var sigma0_64 = function (x) {
		var rotr28 = rotr_64(x, 28);
		var rotr34 = rotr_64(x, 34);
		var rotr39 = rotr_64(x, 39);

		return new Int_64(
				rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,
				rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);
	};

	/*
	 * The 32-bit implementation of the NIST specified Sigma1 function
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var sigma1_32 = function (x) {
		return rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);
	};

	/*
	 * The 64-bit implementation of the NIST specified Sigma1 function
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var sigma1_64 = function (x) {
		var rotr14 = rotr_64(x, 14);
		var rotr18 = rotr_64(x, 18);
		var rotr41 = rotr_64(x, 41);

		return new Int_64(
				rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,
				rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);
	};

	/*
	 * The 32-bit implementation of the NIST specified Gamma0 function
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var gamma0_32 = function (x) {
		return rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);
	};

	/*
	 * The 64-bit implementation of the NIST specified Gamma0 function
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var gamma0_64 = function (x) {
		var rotr1 = rotr_64(x, 1);
		var rotr8 = rotr_64(x, 8);
		var shr7 = shr_64(x, 7);

		return new Int_64(
				rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,
				rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder);
	};

	/*
	 * The 32-bit implementation of the NIST specified Gamma1 function
	 *
	 * @private
	 * @param {Number} x The 32-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var gamma1_32 = function (x) {
		return rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);
	};

	/*
	 * The 64-bit implementation of the NIST specified Gamma1 function
	 *
	 * @private
	 * @param {Int_64} x The 64-bit integer argument
	 * @return The NIST specified output of the function
	 */
	var gamma1_64 = function (x) {
		var rotr19 = rotr_64(x, 19);
		var rotr61 = rotr_64(x, 61);
		var shr6 = shr_64(x, 6);

		return new Int_64(
				rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,
				rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder);
	};

	/*
	 * Add 32-bit integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 *
	 * @private
	 * @param {Number} x The first 32-bit integer argument to be added
	 * @param {Number} y The second 32-bit integer argument to be added
	 * @return The sum of x + y
	 */
	var safeAdd_32 = function (x, y) {
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >>> 16) + (y >>> 16) + (lsw >>> 16);

		return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	};

	/*
	 * Add 64-bit integers, wrapping at 2^64. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 *
	 * @private
	 * @param {Int_64} x The first 64-bit integer argument to be added
	 * @param {Int_64} y The second 64-bit integer argument to be added
	 * @return The sum of x + y
	 */
	var safeAdd_64 = function (x, y) {
		var lsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);
		var msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);
		var lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

		lsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);
		msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);
		var highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);

		return new Int_64(highOrder, lowOrder);
	};

	/*
	 * Calculates the SHA-1 hash of the string set at instantiation
	 *
	 * @private
	 * @return The array of integers representing the SHA-1 hash of message
	 */
	var coreSHA1 = function () {
		var W = [];
		var a, b, c, d, e;
		var T;
		var ch = ch_32, parity = parity_32, maj = maj_32, rotl = rotl_32, safeAdd = safeAdd_32;
		var H = [
			0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476,	0xc3d2e1f0
		];
		var K = [
			0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
			0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
			0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
			0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
			0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
			0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
			0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
			0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
			0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
			0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
			0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
			0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
			0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
			0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
			0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
			0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
			0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
			0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
			0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
			0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6
		];
		var message = strToHash.slice();

		message[strBinLen >> 5] |= 0x80 << (24 - strBinLen % 32); // Append '1' at  the end of the binary string
		message[((strBinLen + 1 + 64 >> 9) << 4) + 15] = strBinLen; // Append length of binary string in the position such that the new length is a multiple of 512

		var appendedMessageLength = message.length;

		for (var i = 0; i < appendedMessageLength; i += 16) {
			a = H[0];
			b = H[1];
			c = H[2];
			d = H[3];
			e = H[4];

			for (var t = 0; t < 80; t++) {
				if (t < 16) {
					W[t] = message[t + i];
				} else {
					W[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
				}

				if (t < 20) {
					T = safeAdd(safeAdd(safeAdd(safeAdd(rotl(a, 5), ch(b, c, d)), e), K[t]), W[t]);
				} else if (t < 40) {
					T = safeAdd(safeAdd(safeAdd(safeAdd(rotl(a, 5), parity(b, c, d)), e), K[t]), W[t]);
				} else if (t < 60) {
					T = safeAdd(safeAdd(safeAdd(safeAdd(rotl(a, 5), maj(b, c, d)), e), K[t]), W[t]);
				} else {
					T = safeAdd(safeAdd(safeAdd(safeAdd(rotl(a, 5), parity(b, c, d)), e), K[t]), W[t]);
				}

				e = d;
				d = c;
				c = rotl(b, 30);
				b = a;
				a = T;
			}

			H[0] = safeAdd(a, H[0]);
			H[1] = safeAdd(b, H[1]);
			H[2] = safeAdd(c, H[2]);
			H[3] = safeAdd(d, H[3]);
			H[4] = safeAdd(e, H[4]);
		}

		return H;
	};

	/*
	 * Calculates the desired SHA-2 hash of the string set at instantiation
	 *
	 * @private
	 * @param {String} variant The desired SHA-2 variant
	 * @return The array of integers representing the SHA-2 hash of message
	 */
	var coreSHA2 = function (variant) {
		var W = [];
		var a, b, c, d, e, f, g, h;
		var T1, T2;
		var H;
		var numRounds, lengthPosition, binaryStringInc, binaryStringMult;
		var safeAdd, gamma0, gamma1, sigma0, sigma1, ch, maj, Int;
		var K;
		var message = strToHash.slice();

		if (variant === "SHA-224" || variant === "SHA-256") // 32-bit variant
		{
			numRounds = 64;
			lengthPosition = ((strBinLen + 1 + 64 >> 9) << 4) + 15;
			binaryStringInc = 16;
			binaryStringMult = 1;
			Int = Number;
			safeAdd = safeAdd_32;
			gamma0 = gamma0_32;
			gamma1 = gamma1_32;
			sigma0 = sigma0_32;
			sigma1 = sigma1_32;
			maj = maj_32;
			ch = ch_32;
			K = [
					0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
					0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
					0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
					0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
					0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
					0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
					0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
					0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
					0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
					0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
					0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
					0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
					0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
					0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
					0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
					0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
				];

			if (variant === "SHA-224") {
				H = [
						0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
						0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
					];
			} else {
				H = [
						0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
						0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
					];
			}
		} else if (variant === "SHA-384" || variant === "SHA-512") {// 64-bit variant
			numRounds = 80;
			lengthPosition = ((strBinLen + 1 + 128 >> 10) << 5) + 31;
			binaryStringInc = 32;
			binaryStringMult = 2;
			Int = Int_64;
			safeAdd = safeAdd_64;
			gamma0 = gamma0_64;
			gamma1 = gamma1_64;
			sigma0 = sigma0_64;
			sigma1 = sigma1_64;
			maj = maj_64;
			ch = ch_64;

			K = [
					new Int_64(0x428a2f98, 0xd728ae22), new Int_64(0x71374491, 0x23ef65cd), new Int_64(0xb5c0fbcf, 0xec4d3b2f), new Int_64(0xe9b5dba5, 0x8189dbbc),
					new Int_64(0x3956c25b, 0xf348b538), new Int_64(0x59f111f1, 0xb605d019), new Int_64(0x923f82a4, 0xaf194f9b), new Int_64(0xab1c5ed5, 0xda6d8118),
					new Int_64(0xd807aa98, 0xa3030242), new Int_64(0x12835b01, 0x45706fbe), new Int_64(0x243185be, 0x4ee4b28c), new Int_64(0x550c7dc3, 0xd5ffb4e2),
					new Int_64(0x72be5d74, 0xf27b896f), new Int_64(0x80deb1fe, 0x3b1696b1), new Int_64(0x9bdc06a7, 0x25c71235), new Int_64(0xc19bf174, 0xcf692694),
					new Int_64(0xe49b69c1, 0x9ef14ad2), new Int_64(0xefbe4786, 0x384f25e3), new Int_64(0x0fc19dc6, 0x8b8cd5b5), new Int_64(0x240ca1cc, 0x77ac9c65),
					new Int_64(0x2de92c6f, 0x592b0275), new Int_64(0x4a7484aa, 0x6ea6e483), new Int_64(0x5cb0a9dc, 0xbd41fbd4), new Int_64(0x76f988da, 0x831153b5),
					new Int_64(0x983e5152, 0xee66dfab), new Int_64(0xa831c66d, 0x2db43210), new Int_64(0xb00327c8, 0x98fb213f), new Int_64(0xbf597fc7, 0xbeef0ee4),
					new Int_64(0xc6e00bf3, 0x3da88fc2), new Int_64(0xd5a79147, 0x930aa725), new Int_64(0x06ca6351, 0xe003826f), new Int_64(0x14292967, 0x0a0e6e70),
					new Int_64(0x27b70a85, 0x46d22ffc), new Int_64(0x2e1b2138, 0x5c26c926), new Int_64(0x4d2c6dfc, 0x5ac42aed), new Int_64(0x53380d13, 0x9d95b3df),
					new Int_64(0x650a7354, 0x8baf63de), new Int_64(0x766a0abb, 0x3c77b2a8), new Int_64(0x81c2c92e, 0x47edaee6), new Int_64(0x92722c85, 0x1482353b),
					new Int_64(0xa2bfe8a1, 0x4cf10364), new Int_64(0xa81a664b, 0xbc423001), new Int_64(0xc24b8b70, 0xd0f89791), new Int_64(0xc76c51a3, 0x0654be30),
					new Int_64(0xd192e819, 0xd6ef5218), new Int_64(0xd6990624, 0x5565a910), new Int_64(0xf40e3585, 0x5771202a), new Int_64(0x106aa070, 0x32bbd1b8),
					new Int_64(0x19a4c116, 0xb8d2d0c8), new Int_64(0x1e376c08, 0x5141ab53), new Int_64(0x2748774c, 0xdf8eeb99), new Int_64(0x34b0bcb5, 0xe19b48a8),
					new Int_64(0x391c0cb3, 0xc5c95a63), new Int_64(0x4ed8aa4a, 0xe3418acb), new Int_64(0x5b9cca4f, 0x7763e373), new Int_64(0x682e6ff3, 0xd6b2b8a3),
					new Int_64(0x748f82ee, 0x5defb2fc), new Int_64(0x78a5636f, 0x43172f60), new Int_64(0x84c87814, 0xa1f0ab72), new Int_64(0x8cc70208, 0x1a6439ec),
					new Int_64(0x90befffa, 0x23631e28), new Int_64(0xa4506ceb, 0xde82bde9), new Int_64(0xbef9a3f7, 0xb2c67915), new Int_64(0xc67178f2, 0xe372532b),
					new Int_64(0xca273ece, 0xea26619c), new Int_64(0xd186b8c7, 0x21c0c207), new Int_64(0xeada7dd6, 0xcde0eb1e), new Int_64(0xf57d4f7f, 0xee6ed178),
					new Int_64(0x06f067aa, 0x72176fba), new Int_64(0x0a637dc5, 0xa2c898a6), new Int_64(0x113f9804, 0xbef90dae), new Int_64(0x1b710b35, 0x131c471b),
					new Int_64(0x28db77f5, 0x23047d84), new Int_64(0x32caab7b, 0x40c72493), new Int_64(0x3c9ebe0a, 0x15c9bebc), new Int_64(0x431d67c4, 0x9c100d4c),
					new Int_64(0x4cc5d4be, 0xcb3e42b6), new Int_64(0x597f299c, 0xfc657e2a), new Int_64(0x5fcb6fab, 0x3ad6faec), new Int_64(0x6c44198c, 0x4a475817)
				];

			if (variant === "SHA-384") {
				H = [
						new Int_64(0xcbbb9d5d, 0xc1059ed8), new Int_64(0x0629a292a, 0x367cd507), new Int_64(0x9159015a, 0x3070dd17), new Int_64(0x152fecd8, 0xf70e5939),
						new Int_64(0x67332667, 0xffc00b31), new Int_64(0x98eb44a87, 0x68581511), new Int_64(0xdb0c2e0d, 0x64f98fa7), new Int_64(0x47b5481d, 0xbefa4fa4)
					];
			} else {
				H = [
						new Int_64(0x6a09e667, 0xf3bcc908), new Int_64(0xbb67ae85, 0x84caa73b), new Int_64(0x3c6ef372, 0xfe94f82b), new Int_64(0xa54ff53a, 0x5f1d36f1),
						new Int_64(0x510e527f, 0xade682d1), new Int_64(0x9b05688c, 0x2b3e6c1f), new Int_64(0x1f83d9ab, 0xfb41bd6b), new Int_64(0x5be0cd19, 0x137e2179)
					];
			}
		}

		message[strBinLen >> 5] |= 0x80 << (24 - strBinLen % 32); // Append '1' at  the end of the binary string
		message[lengthPosition] = strBinLen; // Append length of binary string in the position such that the new length is correct

		var appendedMessageLength = message.length;

		for (var i = 0; i < appendedMessageLength; i += binaryStringInc) {
			a = H[0];
			b = H[1];
			c = H[2];
			d = H[3];
			e = H[4];
			f = H[5];
			g = H[6];
			h = H[7];

			for (var t = 0; t < numRounds; t++) {
				if (t < 16) {
					W[t] = new Int(message[t * binaryStringMult + i], message[t * binaryStringMult + i + 1]); // Bit of a hack - for 32-bit, the second term is ignored
				} else {
					W[t] = safeAdd(safeAdd(safeAdd(gamma1(W[t - 2]), W[t - 7]), gamma0(W[t - 15])), W[t - 16]);
				}

				T1 = safeAdd(safeAdd(safeAdd(safeAdd(h, sigma1(e)), ch(e, f, g)), K[t]), W[t]);
				T2 = safeAdd(sigma0(a), maj(a, b, c));
				h = g;
				g = f;
				f = e;
				e = safeAdd(d, T1);
				d = c;
				c = b;
				b = a;
				a = safeAdd(T1, T2);
			}

			H[0] = safeAdd(a, H[0]);
			H[1] = safeAdd(b, H[1]);
			H[2] = safeAdd(c, H[2]);
			H[3] = safeAdd(d, H[3]);
			H[4] = safeAdd(e, H[4]);
			H[5] = safeAdd(f, H[5]);
			H[6] = safeAdd(g, H[6]);
			H[7] = safeAdd(h, H[7]);
		}

		switch (variant) {
		case "SHA-224":
			return	[
				H[0], H[1],	H[2], H[3],
				H[4], H[5],	H[6]
			];
		case "SHA-256":
			return H;
		case "SHA-384":
			return	[
				H[0].highOrder, H[0].lowOrder,
				H[1].highOrder, H[1].lowOrder,
				H[2].highOrder, H[2].lowOrder,
				H[3].highOrder, H[3].lowOrder,
				H[4].highOrder, H[4].lowOrder,
				H[5].highOrder, H[5].lowOrder
			];
		case "SHA-512":
			return	[
				H[0].highOrder, H[0].lowOrder,
				H[1].highOrder, H[1].lowOrder,
				H[2].highOrder, H[2].lowOrder,
				H[3].highOrder, H[3].lowOrder,
				H[4].highOrder, H[4].lowOrder,
				H[5].highOrder, H[5].lowOrder,
				H[6].highOrder, H[6].lowOrder,
				H[7].highOrder, H[7].lowOrder
			];
		default:
			return []; // This should near be reached
		}
	};

	var getFormatFunc = function (format) {
		switch (format) {
			case "HEX":
				return binb2hex;
			case "B64":
				return binb2b64;
			case "RAW":
				return binb2binb;
			default:
				return null;
		}
	};

	var getSHAFunc = function (variant) {
		switch (variant) {
			case "SHA-1":
				return coreSHA1;
			case "SHA-224":
			case "SHA-256":
			case "SHA-384":
			case "SHA-512":
				return coreSHA2;
			default:
				return null;
		}
	};

	this.getHMAC = function (key, variant, format) {
		var binaryKey = str2binb(key), numWordsPerBlock = (variant === "SHA-384" || variant === "SHA-512" ? 32 : 16), localSHA, i, innerPad = new Array(numWordsPerBlock), outerPad = new Array(numWordsPerBlock), hmac;
		if (binaryKey.length > numWordsPerBlock) {
			localSHA = new jsSHA(key);
			binaryKey = localSHA.getHash(variant, "RAW");
		}

		for (i = 0; i < numWordsPerBlock; ++i) {
			innerPad[i] = binaryKey[i] ^ 0x36363636;
			outerPad[i] = binaryKey[i] ^ 0x5c5c5c5c;
		}

		localSHA = new jsSHA(binb2str(innerPad) + srcString);
		hmac = localSHA.getHash(variant, "RAW");

		localSHA = new jsSHA(binb2str(outerPad.concat(hmac)));
		hmac = localSHA.getHash(variant, "RAW");

		return getFormatFunc(format)(hmac);
	};

	/*
	 * Returns the desired SHA hash of the string specified at instantiation using the specified parameters
	 *
	 * @param {String} variant The desired SHA variant (SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512)
	 * @param {String} format The desired output formatting (B64 or HEX)
	 * @return The string representation of the hash in the format specified
	 */
	this.getHash = function (variant, format) {
		switch (variant) {
			case "SHA-1":
				return getFormatFunc(format)(coreSHA1());
			case "SHA-224":
			case "SHA-256":
			case "SHA-384":
			case "SHA-512":
				return getFormatFunc(format)(coreSHA2(variant));
			default:
				return "HASH NOT RECOGNIZED";
		}
	};
}
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

MD5 = new function(){
/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
this.hex_md5 = function(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}
this.b64_md5 = function (s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}
this.str_md5 = function(s) { return binl2str(core_md5(str2binl(s), s.length * chrsz));}
this.hex_hmac_md5 = function(key, data) { return binl2hex(core_hmac_md5(key, data)); }
this.b64_hmac_md5 = function(key, data) { return binl2b64(core_hmac_md5(key, data)); }
this.str_hmac_md5 = function(key, data) { return binl2str(core_hmac_md5(key, data)); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
function core_hmac_md5(key, data)
{
  var bkey = str2binl(key);
  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
  return core_md5(opad.concat(hash), 512 + 128);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
  return bin;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
  return str;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of little-endian words to a base-64 string
 */
function binl2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}
};


/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

YAHOO.util.Connect.handleTransactionResponse = function(o, callback, isAbort) {
	if (!callback) {
		this.releaseObject(o);
		YAHOO.log('No callback object to process. Transaction complete.', 'info', 'Connection');
		return;
	}
	var httpStatus, responseObject;

	try {
		if (o.conn.status !== undefined) {
			httpStatus = o.conn.status;
		} else {
			httpStatus = 13030;
		}
	}
	catch(e) {

		httpStatus = 13030;
	}
	if ((httpStatus >= 200 && httpStatus < 300) || httpStatus === 1223 || (httpStatus === 0 && callback.scheme === 'file')) {

		responseObject = this.createResponseObject(o, callback.argument);
		if (callback.success) {
			if (!callback.scope) {
				callback.success(responseObject);
				YAHOO.log('Success callback. HTTP code is ' + httpStatus, 'info', 'Connection');
			} else {
				callback.success.apply(callback.scope, [responseObject]);
				YAHOO.log('Success callback with scope. HTTP code is ' + httpStatus, 'info', 'Connection');
			}
		}

		this.successEvent.fire(responseObject);

		if (o.successEvent) {
			o.successEvent.fire(responseObject);
		}
	} else {
		switch (httpStatus) {
		case 12002:
		case 12029:
		case 12030:
		case 12031:
		case 12152:
		case 13030:
			responseObject = this.createExceptionObject(o.tId, callback.argument, (isAbort ? isAbort : false));
			if (callback.failure) {
				if (!callback.scope) {
					callback.failure(responseObject);
					YAHOO.log('Failure callback. Exception detected. Status code is ' + httpStatus, 'warn', 'Connection');
				} else {
					callback.failure.apply(callback.scope, [responseObject]);
					YAHOO.log('Failure callback with scope. Exception detected. Status code is ' + httpStatus, 'warn', 'Connection');
				}
			}
			break;
		default:
			responseObject = this.createResponseObject(o, callback.argument);
			if (callback.failure) {
				if (!callback.scope) {
					callback.failure(responseObject);
					YAHOO.log('Failure callback. HTTP status code is ' + httpStatus, 'warn', 'Connection');
				} else {
					callback.failure.apply(callback.scope, [responseObject]);
					YAHOO.log('Failure callback with scope. HTTP status code is ' + httpStatus, 'warn', 'Connection');
				}
			}
		}

		this.failureEvent.fire(responseObject);

		if (o.failureEvent) {
			o.failureEvent.fire(responseObject);
		}

	}

	this.releaseObject(o);
	responseObject = null;
};

(function() {

	this.XLinkElement = new UX.Class({

		toString: function() {
			return 'xf:xlink';
		},

		initialize: function() {
			this.m_bTraversed = false;
			this.m_sActuate = "";
		},

		onDocumentReady: function() {
			this.m_sActuate = this.element.getAttribute("xlink:actuate");
			if (this.m_sActuate == "onRequest") {
				if (this.XLinkRequestEvent) {
					this.element.addEventListener(this.XLinkRequestEvent, this, false);
				}
			} else if (this.m_sActuate == "onLoad") {
				this.Actuate();
			}
		},

		handleEvent: function(evt) {
			if (evt.type == this.XLinkRequestEvent) {
				this.Actuate();
			}
		},

		/**
		 Executes the xlink behaviour.
		 */
		Actuate: function() {
			if (this.m_bTraversed) return;

			var sHref = this.element.getAttribute("xlink:href");
			var sShow = this.element.getAttribute("xlink:show");
			var sResolvedHref = resolveURL(this.element, sHref);
			var oCallback;
			var self = this;
			switch (sShow) {
			case "replace":
				document.location.href = sResolvedHref;
				break;
			case "new":
				window.open(sResolvedHref, "_blank");
				break;
			case "embed":
				oCallback = {
					processResult: function(data, isFailure) {
						if (isFailure) {
							self.embed_handleFailure(data);
						} else {
							self.embed_handleResponse(data);
						}
					},
					success: this.embed_handleResponse,
					failure: this.embed_handleFailure,
					scope: this
				};
				var targetElement = this.getTargetElement();
				targetElement.innerHTML = "<img src='theme/bartek/images/spinner.gif' />";
				this.fetchData(sResolvedHref, oCallback);
				targetElement.setAttribute("xml:base", sHref);
				break;
			case "none":
				oCallback = {
					processResult: this.doNothing,
					success: this.doNothing,
					failure: this.doNothing,
					scope: this

				};
				this.fetchData(sResolvedHref, oCallback);
				break;
			case "other":
				var sAction = element.getAttribute("xlinkShowAction");
				if (sAction) {
					oCallback = {
						processResult: this.doAction,
						success: this.doAction,
						failure: this.doAction,
						action: this.sAction,
						element: this.element
					};
					this.fetchData(sResolvedHref, oCallback);
				}

			}
		},

		doAction: function(o) {
			if (o.status === 0) {
				o.responseXML.async = false;
				if (o.responseText.indexOf("<?xml") === 0) {
					o.responseXML.loadXML(o.responseText.substr(o.responseText.indexOf("?>") + 2));
				} else {
					o.responseXML.loadXML(o.responseText);
				}
			}
			var sAction = this.action;
			var self = this;
			spawn(function() {
				eval(sAction);
				self.onXLinkTraversed();
			});
		},

		doNothing: function() {

		},

		fetchData: function(sHref, oCallback) {
			var schemeHandler, m_transaction;
			try {
				oCallback.scheme = spliturl(sHref).scheme;
				schemeHandler = schemeHandlers[oCallback.scheme];

				if ((UX.isFF || UX.isWebKit) && schemeHandler && schemeHandler["GET"]) {
					spawn(function() {
						schemeHandler["GET"](sHref, null, null, oCallback);
					});
				} else {
					m_transaction = YAHOO.util.Connect.asyncRequest("GET", sHref, oCallback, null);
				}
			}
			catch(e) {
				if (element.getAttribute("xlink:show") === "embed") {
					oCallback.failure();
				} else {
					console.log("xlink:show != 'embed'");
				}
			}

		},

		/**
		 Responds to a successful return from the http request.
		 @param {Object} an object containing the response
		 */
		getTargetElement: function() {
			var targetElement = null;
			var id = this.element.getAttribute("targetref") || this.element.getAttribute("target");
			if (id) {
				targetElement = this.element.ownerDocument.getElementById(id);
			}
			return targetElement || this.element;
		},

		embed_handleResponse: function(o) {
			var targetElement = this.getTargetElement();
			if (!DECORATOR.getBehaviour(targetElement).xlinkEmbed) {
				DECORATOR.getBehaviour(targetElement).xlinkEmbed = function(s) {
					this.innerHTML = s;
				};
			}

			var element = this.element;
			var self = this;
			spawn(function() {
				DECORATOR.getBehaviour(targetElement).xlinkEmbed(o.responseText, element.getAttribute("xlink:href"));
				window.status = "";
				self.onXLinkTraversed();
			});
		},

		embed_handleFailure: function(o) {
			var evt;
			try {
				evt = element.ownerDocument.createEvent("Events");
				evt.initEvent("xlink-traversal-failure", false, false);
				evt.context = {
					"resource-uri": this.element.getAttribute("xlink:href")
				};
				this.element.dispatchEvent(evt);
			} catch(e) {
			}
			if (this.m_sActuate === "onRequest" && this.XLinkRequestEvent) {
				this.element.removeEventListener(this.XLinkRequestEvent, this, false);
			}
		},

		onXLinkTraversed: function() {
			try {
				var evt = this.element.ownerDocument.createEvent("Events");
				evt.initEvent("xlink-traversed", false, false);
				this.element.dispatchEvent(evt);
			}
			catch(e) {
			}
			if (this.m_sActuate == "onRequest" && this.XLinkRequestEvent) {
				this.element.removeEventListener(this.XLinkRequestEvent, this, false);
			}
			this.m_bTraversed = true;
		}

	});

	/*
	 * [ISSUE] There are loads of issues with this...what if @xml:base is
	 * already absolute, on the first iteration? The code here doesn't test
	 * for that until the end of the while loop, but should do so at the
	 * beginning. Also, if a path uses ".." they must be factored out.
	 */

	function getBase(element) {

		/*
		 * If we have an @xml:base then begin with that.
		 */

		var base = element.getAttribute("xml:base");

		if (!base) {
			base = "";
		}

		var parent = element.parentNode;

		while (parent && parent.nodeType === 1) {
			if (parent.getAttribute("base")) {
				base = parent.getAttribute("base") + base;
				parent = null;
				break;
			}

			var s = parent.getAttribute("xml:base");

			if ( !! s) {
				base = s.substr(0, s.lastIndexOf("/") + 1) + base;
			}

			if (!isRelativePath(base)) {
				break;
			}
			parent = parent.parentNode;
		}

		/*
		 * If we got to the top of the document then use the URL
		 * of the document.
		 */

		if (!parent || parent.nodeType === 9) {
			var docHref = element.ownerDocument.location.href;
			base = docHref.substr(0, docHref.lastIndexOf("/") + 1) + base;
		}

		return base;
	}

	function isRelativePath(sURL) {
		if (sURL.charAt(0) == "/") {
			return false;
		} else {
			if ((spliturl(sURL).scheme)) {
				return false; // valid URI and therefore is not relative but Absolute
			}
		}
		return true;
	}

	function resolveURL(element, URL) {
		if (isRelativePath(URL)) {
			if (!element.getAttribute("base")) {
				element.setAttribute("base", getBase(element));
			}
			return element.getAttribute("base") + URL;
		} else {
			return URL;
		}
	}

})();
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var LoadExternalMixin = new UX.Class({

	toString: function() {
		return 'xf:load-external-mixin';
	},

	onContentReady: function() {
		if (!this.m_oDOM) {
			var src = this.element.getAttribute("src");
			if (src) {
				this.load(src);
			} else {
				this.parseInstance();

				if (!this.finishLoad()) {
					var resource = this.element.getAttribute("resource");
					if (resource) {
						this.load(resource);
					}
				}
			}
		}
	},

	dispatchException: function(exceptionName, exceptionContext) {
		var evt = document.createEvent("Events");
		evt.initEvent(exceptionName, true, false);
		evt.context = exceptionContext;
		this.element["elementState"] = -1;
		FormsProcessor.dispatchEvent((typeof this.element.parentNode.modelConstruct === "function") ? this.element.parentNode : this.element, evt);
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Instance = new UX.Class({

	Mixins: [LoadExternalMixin],

	toString: function() {
		return 'xf:instance';
	},

	initialize: function(element) {
		this.element = element;
		this.m_oDOM = null;
		this.element["elementState"] = 1;
		this.model = element.parentNode;
		UX.addStyle(this.element, "display", "none");
	},

	load: function(domURL) {

		if (domURL) {
			this.element.setAttribute("xlink:actuate", "onRequest");
			this.element.setAttribute("xlink:show", "embed");
			this.element.setAttribute("xlink:href", domURL);

			UX.extend(this, new XLinkElement(this.element));

			this.element.addEventListener("xlink-traversed", {
				context: this,
				handleEvent: function(evtParam) {
					var evt = this.context.element.ownerDocument.createEvent("Events");
					evt.initEvent("instance-load", true, false);
					var oTarget = this.context.element;
					FormsProcessor.dispatchEvent(oTarget, evt);
				}
			},
			false);

			this.element.addEventListener("xlink-traversal-failure", {
				context: this,
				handleEvent: function(evtParam) {
					var dispatcher = this.context;
					spawn(function() {
						dispatcher.dispatchException("xforms-link-exception", evtParam.context);
					});
				}
			},
			false);

			/*
	        * [ISSUE] Need to decide how to actuate, since
	        * onLoad is too late.
	        */

			this.Actuate();
		}
	},

	xlinkEmbed: function(s, domURL) {
		this.m_oDOM = new DOMParser().parseFromString(s, "text/xml");
		this.element["elementState"] = 0;
		this.finishLoad(domURL);
		return true;
	},

	parseInstance: function() {
		var sXML = "";
		if (UX.isXHTML) {
			var o = new XMLSerializer();
			var n = this.element.firstChild;
			while (n) {
				sXML += o.serializeToString(n);
				n = n.nextSibling;
			}
		} else {
			sXML = this.element.innerHTML.replace(/<input>((?:.|\n)*?)(?:\s*<|$)/g, function(full, match) {
					return '<input>' + match + '</input><';
			}).replace(/<\/?([^ >]*)/g, function(full, match){return full.toLowerCase()});//ie sometimes returns uppercased tag names in innerHTML
		}

		if (sXML !== "") {
			try {
				this.m_oDOM = new DOMParser().parseFromString(sXML, "text/xml");
			} catch(e) {
			}
			this.element["elementState"] = 0;
		}
		return;
	},

	finishLoad: function(domURL) {
		var ret = false;
		if (this.m_oDOM && this.m_oDOM.documentElement) {
			ret = true;
			if (typeof this.model.flagRebuild === "function") this.model.flagRebuild();
			this.m_oDOM.documentElement.setAttribute('ux_uid_element', this.element.ux_uid);
			this.m_oOriginalDOM = UX.cloneDocument(this.m_oDOM);
			NamespaceManager.readOutputNamespacesFromInstance(this.m_oDOM);
		} else if (!this.element["elementState"]) {
			ret = true;
			this.dispatchException("xforms-link-exception", {
				"resource-uri": domURL || ("#" + this.element.getAttribute("id"))
			});
		}

		return ret;
	},

	getDocument: function() {
		return this.m_oDOM;
	},

	replaceDocument: function(oDom) {
		this.m_oDOM = oDom;
		if (!this.m_oOriginalDOM) {
			this.m_oOriginalDOM = UX.cloneDocument(this.m_oDOM);
		}
		return;
	},

	reset: function() {
		this.replaceDocument(UX.cloneDocument(this.m_oOriginalDOM));
	},

	deleteNodes: function(oContext, nodesetExpr, atExpr) {
		return this.deleteFromNodeset(oContext, this.evalXPath(nodesetExpr, oContext).nodeSetValue(), atExpr);
	},

	deleteFromNodeset: function(oContext, nodeset, atExpr) {
		var at, atContext, i, node, nsDeleted = [],
			evt;

		/**
		 Helper function: deleteNode - deletes a given node as per XForms 1.1 section 10.4 step 4.
		 Returns true if the node is indeed deleted or false if the node cannot be deleted according the XForms 1.1.
		 delete processing rules (and must be ignored).
		 */
		var deleteNode = function(node, deleteLocation) {
			var parentNode;
			if(node.nodeType == 2) {//attr
				parentNode = !UX.isIE ? node.ownerElement : node.selectSingleNode('..');
			} else {
				parentNode = node.parentNode;
			}

			if (!parentNode || ((parentNode.nodeType === DOM_DOCUMENT_NODE) && (node.nodeType === DOM_ELEMENT_NODE))) {
				return false;
			}
			if (UX.isNodeReadonly((deleteLocation) ? parentNode : node)) {
				return false;
			}

			var proxy = UX.getProxyNode(node, true);
			if(proxy) proxy.m_oNode = null;

			if (node.nodeType === DOM_ATTRIBUTE_NODE) {
				parentNode.removeAttribute(node.nodeName);
			} else {
				parentNode.removeChild(node);
			}

			return true;
		};
		if (nodeset.length) {

			if (atExpr) {
				atContext = UX.beget(oContext);
				atContext.size = nodeset.length;
				atContext.position = 1;
				atContext.node = nodeset[0];
				at = Math.round(this.evalXPath(atExpr, atContext).numberValue());
			}

			if (at !== undefined) {
				at = at < 1 ? 1 : (at <= nodeset.length ? at : nodeset.length);

				node = nodeset[at - 1];
				if (deleteNode(node, at)) {
					nsDeleted.push(node);
				}

			} else {
				for (i = 0; i < nodeset.length; i++) {
					node = nodeset[i];
					if (deleteNode(node)) {
						nsDeleted.push(node);
					}
				} // for each node
			} // if there is an at value ... else ...
		} // if no nodes were found
		if (nsDeleted.length) {
			evt = document.createEvent("Events");
			evt.initEvent("xforms-delete", true, false);
			evt.context = {
				"deleted-nodes": nsDeleted,
				"delete-location": at
			};
			FormsProcessor.dispatchEvent(this, evt);
			return true;
		} else {
			return false;
		}
	},

	insertNodes: function(oContext, nodesetExpr, atExpr, position, originExpr) {
		return this.insertNodeset(oContext, ((nodesetExpr) ? this.evalXPath(nodesetExpr, oContext).nodeSetValue() : null), atExpr, position, originExpr);
	},

	insertNodeset: function(oContext, ns, atExpr, position, originExpr) {
		var nsOrigin = (originExpr) ? (typeof originExpr === 'string' ? this.evalXPath(originExpr, oContext).nodeSetValue() : originExpr) : ((ns) ? new Array(ns[ns.length - 1]) : null);
		var at, after, i, insertLocationNode, insertTarget, insertBeforeNode, cloneNode, nsLocationNode = [],
			nsInserted = [],
			evt, atRoot, insertNode;

		if(!oContext) return false;
		if (ns && ns.length > 0) {
			if (atExpr) {
					var atContext = UX.beget(oContext);
					atContext.size = ns.length;
					atContext.position = 1;
					at = Math.round(this.evalXPath(atExpr, atContext).numberValue());
			} else {
					at = ns.length;
			}
			at = at < 1 ? 1 : (at <= ns.length ? at : ns.length);

			insertLocationNode = ns[at - 1];
			nsLocationNode.push(insertLocationNode);

			after = (position) ? (position !== 'before') : true;

			if (after) {
				insertBeforeNode = insertLocationNode.nextSibling ? insertLocationNode.nextSibling : null;
			} else {
				insertBeforeNode = insertLocationNode;
			}

			insertTarget = insertLocationNode.parentNode;

		} // end if (non-empty nodeset)
		else if (oContext.initialContext && nsOrigin && nsOrigin.length > 0) {
			insertTarget = oContext.node ? oContext.node : oContext;
			nsLocationNode.push(insertTarget);
			insertBeforeNode = (insertTarget.firstChild) ? insertTarget.firstChild : null;
		}

		if (insertTarget) {
			atRoot = false;
			for (i = 0; i < nsOrigin.length; i++) {
				insertNode = true;
				if ((insertTarget.nodeType === DOM_DOCUMENT_NODE) && (nsOrigin[i].nodeType === DOM_ELEMENT_NODE)) {
					if (atRoot) {
						insertNode = false;
					} else {
						atRoot = true;
					}
				}

				if (nsOrigin[i].nodeType === DOM_ATTRIBUTE_NODE) {
					if ((insertTarget.nodeType !== DOM_ELEMENT_NODE) || (ns && ns.length > 0)) {
						insertNode = false;
					}
				}

				if (insertNode) {
					cloneNode = nsOrigin[i].cloneNode(true);
					nsInserted.push(cloneNode);
				}
			}

			if (atRoot) {
				insertLocationNode = insertTarget.firstChild;
				while (insertLocationNode && (insertLocationNode.nodeType !== DOM_ELEMENT_NODE)) {
					insertLocationNode = insertLocationNode.nextSibling;
				}

				if (insertLocationNode) {
					if (insertBeforeNode && insertBeforeNode === insertLocationNode) {
						insertBeforeNode = insertBeforeNode.nextSibling;
					}
					insertTarget.removeChild(insertLocationNode);
				}
			}

			for (i = 0; i < nsInserted.length; i++) {
				if (nsInserted[i].nodeType !== DOM_ATTRIBUTE_NODE) {
					insertTarget.insertBefore(nsInserted[i], insertBeforeNode);
				} else {
					insertTarget.setAttributeNode(nsInserted[i]);
				}
			}
		}
		if (!nsInserted.length) return false;
		evt = document.createEvent("Events");
		evt.initEvent("xforms-insert", true, false);

		evt.context = {
			"inserted-nodes": nsInserted,
			"origin-nodes": nsOrigin,
			"insert-location-node": nsLocationNode,
			"position": (after ? "after" : "before")
		};
		FormsProcessor.dispatchEvent(this, evt);
		return true;
	},

	evalXPath: function(expr, oContext) {
		return xpathDomEval(expr, oContext || {
			node: this.m_oDOM.documentElement
		});
	}

});

document.notify = document.notify || { };

document.notify.activate = function( el ) {
  UX.replaceClassName(el, "inactive", "active");
  return;
};

document.notify.deactivate = function( el ) {
  UX.replaceClassName(el, "active", "inactive");
  return;
};

document.notify.ephemeral = function(message, activate) {
  if (activate === undefined || activate) {
    document.notify.activate( message );

    setTimeout(
      function() {
        document.notify.deactivate( message );
        return;
      },
     6000
    );
  } else {
    document.notify.deactivate( message );
  }
  return;
};
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function Vertex(oVT) {
	this.vertexTarget = oVT;
	this.depList = [];
	this.depListIdx = {};
	this.inDegree = 0;
	this.visited = false;
	this.index = 0;
	this.initId();
}

(function() {

	var vertexCount = 0;

	Vertex.prototype.initId = function() {
		this.vertexId = ++vertexCount;
	};

})();

Vertex.prototype.setDependencyList = function(ar) {
	this.depList = ar;
	this.depListIdx = {};
	for (var i = 0; i < ar.length; i++) {
		var oVertex = ar[i];
		this.depListIdx[oVertex.vertexId] = oVertex;
	}
};

Vertex.prototype.addDependent = function(oVertex) {
	this.depList.push(oVertex);
	this.depListIdx[oVertex.vertexId] = oVertex;
};



function Pair(first, second) {
	this.first = first;
	this.second = second;
}



function ChangeList() {
	this.m_Lc = [];
}

ChangeList.prototype.addChange = function(oVertex) {
	this.m_Lc.push(oVertex);
};

ChangeList.prototype.clear = function() {
	this.m_Lc.length = 0;
};



function dependencyEngine(model) {
	this.m_M = [];
	this.m_contextNodes = {};
	this.m_proxyNodes = {};
	this.model = model;
}

dependencyEngine.prototype.clear = function() {
	var M = this.m_M;

	/*
	 * Before we clear the list we need to go to
	 * each of the vertices in the list and find
	 * its vertex target, which will in turn give
	 * us the proxy node...where we need to remove
	 * the reference to the vertex.
	 */

	for (var i = 0; i < M.length; i++) {
		var v = M[i];
		var oVT = v.vertexTarget;

		if (oVT && oVT.m_oProxy) {
			oVT.m_oProxy.m_vertex = null;
		}
	}

	/*
	 * Now clear the list.
	 */

	M.length = 0;
};

dependencyEngine.prototype.createVertex = function(oVT) {
	var v = new Vertex(oVT);
	this.m_M.push(v);

	var node, nodeId;
	if (oVT.m_oContext && oVT.m_oContext.node) {
		nodeId = UX.getNodeUID(oVT.m_oContext.node);
		this.addToNodeVertexIndex(this.m_contextNodes, nodeId, v);
	}
	if (oVT.m_oProxy && oVT.m_oProxy.m_oNode) {
		nodeId = UX.getNodeUID(oVT.m_oProxy.m_oNode);
		this.addToNodeVertexIndex(this.m_proxyNodes, nodeId, v);
	}

	return v;
};

dependencyEngine.prototype.addToNodeVertexIndex = function(nodeIdxObj, nodeId, vertexToAdd) {
	if (!nodeId) return;
	if (!vertexToAdd || !vertexToAdd.vertexId) return;

	var vertexId = vertexToAdd.vertexId;

	if (typeof(nodeIdxObj[nodeId]) !== 'object') {
		nodeIdxObj[nodeId] = {};
	}
	nodeIdxObj[nodeId][vertexId] = vertexToAdd;
};

dependencyEngine.prototype.recalculate = function(oChangeList) {
	this.ProcessPertinentDependencySubgraph(
		this.CreatePertinentDependencySubgraph(oChangeList.m_Lc)
	);
};

dependencyEngine.prototype.CreatePertinentDependencySubgraph = function(Lc) {
	var M = this.m_M;
	var S = [];
	var stack = [];
	var i, j, x, vS, v;
	for (i = 0; i < Lc.length; ++i) {
		var r = Lc[i];
		if (r.visited === false) {
			stack.push(new Pair(null, r));
			while (stack.length > 0) {
				var p = stack.pop();
				v = p.first;
				var w = p.second;

				var wS = null;
				if (w.visited === false) {
					w.visited = true;
					w.index = S.length;
					wS = new Vertex(w.vertexTarget);
					for (j = 0; j < M.length; ++j) {
						x = M[j];
						if (x == w) {
							wS.index = j;
							break;
						}
					}
					S.push(wS);
					if (typeof w.depList == "object" && w.depList !== null) {
						for (j = 0; j < w.depList.length; ++j) {
							x = w.depList[j];
							stack.push(new Pair(w, x));
						}
					}
				} else wS = S[w.index];

				if (v !== null && wS) {
					vS = S[v.index];
					if (typeof(vS.depList) != "object" || vS.depList == null) {
						vS.depList = new Array;
						vS.depListIdx = {};
					}

					vS.depList.push(wS);
					vS.depListIdx[wS.vertexId] = wS;
					++wS.inDegree;
				}

			}
		}
	}

	for (i = 0; i < S.length; ++i) {
		vS = S[i];
		v = M[vS.index];
		v.visited = false;
	}

	return S;
};
dependencyEngine.prototype.ProcessPertinentDependencySubgraph = function(S) {
	/*
	while(S.length > 0)
	{
		var vS = S.shift();
		if (vS.inDegree == 0) {
			this.doUpdate(vS);

			if(typeof(vS.depList) == "object" && vS.depList != null) {
				for(var j = 0; j < vS.depList.length; ++j) {
					var wS = vS.depList[j];
					--wS.inDegree;
				}
			}
		}
		else
		{
			S.push(vS);
		}

	}*/

	for (var i = 0; i < S.length; i++) {
		var vS = S[i];
		if (vS.inDegree == 0) {
			S.splice(i, 1);

			this.doUpdate(vS);

			if (typeof(vS.depList) == "object" && vS.depList != null) {
				for (var j = 0; j < vS.depList.length; ++j) {
					var wS = vS.depList[j];
					--wS.inDegree;
				}
			}

			this.ProcessPertinentDependencySubgraph(S);

			break;
		}
	}

	if (S.length > 0) {
		var evt = document.createEvent("Events");
		evt.initEvent("xforms-compute-exception", true, false);
		evt.context = {
			"error-message": "Recursive calculation structure detected."
		};
		this.model.dispatchEvent(evt);
	}
};

dependencyEngine.prototype.doUpdate = function(vS) {
	if (typeof(vS) == "object" && vS != null && typeof(vS.vertexTarget) == "object" && vS.vertexTarget != null) {
		vS.vertexTarget.update();
	} else throw "doUpdate(): Invalid argument.";
};

var bEnableDumpState = false;
if (bEnableDumpState) {
	Vertex.prototype.dumpState = function(sIndent) {
		var s = "[vertex] target=" + this.vertexTarget.identifier();
		var sChildIndent = sIndent + "\t";
		for (var i = 0; i < this.depList.length; ++i) {
			s += ("\n" + sIndent + this.depList[i].dumpState(sChildIndent));
		}
		return s;
	};

	dependencyEngine.prototype.dumpState = function() {
		var s = "Dependency Engine";
		for (var i = 0; i < this.m_M.length; ++i) {
			s += ("\n" + this.m_M[i].dumpState("\t"));
		}
		return s;
	};
}
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function processBinds(model, element, context) {
	var binds = element.childNodes;
	for (var i = 0, l = binds.length; i < l; i++) {
		var bind = binds[i];
		if (NamespaceManager.compareFullName(bind, "bind", "http://www.w3.org/2002/xforms")) {
			bind["ownerModel"] = model;
			expr = bind.getAttribute("nodeset") || ".";
			if (expr) {
				processBind(bind, expr, model, context);
			}
		}
	}
}


function processBind(oBind, sExpr, oModel, oContext) {
	document.logger.log("Start processBind: " + sExpr, "mdl");
	var oNodeset, oNode, oPN, i, j, sMIPName, sMIPVal, modelItemProps = ["readonly", "required", "relevant", "calculate", "constraint", "type"
	/*, "p3ptype" */
	],
		oRes = oModel.EvaluateXPath(sExpr, oContext),
		oBinder = null,
		oParentBind = null,
		loopContext;
	if (oRes) {
		if (oBind.getAttribute("context")) {
			oBinder = oBind.parentNode;

			while (oBinder) {
				if (oBinder.getAttribute("nodeset")) {
					oParentBind = oBinder;
					break;
				}
				oBinder = oBinder.parentNode;
			}
		}
		switch (oRes.type) {
		case "node-set":
			oNodeset = oRes.nodeSetValue();

			if (oNodeset) {
				for (i = 0; i < oNodeset.length; i++) {
					oNode = oNodeset[i];
					loopContext = {
						node: oNode,
						model: oModel,
						position: i,
						size: oNodeset.length,
						resolverElement: oBind
					};
					if (oNode) {
						oPN = UX.getProxyNode(oNode);
						if (i === 0) {
							oBind.boundNode = oPN;
							oBind.boundNodeSet = oNodeset;
						}

						if (!oPN.m_vertex) {
							var oSE = new SubExpression(oPN);
							oPN.m_vertex = oModel.m_oDE.createVertex(oSE);

							oModel.changeList.addChange(oPN.m_vertex);
						}

						for (j = 0; j < modelItemProps.length; j++) {
							var oMIPVertex = null;
							sMIPName = modelItemProps[j];
							sMIPVal = oBind.getAttribute(sMIPName);

							if (sMIPVal) {
								if (sMIPName === "calculate") {
									oMIPVertex = oPN.m_vertex;
								} else if (sMIPName === "relevant") {
									sMIPName = "enabled";
								} else if (sMIPName === "type") {
									oPN.datatype = sMIPVal;
								}

								if (oParentBind) {
									oPN = oParentBind["boundNode"];
								}
								oModel.createMIP(oMIPVertex, sMIPName, sMIPVal, oPN, loopContext);
							}
						}

						processBinds(oModel, oBind, loopContext);
					}
				} // for ( each of the nodes in the node-list )
			}
			break;

		case "boolean":
			break;

		case "number":
			break;

		case "string":
			break;
		default:
			document.logger.log("Binding exception: " + sExpr, "error");
			throw "Binding exception.";
			break;
		}
	}
	document.logger.log("End processBind: " + sExpr, "mdl");
}

function testForReady(self) {
	if (!self.elementLoaded) return;

	if (!FormsProcessor.testModelVersion(self)) return;

	self.elementState = 0;

	var children = self.element.childNodes;
	for (var i = 0, l = children.length; i < l; i++) {
		var oNode = children[i];

		if (!oNode) {
			self.elementState = -1;
			break;
		} else if (oNode.elementState) {
			if (oNode.elementState === 1) {
				self.elementState = 1;
				break;
			} else if (oNode.elementState === -1) {
				self.elementState = -1;
				break;
			}
		}
	}
	/*
    * When the model is ready we can begin the 'model construct' process.
    * [TODO] This should also be on an 'element ready' kind of event.
    */
	if (self.elementState === 0) {
		var evt = document.createEvent("Events");
		evt.initEvent("xforms-model-construct", true, false);
		evt._actionDepth = -1;
		FormsProcessor.dispatchEvent(self.element, evt);
	}
}

function __replaceInstanceDocument(self, oInstance, oDom) {
	var bRet = false;

	if (!oInstance) {
		throw "No instance found with an ID of '" + sID + "'";
	} else if (oInstance.length) {
		throw "Multiple instances found with an ID of '" + sID + "'";
	} else {
		oInstance.replaceDocument(oDom);
		self.flagRebuild();
		bRet = true;
	}
	return bRet;
}



function _replaceInstanceDocument(self, sID, oDom) {
	var bRet = false;
	var oInstance = null;

	if (sID) {
		oInstance = self.element.ownerDocument.getElementById(sID);
		bRet = __replaceInstanceDocument(self, oInstance, oDom);
	}

	return bRet;
}



function _addBindingTemp(self, oContext, sXPath) {
	var oRet = null;
	var oPN;

	/*
     * First locate the node that we're binding to.
     */
	var oNode = getFirstNode(self.EvaluateXPath(sXPath, oContext));

	/*
     * Now use the node to create a proxy if one doesn't already exist.
     */
	if (oNode) {
		oPN = UX.getProxyNode(oNode);
	} else {
		/*
         * If there is no node to bind to then create a default one.
         */
		oPN = new ProxyNode(null);
	}

	oRet = oPN;
	return oRet;
}



function _addControlExpression(self, oTarget, oContext, sXPath) {
	var oRet = null;

	self.element.ownerDocument.logger.log("Adding expression for '" + oTarget.tagName + "' to '" + sXPath + "'", "mdl");

	if (!oContext) {
		oContext = self;
	}

	var oPE = new ProxyExpression(oContext, sXPath, self);

	/*
     * Store a reference to the proxy in the control.
     */
	oTarget.m_proxy = oPE;
	oRet = oPE;
	return oRet;
}

/*
 * [ISSUE] Not sure I like the test for oVertex, but equally having two
 * functions--one for @calculate and one for all other MIPs seems a little
 * unnecessary too. (The only difference between them is that @calculate will
 * store its result in a node, and therefore needs to have a dependent vertex.)
 */
function _createMIP(self, oVertex, sMIPName, sExpr, oPN, oContext) {
	/*
     * Create an expression.
     */
	var oCPE = (oVertex) ? new ComputedXPathExpression(oPN, sExpr, oContext, self) : new MIPExpression(oPN, sExpr, oContext, self);

	if (sMIPName === "readonly") {
		oCPE.getValue = function() {
			return FormsProcessor.inheritTrue("readonly", oContext.node);
		};
	} else if (sMIPName === "enabled") {
		oCPE.getValue = function() {
			return FormsProcessor.inheritFalse("enabled", oContext.node);
		};

	}

	oPN[sMIPName] = oCPE;
	/*
     * Create a vertex for the expression, and add the vertex for the node that
     * we are iterating over as a dependent (if there is one).
     */
	var oCalcVertex = self.m_oDE.createVertex(oCPE);

	self.changeList.addChange(oCalcVertex);
	if (oVertex) {
		oCalcVertex.addDependent(oVertex);
	}

	/*
     * Now we need to see if there are any sub-expressions in the expression
     * we've just used.
     */

	oCPE.addDependentExpressions(oCalcVertex, self.m_oDE, self.changeList);
	return;
} // createMIP()


/*
 * The deferred update process allows the model to bring
 * itself up-to-date.
 */

function _deferredUpdate(self) {
	if (!self.m_bReady) return;

	if (self.deferredUpdating) return;
	self.deferredUpdating = true;

	if (self.m_bNeedRebuild) {
		self.rebuild();
		self.rebuilding = true;
	}
	if (self.m_bNeedRecalculate) self.recalculate();
	if (self.m_bNeedRevalidate) self.revalidate();
	if (self.m_bNeedRewire) self.rewire();
	if (self.m_bNeedRefresh) self.refresh();

	self.deferredUpdating = false;
	self.rebuilding = false;
}



function _model_contentReady(self) {
	self.changeList = new ChangeList();
	self.m_oDE = new dependencyEngine(self);

	/*
     * Register for any child elements completing their
     * 'document load'.
     */
	self.element.addEventListener("instance-load", {
		handleEvent: function(evt) {
			testForReady(self);
		}
	},
	false);

	/*
     * Register the default model construct handler.
     */
	FormsProcessor.addDefaultEventListener(self.element, "xforms-model-construct", {
		handleEvent: function(evt) {
			self.modelConstruct();
		}
	},
	false);

	/*
     * Register the default model construct done handler.
     */
	FormsProcessor.addDefaultEventListener(self, "xforms-model-construct-done", {
		handleEvent: function(evt) {
			self.modelConstructDone();
		}
	},
	false);

	/*
     * Register the default xforms-link-exception handler.
     */
	FormsProcessor.addDefaultEventListener(self, "xforms-link-exception", {
		handleEvent: function(evt) {
			FormsProcessor.halted = true;
			document.logger.log("xforms-link-exception, resource-uri: [" + evt.context["resource-uri"] + "]");
		}
	},
	false);

	/*
     * Register the default xforms-version-exception handler.
     */
	FormsProcessor.addDefaultEventListener(self, "xforms-version-exception", {
		handleEvent: function(evt) {
			FormsProcessor.halted = true;
			document.logger.log("xforms-version-exception, error-information: [" + evt.context["error-information"] + "]");
		}
	},
	false);

	self.element.addEventListener("xforms-insert", {
		scope: self,
		handleEvent: function(evt) {
			self.storeInsertedNodes(evt.context["inserted-nodes"]);
		}
	},
	false);

	return;
}



function _modelConstruct(self) {
	/*
     * - Load schemas.
     * - Load instance data.
     * - Initialise P3P.
     * - Construct instance data.
     */

	self._rebuild();
	self._recalculate();
	self._revalidate();
	self.m_bNeedRefresh = false;

	var evt = self.element.ownerDocument.createEvent("Events");
	evt._actionDepth = -1;
	evt.initEvent("xforms-model-construct-done", true, false);
	FormsProcessor.dispatchEvent(self.element, evt);
	return;
}
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global ProxyNode, UX, FormsProcessor, DOM_ELEMENT_NODE, DOM_TEXT_NODE, DOM_ATTRIBUTE_NODE, DOM_CDATA_SECTION_NODE*/

/*
 * [ISSUE] Things have got a little untidy, in that
 * in the various context functions (getBoundNode,
 * getEvaluationContext and getEvaluationContextFromParent)
 * we sometimes return a DOM node and sometimes return
 * a proxy node. This means that if we actually want
 * the proxy node, we have to do a bit of analysis on
 * the node returned, and potentially create a proxy
 * node if one doesn't exist. This could all do with
 * a big old sort out.
 */


(function(){

var proxies = {};

UX.getProxyNode = function(node, onlyGet) {
	if (!node) throw "UX.getProxyNode, E_INVALIDARG";
	if (node.m_oNode) {//If node a proxy node, then no more action is required.
		return node;
	}
	var uid = UX.getNodeUID(node);
	var proxy = proxies[uid];
	if(proxy) return proxy;
	if(onlyGet) return null;
	proxy = new ProxyNode(node);
	proxies[uid] = proxy;
	return proxy;
};

})();

UX.getElementValueOrContent = function(context, element) {
	var value = element.getAttribute("value");
	if (!value) {
		return UX.isXHTML ? element.textContent : element.innerHTML;
	} else {
		return getStringValue(context.model.EvaluateXPath(value, context));
	}
};

/**
 Gets the first node from an XPathResult that contains a nodeset.
 Use the appropriate methods on XPathResult for accessing other result types.

 @param {XPathResult} oRes An XPathResult object that is expected to contain a nodeset.
 @returns The first node in the nodeset contained by oRes, if oRes is not a node-set, then this function returns null.

 */
function getFirstNode(oRes) {
	var oRet = null;
	var nodeSet = null;
	if (oRes && oRes.type === "node-set") {
		nodeSet = oRes.nodeSetValue();
		if (nodeSet.length) {
			oRet = nodeSet[0];
		}
	}
	return oRet;
}

/**
 Gets the first text child from a node, if the node has no text children, and is capable of having them,
 then one is created, inserted, and returned.


 @param {Node} oNode The node whose first text child to return.
 @returns The first child of node that is a text node.

 */
function getFirstTextNode(oNode) {
	var oRet = null;

	if (oNode) {
		if ((oNode.nodeType == DOM_TEXT_NODE) || (oNode.nodeType == DOM_ATTRIBUTE_NODE)) {
			oRet = oNode;
		} else if (oNode.nodeType == DOM_ELEMENT_NODE) {

			oRet = oNode.firstChild;

			if (!oRet || ((oRet.nodeType != DOM_TEXT_NODE) && (oRet.nodeType != DOM_CDATA_SECTION_NODE))) {
				var newNode = oNode.ownerDocument.createTextNode("");

				/*
				 * If there were no existing nodes then add the new
				 * text node directly...
				 */

				if (!oRet) {
					oNode.appendChild(newNode);
				} else {
					/*
    			 * ...otherwise place it before the non-text node that
    			 * we just located.
    			 */
					oNode.insertBefore(newNode, oRet);
				}

				/*
				 * It's the new text node that we want to return.
				 */

				oRet = newNode;
			}
		}
	}
	return oRet;
}



function getStringValue(oRes) {
	var sRet = "";
	var oNode = null;

	if (oRes) {
		switch (oRes.type) {
		case "node-set":
			oNode = getFirstNode(oRes);
			if (oNode) {
				/*
					 * If we already have the text node then just
					 * return it.
					 */

				if ((oNode.nodeType == DOM_TEXT_NODE) || (oNode.nodeType == DOM_ATTRIBUTE_NODE)) {
					sRet = oNode.nodeValue;
				} else if (oNode.nodeType == DOM_ELEMENT_NODE) {
					/*
  					 * Otherwise, if the node is an element then we want
  					 * the first text node, but we'll create one if there
  					 * isn't one.
  					 */
					oNode = oNode.firstChild;
					if (oNode && oNode.nodeType == DOM_TEXT_NODE) sRet = oNode.nodeValue;
				}
			}
			break;

		case "string":
			sRet = oRes.stringValue();
			oNode = null;
			break;

		case "boolean":
			sRet = oRes.booleanValue();
			break;

		case "number":
			sRet = oRes.numberValue();
			break;

		default:
			console.log("getStringValue() has unsupported type");
			break;
		}
	}

	return sRet;
}



function ProxyExpression(oContext, sXPath, oModel) {
	this.m_context = oContext;
	this.m_xpath = sXPath;
	this.m_model = oModel;
	this.datatype = "";
	return;
}

ProxyExpression.prototype.getType = function() {
	return this.datatype;
};

ProxyExpression.prototype.getNodeset = function() {
	var sRet = null;
	var oModel = this.m_model;

	if (oModel) {
		/*
		 * [ISSUE] This should all be rolled into the one function
		 * in the same way as DOM 3 XPath allows us to specify the
		 * return type.
		 */

		oRet = oModel.EvaluateXPath(this.m_xpath, this.m_context);
	}

	return oRet;
};

ProxyExpression.prototype.getValue = function() {
	var sRet = "";
	var oRes = this.getNodeset();

	if (oRes) {
		switch (oRes.type) {
		case "number":
			sRet = oRes.numberValue();
			break;

		case "string":
			sRet = oRes.stringValue();
			break;

		case "node-set":
			var oNode = getFirstTextNode(oRes.nodeSetValue()[0]);

			if (oNode) sRet = oNode.nodeValue;
			break;
		case "boolean":
			sRet = oRet.booleanValue();
			break;

		default:
			/* please add any other types that are missing! */
			console.log("ProxyExpression.getValue() has unsupported type");
			break;
		}
	}
	return sRet;
};

/*
 * A ProxyNode is...surprisingly, a proxy for a DOM node, onto
 * which we attach all sorts of 'extra' properties.
 */

function ProxyNode(oNode) {
	this.m_oNode = oNode;
	this.m_refcount = 0;
	this.calculate = null;

	this.readonly = {
		value: undefined,
		getValue: function() {
			return FormsProcessor.inheritTrue("readonly", oNode);
		}
	};

	this.required = {
		getValue: function() {
			return false;
		}
	};

	this.enabled = {
		value: true,
		getValue: function() {
			return FormsProcessor.inheritFalse("enabled", oNode);
		}
	};

	this.outOfRange = {
		getValue: function() {
			return false;
		}
	};

	this.valid = {
		oPN: this,
		getValue: function() {
			if (this.oPN && this.oPN.constraint) {
				if (!this.oPN.constraint.getValue()) {
					return false;
				}
			}

			if (this.oPN && this.oPN.required) {
				if (this.oPN.required.getValue() && !this.oPN.getValue()) {
					return false;
				}
			}

			if (this.oPN && this.oPN.validate) {
				if (!this.oPN.validate()) {
					return false;
				}
			}

			return true;
		}
	};

	this.datatype = (oNode.nodeType === DOM_ELEMENT_NODE) ? oNode.getAttribute("xsi:type") || "" : "";
}

ProxyNode.prototype.toString = function() {
	return 'xf:proxy';
};

ProxyNode.prototype.getMIP = function(sMIPName) {
	var mipRet = this[sMIPName];

	if (!mipRet) {
		mipRet = null;
		console.log("MIP " + sMIPName + " does not exist.");
	}

	return mipRet;
};

ProxyNode.prototype.getMIPState = function(sMIPName) {
	var oMIP = this.getMIP(sMIPName);
	var bRet = false;

	if (oMIP) bRet = oMIP.getValue();

	return bRet;
};

ProxyNode.prototype.getNode = function() {
	return this.m_oNode;
};

ProxyNode.prototype.getType = function() {
	return this.datatype;
};

ProxyNode.prototype.getValue = function() {
	var sRet = "";
	var oNode = this.getNode();

	if (oNode) {
		oNode = getFirstTextNode(oNode);

		if (oNode) sRet = oNode.nodeValue;
	}

	return sRet;
};

ProxyNode.prototype.removeChild = function(node, caller) {
	if (this.m_oNode.nodeType === DOM_ELEMENT_NODE) {
		if (!this.readonly.getValue()) {
			this.m_oNode.removeChild(node);
			return true;
		}
	} else {
		UX.dispatchEvent(caller, "xforms-binding-exception", true, false);
	}
	return false;
};

ProxyNode.prototype.appendChild = function(node, caller) {

	if (this.m_oNode.nodeType === DOM_ELEMENT_NODE) {
		if (!this.readonly.getValue()) {
			return this.m_oNode.appendChild(node);
		}
	} else {
		UX.dispatchEvent(caller, "xforms-binding-exception", true, false);
	}
	return null;

};

ProxyNode.prototype.setValue = function(value, model) {
	if (this.readonly.getValue()) return;

	var node = this.getNode();
	if (node) {
		node = getFirstTextNode(node);
		if (node) {
			node.nodeValue = (typeof(value) == "object") ? value.stringValue() : "" + value;
		}
	}
	/*
	 * If the proxy has a corresponding vertex
	 * then it means our node has been used in
	 * a calculation somewhere. We therefore need
	 * to add the vertex to the change list,
	 *
	 * The need for a recalculate must be signalled
	 * regardless, as a value has changed.
	 *
	 */
	if (!model) return;
	if (this.m_vertex) {
		var vertex = this.m_vertex;
		/*
		 * [ISSUE] These two could go probably go
		 * into one function.
		 */
		model.changeList.addChange(vertex);
	}
	model.flagRecalculate();
	model.flagRefresh();
};

ProxyNode.prototype.validate = function() {
	var arrSegments, prefix, dataType, dataTypeNS;

	if (!this.datatype) {
		return true;
	}

	arrSegments = this.datatype.split(":");
	prefix = arrSegments.length === 1 ? "" : arrSegments[0];
	dataType = arrSegments.length === 1 ? arrSegments[0] : arrSegments[1];
	dataTypeNS = prefix ? NamespaceManager.getNamespaceURIForPrefix(prefix) : "";
	return Validator.validateValue(dataTypeNS, dataType, this.getValue());
};



function ControlProxyNodeVertex(oTarget, oContext, oModel, oPN) {
	this.m_oContext = oContext;
	this.m_oModel = oModel;
	this.node = oPN.m_oNode;
	this.m_oProxy = oPN;
	this.targetControl = oTarget;
	this.dependencies = [];
}

/**
 * @returns 'ctrl[...]' where ... is the localName and id (if it exists)
 */
ControlProxyNodeVertex.prototype.identifier = function() {
	var ctrl = this.targetControl;
	var identifier = ctrl.localName;
	var ctrlId = ctrl.getAttribute('id');
	if (ctrlId) {
		identifier += '#' + ctrlId;
	}
	return "ctrl[" + identifier + "]";
};

ControlProxyNodeVertex.prototype.update = function() {
	if (typeof(this.targetControl.refresh) === 'function') {
		this.targetControl.refresh();
	}
};

ControlProxyNodeVertex.prototype.addDependentProxyNodes = function() {
	if (!this.node) return;

	var xnodeId = UX.getNodeUID(this.node);
	var oDE = this.m_oModel.m_oDE;
	var vertex, ctrlVertex, vertexId, i;

	ctrlVertex = this.m_oProxy.m_ctrlVertex;
	if (this.m_oProxy.m_vertex) {
		vertexId = this.m_oProxy.m_vertex.vertexId;
	}

	if (oDE.m_contextNodes[xnodeId]) {
		for (i in oDE.m_contextNodes[xnodeId]) {
			vertex = oDE.m_contextNodes[xnodeId][i];
			if (vertex != ctrlVertex && !vertex.depListIdx[vertexId]) {
				vertex.addDependent(ctrlVertex);
			}
		}
	}

	if (oDE.m_proxyNodes[xnodeId]) {
		for (i in oDE.m_proxyNodes[xnodeId]) {
			vertex = oDE.m_proxyNodes[xnodeId][i];
			if (vertex != ctrlVertex && !vertex.depListIdx[vertexId]) {
				vertex.addDependent(ctrlVertex);
			}
		}
	}
};


function SingleNodeExpression(oTarget, sXPath, oContext, oModel) {
	this.m_sXPathExpr = sXPath;
	this.m_oContext = oContext;
	this.m_oModel = oModel;
	this.node = null;

	this.identifier = function() {
		return "snb[" + sXPath + "]";
	};
}

SingleNodeExpression.prototype.update = function() {
	var r = this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);

	if (r !== null) {
		this.node = new ProxyNode(r.value[0]);
		return r.value[0];
	}
	return null;
};

SingleNodeExpression.prototype.determineDependentExpressions = function() {
	/*
	 * The dependencies are worked out in the XPath expression
	 * evaluator.
	 */

	g_bSaveDependencies = true;
	this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);
	g_bSaveDependencies = false;

	return;
};



function NodesetExpression(oTarget, sXPath, oContext, oModel) {
	this.m_sXPathExpr = sXPath;
	this.m_oContext = oContext;
	this.m_oModel = oModel;
	var m_nodeset = null;

	this.dependentExpressions = new Array();

	this.getNode = function(i) {
		return ProxyNode(m_nodeset[i]);
	};

	this.AddExpressionWhichTakesThisAsContext = function(sXPath) {
		this.dependentExpressions.push(new ComputedXPathExpression(sXPath, this, this.m_oModel));
	};

	this.identifier = function() {
		return "nsetb[" + sXPath + "]";
	};
}

NodesetExpression.prototype.update = function() {
	var r = this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);

	if (r !== null) {
		this.node = new ProxyNode(r.value);
		return r.value;
	}
	return null;
};

NodesetExpression.prototype.determineDependentExpressions = function() {
	/*
	 * The dependencies are worked out in the XPath expression
	 * evaluator.
	 */

	g_bSaveDependencies = true;
	this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);
	g_bSaveDependencies = false;

	return;
};



function ComputedXPathExpression(oProxy, sXPath, oContext, oModel) {
	this.m_oProxy = oProxy;
	this.m_sXPathExpr = sXPath;
	this.m_oContext = oContext;
	this.m_oModel = oModel;
	this.value = null;
	this.dependentExpressions = new Array();

	this.identifier = function() {
		return "comp[" + sXPath + "]";
	};
}

ComputedXPathExpression.prototype.update = function() {
	var oRet = "";
	var oRes = this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);

	if (oRes) {
		oRet = oRes.stringValue();
		if (this.m_oProxy.setValue) {
		this.m_oProxy.setValue(oRet, null);
	}
	}

	this.value = oRet;
	return oRet;
};

/*
 * This breaks computed expression into further expressions on which
 * this one depends.
 */

ComputedXPathExpression.prototype.addDependentExpressions = function(oVertex, oDepEngine, oChangeList) {
	var oRes = this.determineDependentExpressions();

	var oNode = null;
	var oPN = null;

	/*
	 * If there are any dependents then each of them needs to have
	 * a vertex added.
	 */

	if (this.dependentExpressions.length) {
		for (var i = 0; i < this.dependentExpressions.length; i++) {
			var oDependentNode = this.dependentExpressions[i];

			/*
			 * Get the proxy node if there is one, or create
			 * a new one.
			 */

			 oPN = UX.getProxyNode(oDependentNode);

			/*
			 * Now see if the node has an associated vertex...
			 */

			var oSubVertex;

			if (oPN.m_vertex) oSubVertex = oPN.m_vertex;

			/*
			 * ...otherwise, a sub-expression is created with its
			 * own vertex.
			 */

			else {
				var oSubExpr = new SubExpression(oDependentNode);

				oSubVertex = oDepEngine.createVertex(oSubExpr);
				oPN.m_vertex = oSubVertex;
				oChangeList.addChange(oSubVertex);
			}

			/*
			 * Make the target vertex dependent on the new
			 * sub-expression.
			 */

			oSubVertex.addDependent(oVertex);
		}
	}
};

ComputedXPathExpression.prototype.determineDependentExpressions = function() {
	var oRet = null;

	/*
	 * The dependencies are worked out in the XPath expression
	 * evaluator, and stored in the array pointed to by g_arrSavedDependencies.
	 */

	g_bSaveDependencies = true;
	g_arrSavedDependencies = this.dependentExpressions;
	oRet = this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);
	g_bSaveDependencies = false;
	return oRet;
};

/*
 * [ISSUE] This is almost exactly the same as ComputedXPathExpression,
 * but we don't call setValue() in update--so we may be able to merge
 * these two classes. (At the very least we should do the inheritance
 * the other way round, and call a base class update() method, before
 * calling ProxyNode::setValue().
 */

function MIPExpression(oProxy, sXPath, oContext, oModel) {
	MIPExpression.superclass.constructor.call(this, oProxy, sXPath, oContext, oModel);
}

YAHOO.extend(MIPExpression, ComputedXPathExpression);

MIPExpression.prototype.getValue = function() {
	return this.value;
};

MIPExpression.prototype.update = function() {
	var bRet = false;
	var oRes = this.m_oModel.EvaluateXPath(this.m_sXPathExpr, this.m_oContext);

	if (oRes) bRet = oRes.booleanValue();

	this.value = bRet;
	return bRet;
};



function SubExpression(oProxy) {
	this.m_oProxy = oProxy;
	this.value = null;
	this.identifier = function() {
		return "sub";
	};
}

/*
 * The update method need do nothing since we're only interested in
 * the dependencies.
 */

SubExpression.prototype.update = function() {
	var oRet = null;

	this.value = oRet;
	return oRet;
};
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Model = new UX.Class({

	toString: function() {
		return 'xf:model';
	},

	initialize: function(element){
		this.element = element;
		this.m_bNeedRebuild = false;
		this.m_bNeedRecalculate = false;
		this.m_bNeedRevalidate = false;
		this.m_bNeedRewire = false;
		this.m_bNeedRefresh = false;
		this.m_bReady = false;
		this.elementState = 1;
		this.elementLoaded = false;
		this.m_arrProxyNodes = {};
		this.controls = [];
		this.xformselement = "model";
		this.externalInstances = [];
		this.m_NodesInsertedSinceLastRewire = [];
	},

	onDocumentReady: function() {
		var self = this;
		this.setElementLoaded();
		this._testForReady();

		FormsProcessor.addDefaultEventListenerFor(this.element, "xforms-reset", this, "reset");

		FormsProcessor.addDefaultEventListenerFor(this.element, "xforms-rebuild", this, "_rebuild");
		FormsProcessor.addDefaultEventListenerFor(this.element, "xforms-recalculate", this, "_recalculate");
		FormsProcessor.addDefaultEventListenerFor(this.element, "xforms-revalidate", this, "_revalidate");
		FormsProcessor.addDefaultEventListenerFor(this.element, "xforms-refresh", this, "_refresh");

		if (window.addEventListener) {
			window.addEventListener("beforeunload", {
				handleEvent: function(evt) {
					self.modelDestruct();
				}
			},
			false);
		} else {
			window.attachEvent("onbeforeunload", function() {
				self.modelDestruct();
			});
		}
		this.checkFunctionsAttribute();
	},

	checkFunctionsAttribute: function() {
		var i, evt, functionString = this.element.getAttribute("functions"),
			requiredFunctions = functionString ? functionString.split(" ") : [];
		for (i = 0; i < requiredFunctions.length; ++i) {
			if (typeof window[requiredFunctions[i]] !== "function") {
				evt = document.createEvent("Events");
				evt.initEvent("xforms-compute-exception", true, false);
				evt.context = {
					"error-message": "function '" + requiredFunctions[i] + "' specified in model/@functions is not a function."
				};
				this.dispatchEvent(evt);
			}
		}
	},

	onContentReady: function() {
		return _model_contentReady(this);
	},

	modelConstruct: function() {
		return _modelConstruct(this);
	},

	modelConstructDone: function() {
		this.constructingUI = true;
		this.initialisationLock = 1;
		this.rewire();
		this.constructingUI = false;
		window.status = "refreshing";
		this._refresh();
		this.resumeXFormsReady();
		this.m_bReady = true;
	},

	stopXFormsReady: function() {
		++this.initialisationLock;
	},

	resumeXFormsReady: function() {
		if (!--this.initialisationLock && !this.m_bXFormsReadyFired) {
			this.fireXFormsReady();
		}
	},

	modelDestruct: function() {
		UX.dispatchEvent(this.element, "xforms-model-destruct", false, false, false);
	},

	fireXFormsReady: function() {
		this.m_bXFormsReadyFired = true;
		UX.dispatchEvent(this.element, "xforms-ready", false, false, true);
	},

	replaceInstanceDocument: function(sID, oDom) {
		return _replaceInstanceDocument(this, sID, oDom);
	},

	getInstanceDocument: function(sID) {
		var oRet = null;
		var oInstance = null;

		if (sID && sID !== "") {
			oInstance = DECORATOR.getBehaviour(document.getElementById(sID));
			if (oInstance && oInstance.element.parentNode !== this.element) {
				throw "instance '" + sID + "' is not part of model '" + this.element.getAttribute('id') + "'";
			} else {
				for (var i = 0, l = this.externalInstances.length; i < l; i++) {
					if (this.externalInstances[i].element.getAttribute('id') === sID) {
						oInstance = this.externalInstances[i];
						isExternal = true;
						break;
					}
				}
			}

		} else {
			oInstance = DECORATOR.getBehaviour(NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "instance")[0]);
			if (!oInstance) {
				oInstance = this.externalInstances[0];
				isExternal = true;
			}
		}

		if (!oInstance) {
			throw "No instance found with an ID of '" + sID + "'";
		} else {
			oRet = oInstance.m_oDOM;
		}

		return oRet;
	},


	getEvaluationContext: function() {
		var context = {
			model: this,
			node: null,
			resolverElement: this.element
		};
		var firstInstance = null;
		var instances = this.instances();
		if (instances && instances.length > 0) {
			firstInstance = instances[0];
			var type = typeof(firstInstance.getDocument);

			if (type === "function") {
				var dom = firstInstance.getDocument();
				if (dom) {
					context.node = dom;
					context.node = getFirstNode(this.EvaluateXPath("/*", context));
				}
			}
		}

		return context;
	},

	getBoundNode: function() {
		return this.getEvaluationContext();
	},

	/*
	 * The setValue method allows us to set any node, via an XPath expression. A
	 * convenient shorthand in XForms is that setting a value on an element has the
	 * effect of setting the first text node.
	 */
	setValue: function(oContext, sXPath, sExprValue) {
		var node = getFirstNode(this.EvaluateXPath(sXPath, oContext));
		if(!node) return;
		/*
         * Evaluate the value part. [TODO] It would be easier if we did what we
         * do in fP where we evaluate an expression and also say what 'type' we
         * want from DOM 3 XPath.
         */
		var sValue = getStringValue(this.EvaluateXPath(sExprValue, {
			node: node,
			model: oContext.model,
			resolverElement: oContext.resolverElement
		}));

		/*
         * If there is no proxy node then create one. [Q] Should we now store
         * this? No reason why not, but it will only ever have default values.
         */

		var proxy = UX.getProxyNode(node);

		proxy.setValue(sValue, this);

		/*
         * [ISSUE] This doesn't feel right, but we either have to do this or set
         * the recalculate flag regardless of the vertices, to force things to
         * 'drop through'. This feels the lesser, for now.
         */
		this.flagRefresh();
	},

	/*
	 * The getValue method allows us to retrieve any node, via an XPath expression.
	 * A convenient shorthand in XForms is that requesting the value of an element
	 * has the effect of getting the first text node.
	 */
	getValue: function(sXPath) {
		var oRet = this.EvaluateXPath(sXPath, this.getEvaluationContext());
		return oRet;
	},

	/*
	 * Evaluates an XPath expression, returning a
	 */
	EvaluateXPath: function(xpath, context) {
		if (!context) {// If no context is given, get the default for the model
			context = this.getEvaluationContext();
		} else if (!context.node) {// If only a context node is given, turn it into a context object
			context = {
				node: context
			};
		}
		context.model = context.model || this;
		context.resolverElement = context.resolverElement || this.element;
		try {
			var result = xpathDomEval(xpath, context);
		} catch(e) {
			if (context.resolverElement && !FormsProcessor.halted) {
				FormsProcessor.halted = true;
				UX.dispatchEvent(context.resolverElement, "xforms-binding-exception", true, false);
			}
		}
		return result;
	},

	addControl: function(oTarget) {
		/*
	     * Add the control to the list of controls attached to this model.
	     */

		var controls = this.controls;
		var i = controls.length;
		for (i; i--;) {
			if (oTarget === controls[i]) {
				break;
			}
		}
		if (i == -1) {
			controls.push(oTarget);
		}

		if (!this.m_bReady) return;
		if (oTarget && typeof oTarget.element == "object") {
			oTarget.rewire();
			oTarget.refresh();
		}

	},

	/*
	 * Creates a connection between a DOM node and a proxy node.
	 */
	addBindingTemp: function(oContext, sXPath) {
		return _addBindingTemp(this, oContext, sXPath);
	},

	/*
	 * Creates a connection between a form control and a proxy node.
	 */
	addControlBinding: function(oTarget) {
		/*
	     * Register for the change event from the control.
	     */
		oTarget.element.addEventListener("target-value-changed", {
			model: this,
			handleEvent: function(event) {
				var oPN = DECORATOR.getBehaviour(event.target).m_proxy;
				if (oPN) {
					oPN.setValue(event.newValue, this.model);
				}
			}
		},
		false);
		return;
	},

	/*
	 * Creates a connection between a form control and a DOM node, via a proxy node.
	 */
	addControlExpression: function(oTarget, oContext, sXPath) {
		return _addControlExpression(this, oTarget, oContext, sXPath);
	},

	/*
	 * Adds a binding between a DOM node and a vertex.
	 */
	AddSingleNodeBinding: function(oTarget, oContext, sXPath) {
		if (!oContext) {
			oContext = this.getEvaluationContext();
		}
		var oSNE = new SingleNodeExpression(oTarget, sXPath, oContext, this, true);

		return oSNE;
	},

	AddNodesetBinding: function(oTarget, oContext, sXPath) {
		if (!oContext) {
			oContext = this.getEvaluationContext();
		}

		var oNE = new NodesetExpression(oTarget, sXPath, oContext, this, false);
		return oNE;
	},

	/**
	 * Informs the model that a rebuild will be required at next update.
	 */
	flagRebuild: function() {
		this.m_bNeedRebuild = true;
	},

	/**
	 * Informs the model that a recalculate will be required at next update.
	 */
	flagRecalculate: function() {
		this.m_bNeedRecalculate = true;
	},

	/**
	 * Informs the model that a revalidate will be required at next update.
	 */
	flagRevalidate: function() {
		this.m_bNeedRevalidate = true;
	},

	/**
	 * Informs the model that a refresh will be required at next update.
	 */
	flagRefresh: function() {
		this.m_bNeedRefresh = true;
	},

	rebuildPending: function() {
		return this.m_bNeedRebuild;
	},

	recalculatePending: function() {
		return this.m_bNeedRecalculate;
	},

	revalidatePending: function() {
		return this.m_bNeedRevalidate;
	},

	refreshPending: function() {
		return this.m_bNeedRefresh;
	},

	rebuild: function() {
		if (this.m_bNeedRebuild) {
			this.m_bNeedRebuild = false;
			UX.dispatchEvent(this.element, "xforms-rebuild", true, true);
		}
	},

	_rebuild: function() {
		document.logger.log("Start _rebuild: " + this.element.id, "xforms");
		/*
	     * Clear the dependency graph and the change list.
	     */
		this.m_oDE.clear();
		this.changeList.clear();

		if (!FormsProcessor.halted) {
			/*
		     * Clear the dependency graph and the change list.
		     */
			this.m_oDE.clear();
			this.changeList.clear();

			/*
		     * Process the bind statements.
		     */
			var oContext = this.getEvaluationContext();
			processBinds(this, this.element, oContext);
			this.m_bNeedRecalculate = true;
			this.m_bNeedRebuild = false;

		}
		document.logger.log("End _rebuild: " + this.element.id, "xforms");
	},

	recalculate: function() {
		if (this.m_bNeedRecalculate) {
			this.m_bNeedRecalculate = false;
			UX.dispatchEvent(this.element, "xforms-recalculate", true, true);
		}
	},

	_recalculate: function() {
		document.logger.log("Start _recalculate: " + this.element.id, "xforms");
		if (!FormsProcessor.halted) {
			this.m_oDE.recalculate(this.changeList);

			/* these could go into one function */
			this.changeList.clear();
			this.m_bNeedRecalculate = false;
			this.m_bNeedRevalidate = true;
		}
		document.logger.log("End _recalculate: " + this.element.id, "xforms");
	},

	revalidate: function() {
		if (this.m_bNeedRevalidate) {
			this.m_bNeedRevalidate = false;
			UX.dispatchEvent(this.element, "xforms-revalidate", true, true);
		}
	},

	_revalidate: function() {
		document.logger.log("Start _revalidate: " + this.element.id, "xforms");
		if (!FormsProcessor.halted) {

			this.applyChildBindConstraints(this);

			this.m_bNeedRevalidate = false;
			this.m_bNeedRewire = true;
		}
		document.logger.log("End _revalidate: " + this.element.id, "xforms");
	},

/*
	 * We give all of the controls the opportunity to update themselves.
	 */
	rewire: function() {
		document.logger.log("Start rewire: " + this.element.id, "xforms");
		var i, control;

		document.logger.log("About to unwire " + this.controls.length + " controls", "xforms");
		for (i = 0; i < this.controls.length; ++i) {
			control = this.controls[i];
			if (control.m_bAlreadyRewired && !this.rebuilding) continue;
			control.unwire();
		}

		document.logger.log("About to rewire " + this.controls.length + " controls", "xforms");
		for (i = 0; i < this.controls.length; ++i) {
			control = this.controls[i];
			if (control.m_bAlreadyRewired && !this.rebuilding) continue;
			control.rewire();
			control.m_bAlreadyRewired = true;
		}

		this.m_bNeedRewire = false;
		this.m_bNeedRefresh = true;
		this.flagRefresh();
		this.m_NodesInsertedSinceLastRewire = [];
		document.logger.log("End rewire: " + this.element.id, "xforms");
		return;
	},

	refresh: function() {
		if (!FormsProcessor.halted && this.m_bNeedRefresh) {
			this.m_bNeedRefresh = false;
			UX.dispatchEvent(this.element, "xforms-refresh", true, true);
		}
	},

	_refresh: function() {
		document.logger.log("Start _refresh: " + this.element.id, "xforms");
		for (var i = 0; i < this.controls.length; ++i) {
			var control = this.controls[i];
			if (control.m_bAlreadyRefreshed && !this.rebuilding) continue;
			control.refresh();
			control.m_bAlreadyRefreshed = true;
		}
		this.m_bNeedRefresh = false;
		document.logger.log("End _refresh: " + this.element.id, "xforms");
		return;
	},

	deferredUpdate: function() {
		return _deferredUpdate(this);
	},

	addInstance: function(theInstance) {
		this.externalInstances.push(theInstance);
		return this;
	},

	storeInsertedNodes: function(nodes) {
		for (var i = 0, l = nodes.length; i < l; i++) {
			this.m_NodesInsertedSinceLastRewire.unshift(nodes[i]);
		}
	},

	indexOfNewNode: function(nodes) {
		for (var i = 0, l = nodes.length; i < l; i++) {
			for (var j = 0, m = this.m_NodesInsertedSinceLastRewire.length; j < m; j++) {
				if (nodes[i] === this.m_NodesInsertedSinceLastRewire[j]) {
					return i;
				}
			}
		}
		return -1;
	},

	removeInstance: function(theInstance) {
		var i;
		var l = this.externalInstances.length;

		for (i = l; i >= 0; --i) {
			if (this.externalInstances[i] == theInstance) {
				this.externalInstances.splice(i, 1);
			}
		}
		return this;
	},

	/**
	 * @returns the list of instances governed by this model.
	 */
	instances: function() {
		var internalInstances = NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "instance");
		var retVal = [];
		for (var i = 0, l = internalInstances.length; i < l; i++) {
			retVal.push(DECORATOR.getBehaviour(internalInstances[i]));
		}
		return retVal.concat(this.externalInstances);
	},

	/**
	 * resets all instance data to its original state.
	 */
	reset: function() {
		document.logger.log("Start reset: " + this.element.id, "xforms");
		if (!FormsProcessor.halted) {
			var instances = this.instances();
			for (var i = 0, l = instances.length; i < l; i++) {
				instances[i].reset();
			}
			this.flagRebuild();
			_deferredUpdate(this);
		}
		document.logger.log("End reset: " + this.element.id, "xforms");
	},

/*
	 * P R I V A T E =============
	 */
	createMIP: function(oVertex, sMIPName, sExpr, oPN, oContext) {
		return _createMIP(this, oVertex, sMIPName, sExpr, oPN, oContext);
	},

	_testForReady: function() {
		testForReady(this);
	},

	setElementLoaded: function() {
		this.elementLoaded = true;
		return;
	},

	applyChildBindConstraints: function(parent) {
		if(parent.element) parent = parent.element;
		for (i = 0, l = parent.childNodes.length; i < l; i++) {
			if (NamespaceManager.compareFullName(parent.childNodes[i], "bind", "http://www.w3.org/2002/xforms")) {
				this.applyBindConstraint(parent.childNodes[i]);
				this.applyChildBindConstraints(parent.childNodes[i]);
			}
		}
	},

	applyBindConstraint: function(bind) {
		if (bind.m_proxy) {
			if (bind.m_proxy.constraint) {
				bind.m_proxy.constraint.update();
			}
			if (bind.m_proxy.required && typeof bind.m_proxy.required.update === "function") {
				bind.m_proxy.required.update();
			}
		}
	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function NavigableControlList() {
	this.orderedList = [];
	this.keyedMap = [];
}

NavigableControlList.prototype.addControl = function(control) {
	if (this.isNavigableControl(control)) {
		this.addControlToOrderedList(control);
		this.addControlToKeyedMap(control);
	}
};

NavigableControlList.prototype.addControlToOrderedList = function(control) {
	this.prepareListItem(control);
	this.orderedList[control.navIndex].push(control);
};

NavigableControlList.prototype.addControlToKeyedMap = function(control) {
	if (typeof control.accessKey === 'string' && control.accessKey !== '') {
		this.keyedMap[control.accessKey.toLowerCase()] = control;
	}
};

NavigableControlList.prototype.getFirstControl = function() {
	return this.getFirstControlAtIndex(1) || this.getFirstControlAfterIndex(1);
};

NavigableControlList.prototype.getLastControl = function() {
	return this.getLastControlAtIndex(0) || this.getLastControlBeforeIndex(this.orderedList.length);
};

NavigableControlList.prototype.getNextControl = function(control) {
	if (this.isNavigableControl(control) && this.hasListItem(control.navIndex)) {
		return this.getNextControlAtSameIndex(control) || this.getFirstControlAfterIndex(control.navIndex);
	}

	return null;
};

NavigableControlList.prototype.getPreviousControl = function(control) {
	if (this.isNavigableControl(control) && this.hasListItem(control.navIndex)) {
		return this.getPreviousControlAtSameIndex(control) || this.getLastControlBeforeIndex(control.navIndex);
	}

	return null;
};

NavigableControlList.prototype.getControlByAccessKey = function(key) {
	return this.keyedMap[key] || null;
};

NavigableControlList.prototype.isNavigableControl = function(control) {
	return typeof control === 'object' && control && control.isNavigableControl && typeof control.navIndex === 'number';
};

NavigableControlList.prototype.prepareListItem = function(control) {
	if (!this.hasListItem(control.navIndex)) {
		this.orderedList[control.navIndex] = [];
	}
};

NavigableControlList.prototype.hasListItem = function(index) {
	return this.orderedList[index] ? true : false;
};

NavigableControlList.prototype.getNextControlAtSameIndex = function(control) {
	var foundControl = false,
		nextControl;
	for (var i = 0; i < this.orderedList[control.navIndex].length; ++i) {
		if (foundControl) {
			nextControl = this.orderedList[control.navIndex][i];
			if (nextControl.isEnabled()) {
				return nextControl;
			}
		}

		foundControl = control === this.orderedList[control.navIndex][i];
	}

	return null;
};

NavigableControlList.prototype.getPreviousControlAtSameIndex = function(control) {
	var foundControl = false,
		previousControl;
	for (var i = this.orderedList[control.navIndex].length; i >= 0; --i) {
		if (foundControl) {
			previousControl = this.orderedList[control.navIndex][i];
			if (previousControl.isEnabled()) {
				return previousControl;
			}
		}

		foundControl = control === this.orderedList[control.navIndex][i];
	}

	return null;
};

NavigableControlList.prototype.getFirstControlAfterIndex = function(index) {
	var i, control;

	for (i = this.incrementIndex(index); i < this.orderedList.length; i = this.incrementIndex(i)) {
		control = this.getFirstControlAtIndex(i);
		if (control) {
			if (control.isEnabled()) {
				return control;
			}

			control = this.getNextControlAtSameIndex(control);
			if (control) {
				return control;
			}
		}
	}

	return null;
};

NavigableControlList.prototype.getLastControlBeforeIndex = function(index) {
	var i, control;

	for (i = this.decrementIndex(index); i >= 0; i = this.decrementIndex(i)) {
		control = this.getLastControlAtIndex(i);
		if (control) {
			if (control.isEnabled()) {
				return control;
			}

			control = this.getPreviousControlAtSameIndex(control);
			if (control) {
				return control;
			}
		}
	}

	return null;
};

NavigableControlList.prototype.incrementIndex = function(index) {
	return index === 0 ? this.orderedList.length : (index >= this.orderedList.length - 1 ? 0 : index + 1);
};

NavigableControlList.prototype.decrementIndex = function(index) {
	return index === 0 ? this.orderedList.length - 1 : (index === 1 ? -1 : index - 1);
};

NavigableControlList.prototype.getFirstControlAtIndex = function(index) {
	var i;
	if (this.hasListItem(index)) {
		for (i = 0; i < this.orderedList[index].length; ++i) {
			if (this.orderedList[index][i].isEnabled()) {
				return this.orderedList[index][i];
			}
		}
	}

	return null;
};

NavigableControlList.prototype.getLastControlAtIndex = function(index) {
	var i;
	if (this.hasListItem(index)) {
		for (i = this.orderedList[index].length - 1; i >= 0; --i) {
			if (this.orderedList[index][i].isEnabled()) {
				return this.orderedList[index][i];
			}
		}
	}

	return null;
};
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global NamespaceManager, UX, document, UX.getProxyNode*/

/**
 * Retrieves the model to which the node <i>oNode</i> is bound. This is based
 * on the presence of model or bind attributes, or on context information gained
 * from the the node's position in the document.
 *
 * @param {Object}
 *            oNode, node whose model is to be resolved.
 * @returns Node that corresponds to the appropriate model for oNode's binding.
 */

function getModelFor(oNode) {
	if (!oNode || oNode.nodeType === 9 /* DOCUMENT_TYPE */ ) {
		if (!document.defaultModel) {
			var models = NamespaceManager.getElementsByTagNameNS(document, "http://www.w3.org/2002/xforms", "model");
			if (models && models.length > 0) {
				document.defaultModel = DECORATOR.getBehaviour(models[0]);
			}
		}
		return document.defaultModel;
	}
	if (oNode.nodeType === 11 /* FRAGMENT_TYPE */) return null;
	if (oNode.ownerModel) return oNode.ownerModel;

	var element = oNode;
	if(element.element) {
		element = element.element;
	} else {
		oNode = DECORATOR.getBehaviour(element);
	}

	var bindId = element.getAttribute("bind");

	if (bindId) {
		var bind = FormsProcessor.getBindObject(bindId, oNode);
		if (bind) {
			oNode.ownerModel = getModelFor(bind);
		}
		return oNode.ownerModel;
	}

	var sModelId = element.getAttribute("model");
	if (sModelId) {
		var oMightBeAModel = DECORATOR.getBehaviour(document.getElementById(sModelId));

		if (oMightBeAModel && (oMightBeAModel.xformselement === "model")) {
			oNode.ownerModel = oMightBeAModel;
		} else {
			UX.dispatchEvent(oNode, "xforms-binding-exception", false, true, true);
		}
		return oNode.ownerModel;
	}

	if (element.tagName === "bind" && DECORATOR.getBehaviour(element.parentNode).xformselement === "model") {
		oNode.ownerModel = DECORATOR.getBehaviour(element.parentNode);
	} else {
		oNode.ownerModel = getModelFor(oNode.parentNode);
	}
	return oNode.ownerModel;
}





var g_DeferredUpdateDepth = 0;



function doUpdate() {
	var models = NamespaceManager.getElementsByTagNameNS(document, "http://www.w3.org/2002/xforms", "model");
	var storedUpdateDepth = g_DeferredUpdateDepth;
	g_DeferredUpdateDepth = 0;
	for (var i = 0, l = models.length; i < l; i++) {
		var model = DECORATOR.getBehaviour(models[i]);
		try {
			if (model.m_bReady) {
				_deferredUpdate(model);
			}
		} catch(e) {
			console.log("Error in deferred update: '" + e + "'.");
		}
	}
	g_DeferredUpdateDepth = storedUpdateDepth;
}

function IncrementDeferredUpdate() {
	++g_DeferredUpdateDepth;
}

function DecrementDeferredUpdate() {
	if (!--g_DeferredUpdateDepth) {
		doUpdate();
	}
}



function XFormsProcessor() {
	this.defaultHandlers = {};
	this.eventStack = [];
	this.hintOffCounter = 0;
	this.supportedVersions = ["1.1"];
	this.halted = false;
	this.navigationList = new NavigableControlList();
}

XFormsProcessor.prototype.find = function(array, value) {
	var i;
	if (!array || !value) {
		return false;
	}
	for (i = 0; i < array.length; i++) {
		if (array[i] === value) {
			return true;
		}
	}

	return false;
};

/**
 Function: getBindObject

 bindid - The id of the bind element that is to be returned
 notifyOnException - An EventTarget object that is to be notified in case of exception
 returns - If bindid refers to a bind object, the bind element referenced by bindid, otherwise, null.

 An xforms-binding-exception will be raised if there is no element referenced by bindid,
 or if the element with that id is not an xforms bind element.

 */
XFormsProcessor.prototype.getBindObject = function(bindid, notifyOnException) {
	var bindObject = null;
	notifyOnException = notifyOnException || document.defaultModel;

	if (bindid) {
		bindObject = document.getElementById(bindid);

		if (!bindObject || !NamespaceManager.compareFullName(bindObject, "bind", "http://www.w3.org/2002/xforms")) {
			bindObject = null;
			if (notifyOnException) {
				UX.dispatchEvent(notifyOnException, "xforms-binding-exception", true, false, false);
			}
			this.halted = true;
		}
	}
	return bindObject;
};

XFormsProcessor.prototype.setVersion = function() {
	var defaultModelVersions, i, maxPos;

	if (!this.version) {
		if (!document.defaultModel) {
			if (!getModelFor(null)) {
				return;
			}
		}

		defaultModelVersions = (document.defaultModel.element.getAttribute("version") || "").split(" ");

		maxPos = -1;
		for (i = 0; i < this.supportedVersions.length; i++) {
			if (defaultModelVersions.length === 1 && defaultModelVersions[0].length === 0 || this.find(defaultModelVersions, this.supportedVersions[i])) {
				if (maxPos === -1 || Number(this.supportedVersions[i]) > Number(this.supportedVersions[maxPos])) {
					maxPos = i;
				}
			}
		}

		if (maxPos >= 0) {
			this.version = this.supportedVersions[maxPos];
		}
	}
};

XFormsProcessor.prototype.testModelVersion = function(pModel) {
	var evt, desiredVersion, exceptionMsg;

	if (this.halted) {
		return false;
	}

	if (!this.version) {
		this.setVersion();
		if (!this.version) {
			exceptionMsg = "Error in default model version";
			pModel = document.defaultModel || pModel;
		}
	}

	desiredVersion = pModel.element.getAttribute("version") || "";

	if (desiredVersion.length === 0 && this.version) {
		return true;
	}

	if (this.find(desiredVersion.split(" "), this.version)) {
		return true;
	} else if (this.version) {
		exceptionMsg = "Unsupported version for model " + (pModel.getAttribute("id") || "");
	}

	evt = document.createEvent("Events");
	evt.initEvent("xforms-version-exception", true, false);
	evt.context = {
		"error-information": exceptionMsg || ""
	};
	FormsProcessor.dispatchEvent(document.defaultModel || pModel, evt);
	return false;
};

XFormsProcessor.prototype.inheritTrue = function(sMIP, oNode) {
	var retval, nodeProxy, parentProxy;
	nodeProxy = UX.getProxyNode(oNode);
	retval = nodeProxy.getMIP(sMIP).value;
	if (retval === undefined && oNode.parentNode) {
		parentProxy = UX.getProxyNode(oNode.parentNode);
		if (parentProxy[sMIP].getValue()) {
			retval = true;
		}
	}
	return retval;
};

XFormsProcessor.prototype.inheritFalse = function(sMIP, oNode) {
	var retval, nodeProxy, parentProxy;
	nodeProxy = UX.getProxyNode(oNode);

	retval = nodeProxy.getMIP(sMIP).value;
	if (retval && oNode.parentNode) {
		parentProxy = UX.getProxyNode(oNode.parentNode);
		if (!parentProxy[sMIP].getValue()) {
			retval = false;
		}
	}
	return retval;
};

XFormsProcessor.prototype.addDefaultEventListener = function(oTarget, sType, oListener) {

	if(oTarget.element) oTarget = oTarget.element;

	if (!oTarget.uniqueID) {
		oTarget.uniqueID = "uuid:" + Math.random() + Math.random();
	}

	if (!this.defaultHandlers[oTarget.uniqueID]) {
		this.defaultHandlers[oTarget.uniqueID] = {};
	}

	if (!this.defaultHandlers[oTarget.uniqueID][sType]) {
		this.defaultHandlers[oTarget.uniqueID][sType] = [];
	}

	this.defaultHandlers[oTarget.uniqueID][sType].push(oListener);
};

XFormsProcessor.prototype.removeDefaultEventListener = function(oTarget, sType, oListener) {
	var arrHandlers, i;
	if (this.defaultHandlers[oTarget.uniqueID]) {
		arrHandlers = this.defaultHandlers[oTarget.uniqueID][sType];

		if (arrHandlers) {
			for (i = 0; i < arrHandlers.length; i++) {
				if (arrHandlers[i] === oListener) {
					arrHandlers[i] = null;
				}
			}
		}
	}
};

XFormsProcessor.prototype.addDefaultEventListenerFor = function(target, event, scopeParam, methodName) {
	this.addDefaultEventListener(target, event, {
		scope: scopeParam,
		handleEvent: function() {
			this.scope[methodName]();
		}
	});
};

XFormsProcessor.prototype.dispatchEvent = function(oTarget, oEvent, bForceInlineExecution) {
	if(oTarget.element) oTarget = oTarget.element;
	var eventExecuted = false;
	try {
		IncrementDeferredUpdate();
		this.eventStack.push(oEvent);
		eventExecuted = oTarget.dispatchEvent(oEvent);

		if (eventExecuted) {
			this.invokeDefault(oTarget, oEvent);
			this.eventStack.pop();
		}
	} catch(e) {
	} finally {
		DecrementDeferredUpdate();
	}
};

XFormsProcessor.prototype.invokeDefault = function(oTarget, e) {
	var arrListeners, i;
	if (this.defaultHandlers[oTarget.uniqueID]) {
		arrListeners = this.defaultHandlers[oTarget.uniqueID][e.type];

		if (arrListeners) {
			for (i = 0; i < arrListeners.length; ++i) {
				if (arrListeners[i]) {
					arrListeners[i].handleEvent(e);
				}
			}
		}
	}
};

XFormsProcessor.prototype.getCurrentEvent = function() {
	var ret = null;
	if (this.eventStack) {
		ret = this.eventStack[this.eventStack.length - 1];
	}
	return ret;
};

XFormsProcessor.prototype.listenForXFormsFocus = function(target, listener) {
	target.element.addEventListener("xforms-focus", {
		handleEvent: function(evt) {
			listener.giveFocus();
		}
	},
	false);
};

(function() {
	var ELEMENT_TYPE = 1,
		chooseDescendentFromList, walkGetElementById, getContainingInnerScope;

	chooseDescendentFromList = function(list, ancestor) {
		var i;
		for (i = 0; i < list.length; ++i) {
			if (ancestor.contains(list[i])) {
				return list[i];
			}
		}
		return null;
	};

	walkGetElementById = function(id, scope) {
		var scopeChild = scope.firstChild,
			returnCandidate = null;
		while (scopeChild && !returnCandidate) {
			if (scopeChild.nodeType === ELEMENT_TYPE && !scopeChild.ignoreOnWalk) {
				if (UX.id(scopeChild) === id) {
					returnCandidate = scopeChild;
				} else {
					returnCandidate = walkGetElementById(id, scopeChild);
				}
			}
			scopeChild = scopeChild.nextSibling;
		}
		return returnCandidate;
	};

	getContainingInnerScope = function(element, outerScope) {
		var candidateScopeContainer = element.parentNode;
		while (candidateScopeContainer.parentNode) {
			if (
				candidateScopeContainer.getAttribute('outerscope') &&
				(!outerScope || outerScope === DECORATOR.getElement(candidateScopeContainer.getAttribute('outerscope')))
			) {
				return candidateScopeContainer;
			}
			candidateScopeContainer = candidateScopeContainer.parentNode;
		}
		return null;
	};

	/**
	 Function: getElementById
	 id: ID used as search term
	 topic: (optional) element used to resolve ambiguities where a scoped ID is concerned

	 Follows the algorithm described here:
	 http://www.w3.org/TR/xforms11/#idref-resolve
	 That is, if the topic is within the same scope as an ambiguous ID, returns the instance
	 of that ID in the same inner scope; otherwise, return the instance that is "exposed"
	 */

	XFormsProcessor.prototype.getElementById = function(id, topic) {
		var returnCandidate, candidateScope;
		returnCandidate = document.getElementById(id);
		if (returnCandidate) {
			candidateScope = getContainingInnerScope(returnCandidate);
			if (candidateScope) {
				var outerScope = DECORATOR.getElement(candidateScope.getAttribute('outerscope'));
				if (topic && outerScope.contains(topic)) {
					returnCandidate = this.getElementByIdWithAncestor(id, getContainingInnerScope(topic, outerScope));
				} else if (!outerScope.exposes(returnCandidate)) {
					returnCandidate = outerScope.getPublicElementById(id);
				}
			}
		}
		return returnCandidate;
	};

	XFormsProcessor.prototype.getElementByIdWithAncestor = function(id, ancestorOrSelf) {
		var returnCandidate, candidateScope;
		if (ancestorOrSelf && UX.id(ancestorOrSelf) === id) {
			returnCandidate = ancestorOrSelf;
		} else {
			returnCandidate = document.getElementById(id);
			if (returnCandidate) {

				if (ancestorOrSelf && !ancestorOrSelf.contains(returnCandidate)) {
					if (UX.isIE) {
						returnCandidate = chooseDescendentFromList(document.getElementsByName(id), ancestorOrSelf);
					} else {
						returnCandidate = walkGetElementById(id, ancestorOrSelf);
					}
				}
			}
		}
		return returnCandidate;
	};

} ());

XFormsProcessor.prototype.getProxyNode = function(object) {
	return object.m_proxy && object.m_proxy.m_oNode ? object.m_proxy : null;
};

XFormsProcessor.prototype.getContextNode = function (object) {
	return (object && object.m_context && object.m_context.node) ? object.m_context.node : null;
};

XFormsProcessor.prototype.visitDescendents = function(nodes, visit) {
	var i;
	for (i = 0; i < nodes.length; ++i) {
		this.visitDescendents(nodes[i].childNodes, visit);
		visit(nodes[i]);
	}
};

XFormsProcessor.prototype.refreshDescendents = function(nodes) {
	this.visitDescendents(nodes, function(n) {
		if (typeof n.refresh === "function") {
			n.refresh();
		}
	});
};

XFormsProcessor.prototype.refreshDescendentsForRelevance = function(nodes) {
	this.visitDescendents(nodes, function(n) {
		if (n.dirtyState && typeof n.refresh === "function") {
			n.dirtyState.setDirty("enabled");
			n.refresh();
		}
	});
};

XFormsProcessor.prototype.addToNavigationList = function(control) {
	this.navigationList.addControl(control);
};

XFormsProcessor.prototype.onKeyDown = function(event) {
	if (event.key == 'tab') {
		if (event.shift) {
			this.navigateToLastControl();
		} else {
			this.navigateToFirstControl();
		}
		event.stop();
		return false;
	} else if (event.alt && this.navigateToKeyedControl(event.key)) {
		event.stop();
		return false;
	}

	return true;
};

XFormsProcessor.prototype.navigateToFirstControl = function() {
	this.focusControl(this.navigationList.getFirstControl());
};

XFormsProcessor.prototype.navigateToLastControl = function() {
	this.focusControl(this.navigationList.getLastControl());
};

XFormsProcessor.prototype.navigateToNextControl = function(control) {
	this.focusControl(this.navigationList.getNextControl(control) || this.navigationList.getFirstControl());
};

XFormsProcessor.prototype.navigateToPreviousControl = function(control) {
	this.focusControl(this.navigationList.getPreviousControl(control) || this.navigationList.getLastControl());
};

XFormsProcessor.prototype.navigateToKeyedControl = function(key) {
	var control = this.navigationList.getControlByAccessKey(key);
	if (control) {
		this.focusControl(control);
		return true;
	}

	return false;
};

XFormsProcessor.prototype.focusControl = function(control) {
	if (control) {
		if (typeof control.giveFocus === 'function') {
			control.giveFocus();
		} else {
			control.focus();
		}
	}
};

XFormsProcessor.prototype.fn = {};

XFormsProcessor.prototype.extend = function(extension) {
	for (var name in extension) {
		if (extension.hasOwnProperty(name)) {
			this.fn[name] = extension[name];
			FunctionCallExpr.prototype.xpathfunctions[name] = function(context) {
				return FormsProcessor.callExtension(name, context, this.args);
			};
		}
	}
};

XFormsProcessor.prototype.callExtension = function(name, context, args) {
	var i, marshalledArgs = [];

	try {
		for (i = 0; i < args.length; ++i) {
			marshalledArgs.push(args[i].evaluate(context).stringValue());
		}

		return new StringValue(this.fn[name].apply(null, marshalledArgs));
	} catch(e) {
		this.dispatchExceptionEvent(context);
	}

	return new StringValue('');
};

XFormsProcessor.prototype.dispatchExceptionEvent = function(context) {
	if (NamespaceManager.compareFullName(context.resolverElement, 'bind', 'http://www.w3.org/2002/xforms')) {
		UX.dispatchEvent(context.currentModel || document.defaultModel, 'xforms-compute-exception', true, false, false);
	} else {
		UX.dispatchEvent(context.resolverElement, 'xforms-binding-exception', true, false, false);
	}
};

var FormsProcessor = new XFormsProcessor();

var flushEventQueue = function() {
	var oPendingEvent = g_pendingEvents.pop();
	while (oPendingEvent) {
		FormsProcessor.dispatchEvent(oPendingEvent.target, oPendingEvent.evt, true);
		oPendingEvent = g_pendingEvents.pop();
	}
};
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global event, document, DOM_TEXT_NODE, NamespaceManager, UX.getProxyNode,
   UX, window, getModelFor, setInitialState, spawn, FormsProcessor,
   setState
   */

var Control = new UX.Class({

	toString: function() {
		return 'xf:control';
	},

	initialize: function(element) {
		this.element = element;
		this.m_MIPSCurrentlyShowing = {};
		this.addedTVCListener = false;
		this.dirtyState = new DirtyState();
	},

	giveFocus: function() {
		if (this.m_proxy && this.m_proxy.enabled && this.m_proxy.enabled.getValue()) {
			if (DECORATOR.getBehaviour(this.m_value) && DECORATOR.getBehaviour(this.m_value).giveFocus) {
				DECORATOR.getBehaviour(this.m_value).giveFocus();
			} else {
				this.m_value.focus();
			}

			return true;
		}

		return false;
	},

	retrieveValuePseudoElement: function() {
		if(this.m_value) return this.m_value;
		var elements = this.element.getElementsByTagName("pe-value");
		for (var i = 0, l = elements.length; i < l; i++) {
			if (elements[i].parentNode === this.element) {
				this.m_value = elements[i];
				break;
			}
		}
		return this.m_value;
	},

	addValuePseudoElement: function() {
		var i, l;
		if (document.media == "print") return;

		this.retrieveValuePseudoElement();
		if (this.m_value) return;
		var childNodes = this.element.childNodes;
		if (childNodes) {
			for (i = 0, l = childNodes.length; i < l; i++) {
				if (DOM_TEXT_NODE === childNodes[i].nodeType) {
					this.m_sValue = childNodes[i].nodeValue;
					childNodes[i].parentNode.removeChild(childNodes[i]);
					break;
				}
			}
		}
		var labelChild = null;

		for (i = 0, l = childNodes.length; i < l; i++) {
			if (NamespaceManager.compareFullName(childNodes[i], "label", "http://www.w3.org/2002/xforms")) {
				labelChild = childNodes[i];
				break;
			}
		}
		var referenceNode = null;
		var insertionPoint = "";

		if (UX.isFF) {
			if (labelChild) {
				referenceNode = labelChild;
				insertionPoint = "afterEnd";
			} else {
				referenceNode = this.element;
				insertionPoint = "afterBegin";
			}
			referenceNode.insertAdjacentHTML(insertionPoint, "<pe-value></pe-value>");
			this.m_value = (labelChild) ? labelChild.nextSibling : this.element.firstChild;
		} else {
			this.m_value = document.createElement("pe-value");
			referenceNode = (labelChild) ? labelChild.nextSibling : this.element.firstChild;
			this.element.insertBefore(this.m_value, referenceNode);
		}
		if(UX.isIE) {
			UX.extend(this.m_value, new EventTarget(this.m_value));
			DECORATOR.attachDecoration(this.m_value, true, true);
		}
		this.addInputEventFilter();
	},

	addInputEventFilter: function() {
		if (!this.m_value) return;
		var self = this;

		var filterKeyPress = function(event) {
			if (self.m_proxy && self.m_proxy.readonly && self.m_proxy.readonly.getValue()) {
				if (event.key != 'tab' &&
				! (event.code >= 112 && event.code <= 123) && //Function Keys
				! (event.keyCode >= 33 && event.keyCode <= 36) // page up, page down, home, end
				) {
					event.stop();
					return false;
				}
			}
			return true;
		};

		filterMouseAction = function(event) {
			if (self.m_proxy && self.m_proxy.readonly && self.m_proxy.readonly.getValue()) {
				event.stop();
				if (!event.rightClick && event.type === "mousedown") {
					event.target.focus();
				}
				return false;
			}
			return true;
		};

		UX.Element(this.m_value).addEvents({
			keydown: filterKeyPress,
			mousedown: filterMouseAction,
			mousemove: filterMouseAction,
			mouseup: filterMouseAction,
			click: filterMouseAction
		});
	},

	/*
	 * Let the model know that we exist.
	 */
	addControlToModel: function() {
		var model = getModelFor(this);
		if (model) {
			setInitialState(this);
			model.addControl(this);
		}
	},

	rewire: function() {
		this.AddTVCListener();

		return this.xrewire();
	},

	AddTVCListener: function() {
		if (this.addedTVCListener) return;
		if (!this.m_value) {
			this.addValuePseudoElement();
		}
		var self = this;
		this.m_value.addEventListener("control-value-changed", {
			control: this,
			handleEvent: function(event) {
				if (self.m_proxy && self.m_proxy.m_vertex) {
					self.m_model.changeList.addChange(self.m_proxy.m_vertex);
					self.m_model.m_bNeedRecalculate = true;
				}
				var oEvt = document.createEvent("MutationEvents");
				oEvt.initMutationEvent("target-value-changed", true, true, null, event.prevValue, event.newValue, null, null);
				FormsProcessor.dispatchEvent(self.element, oEvt);
			}
		}, false);
		this.addedTVCListener = true;
	},

	getValue: function() {
		if (DECORATOR.getBehaviour(this.m_value).getValue) {
			return DECORATOR.getBehaviour(this.m_value).getValue();
		} else {
			return this.m_sValue;
		}
	},

/*
	 * Setting the value on a control actually sets it on the pe-value child.
	 */
	setValue: function(value) {
		var oldValue = this.m_sValue;
		if(oldValue == value) return;
		this.m_sValue = value;
		if (oldValue !== value) {
			this.dirtyState.setDirty("value");
		}

		try {
			if (this.m_value && DECORATOR.getBehaviour(this.m_value).setValue) {
				if (DECORATOR.getBehaviour(this.m_value).setValue(value)) {

					var oEvt = document.createEvent("MutationEvents");

					oEvt.initMutationEvent("data-value-changed", false, false, null, "", value, "", null);
					oEvt._actionDepth = -1;
					var self = this;
					spawn(function() {
						FormsProcessor.dispatchEvent(self.element, oEvt);
					});
				}
			}

			if (this.dirtyState.isDirty("value")) {
				var oEvt2 = document.createEvent("MutationEvents");
				oEvt2.initMutationEvent("xforms-value-changed", true, false, null, oldValue, value, "", null);
				FormsProcessor.dispatchEvent(this.element, oEvt2);
			}
		} catch(e) {
			document.logger.log("Control '" + this.element.tagName + "' has no setValue() method.", "control");
		}
		return;
	},

	setType: function(type) {
		if(this.type == type) return;

		UX.removeClassName(this.element, this.type);

		this.type = type;
		UX.addClassName(this.element, this.type);

		var pevalue = this.retrieveValuePseudoElement();
		if (pevalue && DECORATOR.getBehaviour(pevalue).isTypeAllowed) {
			if (!DECORATOR.getBehaviour(pevalue).isTypeAllowed(this.type)) {
				UX.dispatchEvent(this.m_model, "xforms-binding-exception", true, false, false);
			}
		}

	},

	refresh: function() {
		document.logger.log("Refreshing: " + this.element.tagName + ":" + this.element.uniqueID, "control");

		var proxy = this.m_proxy;

		this.updateMIPs();

		if (proxy) {
			this.setType(proxy.getType());
			this.setValue(proxy.getValue());
		}

		if (this.dirtyState.isDirty()) {
			this.broadcastMIPs();
			this.dirtyState.setClean();
		}
	},

	getValue: function() {
		if (DECORATOR.getBehaviour(this.m_value).getValue) {
			return DECORATOR.getBehaviour(this.m_value).getValue();
		} else {
			return this.m_sValue;
		}
	},

	onDocumentReady: function() {
		this.addControlToModel();

		var element = this.element;
		FormsProcessor.addDefaultEventListener(this, "xforms-binding-exception", {
			handleEvent: function(evt) {
				throw "Fatal Error: XForms Binding Exception on " + element.nodeName + "!";
			}
		}, false);
	},

	onContentReady: function() {
		this.addValuePseudoElement();
		FormsProcessor.listenForXFormsFocus(this, this);
	},

	isBoundToComplexContent: function() {
		var boundNode = this.getBoundNode(1).node;
		if (!boundNode) return false;

		var childNodes = boundNode.childNodes;
		for (var i = 0, l = childNodes.length; i < l; i++) {
			if (childNodes[i].nodeType == DOM_ELEMENT_NODE) {
				return true;
			}
		}
		return false;
	}

});
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SrcMixin = new UX.Class({

	toString: function() {
		return 'xf:srcmixin';
	},

	initialize: function(element) {
		this.element = element;
		this.m_oDOM = null;
		this.m_sValue = null;
	},

	load: function(labelURL) {

		if (labelURL) {
			this.element.setAttribute("xlink:actuate", "onRequest");
			this.element.setAttribute("xlink:show", "embed");
			this.element.setAttribute("xlink:href", labelURL);

			UX.extend(this, new XLinkElement(this.element));

			this.element.addEventListener("xlink-traversed", {
				context: this,
				handleEvent: function(evtParam) {
					this.context.textContent = this.context.innerHTML;
				}
			},
			false);

			this.element.addEventListener("xlink-traversal-failure", {
				context: this,
				handleEvent: function(evtParam) {
					var dispatcher = this.context;
					spawn(function() {
						dispatcher.dispatchException("xforms-link-exception", evtParam.context);
					});
				}
			},
			false);

			/*
	        * [ISSUE] Need to decide how to actuate, since
	        * onLoad is too late.
	        */

			this.Actuate();
		}
	},

	parseInstance: function() {

	},

	finishLoad: function() {
		return false;
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ActionExecutor = {

	invokeListener: function(listener, oEvt) {
		var realListener, context, oRes, i, sIf, sWhile;
		realListener = listener.realListener || listener;
		if (!realListener.getEvaluationContext) {
			listener.handleEvent(oEvt);
			return;
		}

		if (realListener.element.getAttribute("iterate")) {
			context = realListener.getEvaluationContext();
			oRes = context.model.EvaluateXPath(realListener.getAttribute("iterate"), context);
			if (!oRes || !oRes.value) return;
			for (i = 0; i < oRes.value.length; ++i) {
				realListener.unwire();
				realListener.m_context = {
					model: context.model,
					node: oRes.value[i],
					resolverElement: realListener.element,
					position: i,
					size: oRes.value.length
				};

				if (evaluateIfCondition(realListener, realListener.m_context)) {
					if (realListener.element.getAttribute("while")) {
						while (evaluateCondition(realListener.element.getAttribute("while"), realListener.m_context) && evaluateIfCondition(realListener, context)) {
							listener.handleEvent(oEvt);
						}
					} else {
						listener.handleEvent(oEvt);
					}
				}
			}
		} else {
			sIf = realListener.element.getAttribute("if");
			sWhile = realListener.element.getAttribute("while");
			if(!sIf && !sWhile) {
				listener.handleEvent(oEvt);
				return;
			}
			context = realListener.getEvaluationContext();
			if (evaluateIfCondition(realListener, context)) {
				if (realListener.element.getAttribute("while")) {
					while (evaluateCondition(realListener.element.getAttribute("while"), context) && evaluateIfCondition(realListener, context)) {
						listener.handleEvent(oEvt);
						context = realListener.getEvaluationContext();
					}
				} else {
					listener.handleEvent(oEvt);
				}
			}
		}
		return;
	}

};

/**
 Evaluates an XPath expression and returns the result as a boolean
 @param sCondition {String} The XPath expression to evaluate.
 @param context {Context}  The context in which to evaluate sCondition
 @returns true if the expression resulted in a boolean within context, false otherwise.
 Note that this means that if context is null, the return value will be false.
 */
function evaluateCondition(condition, context) {
	if(!context) return false;
	var result = context.model.EvaluateXPath(condition, context);
	if(!result) return false;
	return result.booleanValue();
}

/**
 Where a listener has an "if" property, that may be used prevent it from executing,
 given the current state of the application, evaluate it.
 If there is no "if" property, this will evaluate to true.
 @returns false if the the if condition evaluated to false, true otherwise
 */
function evaluateIfCondition(listener, context) {
	if (!listener.element.getAttribute("if")) return true;
	return evaluateCondition(listener.element.getAttribute("if"), context);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isValidEmail(sEmail) {
	return (
	sEmail.match(/^([A-Za-z0-9!#-'\*\+\-\/=\?\^_`\{-~]+(\.[A-Za-z0-9!#-'\*\+\-\/=\?\^_`\{-~]+)*@[A-Za-z0-9!#-'\*\+\-\/=\?\^_`\{-~]+(\.[A-Za-z0-9!#-'\*\+\-\/=\?\^_`\{-~]+)*)?$/) ? true : false);
}



function isValidCardNumber(sNum) {
	return (
	sNum.match(/^\d*[0-9]?$/) && sNum.length >= 12 && sNum.length <= 19 ? true : false);
}



function isValidDateTime(sDateTime) {
	return (
	sDateTime.match(/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}\:[0-9]{2}\:[0-9]{2}$/) || sDateTime.match(/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}\:[0-9]{2}\:[0-9]{2}Z$/) || sDateTime.match(/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}\:[0-9]{2}\:[0-9]{2}[+-][0-9]{2}\:[0-9]{2}$/) ? true : false);
}



function isValidTime(sTime) {
	return (
	sTime.match(/^[0-9]{2}\:[0-9]{2}\:[0-9]{2}$/) || sTime.match(/^[0-9]{2}\:[0-9]{2}\:[0-9]{2}[+-][0-9]{2}\:[0-9]{2}$/) ? true : false);
}



function isValidDate(sDate) {
	return (
	sDate.match(/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}$/) || sDate.match(/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}[+-][0-9]{2}\:[0-9]{2}$/) ? true : false);
}



function isValidGYearMonth(sGYearMonth) {
	return (
	sGYearMonth.match(/^[0-9]{4}\-[0-9]{2}$/) ? true : false);
}



function isValidGYear(sGYear) {
	return (
	sGYear.match(/^[0-9]{4}$/) ? true : false);
}



function isValidGMonthDay(sGMonthDay) {
	return (
	sGMonthDay.match(/^\-\-[0-9]{2}\-[0-9]{2}$/) ? true : false);
}



function isValidGDay(sGDay) {
	return (
	sGDay.match(/^\-\-\-[0-9]{2}$/) ? true : false);
}



function isValidGMonth(sGMonth) {
	return (
	sGMonth.match(/^\-\-[0-9]{2}$/) ? true : false);
}



function isValidBase64Binary(sBase64) {
	return (
	sBase64.match(/^[a-zA-Z0-9\+\/\=]+$/) ? true : false);
}



function isValidHexBinary(sHexBinary) {
	return (
	sHexBinary.match(/^[0-9a-fA-F]+$/) ? true : false);
}



function isValidNCName(sNCName) {
	return (
	sNCName.match(/^[_a-zA-Z][\w\.\-]*$/i) ? true : false);
}



function isValidAnyURI(sURI) {
	var i, c, match, encodedURI = "";

	for (i = 0; i < sURI.length; i++) {
		c = sURI.charCodeAt(i);
		if (((c >= 0 && c <= 31) || c === 127) || (c === 32) || (c === 34) || (c === 60) || (c === 62) || (c === 91) || (c === 92) || (c === 93) || (c === 94) || (c === 96) || (c === 123) || (c === 124) || (c === 125) || (c > 127)) {
			encodedURI += (encodeURIComponent(String.fromCharCode(c)));
		} else {
			encodedURI += (String.fromCharCode(c));
		}
	}

	match = encodedURI.match(/^(([^:\/?#]+):)?(\/\/([^\/\?#]*))?([^\?#]*)(\?([^#]*))?(#([^\:#\[\]\@\!\$\&\\'\(\)\*\+\,\;\=]*))?$/);
	return match ? _isValidAnyURI(match[0]) : false;
}



function _isValidAnyURI(sURI) {
	var ixPercent, s;

	ixPercent = sURI.indexOf("%");
	while (ixPercent !== -1) {
		s = sURI.substr(ixPercent);
		if (s.length < 3 || !s.substr(ixPercent + 1, 2).match(/^[0-9a-fA-F]$/)) {
			return false;
		}
		s = s.substr(ixPercent + 3);
		ixPercent = s.indexOf("%");
	}
	return true;
}



function isValidQName(sQName) {
	var arrSegments, prefix, localPart;

	arrSegments = sQName.split(":");
	prefix = arrSegments.length === 1 ? "" : arrSegments[0];
	localPart = arrSegments.length === 1 ? arrSegments[0] : arrSegments[1];

	return prefix ? isValidNCName(prefix) && isValidNCName(localPart) : isValidNCName(localPart);
}



function isInfinityOrNaN(sValue) {
	return (
	sValue === 'INF' || sValue === '-INF' || sValue === 'NaN');
}



function isValidBoolean(sBoolean) {
	return (
	sBoolean === "true" || sBoolean === "false" || sBoolean === "1" || sBoolean === "0");
}



function isValidInteger(sInteger) {
	return (
	sInteger.match(/^[-+]?[0-9]+$/) ? true : false);
}



function isValidPositiveInteger(sInteger) {
	return (
	sInteger.match(/^[+]?[1-9]+[0-9]*$/) ? true : false);
}



function isValidFloat(sFloat) {
	if (isInfinityOrNaN(sFloat)) {
		return true;
	} else {
		return (
		sFloat.match(/^[-+]?0*[1-9]?[0-9]*([\.]{1}[0-9]+)?([eE]{1}[-+]?[0-9]+)?$/) ? true : false);
	}
}



function isValidDouble(sDouble) {
	return isValidFloat(sDouble);
}



function isValidDecimal(sDecimal) {
	return (
	sDecimal.match(/^[-+]?0*[1-9]?[0-9]*([\.]{1}[0-9]+)?$/) ? true : false);
}



function isValidNormalizedString(sString) {
	return (
	sString.match(/^[^\n\r\t\s]+$/) ? true : false);
}



function isValidListItems(sList) {
	var arrSegments, i;

	arrSegments = sList.split(" ");
	for (i = 0; i < arrSegments.length; i++) {
		if (!isValidNormalizedString(arrSegments[i])) {
			return false;
		}
	}

	return true;
}



function isValidToken(sToken) {
	var ixSpace;

	if (sToken.charAt(0) === " " || sToken.charAt(sToken.length - 1) === " " || sToken.match(/^[\s]{2,}$/)) {
		return false;
	}
	return isValidNormalizedString(sToken);
}



function isValidLanguage(sLanguage) {
	return (
	sLanguage.match(/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/) ? true : false);
}



function isValidName(sName) {
	return (
	sName.match(/^[a-zA-Z\_\:][a-zA-Z0-9.\-\_\:]*$/i) ? true : false);
}



function isValidIDREFS(sIDREFS) {
	var arrSegments, i;

	arrSegments = sIDREFS.split(" ");
	for (i = 0; i < arrSegments.length; i++) {
		if (!isValidNCName(arrSegments[i])) {
			return false;
		}
	}

	return true;
}



function isValidNMTOKEN(sNMTOKEN) {
	return (
	sNMTOKEN.match(/^[a-zA-Z0-9\.\-\_\:]+$/) ? true : false);
}



function isValidNMTOKENS(sNMTOKENS) {
	var arrSegments, i;

	arrSegments = sNMTOKENS.split(" ");
	for (i = 0; i < arrSegments.length; i++) {
		if (!isValidNMTOKEN(arrSegments[i])) {
			return false;
		}
	}

	return true;
}



function isValidNonPositiveInteger(sInteger) {
	return (
	sInteger.match(/^[-]{1}[0-9]+$/) || sInteger.match(/^[+]?0$/) ? true : false);
}



function isValidNegativeInteger(sInteger) {
	return (
	sInteger.match(/^[-]{1}[0-9]+$/) ? true : false);
}



function isValidLong(sLong) {
	var match, value;

	match = sLong.match(/^[+-]?[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= -9223372036854775808 && value <= 9223372036854775807) {
			return true;
		}
	}

	return false;
}



function isValidInt(sInt) {
	var match, value;

	match = sInt.match(/^[+-]?[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= -2147483648 && value <= 2147483647) {
			return true;
		}
	}

	return false;
}



function isValidShort(sShort) {
	var match, value;

	match = sShort.match(/^[+-]?[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= -32768 && value <= 32767) {
			return true;
		}
	}

	return false;
}



function isValidByte(sByte) {
	var match, value;

	match = sByte.match(/^[+-]?[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= -128 && value <= 127) {
			return true;
		}
	}

	return false;
}



function isValidNonNegativeInteger(sInteger) {
	return (
	sInteger.match(/^[+]?[0-9]+$/) || sInteger.match(/^[+-]?0$/) ? true : false);
}



function isValidUnsignedLong(sULong) {
	var match, value;

	match = sULong.match(/^[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= 0 && value <= 18446744073709551615) {
			return true;
		}
	}

	return false;
}



function isValidUnsignedInt(sUInt) {
	var match, value;

	match = sUInt.match(/^[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= 0 && value <= 4294967295) {
			return true;
		}
	}

	return false;
}



function isValidUnsignedShort(sUShort) {
	var match, value;

	match = sUShort.match(/^[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= 0 && value <= 65535) {
			return true;
		}
	}

	return false;
}



function isValidUnsignedByte(sUByte) {
	var match, value;

	match = sUByte.match(/^[0-9]+$/);
	if (match) {
		value = Number(match[0]);
		if (value >= 0 && value <= 255) {
			return true;
		}
	}

	return false;
}



function evalXPathFunc(func, args, ctx) {
	var funcName = new StringValue(func);
	var argToken = null;

	var ret = new FunctionCallExpr(funcName);

	for (var i = 0; i < args.length; ++i) {
		argToken = new TokenExpr(args[i]);
		ret.appendArg(argToken);
	}
	return ret.evaluate(ctx);
}

var xformsRules = {
	namespace: "http://www.w3.org/2002/xforms",
	rules: {
		"dateTime": {
			validate: function(sValue) {
				return sValue === "" || isValidDateTime(sValue);
			}
		},

		"time": {
			validate: function(sValue) {
				return sValue === "" || isValidTime(sValue);
			}
		},

		"date": {
			validate: function(sValue) {
				return sValue === "" || isValidDate(sValue);
			}
		},

		"gYearMonth": {
			validate: function(sValue) {
				return sValue === "" || isValidGYearMonth(sValue);
			}
		},

		"gYear": {
			validate: function(sValue) {
				return sValue === "" || isValidGYear(sValue);
			}
		},

		"gMonthDay": {
			validate: function(sValue) {
				return sValue === "" || isValidGMonthDay(sValue);
			}
		},

		"gDay": {
			validate: function(sValue) {
				return sValue === "" || isValidGDay(sValue);
			}
		},

		"gMonth": {
			validate: function(sValue) {
				return sValue === "" || isValidGMonth(sValue);
			}
		},

		"string": {
			validate: function(sValue) {
				return true;
			}
		},

		"boolean": {
			validate: function(sValue) {
				return sValue === "" || isValidBoolean(sValue);
			}
		},

		"base64Binary": {
			validate: function(sValue) {
				return sValue === "" || isValidBase64Binary(sValue);
			}
		},

		"hexBinary": {
			validate: function(sValue) {
				return sValue === "" || isValidHexBinary(sValue);
			}
		},

		"integer": {
			validate: function(sValue) {
				return sValue === "" || isValidInteger(sValue);
			}
		},

		"positiveInteger": {
			validate: function(sValue) {
				return sValue === "" || isValidPositiveInteger(sValue);
			}
		},

		"float": {
			validate: function(sValue) {
				return sValue === "" || isValidFloat(sValue);
			}
		},

		"decimal": {
			validate: function(sValue) {
				return sValue === "" || isValidDecimal(sValue);
			}
		},

		"double": {
			validate: function(sValue) {
				return sValue === "" || isValidDouble(sValue);
			}
		},

		"anyURI": {
			validate: function(sValue) {
				return sValue === "" || isValidAnyURI(sValue);
			}
		},

		"QName": {
			validate: function(sValue) {
				return sValue === "" || isValidQName(sValue);
			}
		},

		"dayTimeDuration": {
			validate: function(sValue) {
				return sValue === "" || isNaN(evalXPathFunc("seconds", [sValue]).numberValue()) === false;
			}
		},

		"yearMonthDuration": {
			validate: function(sValue) {
				var sExpr = "months(" + "'" + sValue + "')";
				return sValue === "" || isNaN(evalXPathFunc("months", [sValue]).numberValue()) === false;
			}
		},

		"email": {
			validate: function(sValue) {
				return sValue === "" || isValidEmail(sValue);
			}
		},

		"card-number": {
			validate: function(sValue) {
				return sValue === "" || isValidCardNumber(sValue);
			}
		},

		"normalizedString": {
			validate: function(sValue) {
				return sValue === "" || isValidNormalizedString(sValue);
			}
		},

		"listItem": {
			validate: function(sValue) {
				return sValue === "" || isValidNormalizedString(sValue);
			}
		},

		"listItems": {
			validate: function(sValue) {
				return sValue === "" || isValidListItems(sValue);
			}
		},

		"token": {
			validate: function(sValue) {
				return sValue === "" || isValidToken(sValue);
			}
		},

		"language": {
			validate: function(sValue) {
				return sValue === "" || isValidLanguage(sValue);
			}
		},

		"Name": {
			validate: function(sValue) {
				return sValue === "" || isValidName(sValue);
			}
		},

		"NCName": {
			validate: function(sValue) {
				return sValue === "" || isValidNCName(sValue);
			}
		},

		"ID": {
			validate: function(sValue) {
				return sValue === "" || isValidNCName(sValue);
			}
		},

		"IDREF": {
			validate: function(sValue) {
				return sValue === "" || isValidNCName(sValue);
			}
		},

		"IDREFS": {
			validate: function(sValue) {
				return sValue === "" || isValidIDREFS(sValue);
			}
		},

		"NMTOKEN": {
			validate: function(sValue) {
				return sValue === "" || isValidNMTOKEN(sValue);
			}
		},

		"NMTOKENS": {
			validate: function(sValue) {
				return sValue === "" || isValidNMTOKENS(sValue);
			}
		},

		"nonPositiveInteger": {
			validate: function(sValue) {
				return sValue === "" || isValidNonPositiveInteger(sValue);
			}
		},

		"negativeInteger": {
			validate: function(sValue) {
				return sValue === "" || isValidNegativeInteger(sValue);
			}
		},

		"long": {
			validate: function(sValue) {
				return sValue === "" || isValidLong(sValue);
			}
		},

		"int": {
			validate: function(sValue) {
				return sValue === "" || isValidInt(sValue);
			}
		},

		"short": {
			validate: function(sValue) {
				return sValue === "" || isValidShort(sValue);
			}
		},

		"byte": {
			validate: function(sValue) {
				return sValue === "" || isValidByte(sValue);
			}
		},

		"nonNegativeInteger": {
			validate: function(sValue) {
				return sValue === "" || isValidNonNegativeInteger(sValue);
			}
		},

		"unsignedLong": {
			validate: function(sValue) {
				return sValue === "" || isValidUnsignedLong(sValue);
			}
		},

		"unsignedInt": {
			validate: function(sValue) {
				return sValue === "" || isValidUnsignedInt(sValue);
			}
		},

		"unsignedShort": {
			validate: function(sValue) {
				return sValue === "" || isValidUnsignedShort(sValue);
			}
		},

		"unsignedByte": {
			validate: function(sValue) {
				return sValue === "" || isValidUnsignedByte(sValue);
			}
		}
	}
};

var xmlSchemaRules = {
	namespace: "http://www.w3.org/2001/XMLSchema",
	rules: {
		"dateTime": {
			validate: function(sValue) {
				return isValidDateTime(sValue);
			}
		},

		"time": {
			validate: function(sValue) {
				return isValidTime(sValue);
			}
		},

		"date": {
			validate: function(sValue) {
				return isValidDate(sValue);
			}
		},

		"gYearMonth": {
			validate: function(sValue) {
				return isValidGYearMonth(sValue);
			}
		},

		"gYear": {
			validate: function(sValue) {
				return isValidGYear(sValue);
			}
		},

		"gMonthDay": {
			validate: function(sValue) {
				return isValidGMonthDay(sValue);
			}
		},

		"gDay": {
			validate: function(sValue) {
				return isValidGDay(sValue);
			}
		},

		"gMonth": {
			validate: function(sValue) {
				return isValidGMonth(sValue);
			}
		},

		"string": {
			validate: function(sValue) {
				return true;
			}
		},

		"boolean": {
			validate: function(sValue) {
				return isValidBoolean(sValue);
			}
		},

		"base64Binary": {
			validate: function(sValue) {
				return isValidBase64Binary(sValue);
			}
		},

		"hexBinary": {
			validate: function(sValue) {
				return isValidHexBinary(sValue);
			}
		},

		"integer": {
			validate: function(sValue) {
				return isValidInteger(sValue);
			}
		},

		"positiveInteger": {
			validate: function(sValue) {
				return isValidPositiveInteger(sValue);
			}
		},

		"float": {
			validate: function(sValue) {
				return isValidFloat(sValue);
			}
		},

		"decimal": {
			validate: function(sValue) {
				return isValidDecimal(sValue);
			}
		},

		"double": {
			validate: function(sValue) {
				return isValidDouble(sValue);
			}
		},

		"anyURI": {
			validate: function(sValue) {
				return isValidAnyURI(sValue);
			}
		},

		"QName": {
			validate: function(sValue) {
				return isValidQName(sValue);
			}
		},

		"normalizedString": {
			validate: function(sValue) {
				return isValidNormalizedString(sValue);
			}
		},

		"token": {
			validate: function(sValue) {
				return isValidToken(sValue);
			}
		},

		"language": {
			validate: function(sValue) {
				return isValidLanguage(sValue);
			}
		},

		"Name": {
			validate: function(sValue) {
				return isValidName(sValue);
			}
		},

		"NCName": {
			validate: function(sValue) {
				return isValidNCName(sValue);
			}
		},

		"ID": {
			validate: function(sValue) {
				return isValidNCName(sValue);
			}
		},

		"IDREF": {
			validate: function(sValue) {
				return isValidNCName(sValue);
			}
		},

		"IDREFS": {
			validate: function(sValue) {
				return isValidIDREFS(sValue);
			}
		},

		"NMTOKEN": {
			validate: function(sValue) {
				return isValidNMTOKEN(sValue);
			}
		},

		"NMTOKENS": {
			validate: function(sValue) {
				return isValidNMTOKENS(sValue);
			}
		},

		"nonPositiveInteger": {
			validate: function(sValue) {
				return isValidNonPositiveInteger(sValue);
			}
		},

		"negativeInteger": {
			validate: function(sValue) {
				return isValidNegativeInteger(sValue);
			}
		},

		"long": {
			validate: function(sValue) {
				return isValidLong(sValue);
			}
		},

		"int": {
			validate: function(sValue) {
				return isValidInt(sValue);
			}
		},

		"short": {
			validate: function(sValue) {
				return isValidShort(sValue);
			}
		},

		"byte": {
			validate: function(sValue) {
				return isValidByte(sValue);
			}
		},

		"nonNegativeInteger": {
			validate: function(sValue) {
				return isValidNonNegativeInteger(sValue);
			}
		},

		"unsignedLong": {
			validate: function(sValue) {
				return isValidUnsignedLong(sValue);
			}
		},

		"unsignedInt": {
			validate: function(sValue) {
				return isValidUnsignedInt(sValue);
			}
		},

		"unsignedShort": {
			validate: function(sValue) {
				return isValidUnsignedShort(sValue);
			}
		},

		"unsignedByte": {
			validate: function(sValue) {
				return isValidUnsignedByte(sValue);
			}
		}
	}
};

var Validator = {
	nsRules: {},

	addRules: function(vRules) {
		this.nsRules[vRules.namespace] = vRules;
	},

	removeRules: function(namespace) {
		var nsRules = this.nsRules;
		var len = nsRules.length;
		var idx;

		for (idx = 0; idx < len; idx++) {
			if (nsRules[idx].namespace === namespace) {
				nsRules.splice(idx, 1);
				break;
			}
		}
	},

	validateValue: function(ns, datatype, value) {
		var validator = null;
		var validateRule = this.nsRules[ns];

		if (validateRule) {
			rule = validateRule.rules[datatype];
			if (rule && rule.validate !== undefined) {
				return rule.validate(value);
			}
		}
		return false;
	}
};

Validator.addRules(xformsRules);
Validator.addRules(xmlSchemaRules);
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Context = new UX.Class({

	toString: function() {
		return 'xf:context';
	},

	initialize: function(element) {
		this.element = element;
		this.m_context = null;
		this.nodes = null;
		this.m_model = null;
		this.m_proxy = null;
	},

	unwire: function() {
		this.m_context = null;
		this.nodes = null;
		if (this.m_proxy && !this.element.getAttribute('bindingcontainer')) {
			this.m_proxy = null;
		}
		return;
	},

	/*
	 * The object returned contains the context "node", the "model" that contains it,
	 * the "initialContext" node before evaluating the context attribute (or undefined
	 * if there is no context attribute), the "position" of the context node in a nodeset
	 * and the "size" of that nodeset if this is repeated (and undefined otherwise).
	 * Finally, the "resolverElement" is this, the element whose inscope evaluation
	 * context is being determined.
	 */
	getEvaluationContext: function() {
		if (this.m_context) {
			return UX.extend({}, this.m_context);
		}

		var context;
		var element = this.element;
		var doc = element.ownerDocument;

		var modelId = element.getAttribute("model");

		if (modelId) {
			var model = doc.getElementById(modelId);

			if (model && DECORATOR.getBehaviour(model)) {
				var oContextModel = getModelFor(element);

				if (oContextModel === model) {
					context = this.getEvaluationContextFromParent();
				} else {
					context = DECORATOR.getBehaviour(model).getEvaluationContext();
				}
			} else {
				UX.dispatchEvent(element, "xforms-binding-exception", false, true, true);
			}
		} else {
			context = Context.prototype.getEvaluationContextFromParent.apply(this);
		}

		context.initialContext = context.node;
		context.resolverElement = this.element;
		this.m_context = context;
		var sContext = element.getAttribute("context");
		if (sContext) {
			context.node = getFirstNode(context.model.EvaluateXPath(sContext, this.m_context));
			if (context.node !== context.initialContext) {
				context.position = undefined;
				context.size = undefined;
			}
		} else {
			context.initialContext = undefined;
		}

		this.m_context = UX.extend({}, context);
		return context;
	},

	/*
	 * If an element doesn't have an evaluation context, then we get it
	 * from the parent.
	 */
	/* This method searches for the nearest ancestor of this that
	 * expresses a binding, and it selects the node that provides
	 * the initial inscope evaluation context for this.
	 * The object returned has the context node, the model
	 * containing it, and possibly a position and size.
	 */
	getEvaluationContextFromParent: function() {
		var context = {
			model: null,
			node: null,
			resolverElement: this.element
		};
		var element = this.element;
		var parentNode = element.parentNode;
		var root = element.ownerDocument.documentElement;
		var boundNode = null;

		var nOrdinal = Number(element.getAttribute("ordinal"));
		if (!nOrdinal || isNaN(nOrdinal)) {
			nOrdinal = 1;
		} else {
			context.position = nOrdinal;
		}

		while (parentNode) {
			var parent = DECORATOR.getBehaviour(parentNode);
			if (parent && parent.getBoundNode) {
				boundNode = parent.getBoundNode(nOrdinal);
				if (boundNode && (boundNode.model || boundNode.node)) {
					if (context.position) {
						context.size = parent.nodes.length;
					}
					context.model = boundNode.model;
					context.node = boundNode.node;
					break;
				}
			}
			parentNode = parentNode.parentNode;
		}


		if (!parentNode || root === parentNode) {
			if (!document.defaultModel) {
				var models = NamespaceManager.getElementsByTagNameNS(root, "http://www.w3.org/2002/xforms", "model");
				if (models && models.length > 0) {
					document.defaultModel = DECORATOR.getBehaviour(models[0]);
				} else {
					context.model = null;
					context.node = null;
					return context;
				}
			}
			context = document.defaultModel.getEvaluationContext();
			context.resolverElement = this.element;
		}
		return context;
	},

	/*
	 * Get the node that this element is bound to.
	 */
	getBoundNode: function(nOrdinal) {
		var proxy = this.m_proxy;
		var element = this.element;
		var bindId = element.getAttribute("bind");
		var oRet = {
			model: null,
			node: null,
			resolverElement: this.element
		};
		var i = 0;

		if (!nOrdinal || isNaN(nOrdinal)) {
			nOrdinal = 1;
		}
		/*
	     * If we have a proxy node (and not a proxy expression) then use that.
	     */
		if (proxy && !proxy.m_xpath) {
			if (!this.m_model) {
				this.m_model = this.getEvaluationContext().model;
			}
			return {
				model: this.m_model,
				node: proxy.getNode(),
				resolverElement: this.element
			};
		}

		if (NamespaceManager.getLowerCaseLocalName(element) === "model") {
			return this.getEvaluationContext();
		}

		if (bindId) {
			if (!this.nodes) {
				var bind = FormsProcessor.getBindObject(bindId, element);
				this.m_model = bind.ownerModel;
				this.nodes = bind.boundNodeSet;
			}
			oRet.model = this.m_model;

			i = nOrdinal - 1;
			if (this.nodes && this.nodes.length > i) {
				oRet.node = this.nodes[i];
			}
			return oRet;
		}

		var ref = element.getAttribute("ref");
		var nodeset = element.getAttribute("nodeset");
		var name = XF4HProcessor.getAttribute(element, "name");

		if ( !(ref || nodeset || name || element.getAttribute("model")) ) return oRet;
		oRet = this.getEvaluationContext();
		if(!oRet.model) return oRet;

		this.m_model = oRet.model;

		if (ref && nOrdinal == 1) {
			var refNode = getFirstNode(this.m_model.EvaluateXPath(ref, oRet));

			if (!refNode && this.m_model.constructingUI) {
				var instanceDoc = this._getDefaultInstanceDocument(this.m_model);

				if (instanceDoc && instanceDoc.documentElement.getAttribute('isLazilyAuthored')) {
					if (xmlSchemaRules.rules["QName"].validate(ref)) {
						refNode = instanceDoc.createElement(ref);

						if (refNode) {
							instanceDoc.documentElement.appendChild(refNode);
							this.m_context = null;
							oRet = this.getEvaluationContext();
						}
						refNode = getFirstNode(this.m_model.EvaluateXPath(ref, oRet));
					} else {
						UX.dispatchEvent(element, "xforms-binding-exception", false, true, true);
					}
				}
			}
			oRet.node = refNode;
		} else if (nodeset) {
			if (!this.nodes) {
				this.nodes = this.m_model.EvaluateXPath(nodeset, oRet).value;
			}
			oRet.node = this.nodes[nOrdinal - 1];
		} else if (name) {
			oRet.node = XF4HProcessor.processElement(this.m_model, oRet.node, element, name);
		}
		return oRet;
	},

	_getDefaultInstanceDocument: function(model) {
		var instanceDoc = null;
		var instanceNode = null;
		try {
			instanceDoc = model.getInstanceDocument();
			return instanceDoc;
		} catch(e) {}

		var nsURI = "http://www.w3.org/2002/xforms";
		if (UX.isXHTML) {
			var instanceRoot = document.createElementNS("", "instanceData");
			instanceNode = document.createElementNS(nsURI, "instance");
			instanceNode.appendChild(instanceRoot);
		} else {
			var prefix = NamespaceManager.getOutputPrefixesFromURI(nsURI)[0];
			instanceNode = document.createElement(prefix + ":" + "instance");
			instanceNode.innerHTML = "<instanceData xmlns='' ></instanceData>";
		}

		model.element.appendChild(instanceNode);
		if (UX.isIE || !UX.hasDecorationSupport) {
			DECORATOR.attachDecoration(instanceNode, true, true);
		}
		DECORATOR.getBehaviour(instanceNode).m_oDOM.documentElement.setAttribute('isLazilyAuthored', true);
		return model.getInstanceDocument();
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This is really 'xf:submission'.
 */


var Submission = new UX.Class({

	Mixins: [Context],

	toString: function() {
		return 'xf:submission';
	},

	initialize: function(element) {
		this.element = element;
		this.submissionBody = "";
	},

	onDocumentReady: function() {
		/*
		* We invoke the submission when we see the
		* xforms-submit event.
		*/
		FormsProcessor.addDefaultEventListener(
		this, "xforms-submit", {
			handleEvent: function(evt) {
				evt.target.ownerDocument.submission.submit(evt.target);
				return;
			}
		});

		FormsProcessor.addDefaultEventListener(
		this, "xforms-submit-serialize", {
			handleEvent: function(evt) {
				if (evt.context) {
					evt.target.submissionBody = evt.context["submission-body"];
				}
			}
		});
	}

});

/* This is a temporary home. */

if (!document.submissionJSON) {
	document.submissionJSON = {
		_timeoutlength: 30000,
		/* 30 seconds by default */
		_running: [],

		_timeout: function(id, url) {
			var cbo = this._running[id];

			this._running[id] = null;
			if (!cbo.callbackErr) return;
			cbo.callbackErr("Timeout", -1, cbo.self);
		},
		_callbackhandler: function(o) {
			var cbo = this._running[callbackIndex];

			if (!cbo) return;
			this._running[callbackIndex] = null;
			window.clearTimeout(cbo.timeout);
			if (!o || !o.count) {
				if (!cbo.callbackErr) return;
				cbo.callbackErr("Bad response", -2, cbo.self);
				return;
			}

			if (!cbo.callbackOk) return;
			cbo.callbackOk(o, cbo.resource, cbo.self);
		},
		_execute: function(url, resource, callbackOk, callbackErr, timeoutlength) {
			if (!timeoutlength) timeoutlength = this._timeoutlength;
			var id = this._running.length;

			url += "&_callback=document.submissionJSON._callbackhandler_" + id;

			var s = document.createElement("script");

			s.setAttribute("src", url);

			var fn = "" + this._callbackhandler;

			fn = fn.replace(/callbackIndex/g, id);
			eval("document.submissionJSON._callbackhandler_" + id + "=" + fn);
			this._running.push({
				self: this,
				resource: resource,
				callbackOk: callbackOk,
				callbackErr: callbackErr,
				timeout: window.setTimeout(
				function() {
					this._timeout(id, url);
				},
				timeoutlength)
			});
			document.getElementsByTagName("head")[0].appendChild(s);
			return id;
		},
		/* use these three calls to run and cancel Pipes calls */
		cancelrequest: function(id) {
			var cbo = this._running[i];

			window.clearTimeout(cbo.timeout);
			this._running[i] = null;
		},
		cancelallrequests: function() {
			for (var i = 0; i < this._running.length; i++)
			this.cancelrequest(i);
		},
		run: function(action, params, resource, callbackOk, callbackErr, timeoutLength) {
			return this._execute(
			document.submission.buildGetUrl(action, params), resource, callbackOk, callbackErr, timeoutLength);
		} //run
	}; //pipesrpc
} //if ( document.submissionJSON is not defined )
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var MIPHandler = new UX.Class({

	toString: function() {
		return 'xf:mip-handler';
	},

	initialize: function(element) {
		this.element = element;
		this.dirtyState = new DirtyState();
		this.m_MIPSCurrentlyShowing = {};
	},

	addControlToModel: function() {
		var model = getModelFor(this);
		if (model) {
			setInitialState(this);
			model.addControl(this);
		} else if ((this.element.getAttribute("ref") || this.element.getAttribute("nodeset"))) {
			throw ("Could not resolve model for MIPHandler");
		}
	},

	rewire: function() {
		var result = false,
			ctxBoundNode = this.getBoundNode(1);

		this.m_model = ctxBoundNode.model;

		if (ctxBoundNode.node) {
			this.m_proxy = UX.getProxyNode(ctxBoundNode.node);
			result = true;
		}

		if (this.isWired === false) {
			this.isWired = true;
		}
		this.xrewire();
		return result;
	},

	xrewire: function() {

		var bRet, ctxBoundNode, oPN, sValueExpr, ctx;

		document.logger.log("Rewiring: " + this.element.tagName + ":" + this.element.uniqueID, "control");
		bRet = false;


		if (this.m_proxy) {
			this.m_proxy = null;
		}

		ctxBoundNode = this.getBoundNode();
		oPN = null;

		if (ctxBoundNode.model) {
			this.m_model = ctxBoundNode.model;
		}

		sValueExpr = this.element.getAttribute("value");

		if (sValueExpr) {
			ctx = ctxBoundNode;
			if (!ctxBoundNode.model && !ctxBoundNode.node) {
				ctx = this.getEvaluationContext();
				if (ctx.model) {
					this.m_model = ctx.model;
				}
			}

			bRet = true;
			if (this.m_proxy && this.m_proxy.m_ctrlProxyTarg && this.m_proxy.m_ctrlProxyTarg.targetControl == this) {
				return bRet;
			}
			oPN = ctx.model.addControlExpression(this, ctx, sValueExpr);
		} else if (ctxBoundNode.node) {
			ctx = ctxBoundNode;
			oPN = UX.getProxyNode(ctxBoundNode.node);

			ctxBoundNode.model.addControlBinding(this);
			bRet = true;
		}

		if (oPN) {
			this.m_proxy = oPN;
			var oModel = ctx.model;
			var oContext = ctx;

			if (this.m_proxy.m_ctrlProxyTarg && this.m_proxy.m_ctrlProxyTarg.targetControl == this) {
				return bRet;
			}

			var oPNVTarg = new ControlProxyNodeVertex(this, oContext, oModel, this.m_proxy);
			var oPNV = oModel.m_oDE.createVertex(oPNVTarg);

			this.m_proxy.m_ctrlProxyTarg = oPNVTarg;
			this.m_proxy.m_ctrlVertex = oPNV;

			if (!this.m_proxy.m_vertex) {
				this.m_proxy.m_vertex = oPNV;
			} else if (this.m_proxy.m_vertex.vertexTarget) {
				this.m_proxy.m_vertex.addDependent(oPNV);
			}

			if (this.m_proxy && this.m_proxy.m_xpath) {
				var sExpr = this.m_proxy.m_xpath;
				var oCPE = new ComputedXPathExpression(oPN, sExpr, oContext, oModel);
				var oCalcVertex = oModel.m_oDE.createVertex(oCPE);
				oCalcVertex.addDependent(oPNV);
				oCPE.addDependentExpressions(oCalcVertex, oModel.m_oDE, oModel.changeList);
			}
			oPNVTarg.addDependentProxyNodes();
		}

		return bRet;
	},

	setState: function(mip, on, off) {
		if ( !this.dirtyState || !this.dirtyState.isDirty(mip) ) return this;
		var state = this.getMIPState(mip);
		if (!state || !state.isSet) return this;
		this.m_MIPSCurrentlyShowing[mip] = state.value;
		if (state.value) {
			UX.Element(this.element).removeClass(off).addClass(on);
		} else {
			UX.Element(this.element).removeClass(on).addClass(off);
		}
		return this;
	},

	updateMIPs: function() {
		this.setDirtyStates();
		this.setState("enabled", "enabled", "disabled")
		.setState("readonly", "read-only", "read-write")
		.setState("required", "required", "optional")
		.setState("valid", "valid", "invalid");
	},

	isDirtyMIP: function(mip) {
		var state = this.getMIPState(mip);
		return this.m_MIPSCurrentlyShowing[mip] === undefined || (state.isSet && this.m_MIPSCurrentlyShowing[mip] !== state.value);
	},

	setDirtyStates: function() {
		this.setDirtyState("enabled").setDirtyState("readonly").setDirtyState("required").setDirtyState("valid");
	},

	setDirtyState: function(mip) {
		if (this.isDirtyMIP(mip)) {
			this.dirtyState.setDirty(mip);
		}
		return this;
	},

	refresh: function() {
		document.logger.log("Refreshing: " + this.element.tagName + ":" + this.element.uniqueID, "control");

		this.updateMIPs();

		if (this.dirtyState.isDirty()) {
			this.broadcastMIPs();
			this.dirtyState.setClean();
		}
	},

	getMIPState: function(mip) {
		var state = {
			isSet: false
		};
		var proxyNode = FormsProcessor.getProxyNode(this);
		if (proxyNode) {
			state.value = proxyNode.getMIPState(mip);
			state.isSet = true;
		} else if(mip === "enabled") {
			state.value = this.isEnabled();
			state.isSet = true;
		}
		return state;
	},

	inheritEnabled: function() {
		var parentNode = this.element.parentNode;
		while (parentNode) {
			var parent = DECORATOR.getBehaviour(parentNode);
			if(!parent) {
				parentNode = parentNode.parentNode;
				continue;
			}
			if (parent.isGroup || parent.isSwitch) {
				if (parent.isEnabled() === false) {
					return false;
				}
			} else if (parent.isCase) {
				if (parent.getSwitch() && typeof parent.getSwitch().getSelectedCase === "function" && parent !== parent.getSwitch().getSelectedCase()) {
					return false;
				}
			}
			parentNode = parentNode.parentNode;
		}
		return true;
	},

	isEnabled: function() {
		if (!this.inheritEnabled()) {
			return false;
		}

		if (this.element.isWired === false) {
			return true;
		}

		var proxyNode = FormsProcessor.getProxyNode(this);
		if (proxyNode) {
			return proxyNode.enabled.getValue();
		}

		var contextNode = FormsProcessor.getContextNode(this);
		if(contextNode) {
			proxyNode = UX.getProxyNode(contextNode);
			if (proxyNode.enabled) {
				return proxyNode.enabled.getValue();
			}
		}
		return this.mustBeBound() ? false : true;
	},

	broadcastMIPs: function() {

	},

	onDocumentReady: function() {
		this.addControlToModel();
	},

	mustBeBound: function() {
		return true;
	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MIPEventTarget = new UX.Class({

	toString: function() {
		return 'xf:mip-event-target';
	},

	initialize: function(element) {
		this.element = element;
	},

	broadcastMIPs: function() {
		var proxyNode = FormsProcessor.getProxyNode(this);
		if (proxyNode) {
			UX.dispatchEvent(this.element, proxyNode.valid.getValue() ? "xforms-valid" : "xforms-invalid", true, false);
			UX.dispatchEvent(this.element, proxyNode.required.getValue() ? "xforms-required" : "xforms-optional", true, false);
			UX.dispatchEvent(this.element, proxyNode.readonly.getValue() ? "xforms-readonly" : "xforms-readwrite", true, false);
			UX.dispatchEvent(this.element, proxyNode.enabled.getValue() ? "xforms-enabled" : "xforms-disabled", true, false);
		} else {
			UX.dispatchEvent(this.element, this.isEnabled() ? "xforms-enabled" : "xforms-disabled", true, false);
		}
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var OptionalBinding = new UX.Class({

	toString: function() {
		return 'xf:optional-binding';
	},

	mustBeBound: function() {
		return false;
	}

});

var OptionalIfUnspecifiedBinding = new UX.Class({

	toString: function() {
		return 'xf:optional-if-binding';
	},

	mustBeBound: function() {
		return Boolean(this.element.getAttribute("ref"));
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global ActionExecutor, document, spawn, FormsProcessor, UX, setTimeout*/
/**
 Used in conjunction with Conditional Invocation
 */
function ConditionalInvocationListener(obj, funcName) {
	return {
		realListener: obj,
		handleEvent: function(evt) {
			return obj[funcName](evt);
		}
	};
}

/**
 Event handlers are mandated to be invoked by their "handleEvent" member function,
 however, XForms provides the possibility for events to be conditionally invoked,
 or looped. XForms Actions, therefore, implement the "performAction" method, and
 use DeferToConditionalInvocationProcessor as handleEvent

 @param {Event} evt An object reprenting the event that is occuring.
 */
function DeferToConditionalInvocationProcessor(evt) {
	var self = this;
	ActionExecutor.invokeListener({
		realListener: this,
		handleEvent: function(evt) {
			return self.performAction(evt);
		}
	}, evt);
}

var Recalculate = new UX.Class({

	toString: function() {
		return 'xf:recalculate';
	},

	intialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var id = this.element.getAttribute("model");
		var model = this.element.ownerDocument.getElementById(id);
		model.recalculate();
	}

});

var Dispatch = new UX.Class({

	Mixins: [Listener],

	toString: function() {
		return 'xf:dispatch';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(evt) {
		var targetID = UX.getPropertyValue(this, "targetid") || UX.getPropertyValue(this, "target");

		if(!targetID) return;

		target = FormsProcessor.getElementById(targetID, this.element);
		if(!target) return;
		var name = UX.getPropertyValue(this, "name");
		if(!name) return;
		var oEvt = this.element.ownerDocument.createEvent("Events");

		oEvt.initEvent(name, UX.JsBooleanFromXsdBoolean(UX.getPropertyValue(this, "bubbles"), "false"), false);

		oEvt._actionDepth = evt._actionDepth;

		var delay_time = UX.getPropertyValue(this, "delay");
		if (!delay_time || isNaN(parseInt(delay_time, 10)) || delay_time < 0) {
			delay_time = 0;
		}
		setTimeout(function() {
			FormsProcessor.dispatchEvent(target, oEvt);
		},
		delay_time);

		if (evt._actionDepth !== oEvt._actionDepth) {
			throw "Unexpected Discord between action depths.";
		}
	}

});

var Send = new UX.Class({

	Mixins: [Listener],

	toString: function() {
		return 'xf:send';
	},

	intialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(evt) {
		var id, submission, oEvt;
		id = this.element.getAttribute("submission");
		if(!id) {
			throw "A submission ID is required.";
		}
		evt.target.ownerDocument.logger.log("Sending to '" + id + "'", "submission");

		submission = document.getElementById(id);
		if(!submission) {
			throw "There is no submission element with an ID of '" + id + "'";
		}
		oEvt = this.element.ownerDocument.createEvent("Events");
		oEvt.initEvent("xforms-submit", false, false, null, null);
		/* Copy through the current event depth.*/
		oEvt._actionDepth = evt._actionDepth;
		spawn(function() {
			FormsProcessor.dispatchEvent(submission, oEvt);
		});

		/*
		* I'm assuming that there is no point in copying the
		* 'new' depth, since it should be the same as the
		* old one...but that might not be true, hence the
		* debugger statement (now changed to throw).
		*/
		if (evt._actionDepth !== oEvt._actionDepth) {
			throw "Unexpected Discord between action depths.";
		}

	}

});

var Load = new UX.Class({

	Mixins: [Listener, Context, OptionalBinding],

	toString: function() {
		return 'xf:load';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var boundNode = this.element.getBoundNode(1);
		var resource = UX.getPropertyValue(this.element, "resource");

		if ((boundNode.node && resource) || (!boundNode.node && !resource)) {
			return;
		}

		if (boundNode.node) {
			var textNode = getFirstTextNode(boundNode.node);
			if (textNode) {
				resource = textNode.nodeValue;
			} else {
				resource = boundNode.node.nodeValue;
			}
		}

		this.element.setAttribute("xlink:href", resource);

		if (!this.Actuate) {
			this.element.setAttribute("xlink:show", this.element.getAttribute("show") || "replace");

			var target = this.element.getAttribute("target");

			if (!target) {
				var id = event.target.id;
				if (id) {
					this.element.setAttribute("target", id);
				}
			}
			UX.extend(this, new XLinkElement(this.element));
			this.handleEvent = DeferToConditionalInvocationProcessor;
		}

		if (this.Actuate) {
			this.Actuate();
		}
	}

});

var Message = new UX.Class({

	Mixins: [Listener, MIPHandler, Context, SrcMixin, Control, OptionalBinding, LoadExternalMixin],

	toString: function() {
		return 'xf:message';
	},

	initialize: function(element) {
		this.element = element;
		this.element.addEventListener("ub-activate", this, false);
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		FormsProcessor.refreshDescendents(this.element.childNodes);

		var level = this.element.getAttribute("level");
		switch (level) {
			case "modeless":
				document.notify.messageWindow(this, false);
				break;
			case "ephemeral":
				document.notify.ephemeral(this.element, event.activate);
				break;
			case "modal":
				document.notify.messageWindow(this, true);
				break;
			default:
				document.notify.messageWindow(this, true);
		}
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global DeferToConditionalInvocationProcessor, ActionExecutor*/

var XFAction = new UX.Class({

	toString: function() {
		return 'xf:action';
	},

	Mixins: [Listener, Context],

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var children = this.element.childNodes;

		for (var i = 0, l = children.length; i < l; i++) {
			var behaviour = DECORATOR.getBehaviour(children[i]);
			if (behaviour && behaviour.handleEvent) {
				ActionExecutor.invokeListener(behaviour, event);
			}
		}
		return;
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function DirtyState() {
	this.m_states = {
		value: false,
		valid: false,
		enabled: false,
		required: false,
		readonly: false
	};
}

DirtyState.prototype.isDirty = function(aspect) {
	var prop, retval = false;
	if (typeof aspect === "undefined") {
		for (prop in this.m_states) {
			if (this.m_states[prop]) {
				retval = true;
				break;
			}
		}
	} else {
		retval = this.m_states[aspect];
		if (typeof retval === "undefined") {
			throw "DirtyState::isDirty, E_INVALIDARG";
		}
	}
	return retval;
};

DirtyState.prototype.setDirty = function(aspect) {
	if (typeof this.m_states[aspect] === "undefined") {
		throw "DirtyState::setDirty, E_INVALIDARG";
	}
	this.m_states[aspect] = true;
};

DirtyState.prototype.setClean = function(aspect) {
	var prop;
	if (typeof aspect === "undefined") {
		for (prop in this.m_states) {
			this.m_states[prop] = false;
		}
	} else {
		this.m_states[aspect] = false;
	}
};
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function setInitialState(self) {
	if (self.initialStateSeted) return;

	self.m_MIPSCurrentlyShowing.readonly = false;
	self.m_MIPSCurrentlyShowing.required = false;
	self.m_MIPSCurrentlyShowing.valid = true;
	self.m_MIPSCurrentlyShowing.enabled = true;
	var element = self.element;
	if (!(element.className || UX.isXHTML)) {
		element.className = "read-write enabled valid optional";
	} else {
		UX.addClassNames(element, ["read-write", "enabled", "valid", "optional"]);
	}
	self.initialStateSeted = true;
}
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var NavigableControl = new UX.Class({

	Mixins: [MIPHandler, MIPEventTarget, Context, Control],

	toString: function() {
		return 'xf:navigable-control';
	},

	initialize: function(element) {
		this.element = element;
	},

	isNavigableControl: true,

	onContentReady: function() {
		this.setNavIndex();
		this.setAccessKey();

		FormsProcessor.addToNavigationList(this);
	},

	setNavIndex: function() {
		this.navIndex = parseInt(this.element.getAttribute('navindex') || '0', 10);
	},

	setAccessKey: function() {
		this.accessKey = this.element.getAttribute('accesskey');
	},

	onKeyDown: function(event) {
		if (event.key == 'tab') {
			if (event.shift) {
				this.navigateToPreviousControl();
			} else {
				this.navigateToNextControl();
			}
			event.stop();
			return false;
		}

		return true;
	},

	navigateToNextControl: function() {
		UX.dispatchEvent(this.element, 'xforms-next', false, true, false);

		FormsProcessor.navigateToNextControl(this);
	},

	navigateToPreviousControl: function() {
		UX.dispatchEvent(this.element, 'xforms-previous', false, true, false);

		FormsProcessor.navigateToPreviousControl(this);
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var PeValue = new UX.Class({

	toString: function() {
		return 'xf:pe-value';
	},

	initialize: function(element) {
		this.element = element;
	},

	giveFocus: function() {
		if (this.m_value) {
			this.m_value.focus();
		}
	}

});
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XFormsBooleanValue = new UX.Class({

	Mixins: [PeValue],

	toString: function() {
		return 'xf:boolean-value';
	},

	initialize: function(element) {
		this.element = element;
		this.currValue = 'false';
		this.m_bFirstSetValue = true;
	},

	onDocumentReady : function() {
		if (this.element.ownerDocument.media == "print") return;
		var input = document.createElement("input");
		var eventName = "click";
		input.type = "checkbox";

		UX.addStyle(input, "backgroundColor", "transparent");
		UX.addStyle(input, "padding", "0");
		UX.addStyle(input, "margin", "0");
		UX.addClassName(input, "ux-input-checkbox");
		UX.addClassName(this.element, "ux-boolean-value");

		var self = this;
		if (typeof input.addEventListener === 'function') {
			input.addEventListener(eventName, function(e) {
				self.booleanValueChanged(e);
			},
			false);
		} else {
			input.attachEvent("on" + eventName, function(e) {
				self.booleanValueChanged(e);
			});
		}
		this.element.appendChild(input);
		this.m_value = input;
	},

	setValue : function(sValue) {
		var bRet = false;
		if (this.m_value.value != sValue) {
			this.m_value.value = sValue;
			this.currValue = sValue;
			if (sValue === 'true' || sValue === '1') {
				this.m_value.checked = 'checked';
			} else {
				this.m_value.checked = '';
			}
			bRet = true;
		} else if (this.m_bFirstSetValue) {
			bRet = true;
			this.m_bFirstSetValue = false;
		}
		return bRet;
	},

	isTypeAllowed : function(sType) {
		var arrSegments, prefix, localPart, namespace;
		arrSegments = sType.split(":");
		prefix = arrSegments.length === 2 ? arrSegments[0] : "";
		localPart = arrSegments.length === 2 ? arrSegments[1] : "";
		namespace = NamespaceManager.getNamespaceURIForPrefix(prefix);

		return ((namespace === "http://www.w3.org/2001/XMLSchema" || namespace === "http://www.w3.org/2002/xforms") && localPart === "boolean" && !DECORATOR.getBehaviour(this.element.parentNode).isBoundToComplexContent());
	},

	booleanValueChanged: function(evt) {
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		if (oEvt.initMutationEvent === undefined) {
			oEvt.initMutationEvent = oEvt.initEvent;
		}
		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currValue, this.m_value.checked ? 'true' : 'false', null, null);
		var self = this;
		spawn(function() {
			FormsProcessor.dispatchEvent(self.element, oEvt);
		});
		evt.cancelBubble = true;
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XFormsInputValue = new UX.Class({

	Mixins: [PeValue],

	toString: function() {
		return 'xf:input-value';
	},

	initialize: function(element) {
		this.element = element;
		this.currValue = "";
		this.m_bFirstSetValue = true;
	},

	getOwnerNodeName: function() {
		return NamespaceManager.getLowerCaseLocalName(this.element.parentNode);
	},

	onDocumentReady: function() {
		if (this.element.ownerDocument.media == "print") return;
		var name = this.getOwnerNodeName();
		var elementType = (name == "textarea") ? "textarea" : "input";
		var input = document.createElement(elementType);
		var eventName = (this.element.parentNode.getAttribute("incremental") === "true") ? "keyup" : "change";

		UX.addStyle(input, "backgroundColor", "transparent");
		UX.addStyle(input, "padding", "0");
		UX.addStyle(input, "margin", "0");
		if (name !== "textarea") {
			UX.addStyle(input, "border", "0");
		}

		var self = this;
		if (input.addEventListener) {
			input.addEventListener(eventName, function(event) {
				self.valueChanged(event);
			},
			false);
		} else {
			input.attachEvent("on" + eventName, function(event) {
				self.valueChanged(event);
			});
		}

		if (name == "secret") {
			input.type = "password";
		} else if (name !== "textarea") {
			input.setAttribute("type", "text");
		}

		this.element.appendChild(input);

		/*
		* [ISSUE] Stick with other method of always
		* 'locating' things just when we need them?
		*/
		this.m_value = input;
	},

	setValue: function(sValue) {
		var bRet = false;
		this.currValue = sValue;
		if (this.m_value.value != sValue) {
			this.m_value.value = sValue;
			bRet = true;
		} else if (this.m_bFirstSetValue) {
			bRet = true;
			this.m_bFirstSetValue = false;
		}
		return bRet;
	},

	isTypeAllowed: function(sType) {
		var arrSegments, prefix, localPart, namespace;

		arrSegments = sType.split(":");
		prefix = arrSegments.length === 2 ? arrSegments[0] : "";
		localPart = arrSegments.length === 2 ? arrSegments[1] : "";
		namespace = NamespaceManager.getNamespaceURIForPrefix(prefix);

		return ((namespace === "http://www.w3.org/2001/XMLSchema" || namespace === "http://www.w3.org/2002/xforms") && localPart !== "base64Binary" && localPart !== "hexBinary" && !DECORATOR.getBehaviour(this.element.parentNode).isBoundToComplexContent());
	},

	valueChanged: function(event) {
		/*
		 * [ISSUE] Not really suitable to use mutation events.
		 */
		var value = UX.isIE ? event.srcElement.value : event.target.value;
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currValue, value, null, null);

		var self = this;
		FormsProcessor.dispatchEvent(self.element, oEvt);
		/*
		 * Cancel bubbling but don't cancel the event itself
		 * otherwise we never get the value actually changed.
		 */
		event.cancelBubble = true;
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XFormsOutputValue = new UX.Class({

	toString: function() {
		return 'xf:output-value';
	},

	initialize: function(element) {
		this.element = element;
		if (DECORATOR.getBehaviour(this.element.parentNode).m_sValue) {
			this.setValue(DECORATOR.getBehaviour(this.element.parentNode).m_sValue);
		}
	},

	setValue: function(value) {
		var renderAsString = true;
		var localName = NamespaceManager.getLowerCaseLocalName(this.element.parentNode);

		if (localName === "mediatype") {
			if ((this.element.parentNode.parentNode) && (NamespaceManager.getLowerCaseLocalName(this.element.parentNode.parentNode) === "output")) {
				this.element.parentNode.parentNode.setAttribute("mediatype", value);
			}
		} else if (localName === "output") {
			renderAsString = this.setValueForOutputRendering(value);
		}

		var textValue = renderAsString ? value : '';
		if (typeof this.element.textContent === 'string') {
			this.element.textContent = textValue;
		} else {
			this.element.innerText = textValue;
		}

		return true;
	},

	getValue: function() {
		var sRet = this.element.textContent || this.element.innerText;
		var composedLabels = null;
		var localName = NamespaceManager.getLowerCaseLocalName(this.element.parentNode);

		if (localName === "label" && !(/[^\t\n\r ]/.test(sRet))) {
			composedLabels = NamespaceManager.getElementsByTagNameNS(this.element.parentNode, "http://www.w3.org/2002/xforms", "output");
			if (composedLabels && composedLabels.length > 0) {
				return composedLabels[0].m_value.getValue();
			}
		}

		return sRet;
	},

	createMediatypeElement: function(sElement) {
		var oRendertype = document.createElement(sElement);
		oRendertype.setAttribute("width", "auto");
		oRendertype.setAttribute("height", "auto");
		this.element.parentNode.appendChild(oRendertype);
		return oRendertype;
	},

	setContent: function(value) {
		var oRendertype = this.element.parentNode["m_mediatype"];
		if (oRendertype && (NamespaceManager.getLowerCaseLocalName(oRendertype) !== "div")) {
			this.element.parentNode.removeChild(oRendertype);
			oRendertype = null;
		}

		if (!oRendertype) {
			oRendertype = this.createMediatypeElement("div");
		}

		oRendertype.innerHTML = value;

		return oRendertype;
	},

	setImage: function(value) {
		var oRendertype = this.element.parentNode["m_mediatype"];
		if (DECORATOR.getBehaviour(this.element.parentNode).type) {
			if (oRendertype && (NamespaceManager.getLowerCaseLocalName(oRendertype) !== "img")) {
				this.element.parentNode.removeChild(oRendertype);
				oRendertype = null;
			}

			if (!oRendertype) {
				oRendertype = this.createMediatypeElement("img");
			}

			if (DECORATOR.getBehaviour(this.element.parentNode).type.indexOf("base64Binary") > 0) {
				oRendertype.setAttribute("src", "data:image/*;base64," + value);
			} else {
				oRendertype.setAttribute("src", value);
			}
		}

		return oRendertype;
	},

	setCalendar: function(value) {
		var oRendertype = this.element.parentNode["m_mediatype"];

		if (oRendertype && (NamespaceManager.getLowerCaseLocalName(oRendertype) !== "div")) {
			this.element.parentNode.removeChild(oRendertype);
			oRendertype = null;
		}

		if (!oRendertype) {
			oRendertype = this.createMediatypeElement("div");
			if (oRendertype) {
				oRendertype.setAttribute("id", "ux-calendar-bg" + UX.calendarcount);
				UX.addClassName(oRendertype, "ux-calendar-bg");
				this.calendar = new OutputValueCalendar(UX.calendarcount);
				UX.calendarcount++;
			}
		}

		if (this.calendar) {
			this.calendar.setValue(value);
			this.calendar.render();
		}

		return oRendertype;
	},

	setValueForOutputRendering: function(value) {
		var renderAsString = true;
		var mediatypeAttr = this.element.parentNode.getAttribute("mediatype");
		var appearance = this.element.parentNode.getAttribute("appearance");
		var oRendertype = null;

		try {
			if (mediatypeAttr) {
				if (mediatypeAttr.indexOf("image") === 0) {
					oRendertype = this.setImage(value);
				} else if ((mediatypeAttr === "application/xhtml+xml") || (mediatypeAttr === "text/html")) {
					oRendertype = this.setContent(value);
				} else {
					throw "Unrecognised media-type";
				}
			} else if ((appearance === "full") && (DECORATOR.getBehaviour(this.element.parentNode).type) && (DECORATOR.getBehaviour(this.element.parentNode).type.indexOf(":date") > 0)) {
				oRendertype = this.setCalendar(value);
			}

			if (oRendertype) {
				this.element.parentNode["m_mediatype"] = oRendertype;
				renderAsString = false;
			}
		} catch(e) {
			UX.dispatchEvent(this.element.parentNode, "xforms-output-error", false, true, true);
		}

		if (renderAsString) {
			oRendertype = this.element.parentNode["m_mediatype"];
			this.element.parentNode["m_mediatype"] = null;
			if (oRendertype) {
				this.element.parentNode.removeChild(oRendertype);
			}
		}
		return renderAsString;
	},

	isTypeAllowed: function(sType) {
		return (!DECORATOR.getBehaviour(this.element.parentNode).isBoundToComplexContent());
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global spawn, FormsProcessor, YAHOO*/



UX.rangecount = 0;

var RangeValue = new UX.Class({

	toString: function() {
		return 'xf:range-value';
	},

	initialize: function(element) {
		this.element = element;
		this.currValue = "";
		this.m_bFirstSetValue = true;
		var rangeElement = element.parentNode;
		this.start = Number(rangeElement.getAttribute("start")) || 0;
		this.end = Number(rangeElement.getAttribute("end")) || (this.start + 10);
		this.step = Number(rangeElement.getAttribute("step")) || 1;
	},

	onDocumentReady: function() {
		if (this.element.ownerDocument.media !== "print") {
			this.element.innerHTML = "<div id='slider-bg" + UX.rangecount + "' class='slider-bg'><div class='slider-thumb' id='slider-thumb" + UX.rangecount + "'> </div></div>";
			this.tickCount = this.end - this.start;
			this.trackWidth = 200;
			this.tickWidthInPixels = this.trackWidth / this.tickCount;
			this.m_value = YAHOO.widget.Slider.getHorizSlider("slider-bg" + UX.rangecount, "slider-thumb" + UX.rangecount, 0, this.trackWidth);
			UX.rangecount++;

			var self = this;
			this.m_value.subscribe((this.element.parentNode.getAttribute("incremental") === "true") ? "change" : "slideEnd", function() {
				self.rangeValueChanged(self.quantizeValue(self.dataValueFromSliderPosition(self.m_value.getValue())));
			});
		}
	},

	setValue: function(sValue) {
		var bRet = false,
			nValue = Number(sValue),
			valueAsSliderPosition = this.sliderPositionFromDataValue(nValue);
		if (this.m_value.getValue() !== valueAsSliderPosition) {
			this.m_value.setValue(valueAsSliderPosition, true, true, true);
			this.currValue = sValue;
			bRet = true;
		} else if (this.m_bFirstSetValue) {
			bRet = true;
			this.m_bFirstSetValue = false;
		}

		if (nValue > this.end || nValue < this.start || this.quantizeValue(nValue) !== nValue) {
			this.element.parentNode.onOutOfRange();
		} else {
			this.element.parentNode.onInRange();
		}
		return bRet;
	},

	getStepGranularity: function() {
		var retVal, sVal;
		sVal = String(this.step);
		sVal = sVal.slice(sVal.indexOf("."));
		if (sVal.charAt(0) === ".") {
			retVal = sVal.length - 1;
		} else {
			retVal = 0;
		}
		return retVal;
	},

	quantizeValue: function(value) {

		var quantizedValue, mod, offsetValue, stepGranularityModifier;
		stepGranularityModifier = Math.pow(10, this.getStepGranularity());

		value = Math.round(value * stepGranularityModifier) / stepGranularityModifier;

		if (value === this.end || quantizedValue === this.start) {
			quantizedValue = value;
		} else {

			offsetValue = value - this.start;
			mod = offsetValue % this.step;

			quantizedValue = value - mod;
			if (mod > (this.step / 2)) {
				quantizedValue += this.step;
			}
			quantizedValue = Math.round(quantizedValue * stepGranularityModifier) / stepGranularityModifier;
		}
		return quantizedValue;

	},

	dataValueFromSliderPosition: function(sliderPos) {
		return this.start + (sliderPos / this.tickWidthInPixels);
	},

	sliderPositionFromDataValue: function(value) {
		return (value - this.start) * this.tickWidthInPixels;
	},

	isTypeAllowed: function(sType) {
		var arrSegments, prefix, localPart, namespace;

		arrSegments = sType.split(":");
		prefix = arrSegments.length === 2 ? arrSegments[0] : "";
		localPart = arrSegments.length === 2 ? arrSegments[1] : "";
		namespace = NamespaceManager.getNamespaceURIForPrefix(prefix);

		return ((namespace === "http://www.w3.org/2001/XMLSchema" || namespace === "http://www.w3.org/2002/xforms") && (localPart === "dayTimeDuration" || localPart === "yearMonthDuration" || localPart === "date" || localPart === "time" || localPart === "dateTime" || localPart === "gYearMonth" || localPart === "gYear" || localPart === "gMonthDay" || localPart === "gDay" || localPart === "gMonth" || localPart === "float" || localPart === "double" || localPart === "decimal"));
	},


	rangeValueChanged: function(sNewValue) {
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		if (oEvt.initMutationEvent === undefined) {
			oEvt.initMutationEvent = oEvt.initEvent;
		}
		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currValue, sNewValue, null, null);
		var self = this;
		spawn(function() {
			FormsProcessor.dispatchEvent(self.element, oEvt);
		});
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Container = new UX.Class({

	toString: function() {
		return 'xf:container';
	},

	initialize: function(element) {
		this.element = element;
		this.isWired = false;
	},

	onContentReady: function() {
		FormsProcessor.listenForXFormsFocus(this, this);
	},

	giveFocus: function() {
		if (!this.m_proxy || !this.m_proxy.enabled || this.m_proxy.enabled.getValue()) {
			return UX.focusFirstEligibleChild(this.element.childNodes);
		}
		return false;
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Group = new UX.Class({

	Mixins: [MIPHandler, MIPEventTarget, Context, Container, OptionalIfUnspecifiedBinding],

	toString: function() {
		return 'xf:group';
	},

	initialize: function(element) {
		this.element = element;
		this.m_MIPSCurrentlyShowing = {};
	},

	isGroup: true,

	setValue: function(sValue) {
		return;
	},

	setType: function(sType) {
		return;
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global DECORATOR, NamespaceManager, UX, document, window, getModelFor*/

var Repeat = new UX.Class({

	Mixins: [Context],

	toString: function() {
		return 'xf:repeat';
	},

	initialize: function(element) {
		this.element = element;
		this.bindingContainerName = "group";
		var sStartIndex = element.getAttribute("startindex");
		this.m_nIndex = (sStartIndex === null || isNaN(sStartIndex)) ? 1 : this.m_nIndex = Number(sStartIndex);
		if (!UX.hasDecorationSupport) {
			this.storeTemplate();
		}
		this.m_CurrentIterationCount = 0;
		this.m_offset = 0;
		this.m_iterationNodesetLength = 0;
	},

	onContentReady: function() {
		FormsProcessor.listenForXFormsFocus(this, this);
	},

	giveFocus: function() {
		var indexNode = this.getCurrentIteration();
		if (typeof DECORATOR.getBehaviour(indexNode).giveFocus === "function") {
			return DECORATOR.getBehaviour(indexNode).giveFocus();
		}
		return true;
	},

	onDocumentReady: function() {
		if (UX.hasDecorationSupport) {
			this.storeTemplate();
		}
		this.addControlToModel();
		this.element.addEventListener("DOMActivate", {
			control: this,
			handleEvent: function(evt) {
				this.control.Activate(evt.target);
			}
		},
		true);
	},

	Activate: function(o) {
		var coll = this.element.childNodes;
		for (var i = 0, l = coll.length; i < l; i++) {
			if (coll[i].contains(o)) {
				this.m_nIndex = i + 1;
				break;
			}
		}
	},

	storeTemplate: function() {

		if (!this.sTemplate) {
			this.sTemplate = this.element.cloneNode(true);
		}
		while (this.element.childNodes.length) {
			this.element.removeChild(this.element.firstChild);
		}
		UX.addClassName(this.element, "repeat-ready");
	},

	addControlToModel: function() {
		if (!this.m_bAddedToModel) {
			var oModel = getModelFor(this);
			if (oModel) {
				oModel.addControl(this);
			}
		}
	},

	refresh: function() {

	},

	getRequestedIterationCount: function() {
		var sNumber = this.element.getAttribute("number"),
			desiredIterationCount = 0;

		if (sNumber === null || isNaN(sNumber)) {
			desiredIterationCount = this.m_iterationNodesetLength;
		} else {
			desiredIterationCount = Number(sNumber);
		}
		return desiredIterationCount;
	},

	putIterations: function(desiredIterationCount) {
		var iterations = this.element.childNodes;
		var i = 0;
		while (i < iterations.length) {
			var node = iterations[i];
			if (DECORATOR.getBehaviour(node).m_proxy && !DECORATOR.getBehaviour(node).m_proxy.m_oNode) {
				this.element.removeChild(node);
			} else {
				i++;
			}
		}
		this.m_CurrentIterationCount = iterations.length;

		var formerOffset = this.m_offset;

		if (this.m_nIndex < this.m_offset) {
			this.m_offset = 1 + this.m_nIndex - desiredIterationCount;
		} else if (this.m_nIndex > (desiredIterationCount + this.m_offset)) {
			this.m_offset = this.m_nIndex - 1;
		}

		for (i = 0; i < this.m_CurrentIterationCount; i++) {
			node = iterations[i];
			if (node.getAttribute('bindingcontainer')) {
				var ordinal = parseInt(node.getAttribute("ordinal"), 10);
				var newOrdinal = 1 + i + this.m_offset;
				if (ordinal !== newOrdinal) {
					node.setAttribute("ordinal", newOrdinal);
				}
			}
			DECORATOR.getBehaviour(node).m_proxy = null;
		}

		var prefix = NamespaceManager.getOutputPrefixesFromURI("http://www.w3.org/2002/xforms")[0] + ":";

		var suspension = false;
		if (desiredIterationCount > this.m_CurrentIterationCount) {
			suspension = true;
			DECORATOR.suspend();
			this.m_model.stopXFormsReady();
		}
		var uid = this.element.ux_uid;
		if(!UX.isXHTML) {
			var html = [];
			var tpl = this.sTemplate.cloneNode(true).innerHTML;
			while (desiredIterationCount > this.m_CurrentIterationCount) {
				html.push('<' + prefix + this.bindingContainerName + ' ref="." ordinal="' + (this.m_offset + this.m_CurrentIterationCount + 1) + '" class="repeat-iteration" bindingcontainer="true" outerscope="' + uid + '">');
				html.push(tpl);
				html.push('</' + prefix + this.bindingContainerName + '>');
				this.m_CurrentIterationCount++;
			}
			if(html.length) this.element.insertAdjacentHTML('beforeEnd', html.join(''));
		} else {
			while (desiredIterationCount > this.m_CurrentIterationCount) {
				var item = document.createElementNS("http://www.w3.org/2002/xforms", prefix + this.bindingContainerName);
				item.setAttribute("ref", ".");
				item.setAttribute("ordinal", this.m_offset + this.m_CurrentIterationCount + 1);
				item.setAttribute("bindingcontainer", "true");
				UX.addClassName(item, "repeat-iteration");
				item.setAttribute("outerscope", uid);
				var templateClone = this.sTemplate.cloneNode(true);
				while (templateClone.hasChildNodes()) {
					item.appendChild(templateClone.firstChild);
				}
				this.element.appendChild(item);
				window.status = "";
				this.m_CurrentIterationCount++;
			}
		}

		var model = this.m_model;
		if (suspension) {
			DECORATOR.resume();
			model.resumeXFormsReady();
		}
	},

	/**
	 function: normaliseIndex
	 returns: The result of constraining val within the range of 1 to the length of the iteration nodeset.
	 */

	normaliseIndex: function(val) {
		return Math.max(Math.min(val, this.m_iterationNodesetLength), !this.m_iterationNodesetLength ? 0 : 1);
	},

	rewire: function() {
		var arrNodes = null,
			sExpr, sBind = this.element.getAttribute("bind"),
			oBind, oContext, r, newIndex;

		if (sBind) {
			oBind = FormsProcessor.getBindObject(sBind, this.element);
			if (oBind) {
				arrNodes = oBind.boundNodeSet;
				this.m_model = oBind.ownerModel;
			}
		} else {
			sExpr = this.element.getAttribute("nodeset");

			if (sExpr) {
				document.logger.log("Rewiring: " + this.element.tagName + ":" + this.element.uniqueID + ":" + sExpr, "info");

				oContext = DECORATOR.getBehaviour(this.element).getEvaluationContext();
				this.m_model = oContext.model;
				r = this.m_model.EvaluateXPath(sExpr, oContext);

				arrNodes = r.value;
			} else {
				document.logger.log("Element: " + this.element.tagName + ":" + this.element.uniqueID + " lacks binding attributes.", "warn");
			}
		}

		if (arrNodes) {
			this.m_iterationNodesetLength = arrNodes.length;
			newIndex = this.m_model.indexOfNewNode(arrNodes);
			if (newIndex !== -1) {
				this.m_nIndex = newIndex + 1;
			}
			this.m_nIndex = this.normaliseIndex(this.m_nIndex);
			this.putIterations(this.getRequestedIterationCount());

			if (!UX.hasDecorationSupport) {
				DECORATOR.applyRules(this.element);
			}
		}

		return false;
	},

	getIndex: function() {
		return this.m_nIndex;
	},

	setIndex: function(newIndex) {
		var ix = this.normaliseIndex(newIndex);
		if (ix > newIndex) {
			UX.dispatchEvent(this.element, "xforms-scroll-first", true, false, true);
		} else if (ix < newIndex) {
			UX.dispatchEvent(this.element, "xforms-scroll-last", true, false, true);
		}
		if (ix !== this.m_nIndex) {
			this.m_nIndex = ix;
			this.m_model.flagRebuild();
		}
	},

	getCurrentIteration: function() {
		return this.element.childNodes[this.getIndex() - this.m_offset - 1];
	},

	getPublicElementById: function(id) {
		return FormsProcessor.getElementByIdWithAncestor(id, this.getCurrentIteration());
	},

	exposes: function(element) {
		return this.getCurrentIteration().contains(element);
	}

});
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Case = new UX.Class({

	initialize: function(element) {
		this.element = element;
	},

	deselect: function() {
		this.element.sDisplay = UX.getStyle(this.element, "display");
		UX.addStyle(this.element, "display", "none");
		return;
	},

	select: function() {
		if (typeof this.element.sDisplay === "undefined") {
			this.element.sDisplay = UX.getStyle(this.element, "display");
		} else {
			UX.addStyle(this.element, "display", this.element.sDisplay);
		}
		return;
	}
});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XFormsCase = new UX.Class({

	Extend: [Context, Container],

	toString: function() {
		return 'xf:case';
	},

	initialize: function(element) {
		this.element = element;
		this._case = new Case(element);
	},

	isCase: true,

	getSwitch: function() {
		return this._case.element.parentNode;
	},

	deselect: function() {
		var element = this._case.element;
		this._case.deselect();
		spawn(function() {
			UX.dispatchEvent(element, "xforms-deselect", true, false, true);
			FormsProcessor.refreshDescendentsForRelevance(element.childNodes);
		});
	},

	select: function() {
		var element = this._case.element;
		this._case.select();
		spawn(function() {
			UX.dispatchEvent(element, "xforms-select", true, false, true);
			FormsProcessor.refreshDescendentsForRelevance(element.childNodes);
		});
	},

	toggle: function() {
		var oSwitch = DECORATOR.getBehaviour(this.getSwitch());
		if (oSwitch && UX.id(this.element)) {
			oSwitch.toggle(UX.id(this.element));
		}
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*members _case, childNodes, deselect, element, getAttribute,
    getElementById, length, nodeType, oCurrentCase, onDocumentReady,
    ownerDocument, prototype, select, toggle, toggleDefault
*/

/**
 class: Switch
 corresponds to the xforms switch element
 */
var Switch = new UX.Class({

	Mixins: [MIPHandler, MIPEventTarget, Context, OptionalBinding],

	toString: function() {
		return 'xf:switch';
	},

	initialize: function(element) {
		this.element = element;
		this.oCurrentCase = null;
	},

	isSwitch: true,

	onContentReady: function() {
		FormsProcessor.listenForXFormsFocus(this, this);
	},

	giveFocus: function() {
		return this.oCurrentCase.giveFocus();
	},

	/**
	 function: toggleDefault
	 Selects the default case according to the definition here: http://www.w3.org/TR/xforms11/#ui-case

	 Called by the xforms processor on document ready.
	 */
	toggleDefault: function() {
		var caseColl = this.element.childNodes;
		var caseInHand = null;
		var candidateDefaultCase = null;
		var bCaseSelectedBySelectedAttribute = false;

		for (var i = 0, l = caseColl.length; i < l; i++) {
			var element = caseColl[i];
			var Case = DECORATOR.getBehaviour(caseColl[i]);
			if (Case && Case.select && Case.deselect) {
				if (!bCaseSelectedBySelectedAttribute && element.getAttribute("selected") === "true") {
					if (candidateDefaultCase !== null) {
						candidateDefaultCase.deselect();
					}
					candidateDefaultCase = Case;
					bCaseSelectedBySelectedAttribute = true;
				} else if (candidateDefaultCase === null) {
					candidateDefaultCase = Case;
				} else {
					Case.deselect();
				}
			}
		}
		if (candidateDefaultCase !== null) {
			candidateDefaultCase.select();
			this.oCurrentCase = candidateDefaultCase;
		}
	},

	/**
	 function: toggle
	 Toggles the child case with the given id.

	 sCaseID - string corresponding to a child case
	 */
	toggle: function(sCaseID) {
		var i, oCase;
		for (i = 0; i < this.element.childNodes.length; ++i) {
			if (UX.id(this.element.childNodes[i]) === sCaseID) {
				oCase = DECORATOR.getBehaviour(this.element.childNodes[i]);
				break;
			}
		}

		if (oCase) {
			if (this.oCurrentCase) {
				this.oCurrentCase.deselect();
			}
			this.oCurrentCase = oCase;
			oCase.select();
		}
	},

	getSelectedCase: function() {
		return this.oCurrentCase;
	},

	onDocumentReady: function(){
		this.toggleDefault();
	}

});

var XLabel = new UX.Class({

	Mixins: [MIPHandler, Context, SrcMixin, Control, OptionalBinding, LoadExternalMixin],

	toString: function() {
		return 'xf:label';
	}

});

var XOutput = new UX.Class({

	Mixins: [NavigableControl, OptionalIfUnspecifiedBinding],

	toString: function() {
		return 'xf:output';
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Multimap = new UX.Class({
	/**
	 Adds an item to the map with the given key
	 @param theItem The item to store
	 @param key The key under which to store it.
	 */
	addItem: function(theItem, key) {

		if (!this.items) {
			this.items = {};
		}
		key = key || theItem.getValue();
		if (this.items[key]) {
			var o = this.items[key];
			if (! (o instanceof Array)) {
				this.items[key] = [];
				this.items[key].push(o);
			}
			this.items[key].push(theItem);
		} else {
			this.items[key] = theItem;
		}

		if (this.onItemAdded) {
			this.onItemAdded(theItem, key);
		}
	},

	/**
	 Removes an item from the map if stored under the given key
	 @param theItem The item to remove
	 @param key The key under which it is stored.
	 @returns true if item was successfully removed, otherwise false.
	 */
	removeItem: function(item, key) {
		var retval = false;
		if (this.items) {
			var thisItem = this.items[key];
			if (thisItem && (thisItem instanceof Array)) {
				var l = thisItem.length;
				for (var i = 0; i < l; ++i) {
					if (thisItem[i] === item) {
						thisItem.splice(i, 1);
						if (l === 2) {
							this.items[key] = thisItem[0];
						}
						retval = true;
						break;
					}
				}
			} else if (this.items[key] === item) {
				retval = true;
				delete this.items[key];
			}

		}
		if (retval && this.onItemRemoved) {
			this.onItemRemoved(item, key);
		}
		return retval;
	},

	/**
	 Retrieves the item stored alongside the given key
	 @param key The key under which to look
	 @param index [optional] If the key corresponds to more than one value, return the one at the given index.  If omitted, 0 is default.
	 @returns The item specified by the given key and index
	 */
	getItem: function(key, index) {
		var theItem = this.items[key];
		if (theItem instanceof Array) {
			var ix = index | 0;
			theItem = theItem[ix];
		}
		return theItem;
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CommonSelect = new UX.Class({

	Mixins: [Multimap],
	/**
	 Updates the map of values to items, to reflect a change in the value of said item
	 */
	itemValueChanged: function(item, oldvalue, newvalue) {
		this.removeItem(item, oldvalue);
		this.addItem(item, newvalue);
	},
	/**
	 Retrieves the label that corresponds to a given value.
	 */
	getSingleDisplayValue: function(sValue) {
		this.currentDisplayValue = sValue;
		var retval = null;
		var theItem = null;
		var i;
		if (this.items) {
			theItem = this.items[sValue];
			if (UX.isArray(theItem)) {
				if (typeof sValue === "object") {
					for (i = 0; i < theItem.length; ++i) {
						if (UX.isEquivalentNode(theItem[i].getValue(), sValue)) {
							theItem = theItem[i];
							break;
						}
					}
				} else {
					theItem = theItem[0];
				}
			}

			if (theItem) {
				retval = theItem.getLabel();
			}
		}
		return retval;
	}

});

/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*globals document, YAHOO, spawn, FormsProcessor */
/*members Dom, addClass, createEvent, dispatchEvent, initEvent,
    isInRange, onInRange, onOutOfRange, removeClass, util
*/

/**
 @constructor
 @class
 Specifies a control that may be requested to  display values that it is incapable of displaying.
 */
var FiniteControl = new UX.Class({

	Mixins: [NavigableControl],

	toString: function() {
		return 'xf:finite';
	},

	initialize: function(element) {
		this.element = element;
		this.m_bInRange = true;
	},

	/**
	 To be called when the appropriate object is incapable of displaying the value given to it.
	 dispatches the out-of-range event and styles the object as out-of-range.
	*/
	onOutOfRange: function() {
		if (!this.m_bInRange) return;
		this.m_bInRange = false;
		var element = this.element;
		if(!element) return;
		UX.addClassName(element, "xforms-out-of-range");
		if (element.dispatchEvent) {
			var oEvt = document.createEvent("Events");
			oEvt.initEvent("xforms-out-of-range", false, true);
			FormsProcessor.dispatchEvent(element, oEvt);
		}
	},

	/**
	 To be called when the appropriate object is capable of displaying the value given to it.
	 dispatches the in-range event and styles the object as in-range.
	 */
	onInRange: function() {
		if(this.m_bInRange) return;
		this.m_bInRange = true;
		var element = this.element;
		if (!element) return;
		UX.removeClassName(element, "xforms-out-of-range");
		if (element.dispatchEvent) {
			var oEvt = document.createEvent("Events");
			oEvt.initEvent("xforms-in-range", false, true);
			FormsProcessor.dispatchEvent(element, oEvt);
		}
	},

	/**
	 Reports whether the object is in range.
	 @returns {Boolean} true if the object is in range, otherwise false.
	 */
	isInRange: function() {
		return this.m_bInRange;
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global document, UX, CommonSelect, spawn, FormsProcessor, NamespaceManager, event, DropBox*/

var XFormsCommonSelect = new UX.Class({

	toString: function() {
		return 'xf:commonselect';
	},

	initialize: function(element) {
		this.element = element;
	},

	giveFocus: function() {
		if (! (this.useDropBox() && this.m_proxy.enabled.getValue()) ) return false;

		if (this.m_value && this.m_value !== document.activeElement && !this.m_value.contains(document.activeElement)) {
			if (typeof DECORATOR.getBehaviour(this.m_value).giveFocus === "function") {
				DECORATOR.getBehaviour(this.m_value).giveFocus();
			} else {
				this.m_value.focus();
			}
		}
		return true;
	},

	isOpen: function() {
		return this.element.getAttribute("selection") === "open";
	},

	refreshDisplayValue: function() {
		if (this.m_value.refreshDisplayValue) {
			this.m_value.refreshDisplayValue();
		}
	},

	containsCopyElements: function() {
		return NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "copy").length > 0;
	}

});

var XFormsCommonSelectValue = new UX.Class({

	initialize: function(element) {
		this.element = element;
		this.currValue = "";
		this.m_bFirstSetValue = true;
	},

	onDocumentReady: function() {
		if (this.element.ownerDocument.media == "print") return;

		var input = document.createElement('input');
		input.style.cssText = "backgroundColor:transparent; padding: 0; margin: 0; border: 0";
		var select = DECORATOR.getBehaviour(this.element.parentNode);
		var self = this;

		UX.Element(input).addEvent("change", function() {
			self.trySetManuallyEnteredValue(input.value);
		}).addEvent("click", function() {
			select.showChoices();
		});

		if (!DECORATOR.getBehaviour(this.element.parentNode).isOpen()) {
			UX.Element(input).addEvent("keypress", function(event) {
				if (event.key != 'tab') event.preventDefault();
			});
		}

		this.element.appendChild(input);
		this.m_value = input;
	},

	giveFocus: function() {
		if (this.m_value) {
			this.m_value.focus();
		} else {
			this.element.focus();
		}
	},

	trySetManuallyEnteredValue: function(value) {
		if (DECORATOR.getBehaviour(this.element.parentNode).isOpen() || DECORATOR.getBehaviour(this.element.parentNode).getDisplayValue(value) !== null) {
			DECORATOR.getBehaviour(this.element.parentNode).onValueSelected(value);
		} else {
			this.setDisplayValue(this.currValue, true);
		}
	},

	setValue: function(value) {
		if (this.m_sValue !== value || DECORATOR.getBehaviour(this.element.parentNode).containsCopyElements()) {
			this.m_sValue = value;
			this.refreshDisplayValue();
			return true;
		}
		return false;
	},

	refreshDisplayValue: function() {
		var displayValue = DECORATOR.getBehaviour(this.element.parentNode).getDisplayValue(this.m_sValue);
		if (displayValue === null && DECORATOR.getBehaviour(this.parentNode).isOpen()) {
			displayValue = this.m_sValue;
		}

		return this.setDisplayValue(displayValue);

	},

	setDisplayValue: function(sDisplayValue, bForceRedisplay) {
		var bRet = false;
		if (sDisplayValue === null) {
			DECORATOR.getBehaviour(this.element.parentNode).onOutOfRange();
			sDisplayValue = "";
		} else {
			DECORATOR.getBehaviour(this.element.parentNode).onInRange();
		}

		if (DECORATOR.getBehaviour(this.element.parentNode).useDropBox()) {
			if (bForceRedisplay || this.currValue !== sDisplayValue) {
				this.m_value.value = sDisplayValue;
				this.currValue = sDisplayValue;
				bRet = true;
			} else if (this.m_bFirstSetValue) {
				bRet = true;
				this.m_bFirstSetValue = false;
			}
		} else {
			bRet = true;
		}
		return bRet;
	}

});

var ElementWithChoices = new UX.Class({

	onDocumentReady: function() {
		this.createChoicesPseudoElement();
	},

	createChoicesPseudoElement: function() {
		if(this.m_choices) return;
		var choices = this.element.ownerDocument.createElement("div");
		UX.Element(choices).addClass("pe-choices");
		for (var i = 0; i < this.element.childNodes.length; i++) {
			var child = this.element.childNodes[i];
			var name = NamespaceManager.getLowerCaseLocalName(child);
			switch (name) {
				case "item":
				case "itemset":
				case "choices":
					choices.appendChild(child);
					--i;
					break;
				default:
			}
		}
		if (this.useDropBox()) {
			this.choicesBox = new DropBox(this.element, DECORATOR.getBehaviour(this.element).m_value, choices);
		} else {
			this.element.appendChild(choices);
		}
		this.m_choices = choices;
	},

	showChoices: function() {
		if (this.choicesBox) {
			this.choicesBox.show();
		}
	},

	hideChoices: function() {
		if (this.choicesBox) {
			this.choicesBox.hide();
		}
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global document, UX, CommonSelect, spawn, FormsProcessor, NamespaceManager, event, DropBox*/

var XFormsSelect = new UX.Class({

	Mixins: [CommonSelect, ElementWithChoices, XFormsCommonSelect, FiniteControl],

	toString: function() {
		return 'xf:select';
	},

	initialize: function(element) {
		this.element = element;
		this.multiselect = true;
		this.element.addEventListener("fp-select", this, false);
		this.element.addEventListener("fp-deselect", this, false);
		this.element.addEventListener("xforms-select", this, false);
		this.element.addEventListener("xforms-deselect", this, false);
		this.element.addEventListener("data-value-changed", this, false);
		this.m_values = [];
	},

	useDropBox: function() {
		return this.element.getAttribute("appearance") === "minimal";
	},

	onValueSelected: function(item) {
		var value = (typeof item === "string") ? item : item.getValue();
		var oEvt;
		if (value && typeof value === "object") {
			clone = value.cloneNode(true);
			item.valueInInstance = this.m_proxy.appendChild(value);
			if (item.valueInInstance) {
				this.m_model.flagRebuild();
				doUpdate();
			}
		} else {
			this.m_values.push(value);
			oEvt = this.element.ownerDocument.createEvent("MutationEvents");
			oEvt.initMutationEvent("control-value-changed", false, true, null, "", this.m_values.join(" "), "", 1);
			FormsProcessor.dispatchEvent(this.m_value, oEvt);
		}
	},

	onValueDeselected: function(item) {
		var oEvt, value = item.getValue();
		if (value && typeof value === "object") {
			if (this.m_proxy.removeChild(value)) {
				this.m_model.flagRebuild();
				doUpdate();
				oEvt = this.element.ownerDocument.createEvent("MutationEvents");
				oEvt.initMutationEvent("data-value-changed", false, true, null, "", "", "", 1);
				FormsProcessor.dispatchEvent(this.element, oEvt);
			}
		} else {
			for (i = 0; i < this.m_values.length; ++i) {
				if (value === this.m_values[i]) {
					this.m_values.splice(i, 1);
					oEvt = this.element.ownerDocument.createEvent("MutationEvents");
					oEvt.initMutationEvent("control-value-changed", false, true, null, "", this.m_values.join(" "), "", 1);
					FormsProcessor.dispatchEvent(this.m_value, oEvt);
					break;
				}
			}
		}
	},

	handleEvent: function(oEvt) {
		switch (oEvt.type) {
			case "fp-select":
				this.onValueSelected(oEvt.target);
				oEvt.stopPropagation();
				break;

			case "fp-deselect":
				this.onValueDeselected(oEvt.target);
				break;
			case "data-value-changed":
				this.m_values = oEvt.newValue.split(" ");
				this.onSelectionChanged(oEvt.newValue);
				oEvt.stopPropagation();
				break;
			case "xforms-select":
			case "xforms-deselect":
				oEvt.stopPropagation();
				break;
		}
	},

	onSelectionChanged: function(s) {
		var oEvt1 = this.element.ownerDocument.createEvent("MutationEvents");
		this.m_undisplayedValues = s.trim().split(" ");
		if (this.element.containsCopyElements()) {
			var children = this.m_proxy.m_oNode.childNodes;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i].nodeType !== DOM_TEXT_NODE) {
					this.m_undisplayedValues.push(children[i]);
				}
			}
		}

		oEvt1.initMutationEvent("selection-changed", false, false, null, "", s, "", 1);
		FormsProcessor.dispatchEvent(this.element, oEvt1);
		if (this.m_undisplayedValues.length) {
			this.onOutOfRange();
		} else {
			this.onInRange();
		}
		return;
	},

	onContentReady: function() {
		var element = this.element;
		var selection = element.getAttribute("selection");
		if (!selection) {
			selection = "closed";
			element.setAttribute("selection", selection);
		}

		var appearance = element.getAttribute("appearance");
		if (!appearance) {
			appearance = (selection === "closed" ? "compact" : "minimal");
			element.setAttribute("appearance", appearance);
		}

		UX.Element(this.element).addClass("selection-" + selection);
		UX.Element(this.element).addClass("appearance-" + appearance);
	},

	getDisplayValue: function(value) {
		var displayValues = [];

		var values = value ? value.trim().split(" ") : [];

		for (var i = 0, l = values; i < l; i++) {
			displayValues.push(this.getSingleDisplayValue(values[i]));
		}

		return displayValues.join(" ");
	}

});

var XFormsSelectValue = XFormsCommonSelectValue;
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global document, UX, CommonSelect, spawn, FormsProcessor, NamespaceManager, event, DropBox*/

var XFormsSelect1 = new UX.Class({

	Mixins: [CommonSelect, ElementWithChoices, XFormsCommonSelect, FiniteControl],

	toString: function() {
		return 'xf:select1';
	},

	initialize: function(element) {
		this.element = element;
		this.currentDisplayValue = "";
		this.element.addEventListener("fp-select", this, false);
		this.element.addEventListener("xforms-select", this, false);
		this.element.addEventListener("xforms-deselect", this, false);
		this.element.addEventListener("xforms-value-changed", this, false);
		this.element.addEventListener("data-value-changed", this, false);
		this.m_currentItem = null;

		var keypressHandler = {
			handleEvent: function(o) {
				switch (o.keyCode) {
				case 38:
					element.selectPreviousItem();
					break;
				case 40:
					element.selectNextItem();
				}
			}
		};

		var wheelHandler = {
			handleEvent: function(o) {
				switch (o.type) {
					case "focus":
						this.trapMouseWheel();
						break;
					case "blur":
						this.untrapMouseWheel();
						break;
					case "mousewheel":
					case "DOMMouseScroll":
						this.handleScroll(o);
				}
			},

			trapMouseWheel: function() {
				if (UX.isFF) {
					document.addEventListener("DOMMouseScroll", this, true);
				} else if (UX.isIE) {
					document.attachEvent("onmousewheel", wheelHandler.handleScroll);
				} else {
					document.addEventListener("mousewheel", this, true);
				}

			},
			untrapMouseWheel: function() {
				if (UX.isFF) {
					document.removeEventListener("DOMMouseScroll", this, true);
				} else if (UX.isIE) {
					document.detachEvent("onmousewheel", wheelHandler.handleScroll);
				} else {
					document.removeEventListener("mousewheel", this, true);
				}
			},

			handleScroll: function(o) {
				if (element.lastChild.style.visibility == "visible") {
					return true;
				}
				var wheelDelta = o.wheelDelta;
				if (typeof wheelDelta === "undefined") {
					wheelDelta = o.detail;
				}

				if (UX.isFF) {
					wheelDelta *= -1;
				}

				var behaviour = DECORATOR.getBehaviour(element);
				if (wheelDelta > 0) {
					behaviour.selectPreviousItem();
				} else {
					behaviour.selectNextItem();
				}

				if (o.preventDefault) {
					o.preventDefault();
				}
				return false;

			}
		};

		if (UX.isIE) {
			this.element.attachEvent("onkeyup", keypressHandler.handleEvent);
			this.element.attachEvent("onfocusin", wheelHandler.trapMouseWheel);
			this.element.attachEvent("onfocusout", wheelHandler.untrapMouseWheel);

		} else {
			this.element.addEventListener("keyup", keypressHandler, false);
			this.element.addEventListener("focus", wheelHandler, true);
			this.element.addEventListener("blur", wheelHandler, true);
		}
	},

	handleEvent: function(oEvt) {
		switch (oEvt.type) {
			case "fp-select":
				this.m_currentItem = DECORATOR.getBehaviour(oEvt.target);
				this.onValueSelected(this.m_currentItem.getValue());
				break;
			case "xforms-select":
			case "xforms-deselect":
				oEvt.stopPropagation();
				break;
			case "xforms-value-changed":
				var self = this;
				spawn(function() {
					self.itemChanged(oEvt);
				});
				break;
			case "data-value-changed":
				this.onSelectionChanged(oEvt.newValue);
				oEvt.stopPropagation();
			break;
		}
	},

	getFirstItem: function() {
		return DECORATOR.getBehaviour(UX.getFirstNodeByName(this.m_choices, "item", "http://www.w3.org/2002/xforms"));
	},

	selectFirstItem: function() {
		var firstItem = this.getFirstItem();
		if (firstItem !== null) {
			firstItem.onUserSelect();
		}
	},

	selectPreviousItem: function() {
		var previousItem;
		if (this.m_currentItem === null) {
			this.selectFirstItem();
		} else {
			previousItem = DECORATOR.getBehaviour(UX.getPreviousNodeByName(this.m_currentItem, "item", "http://www.w3.org/2002/xforms", this.m_choices));
			if (previousItem !== null) {
				previousItem.onUserSelect();
			}
		}
	},

	selectNextItem: function() {
		var nextItem;
		if (this.m_currentItem === null) {
			this.selectFirstItem();
		} else {
			nextItem = DECORATOR.getBehaviour(UX.getNextNodeByName(this.m_currentItem, "item", "http://www.w3.org/2002/xforms", this.m_choices));
			if (nextItem !== null) {
				nextItem.onUserSelect();
			}
		}
	},

	onValueSelected: function(value) {
		this.hideChoices();
		if (this.currentlySelectedNode !== value) {
			if (this.currentlySelectedNode) {
				this.m_proxy.removeChild(this.currentlySelectedNode);
				this.currentlySelectedNode = null;
			}
			if (value && typeof value === "object") {
				var clone = value.cloneNode(true);
				this.currentlySelectedNode = this.m_proxy.appendChild(value);
				if (this.currentlySelectedNode) {
					var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
					oEvt.initMutationEvent("data-value-changed", false, true, null, "", "", "", 1);
					FormsProcessor.dispatchEvent(this.element, oEvt);
					if (this.useDropBox()) {
						this.m_value.refreshDisplayValue();
					}
					this.m_model.flagRebuild();
					doUpdate();
				}
			} else {
				var oEvt1 = document.createEvent("MutationEvents");
				oEvt1.initMutationEvent("control-value-changed", false, true, null, "", value, "", 1);
				FormsProcessor.dispatchEvent(this.m_value, oEvt1);
			}
		}
	},

	itemChanged: function(oEvt) {
		if (oEvt.target !== this.element) {
			var localName = NamespaceManager.getLowerCaseLocalName(oEvt.target);
			if (localName === "value") {
				this.itemValueChanged(oEvt.target.parentNode, oEvt.prevValue, oEvt.newValue);
			}
		}
	},

	onContentReady: function() {
		var appearance = this.element.getAttribute("appearance") || "minimal";
		UX.Element(this.element).addClass("appearance-" + appearance);
	},

	getDisplayValue: function(value) {
		if (this.containsCopyElements()) {
			value = this.m_proxy.m_oNode.firstChild;
			while (value && value.nodeType === DOM_TEXT_NODE) {
				value = value.nextSibling;
			}
			this.currentlySelectedNode = value;
		}
		return this.getSingleDisplayValue(value);
	},

	onItemAdded: function(item, key) {
		if (!this.isInRange() && key === this.currentDisplayValue && this.m_value.setValue) {
			this.m_value.setValue(key);
		}
	},

	onItemRemoved: function(item, key) {
		if (this.isInRange() && key === this.currentDisplayValue && this.m_value.setValue) {
			this.m_value.setValue(key);
		}
	},

	useDropBox: function() {
		return (this.element.getAttribute("appearance") === null || this.element.getAttribute("appearance") === "minimal");
	},

	onSelectionChanged: function(s) {
		if (this.containsCopyElements()) {
			this.m_undisplayedValues = [];
			for (i = 0; i < this.m_proxy.m_oNode.childNodes.length; ++i) {
				if (this.m_proxy.m_oNode.childNodes[i].nodeType !== 3 /*DOM_TEXT_NODE*/) {
					this.m_undisplayedValues.push(this.m_proxy.m_oNode.childNodes[i]);
				}
			}
		}

		var oEvt1 = this.element.ownerDocument.createEvent("MutationEvents");
		oEvt1.initMutationEvent("selection-changed", false, false, null, "", s, "", 1);
		FormsProcessor.dispatchEvent(this.element, oEvt1);
		return;
	}

});

var XFormsSelect1Value = XFormsCommonSelectValue;
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global Repeat, DOM_TEXT_NODE, spawn, UX, NamespaceManager, FormsProcessor*/

var Value = new UX.Class({

	Mixins: [MIPHandler, Context, Control, OptionalBinding],

	toString: function() {
		return 'xf:value';
	},

	initialize: function(element) {
		this.element = element;
		UX.addStyle(this.element, "display", "none");
	},

	onContentReady: function() {
		var ownerSelect;
		if (DECORATOR.getBehaviour(this.element.parentNode).getOwnerSelect) {
			ownerSelect = DECORATOR.getBehaviour(this.element.parentNode).getOwnerSelect();
			if (ownerSelect) {
				DECORATOR.getBehaviour(ownerSelect).addItem(DECORATOR.getBehaviour(this.element.parentNode), this.getValue());
			}
		}
	},

	setValue: function(s) {
		var ownerSelect;
		if (DECORATOR.getBehaviour(this.element.parentNode).getOwnerSelect) {
			ownerSelect = DECORATOR.getBehaviour(this.element.parentNode).getOwnerSelect();
			if (this.m_sValue !== s) {
				if (ownerSelect) {
					var select = DECORATOR.getBehaviour(ownerSelect);
					select.removeItem(DECORATOR.getBehaviour(this.element.parentNode), this.m_sValue);
					this.m_sValue = s;
					select.addItem(DECORATOR.getBehaviour(this.element.parentNode), s);
					select.refreshDisplayValue();
				}
			}
		} else {
			this.m_sValue = s;
		}
	},

	getValue: function() {
		if (this.m_sValue === undefined) {
			if (this.element.firstChild && DOM_TEXT_NODE === this.element.firstChild.nodeType) {
				this.m_sValue = this.element.firstChild.nodeValue;
			} else {
				this.m_sValue = "";
			}
		}

		return this.m_sValue;
	}

});



var Itemset = new UX.Class({

	Mixins: [Context, Repeat],

	toString: function() {
		return 'xf:itemset';
	},

	initialize: function(element) {
		this.element = element;
		this.bindingContainerName = "item";
	}

});




var Item = new UX.Class({

	Mixins: [Context],

	toString: function() {
		return 'xf:item';
	},

	initialize: function(element) {
		this.m_value = null;
		this.m_copy = null;
		this.m_bSelected = false;
		this.m_bReady = false;
		this.m_ownerSelect = null;
		this.element = element;
	},

	getOwnerSelect: function() {
		if (!this.m_ownerSelect) {
			var el = this.element.parentNode;
			while (el) {
				var s = NamespaceManager.getLowerCaseLocalName(el);
				if (s.indexOf("select") === 0) {
					this.m_ownerSelect = el;
					break;
				}
				el = el.parentNode;
			}
		}
		return this.m_ownerSelect;
	},

	getLabel: function() {
		var s;
		if (this.m_label) {
			if (DECORATOR.getBehaviour(this.m_label).getValue) {
				s = DECORATOR.getBehaviour(this.m_label).getValue();
			} else {
				s = this.m_label.innerHTML;
			}
		} else {
			s = DECORATOR.getBehaviour(this.m_value).getValue();
		}
		return s;
	},

	findValueElement: function() {
		var coll = NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "value");
		for (var i = 0, l = coll.length; i < l; i++) {
			if (coll[i].parentNode === this.element) {
				this.m_value = coll[i];
				break;
			}
		}
		if (!this.m_value) {
			coll = NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "copy");
			for (i = 0, l = coll.length; i < l; i++) {
				if (coll[i].parentNode === this.element) {
					this.m_copy = coll[i];
					break;
				}
			}
		}
	},

	findLabelElement: function() {
		var coll = NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "label");
		for (var i = 0, l = coll.length; i < l; i++) {
			if (coll[i].parentNode === this.element) {
				this.m_label = coll[i];
				break;
			}
		}
	},

	onContentReady: function() {
		this.findValueElement();
		this.findLabelElement();
		this.addVisualRepresentation();

		var ownerSelect = this.getOwnerSelect();
		if (ownerSelect) {
			var self = this;
			ownerSelect.addEventListener("selection-changed", {
				handleEvent: function(e) {
					self.handleEvent(e);
				}
			},
			false);

			this.element.addEventListener("DOMActivate", {
				handleEvent: function(evt) {
					DECORATOR.getBehaviour(evt.currentTarget).toggleSelectionStatus();
					evt.stopPropagation();
				}
			},
			false);
		}
		if (!this.m_bReady) {
			this.m_bSelected = false;
			UX.Element(this.element).addClass("pc-deselected");
		}
	},

	addVisualRepresentation: function() {

	},

	handleEvent: function(oEvt) {

		if (oEvt.type === "selection-changed" && oEvt.target === this.getOwnerSelect()) {
			if (oEvt.target.m_undisplayedValues) {
				oEvt.target.m_undisplayedValues = this.array_tryDataselect(oEvt.target.m_undisplayedValues);
			} else {
				this.string_tryDataselect(oEvt.newValue);
			}
		}
	},

	getValue: function() {
		var value;
		if (this.m_value && DECORATOR.getBehaviour(this.m_value).getValue) {
			return DECORATOR.getBehaviour(this.m_value).getValue();
		} else if (this.m_copy && DECORATOR.getBehaviour(this.m_copy).getValue) {
			if (this.valueInInstance) {
				value = DECORATOR.getBehaviour(this.m_copy).getValue();
				if (UX.isEquivalentNode(this.valueInInstance, value)) {
					return this.valueInInstance;
				}
			} else {
				return DECORATOR.getBehaviour(this.m_copy).getValue();
			}
		} else {
			return "";
		}
	},

	string_tryDataselect: function(s) {
		if (s !== "" && s === this.getValue()) {
			this.onDataSelect();
			return true;
		} else {
			this.onDataDeselect();
			return false;
		}
	},

	array_tryDataselect: function(arr) {
		var s, i;
		s = this.getValue();
		if (s !== "") {
			for (i = 0; i < arr.length; ++i) {
				if (s && (s === arr[i] || (typeof s === "object" && UX.isEquivalentNode(s, arr[i])))) {
					this.valueInInstance = arr[i];
					this.onDataSelect();
					arr.splice(i, 1);
					return arr;
				}
			}
		}
		this.onDataDeselect();
		return arr;
	},

	toggleSelectionStatus: function() {
		var bSelected = !this.m_bSelected;
		if (bSelected) {
			this.onUserSelect();
		} else {
			this.onUserDeselect();
		}
	},

	onUserSelect: function() {
		var oEvt = this.element.ownerDocument.createEvent("Events");
		oEvt.initEvent("fp-select", true, true);
		var element = this.element;
		spawn(function() {
			FormsProcessor.dispatchEvent(element, oEvt);
		});
	},

	onUserDeselect: function() {
		var oEvt = this.element.ownerDocument.createEvent("Events");
		oEvt.initEvent("fp-deselect", true, true);
		var element = this.element;
		spawn(function() {
			FormsProcessor.dispatchEvent(element, oEvt);
		});
	},

	onDataSelect: function() {
		var oEvt;
		if (!this.m_bSelected || !this.m_bReady) {
			this.m_bSelected = true;
			UX.removeClassName(this.element, "pc-deselected");
			UX.addClassName(this.element, "pc-selected");
			oEvt = this.element.ownerDocument.createEvent("Events");
			oEvt.initEvent("xforms-select", true, true);
			FormsProcessor.dispatchEvent(this.element, oEvt);
			this.m_bReady = true;
		}
	},

	onDataDeselect: function() {
		var oEvt;
		if (this.m_bSelected) {
			this.m_bSelected = false;
			UX.removeClassName(this.element, "pc-selected");
			UX.addClassName(this.element, "pc-deselected");
			oEvt = this.element.ownerDocument.createEvent("Events");
			oEvt.initEvent("xforms-deselect", true, true);
			FormsProcessor.dispatchEvent(this.element, oEvt);
			this.m_bReady = true;
		}
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Copy = new UX.Class({

	Mixins: [Context, Control, OptionalBinding],

	toString: function() {
		return 'xf:copy';
	},

	initialize: function(element) {
		this.element = element;
		this.m_oValue = undefined;
		UX.addStyle(this.element, "display", "none");
	},

	onContentReady: function() {
		var ownerSelect = this.element.parentNode.getOwnerSelect();
		if (ownerSelect) {
			ownerSelect.addItem(this.element.parentNode, this.getValue());
		}
	},

	onDocumentReady: function() {
		var self = this;
		spawn(function() {
			var ownerSelect;
			if (typeof self.element.parentNode.getOwnerSelect === "function") {
				ownerSelect = self.element.parentNode.getOwnerSelect();
				if (getModelFor(self) !== getModelFor(ownerSelect)) {
					UX.dispatchEvent(self.element, "xforms-binding-exception", true, false);
				}
			}
		});
	},

	setValue: function(o) {
		var ownerSelect = this.element.parentNode.getOwnerSelect();
		if(!ownerSelect || this.m_oValue == this.m_proxy.m_oNode) return;
		ownerSelect.itemValueChanged(this.element.parentNode, this.getValue(), this.m_proxy.m_oNode);
		this.m_oValue = this.m_proxy.m_oNode;
		ownerSelect.refreshDisplayValue();
	},

	getValue: function() {
		return this.m_oValue || null;
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 Action handler used as a base class for elements that are used to call an extant method on a model.
 @param method {Function} a function that takes a model as an argument, and calls the appropriate method on it.
 */
function ModelFunctionAction(method) {
	this.ModelMethod = method;
	this.handleEvent = DeferToConditionalInvocationProcessor;

	this.performAction = function(evt) {
		var m = getModelFor(this.element);
		this.ModelMethod(m);
	};
	return this;
}
/**Specialisation of ModelFunctionAction to call rebuild*/

var Rebuild = new UX.Class({

	Mixins: [Listener, new ModelFunctionAction(function(model) {
		model._rebuild();
	})],

	toString: function() {
		return 'xf:rebuild';
	},

	initialize: function(element) {
		this.element = element;
	}
});

/**
 Specialisation of ModelFunctionAction to call recalculate
 */
var Recalculate = new UX.Class({

	Mixins: [Listener, new ModelFunctionAction(function(model) {
		model._recalculate();
	})],

	toString: function() {
		return 'xf:recalculate';
	},

	initialize: function(element) {
		this.element = element;
	}

});

/**
 Specialisation of ModelFunctionAction to call revalidate
 */
var Revalidate = new UX.Class({

	Mixins: [Listener, new ModelFunctionAction(function(model) {
		model._revalidate();
	})],

	toString: function() {
		return 'xf:revalidate';
	},

	initialize: function(element) {
		this.element = element;
	}

});

/**
 Specialisation of ModelFunctionAction to call refresh
 */
var Refresh = new UX.Class({

	Mixins: [Listener, new ModelFunctionAction(function(model) {
		model._refresh();
	})],

	toString: function() {
		return 'xf:refresh';
	},

	initialize: function(element) {
		this.element = element;
	}

});

/**
 Specialisation of ModelFunctionAction to call reset
 */
var Reset = new UX.Class({

	Mixins: [Listener, new ModelFunctionAction(function(model) {
		UX.dispatchEvent(model, "xforms-reset", true, true);
	})],

	toString: function() {
		return 'xf:reset';
	},

	initialize: function(element) {
		this.element = element;
	}

});
/*
 * Copyright (c) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global document, doUpdate, DeferToConditionalInvocationProcessor*/

var SetIndex = new UX.Class({

	Mixins: [Listener, Context],

	toString: function() {
		return 'xf:set-index';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(evt) {
		doUpdate();
		if (! (this.element.hasAttribute) || this.element.hasAttribute("repeat")) {
			var repeatID = this.element.getAttribute("repeat");
			var repeatElement = FormsProcessor.getElementById(repeatID, this.element);
			if (repeatElement) {
				if (repeatElement.setIndex) {
					if (! (this.element.hasAttribute) || this.element.hasAttribute("index")) {
						var indexXPath = this.getAttribute("index");
						var ctx = this.getEvaluationContext();
						var indexResult = ctx.model.EvaluateXPath(indexXPath);
						if (indexResult) {
							var indexValue = indexResult.numberValue();
							if (!isNaN(indexValue)) {
								repeatElement.setIndex(indexValue);
							}
						} else {
							throw "The number attribute of the setindex element must contain a valid XPath expression.";
						}
					} else {
						throw "The number attribute of the setindex element is required.";
					}
				} else {
					throw "The IDREF provided by setindex/@repeat must resolve to a repeating structure that implements a setIndex method. '" + repeatID + "' is not such a structure.";
				}

			}
		} else {
			throw "The repeat attribute of the setindex element is required.";
		}
	}

});

/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global DeferToConditionalInvocationProcessor, UX.getElementValueOrContent, UX.getProxyNode*/

var SetValue = new UX.Class({

	Mixins: [Listener, Context],

	toString: function() {
		return 'xf:setvalue';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(evt) {
		var context = this.getBoundNode(1);
		var node = context.node;
		var oPE = UX.getProxyNode(node);

		var value = UX.getElementValueOrContent(context, this.element);
		oPE.setValue(value, context.model);
		this.m_model._recalculate();
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

SetFocus = new UX.Class({

	Mixins: [Listener, Context],

	toString: function() {
		return 'xf:set-focus';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function() {
		doUpdate();
		var controlId = UX.getPropertyValue(this, "control");
		if (controlId) {
			var control = FormsProcessor.getElementById(controlId, this.element);
			if (control) {
				UX.dispatchEvent(control, "xforms-focus", false, true);
			}
		}
	}

});
/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Insert = new UX.Class({

	Mixins: [Listener, Context, OptionalBinding],

	toString: function() {
		return 'xf:insert';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(evt) {
		var context = this.getEvaluationContext();
		var bindid = this.element.getAttribute("bind");
		var atExpr = this.element.getAttribute("at");
		var positionExpr = this.element.getAttribute("position");
		var originExpr = this.element.getAttribute("origin");

		var nodeset;
		if (bindid) {
			var bindObject = FormsProcessor.getBindObject(bindid, this.element);
			nodeset = bindObject.boundNodeSet;
		} else {
			var nodesetExpr = this.element.getAttribute("nodeset");
			instance = context.model.instances()[0];
			nodeset = (nodesetExpr) ? instance.evalXPath(nodesetExpr, context).nodeSetValue() : null;
		}

		/* We need to determine what instance to use - calling through the right instance is
			important, in particular, in order to dispatch an xforms-insert event to
			the correct target. We also need model that contains the instance so
			so we can mark it for deferred rebuild.
		*/

		var instance = (nodeset && nodeset.length > 0) ? DECORATOR.getBehaviour(nodeset[0].ownerDocument.documentElement.getAttribute('ux_uid_element')) : context.model.instances()[0];
		model = DECORATOR.getBehaviour(instance.model);
		if (instance.insertNodeset(context, nodeset, atExpr, positionExpr, originExpr)) {
			if (model && typeof(model.flagRebuild === 'function')) model.flagRebuild();
		}

		this.m_context = null;
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Delete = new UX.Class({

	Mixins: [Listener, Context],

	toString: function() {
		return 'xf:delete';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var context = this.getEvaluationContext();
		var bindid = this.element.getAttribute("bind");
		var atExpr = this.element.getAttribute("at");
		var instance = context.model.instances()[0];
		var nodeset;

		if (bindid) {
			var bindObject = FormsProcessor.getBindObject(bindid, this.element);
			nodeset = bindObject.boundNodeSet;
		} else {
			var nodesetExpr = this.element.getAttribute("nodeset");
			nodeset = (nodesetExpr) ? instance.evalXPath(nodesetExpr, context).nodeSetValue() : null;
		}

		if (instance.deleteFromNodeset(context, nodeset, atExpr)) {
			context.model.flagRebuild();
		}
	}

});

/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Toggle = new UX.Class({

	Mixins: [Listener, Context],

	toString: function() {
		return 'xf:toggle';
	},

	initialize: function(element) {
		this.element = element;
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var context = this.getEvaluationContext();
		var ns = NamespaceManager.getElementsByTagNameNS(this.element, "http://www.w3.org/2002/xforms", "case");

		var caseId = (ns && ns.length > 0) ? UX.getElementValueOrContent(context, ns[0]) : this.element.getAttribute("case");
		if (caseId) {
			var oCase = DECORATOR.getBehaviour(FormsProcessor.getElementById(caseId, this.element));
			if (oCase && oCase.toggle) {
				oCase.toggle();
			}
		}
	}

});
/*
 * Copyright (C) 2008 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Submit = new UX.Class({

	Mixins: [NavigableControl, OptionalBinding],

	toString: function() {
		return 'xf:submit';
	},

	initialize: function(element) {
		this.element = element;
		this.element.addEventListener("DOMActivate", this, false);
	},

	handleEvent: DeferToConditionalInvocationProcessor,

	performAction: function(event) {
		var control = this;
		var submission = null;
		var doc = control.element.ownerDocument;
		if (event.type != "DOMActivate" || (UX.isWebKit && !event.mappedFromClick)) return;
		var id = control.element.getAttribute("submission");
		if (id) {
			submission = doc.getElementById(id);
			if (!submission || !NamespaceManager.compareFullName(submission, "submission", "http://www.w3.org/2002/xforms")) {
				UX.dispatchEvent(this.element, "xforms-binding-exception", true, false, false);
			}
		} else {
			var model = getModelFor(doc);

			if (model) {
				var children = model.element.childNodes;
				for (var i = 0, l = children.length; i < l; i++) {
					if (NamespaceManager.compareFullName(children[i], "submission", "http://www.w3.org/2002/xforms")) {
						submission = children[i];
						break;
					}
				}
			}

			if (!submission) {
				throw "There is no submission element associated with the default model.";
			}
		}

		if (submission) {
			var submitEvent = doc.createEvent("Events");
			submitEvent.initEvent("xforms-submit", true, true, null, null);
			spawn(function() {
				FormsProcessor.dispatchEvent(submission, submitEvent);
			});
		}
	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Ubiquity provides a standards-based suite of browser enhancements for
 * building a new generation of internet-related applications.
 *
 * The Ubiquity XForms module adds XForms 1.1 support to the Ubiquity
 * library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * The Hint mixin registers for the XForms hint event, and then activates
 * whichever object it is attached to.
 *
 * Accompanying CSS classes are in hint.css.
 */

var HintMixin = new UX.Class({

	Mixins: [Message],

	toString: function() {
		return 'xf:hint';
	},

	initialize: function(element) {
		this.element = element;

		var context = element.parentNode;

		if (!context) {
			throw "No context found for hint";
		}

		element.setAttribute("level", "ephemeral");

		UX.addClassName(context, "xf-hint-container");

		if (typeof context.addEventListener === "function") {
			context.addEventListener("xforms-hint", {
				handleEvent: function(evt) {
					var forwardEvt = document.createEvent("Events");

					forwardEvt.initEvent("ub-activate", false, false);
					forwardEvt.activate = true;
					FormsProcessor.dispatchEvent(element, forwardEvt);
					return;
				}
			},
			false);
			context.addEventListener("xforms-hint-off", {
				handleEvent: function(evt) {
					var forwardEvt = document.createEvent("Events");

					forwardEvt.initEvent("ub-activate", false, false);
					forwardEvt.activate = false;
					FormsProcessor.dispatchEvent(element, forwardEvt);
					return;
				}
			},
			false);
		}
	}

});
/*
 * Copyright (c) 2009 Backplane Ltd.
 *
 * Ubiquity provides a standards-based suite of browser enhancements for
 * building a new generation of internet-related applications.
 *
 * The Ubiquity XForms module adds XForms 1.1 support to the Ubiquity
 * library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * The Help mixin registers for the XForms help event, and then activates
 * whichever object it is attached to.
 *
 * Accompanying CSS classes are in help.css.
 */

var HelpMixin = new UX.Class({

	Mixins: [Message],

	toString: function() {
		return 'xf:help';
	},

	initialize: function(element) {
		this.element = element;

		var context = element.parentNode;

		if (!context) {
			throw "No context found for help";
		}

		element.setAttribute("level", "modeless");

		UX.addClassName(context, "xf-help-container");

		context.addEventListener("xforms-help", {
			handleEvent: function(evt) {
				var forwardEvt = element.ownerDocument.createEvent("Events");

				forwardEvt.initEvent("ub-activate", false, false);
				FormsProcessor.dispatchEvent(element, forwardEvt);
				return;
			}
		},
		false);
	}

});
/*
 * Copyright (c) 2008-9 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Header = new UX.Class({

	Mixins: [Context],

	toString: function() {
		return 'xf:header';
	},

	initialize: function(element) {
		this.element = element;
		this.template = null;
		if (!this.element.getAttribute('nodeset')) {
			UX.addClassName(this.element, 'header-ready');
		}
	},

	onDocumentReady: function() {
		var model = null;

		if (this.element.getAttribute("nodeset")) {
			this.template = this.element.cloneNode(true);

			while (this.element.hasChildNodes()) {
				this.element.removeChild(this.element.firstChild);
			}

			model = getModelFor(this);
			model.addControl(this);

			UX.addClassName(this.element, "header-ready");
		}
	},

	refresh: function() {

	},

	rewire: function() {
		var expression = this.element.getAttribute("nodeset");
		if(!expression) return;
			while (this.element.childNodes.length > 0) {
			this.element.removeChild(this.element.firstChild);
		}
		var context = this.element.getEvaluationContext();
		var nodes = context.model.EvaluateXPath(expression, context).value;
		if(!nodes) return;

		var name = NamespaceManager.getOutputPrefixesFromURI("http://www.w3.org/2002/xforms")[0] + ":header";

		for (var i = 0, l = nodes.length; i < l; i++) {

			var element = document.createElementNS("http://www.w3.org/2002/xforms", name);

			element.setAttribute("ref", ".");
			element.setAttribute("ordinal", i + 1);
			UX.addClassName(element, "header-ready");

			var template = this.template.cloneNode(true);

			while (template.hasChildNodes()) {
				element.appendChild(template.firstChild);
			}

			this.element.appendChild(element);
		}

		if (!UX.hasDecorationSupport) {
			DECORATOR.applyRules(this.element);
		}

	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TriggerMinimalMixin = new UX.Class({

	toString: function() {
		return 'xf:trigger-minimal';
	},

	initialize: function(element) {
		this.element = element;
		UX.addClassName(this.element.parentNode.parentNode, 'appearance-minimal');
	}

});

var Trigger = new UX.Class({

	Mixins: [NavigableControl, OptionalBinding],

	toString: function() {
		return 'xf:trigger';
	}

});

var Alert = new UX.Class({

	Mixins: [MIPHandler, Context, SrcMixin, Control, OptionalBinding, LoadExternalMixin],

	toString: function() {
		return 'xf:alert';
	}

});

var MediaType = new UX.Class({

	Mixins: [MIPHandler, Context, Control],

	toString: function() {
		return 'xf:mediatype';
	}

});
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *  XF4HProcessor
 */
XF4HProcessor = {
	/**
	 @description namespacceURI for XF4H
	 @type String
	 */
	nsURI: "http://www.w3.org/TR/xf4h",

	/**
	 @description default prefix for XF4H
	 @type String
	 */
	defaultPrefix: "x4h:",

	/**
	 Get the attribute value for an XF4H's attribute.
	 Since XF4H can be part of a HTML document without any namespace declaration,
	 We need to try to get the attribute with the "x4h:" prefix if failed to retrieve the
	 attribute vale via getAttributeNS
	 @param {Object} Element to get attribute from
	 @param {String} Attribute name
	 @returns String, Attribute Value
	 @throws
	 */
	getAttribute: function(oElement, sAttributeName) {
		var sAttrValue = NamespaceManager.getAttributeNS(oElement, this.nsURI, sAttributeName);

		if (!sAttrValue) {
			sAttrValue = oElement.getAttribute(this.defaultPrefix + sAttributeName);
		}

		return sAttrValue;
	},

	/**
	 Process XF4H element, create reference node and node value in an instance
	 and create bind for the control.
	 @param {Object} Model node of the evaluation context
	 @param {Object} Context node of the evaluation context
	 @param {Object} Control's DOM Node
	 @param {String} Name attribute of the control
	 @returns Object Reference node of the binded control
	 @throws
	 */
	processElement: function(oModel, oContextNode, oElement, sName) {
		var sValue, oValueNode, oParent;
		var oRefNode = null;

		var oEvalResult = oModel.EvaluateXPath(sName, {
			node: oContextNode,
			model: oModel,
			resolverElement: oElement
		});
		if (oEvalResult) {
			oRefNode = getFirstNode(oEvalResult);
		}
		var oInstDoc = Context.prototype._getDefaultInstanceDocument(oModel);

		if (!oRefNode && oInstDoc) {
			oRefNode = oInstDoc.createElement(sName);
			sValue = this.getAttribute(oElement, "value");

			if (sValue && sValue.length !== 0) {
				oValueNode = oInstDoc.createTextNode(sValue);
				if (oValueNode) {
					oRefNode.appendChild(oValueNode);
				}
			}
			oParent = oContextNode ? oContextNode : oInstDoc.documentElement;
			oParent.appendChild(oRefNode);
		}

		if (!oElement["bindCreated"]) {
			this._createBind(oModel, oElement, oRefNode);
			oElement["bindCreated"] = true;
		}

		return oRefNode;
	},

	/**
	 Create corresponding bind from XF4H control's constraint attributes
	 (datatype, calculate, constraint, relevant, readonly, required)
	 @param {Object} Model node of the evaluation context
	 @param {Object} Context node of the evaluation context
	 @param {Object} Control's DOM Node
	 @returns n/a
	 @throws n/a
	 */
	_createBind: function(oModel, oElement, oRefNode) {
		var sDatatype, sCalculate, sConstraint;
		var sRelevant, sReadonly, sRequired, sNodeset;
		var oBind = null;
		var oContextBind = null;

		if (!oModel || !oElement || !oRefNode) {
			return;
		}

		sDatatype = this.getAttribute(oElement, "datatype");
		sCalculate = this.getAttribute(oElement, "calculate");
		sConstraint = this.getAttribute(oElement, "constraint");
		sRelevant = this.getAttribute(oElement, "relevant");
		sReadonly = this.getAttribute(oElement, "readonly");
		sRequired = this.getAttribute(oElement, "required");

		if (!sDatatype && !sCalculate && !sConstraint && !sRelevant && !sReadonly && !sRequired) {
			return;
		}

		oBind = UX.createElementNS(oElement, "http://www.w3.org/2002/xforms", "bind");

		sNodeset = this._getNodeset(oRefNode, oRefNode.ownerDocument.documentElement);

		if (!oBind || !sNodeset) {
			return;
		}
		oBind.setAttribute("nodeset", sNodeset);
		oContextBind = UX.createElementNS(oElement, "http://www.w3.org/2002/xforms", "bind");
		oContextBind.setAttribute("context", "..");
		oBind.appendChild(oContextBind);

		if (sDatatype) {
			var sType = "xsd:" + sDatatype;
			oContextBind.setAttribute("type", sType);
		}

		if (sCalculate) {
			oContextBind.setAttribute("calculate", sCalculate);
		}

		if (sConstraint) {
			oBind.setAttribute("constraint", sConstraint);
		}

		if (sRelevant) {
			oContextBind.setAttribute("relevant", sRelevant);
		}

		if (sReadonly) {
			oContextBind.setAttribute("readonly", ((sReadonly != "false") ? "true" : "false"));
		}

		if (sRequired) {
			oContextBind.setAttribute("required", ((sRequired !== "false") ? "true()" : "false()"));
		}
		oModel.appendChild(oBind);

		if (!UX.hasDecorationSupport) {
			oModel.rebuild();
		}
	},

	/**
	 Determine the XPath expression of the nodeset by traversing the instance,
	 this method is called recusively.
	 @param {Object} prefix The prefix used to select the given URI
	 @param {Object} uri  The URI to which the prefix is to be bound
	 @returns String, XPath expression of current refernce
	 @throws
	 */
	_getNodeset: function(oElem, oDocRoot) {
		var sParentRef = null;

		if (!oElem || oElem === oDocRoot) {
			return null;
		} else {
			sParentRef = this._getNodeset(oElem.parentNode, oDocRoot);

			if (sParentRef) {
				sParentRef += "/";
			} else {
				sParentRef = "";
			}
			return sParentRef + oElem.nodeName;
		}
	}
};


FunctionCallExpr.prototype.xpathfunctions["serialize"] = function (ctx) {
	var o, ns, n;

	if (this.args[0]) {
		o = this.args[0].evaluate(ctx);
		ns = o.nodeSetValue();
		if (ns.length && ns[0]) {
			n = ns[0];
		} else {
			return new StringValue( "" );
		}
	} else {
		n = ctx.node;
	}

	if (g_bSaveDependencies) {
		descendants = [];
		xpathCollectDescendants(descendants, n);
		for (var i = 0; i < descendants.length; ++i) {
			if (descendants[i].nodeName != '#text')
			g_arrSavedDependencies.push(descendants[i]);
		}
	}

	return new StringValue( xmlText( n ) );
};


FormsProcessor.extend({
	"format-number": function (value, picture, decimalFormatName) {
		var decimalPlaces,
			prefix,
			result,
			suffix;

		if (picture) {
			picture.match( /^([^\#]*)?(\#*)?(\.(\#*))?([^\#]*)?/ );

			prefix = RegExp.$1 || "";
			decimalPlaces = (RegExp.$3)
				? (RegExp.$4 ? RegExp.$4.length : 0)
				: undefined;
			suffix = RegExp.$5 || "";

			result =
				prefix +
				(
					( decimalPlaces === undefined || isNaN(parseFloat(value)) )
						? value
						: parseFloat( value ).toFixed( decimalPlaces )
				) +
				suffix;
		} else {
			result = value;
		}

		return result;
	}
});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

FormsProcessor.extend({
	hmac: function (key, data, algorithm, encoding) {
		var hmac;

		if (!encoding) {
			encoding = 'base64';
		} else if (encoding !== 'hex' && encoding !== 'base64') {
			throw 'hmac(): invalid encoding "' + encoding + '"';
		}

		switch (algorithm) {
			case "MD5":
				if (encoding === "hex") {
					hmac = MD5.hex_hmac_md5(key, data);
				} else {
					hmac = MD5.b64_hmac_md5(key, data);
				}
				break;
			case "SHA-1":
			case "SHA-256":
			case "SHA-384":
			case "SHA-512":
				hmac = (new jsSHA(data)).getHMAC(key, algorithm, encoding === "hex" ? "HEX" : "B64");
				break;
			default:
				throw 'hmac(): invalid algorithm "' + algorithm + '"';
		}

		return hmac;
	}
});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var GMapControl = new UX.Class({

	toString: function() {
		return 'xf:gmap';
	},

	initialize: function(element) {
		this.element = element;
		var self = this;
		element.parentNode.setMapInfo = function(infoElement) {
			self.setMapInfo(infoElement);
		};
	},

	setMapInfo: function(infoElement) {
		this.mapInfo = infoElement;
	},

	createMap: function() {
		this.mapContainer = document.createElement('div');
		this.element.appendChild(this.mapContainer);

		this.setMapDimensionUnlessParentIsSet('width', '300px');
		this.setMapDimensionUnlessParentIsSet('height', '200px');

		this.map = new GMap2(this.mapContainer);
		var self = this;
		spawn(function() {//delay, because in ff this.mapContainer.clientWidth 0 if UX.hasDecorationSupport = false
			self.mapLocation = new GLatLng(51.523811, -0.107878);
			self.map.setCenter(self.mapLocation, self.estimateInitialZoom());
			self.addMapControls();
		});
	},

	setMapDimensionUnlessParentIsSet: function(dimension, value) {
		if (this.element.parentNode.style[dimension] === '') {
			UX.addStyle(this.mapContainer, dimension, value);
		} else {
			UX.addStyle(this.mapContainer, dimension, this.element.parentNode.style[dimension]);
		}
	},

	estimateInitialZoom: function() {
		if (this.mapContainer.clientWidth < 120 || this.mapContainer.clientHeight < 120) {
			return 8;
		}

		if (this.mapContainer.clientWidth < 160 || this.mapContainer.clientHeight < 160) {
			return 13;
		}

		if (this.mapContainer.clientWidth < 200 || this.mapContainer.clientHeight < 200) {
			return 14;
		}

		return 16;
	},

	addMapControls: function() {
		this.addCommonMapControls();

		if (typeof this.addMapNavigationControl === 'function') {
			this.addMapNavigationControl();
		}
	},

	addCommonMapControls: function() {
		this.addMapTypeControl();
		this.addMapScaleControl();
		this.addMapOverviewControl();
	},

	addMapTypeControl: function() {
		if (this.mapContainer.clientWidth >= 260 && this.mapContainer.clientHeight >= 100) {
			this.map.addControl(new GMapTypeControl());
		} else if (this.mapContainer.clientWidth >= 190 && this.mapContainer.clientHeight >= 120) {
			this.map.addControl(new GHierarchicalMapTypeControl());
		} else if (this.mapContainer.clientWidth >= 140 && this.mapContainer.clientHeight >= 140) {
			this.map.addControl(new GMenuMapTypeControl());
		}
	},

	addMapScaleControl: function() {
		if (this.mapContainer.clientWidth >= 500 && this.mapContainer.clientHeight >= 200) {
			this.map.addControl(new GScaleControl());
		}
	},

	addMapOverviewControl: function() {
		if (this.mapContainer.clientWidth >= 620 && this.mapContainer.clientHeight >= 200) {
			this.map.addControl(new GOverviewMapControl());
		}
	},

	setValue: function(value) {
		var match;
		if (value !== this.currentValue) {
			match = value.match(/([\-+]?\d*\.?\d+)[\,\s\;]*([\-+]?\d*\.?\d+)/);
			if (match) {
				this.setMapCoordinates(new GLatLng(Number(match[1]), Number(match[2])));
			} else {
				this.setMapLocation(value);
			}

			this.currentValue = value;
		}
	},

	setMapLocation: function(location) {
		var self = this;

		if (!this.geocoder) {
			this.geocoder = new GClientGeocoder();
		}

		this.geocoder.getLatLng(location, function(coords) {
			self.setMapCoordinates(coords);
		});
	},

	setMapCoordinates: function(coords) {
		if (coords) {
			this.mapLocation = coords;

			if (this.mapMarker) {
				this.moveMapMarker();
			} else {
				this.addMapMarker();
			}
		}
	},

	addMapMarker: function() {
		var self = this;
		this.mapMarker = new GMarker(this.mapLocation, { clickable: this.mapInfo ? true : false, draggable: false });
		GEvent.addListener(this.mapMarker, 'click', function () {
			self.onClickMapMarker();
		});
		GEvent.addListener(this.mapMarker, 'infowindowclose', function () {
			self.onMapInfoDismissed();
		});
		GEvent.addListener(this.map, 'moveend', function() {
			var value;
			if (!self.mapInfoIsVisible) {
				value = self.map.getCenter().lat() + ";" + self.map.getCenter().lng();
				if(value !== self.currentValue) {
					self.valueChanged(value);
				}
			}
		});
		this.map.addOverlay(this.mapMarker);
	},

	moveMapMarker: function() {
		if (!this.mapInfoIsVisible) {
			this.mapMarker.setLatLng(this.mapLocation);
			this.map.setCenter(this.mapLocation, this.map.getZoom());
		}
	},

	onClickMapMarker: function() {
		if (this.mapInfo) {
			if (this.mapInfoIsVisible) {
				this.mapMarker.closeInfoWindow();
			} else {
				this.mapInfoIsVisible = true;
				FormsProcessor.refreshDescendents(this.mapInfo.childNodes);
				this.mapMarker.openInfoWindowHtml(this.mapInfo.getValue(), { maxWidth: this.mapContainer.clientWidth >= 200 ? this.mapContainer.clientWidth - 80 : 120 });
			}
		}
	},

	onMapInfoDismissed: function() {
		this.map.panTo(this.mapLocation);
		this.mapInfoIsVisible = false;
	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var HintGMap = new UX.Class({

	Mixins: [Listener, MIPHandler, Context, Control, OptionalBinding],

	initialize: function(element) {
		this.element = element;
		this.mapControl = this.element.parentNode;
	},

	onDocumentReady: function () {
		this.mapControl.setMapInfo(this.element);
	}

});
/*
 * Copyright  2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XFormsOutputValueGMap = new UX.Class({

	Mixins: [GMapControl],

	toString: function() {
		return 'xf:output-value-gmap';
	},

	onDocumentReady: function() {
		this.createMap();
		this.map.disableDragging();
	},

	addMapNavigationControl: function() {
		if (this.mapContainer.clientWidth >= 110 && this.mapContainer.clientHeight >= 100) {
			this.map.addControl(new GSmallZoomControl3D());
		} else if (this.mapContainer.clientWidth >= 80 && this.mapContainer.clientHeight >= 80) {
			this.map.addControl(new GSmallZoomControl());
		}
	}

});
var RangeValueGMAP = new UX.Class({

	Mixins: [GMapControl],

	toString: function() {
		return 'xf:gmap-range';
	},

	valueChanged: function(value) {
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		if (oEvt.initMutationEvent === undefined) {
			oEvt.initMutationEvent = oEvt.initEvent;
		}

		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currentValue, value, null, null);
		var self = this;
		spawn(function() {
			FormsProcessor.dispatchEvent(self.element, oEvt);
		});
	},

	onDocumentReady: function() {
		this.createMap();
	},

	addMapNavigationControl: function() {
		if (this.mapContainer.clientWidth >= 180 && this.mapContainer.clientHeight >= 300) {
			this.map.addControl(new GLargeMapControl3D());
		} else if (this.mapContainer.clientWidth >= 120 && this.mapContainer.clientHeight >= 140) {
			this.map.addControl(new GSmallMapControl());
		}
	}

});
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

UX.calendarcount = 0;

var InputValueCalendar = new UX.Class({

	Mixins: [PeValue],

	toString: function(){
		return 'xf:calendar-value';
	},

	initialize: function(element) {
		this.element = element;
		this.currValue = "";
		this.m_bFirstSetValue = true;
		this.m_bPopup = false;
		this.m_sInputId = '';
	},

	currentCalendarValue: function() {
		var date = this.m_value.getSelectedDates()[0];
		var yr = date.getYear();
		var mn = date.getMonth() + 1;
		var da = date.getDate();
		var xsdDate;
		yr = (yr > 1900) ? yr : (1900 + yr); // TODO, Calendar may return year modulo 1900 to begin with
		mn = (mn < 10) ? ('0' + mn) : mn;
		da = (da < 10) ? ('0' + da) : da;
		this.currValue = mn + '/' + da + '/' + yr;
		xsdDate = yr + '-' + mn + '-' + da;
		if (this.m_bPopup) {
			YAHOO.util.Dom.get(this.m_sInputId).value = xsdDate;
		}
		return xsdDate;
	},

	onDocumentReady: function() {
		if (this.element.ownerDocument.media == "print") return;
		var self = this,
			appearance = this.element.parentNode.getAttribute("appearance"),
			datatype = this.element.parentNode.getAttribute("datatype"),
			xf4hdatatype = XF4HProcessor.getAttribute(this.element.parentNode, "datatype");

		if (appearance === 'yui:popup-calendar' || ((datatype === 'xsd:date' || datatype === 'xf:date' || datatype === 'xforms:date' || xf4hdatatype === 'date') && (appearance === null || appearance === 'compact'))) { // popup
			this.m_bPopup = true;
			this.m_sInputId = "ux-calendar-input-" + UX.calendarcount;
			this.element.innerHTML = "<div id='ux-calendar-bg" + UX.calendarcount + "' class='ux-calendar-bg'>" + "<input type='text' disabled='true' class='ux-input-compact-calendar' id='" + this.m_sInputId + "'></input></div>";

			var calendarMenu = new YAHOO.widget.Overlay("calendarmenu" + UX.calendarcount, {
				visible: false
			});
			var button = new YAHOO.widget.Button({
				type: "menu",
				id: "calendarpicker" + UX.calendarcount,
				label: "",
				menu: calendarMenu,
				container: "ux-calendar-bg" + UX.calendarcount
			});
			var calcount = UX.calendarcount;

			button.on("appendTo", function() {
				calendarMenu.setBody("&#32;"); // body is needed, add a space
				calendarMenu.body.id = "calendarcontainer" + calcount;
				calendarMenu.render(this.get("container"));
			});

			button.on("click", function() {
				if (!self.m_value) {

					self.m_value = new YAHOO.widget.Calendar("ux-calendar-" + calcount, calendarMenu.body.id);
					if (self.currValue) { // set initial date, if one is bound
						self.m_value.setYear(self.currValue.substring(6, 10));
						self.m_value.setMonth(self.currValue.substring(0, 2) - 1);
						self.m_value.select(self.currValue);
					}
					self.m_value.render();

					self.m_value.changePageEvent.subscribe(function() {
						window.setTimeout(function() {
							calendarMenu.show();
						},
						0);
					});

					self.m_value.selectEvent.subscribe(function() {
						self.calendarValueChanged(self.currentCalendarValue());
						calendarMenu.hide();
						self.m_value.hide(); // Required to avoid bleeding in IE
					});
				}

				self.m_value.show();
				calendarMenu.show();
			});

		} else { // inline
			this.element.innerHTML = "<div id='ux-calendar-bg" + UX.calendarcount + "' class='ux-calendar-bg'></div>";
			this.m_value = new YAHOO.widget.Calendar("ux-calendar-" + UX.calendarcount, "ux-calendar-bg" + UX.calendarcount);

			this.m_value.selectEvent.subscribe(
			function() {
				self.calendarValueChanged(self.currentCalendarValue());
			});

			this.m_value.render();
		}

		UX.calendarcount++;
	},

	setValue: function(value) {
		if (!value.match(/^(\d{4})\-(\d{2})\-(\d{2})/)) return false;

		var yr = RegExp.$1;
		var mn = RegExp.$2;
		var da = RegExp.$3;
		var calendarDate = mn + '/' + da + '/' + yr; // default format used by the calendar implementation
		if (this.currValue != calendarDate || this.m_bFirstSetValue) {
			this.currValue = calendarDate;
			if (this.m_bPopup) {
				YAHOO.util.Dom.get(this.m_sInputId).value = value;
			}
			if (this.m_value) { // avoid race when popup
				this.m_value.setYear(yr);
				this.m_value.setMonth(mn - 1);
				this.m_value.select(calendarDate);
				this.m_value.render();
			}
			if (this.m_bFirstSetValue) {
				this.m_bFirstSetValue = false;
			}
			return true;
		} else {
			return false;
		}
	},

	calendarValueChanged: function(sNewValue) {
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		if (oEvt.initMutationEvent === undefined) {
			oEvt.initMutationEvent = oEvt.initEvent;
		}

		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currValue, sNewValue, null, null);
		var self = this;
		spawn(function() {
			FormsProcessor.dispatchEvent(self.element, oEvt);
		});
	}

});
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

UX.colorcount = 0;

var InputValueColor = new UX.Class({

	Mixins: [PeValue],

	toString: function() {
		return 'xf:color-value';
	},

	initialize: function(element) {
		this.element = element;
		this.currValue = "";
		this.m_bFirstSetValue = true;
	},

	onDocumentReady: function() {
		if (this.element.ownerDocument.media == "print") return;
		this.element.innerHTML = "<div id='ux-color-bg" + UX.colorcount + "' class='ux-color-bg'></div>";
		this.m_value = new YAHOO.widget.ColorPicker("ux-color-bg" + UX.colorcount, {
			images: {
				PICKER_THUMB: "http://yui.yahooapis.com/2.8.0/build/colorpicker/assets/picker_thumb.png",
				HUE_THUMB: "http://yui.yahooapis.com/2.8.0/build/colorpicker/assets/hue_thumb.png"
			}
		});
		UX.colorcount++;

		var self = this;
		this.m_value.on("rgbChange", function(o) {
			self.colorValueChanged("#" + self.m_value.get("hex"));
		});
	},

	setValue: function(sValue) {
		var bRet = false;

		if (sValue.match(/^#[0-9abcdefABCDEF]{6}/)) {
			if (this.currValue != sValue || m_bFirstSetValue) {
				var rgb = YAHOO.util.Color.hex2rgb(sValue.substring(1));
				this.m_value.setValue(rgb, true);
				this.currValue = sValue;
				bRet = true;
				if (this.m_bFirstSetValue) {
					this.m_bFirstSetValue = false;
				}
			}
		}

		return bRet;

	},

	colorValueChanged: function(value) {
		var oEvt = this.element.ownerDocument.createEvent("MutationEvents");
		if (oEvt.initMutationEvent === undefined) {
			oEvt.initMutationEvent = oEvt.initEvent;
		}
		oEvt.initMutationEvent("control-value-changed", true, true, null, this.currValue, value, null, null);
		var self = this;
		spawn(function() {
			FormsProcessor.dispatchEvent(self.element, oEvt);
		});
	}

});

/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

DECORATOR.addRules({
	"namespaceURI": "http://www.w3.org/2002/xforms",
	"rules": {
		"model": [{
			"name": "model-element",
			"apply": function(arrBehaviours) {
				return Model;// arrBehaviours.concat([EventTarget, Model]);
			}
		}],

		"instance": [{
			"name": "instance-element",
			"apply": function(arrBehaviours) {
				return Instance;// arrBehaviours.concat([EventTarget, Instance, LoadExternalMixin]);
			}
		}],

		"submission": [{
			"name": "submission-element",
			"apply": function(arrBehaviours) {
				return Submission;//arrBehaviours.concat([EventTarget, Context, Submission]);
			}
		}],

		"header": [{
			"name": "header-element",
			"apply": function(arrBehaviours) {
				return Header;//arrBehaviours.concat([Context, Header]);
			}
		}],

		"name": [{
			"name": "name-element",
			apply: function(arrBehavious) {
				return Value;//arrBehavious.concat([EventTarget, MIPHandler, Context, Control, Value]);
			}
		}],
		"group": [{
			"name": "group-element",
			"apply": function(arrBehaviours) {
				return Group;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Container, OptionalIfUnspecifiedBinding, Group]);
			}
		}],

		"switch": [{
			"name": "switch-element",
			"apply": function(arrBehaviours) {
				return Switch;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, OptionalBinding, Switch]);
			}
		}],

		"case": [{
			"name": "case-element",
			"apply": function(arrBehaviours) {
				return XFormsCase;//arrBehaviours.concat([EventTarget, Context, Container, XFormsCase]);
			}
		}],

		"repeat": [{
			"name": "repeat-element",
			"apply": function(arrBehaviours) {
				return Repeat;//arrBehaviours.concat([EventTarget, Context, Repeat]);
			}
		}],
		"submit": [{
			"name": "submit-element",
			"apply": function(arrBehaviours) {
				return Submit;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, OptionalBinding, Submit]);
			}
		}],

		"trigger": [{
			"name": "trigger-element",
			"apply": function(arrBehaviours) {
				return Trigger;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, OptionalBinding]);
			}
		}],

		"input": [{
			"name": "input-element",
			"apply": function(arrBehaviours) {
				return NavigableControl;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl]);
			}
		}],

		"output": [{
			"name": "output-element",
			"apply": function(arrBehaviours) {
				return XOutput;// arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, OptionalIfUnspecifiedBinding]);
			}
		}],

		"range": [{
			"name": "range-element",
			"apply": function(arrBehaviours) {
				return FiniteControl;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, FiniteControl]);
			}
		}],

		"textarea": [{
			"name": "textarea-element",
			"apply": function(arrBehaviours) {
				return NavigableControl;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl]);
			}
		}],

		"secret": [{
			"name": "secret-element",
			"apply": function(arrBehaviours) {
				return NavigableControl;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl]);
			}
		}],

		"select": [{
			"name": "select-element",
			"apply": function(arrBehaviours) {
				return XFormsSelect;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, XFormsCommonSelect, ElementWithChoices, XFormsSelect, FiniteControl]);
			}
		}],

		"select1": [{
			"name": "select1-element",
			"apply": function(arrBehaviours) {
				return XFormsSelect1;//arrBehaviours.concat([EventTarget, MIPHandler, MIPEventTarget, Context, Control, NavigableControl, XFormsCommonSelect, ElementWithChoices, XFormsSelect1, FiniteControl]);
			}
		}],

		"itemset": [{
			"name": "item-element",
			"apply": function(arrBehaviours) {
				return Itemset;//arrBehaviours.concat([EventTarget, Context, Itemset]);
			}
		}],

		"mediatype": [{
			"name": "mediatype-element",
			"apply": function(arrBehaviours) {
				return MediaType;//arrBehaviours.concat([EventTarget, MIPHandler, Context, Control]);
			}
		}],

		"label": [{
			"name": "label-element",
			"apply": function(arrBehaviours) {
				return XLabel;// arrBehaviours.concat([EventTarget, MIPHandler, Context, SrcMixin, Control, OptionalBinding, LoadExternalMixin]);
			}
		}],

		"alert": [{
			"name": "alert-element",
			"apply": function(arrBehaviours) {
				return Alert;//arrBehaviours.concat([EventTarget, MIPHandler, Context, SrcMixin, Control, OptionalBinding, LoadExternalMixin]);
			}
		}],

		"hint": [
		{
			"name": "hint-element",
			"match": function(element) {
				if (!element.parentNode.className || element.parentNode.className.indexOf('geolocation') === -1) {
					return true;
				}
				return false;
			},
			"apply": function(arrBehaviours) {
				return HintMixin;//arrBehaviours.concat([Listener, EventTarget, MIPHandler, Context, SrcMixin, Control, OptionalBinding, Message, HintMixin, LoadExternalMixin]);
			}
		},
		{
			"name": "hint-map",
			"match": function(element) {
				if (element.parentNode.className && element.parentNode.className.indexOf('geolocation') !== -1) {
					return true;
				}
				return false;
			},
			"apply": function(arrBehaviours) {
				return HintGMap;//arrBehaviours.concat([Listener, EventTarget, MIPHandler, Context, Control, OptionalBinding, HintGMap]);
			}
		}],
		"item": [{
			"name": "item-element",
			"apply": function(arrBehaviours) {
				return Item;//arrBehaviours.concat([EventTarget, Context, Item]);
			}
		}],

		"value": [{
			"name": "value-element",
			"apply": function(arrBehaviours) {
				return Value;//arrBehaviours.concat([EventTarget, MIPHandler, Context, Control, OptionalBinding, Value]);
			}
		}],

		"copy": [{
			"name": "copy-element",
			"apply": function(arrBehaviours) {
				return Copy;//arrBehaviours.concat([EventTarget, Context, Control, OptionalBinding, Copy]);
			}
		}],
		"action": [{
			"name": "action-element",
			"apply": function(arrBehaviours) {
				return XFAction;//arrBehaviours.concat([Listener, Context, XFAction]);
			}
		}],

		"help": [{
			"name": "help-element",
			"apply": function(arrBehaviours) {
				return HelpMixin;//arrBehaviours.concat([/* It's a Message ... */ Listener, EventTarget, MIPHandler, Context, SrcMixin, Control, OptionalBinding, Message, /* ... and a Help.    */ HelpMixin, LoadExternalMixin]);
			}
		}],

		"load": [{
			"name": "setvalue-element",
			"apply": function(arrBehaviours) {
				return Load;//arrBehaviours.concat([Listener, EventTarget, Context, OptionalBinding, Load]);
			}
		}],

		"message": [{
			"name": "message-element",
			"apply": function(arrBehaviours) {
				return Message;//arrBehaviours.concat([Listener, EventTarget, MIPHandler, Context, SrcMixin, Control, OptionalBinding, Message, LoadExternalMixin]);
			}
		}],

		"setindex": [{
			"name": "setindex-element",
			"apply": function(arrBehaviours) {
				return SetIndex;//arrBehaviours.concat([Listener, Context, SetIndex]);
			}
		}],

		"setvalue": [{
			"name": "setvalue-element",
			"apply": function(arrBehaviours) {
				return SetValue;//arrBehaviours.concat([Listener, Context, SetValue]);
			}
		}],

		"setfocus": [{
			"name": "setfocus-element",
			"apply": function(arrBehaviours) {
				return SetFocus;//arrBehaviours.concat([Listener, Context, SetFocus]);
			}
		}],

		"insert": [{
			"name": "insert-element",
			"apply": function(arrBehaviours) {
				return Insert;//arrBehaviours.concat([Listener, Context, OptionalBinding, Insert]);
			}
		}],

		"delete": [{
			"name": "delete-element",
			"apply": function(arrBehaviours) {
				return Delete;//arrBehaviours.concat([Listener, Context, Delete]);
			}
		}],

		"send": [{
			"name": "send-element",
			"apply": function(arrBehaviours) {
				return Send;//arrBehaviours.concat([Listener, Send]);
			}
		}],

		"dispatch": [{
			"name": "dispatch-element",
			"apply": function(arrBehaviours) {
				return Dispatch;//arrBehaviours.concat([Listener, Dispatch]);
			}
		}],

		"toggle": [{
			"name": "toggle-element",
			"apply": function(arrBehaviours) {
				return Toggle;//arrBehaviours.concat([Listener, Context, Toggle]);
			}
		}],

		"rebuild": [{
			"name": "rebuild-element",
			"apply": function(arrBehaviours) {
				return Rebuild;//arrBehaviours.concat([Listener, Rebuild]);
			}
		}],

		"recalculate": [{
			"name": "recalculate-element",
			"apply": function(arrBehaviours) {
				return Recalculate;//arrBehaviours.concat([Listener, Recalculate]);
			}
		}],

		"revalidate": [{
			"name": "revalidate-element",
			"apply": function(arrBehaviours) {
				return Revalidate;//arrBehaviours.concat([Listener, Revalidate]);
			}
		}],

		"refresh": [{
			"name": "refresh-element",
			"apply": function(arrBehaviours) {
				return Refresh;//arrBehaviours.concat([Listener, Refresh]);
			}
		}],

		"reset": [{
			"name": "reset-element",
			"apply": function(arrBehaviours) {
				return Reset;//arrBehaviours.concat([Listener, Reset]);
			}
		}],
		"pe-value": [{
			"name": "value-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "value", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return function(){};//arrBehaviours.concat([EventTarget]);
			}
		},
		{
			"name": "output-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "output", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "label", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "alert", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "help", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "hint", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "message", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "mediatype", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "name", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return XFormsOutputValue;//arrBehaviours.concat([EventTarget, XFormsOutputValue]);
			}
		},
		{
			"name": "input-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "input", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "secret", "http://www.w3.org/2002/xforms") || NamespaceManager.compareFullName(element.parentNode, "textarea", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return XFormsInputValue; //arrBehaviours.concat([EventTarget, PeValue, XFormsInputValue]);
			}
		},
		{
			"name": "select-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "select", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return XFormsSelectValue;// arrBehaviours.concat([EventTarget, XFormsSelectValue]);
			}
		},
		{
			"name": "select1-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "select1", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return XFormsSelect1Value;//arrBehaviours.concat([EventTarget, XFormsSelect1Value]);
			}
		},
		{
			"name": "range-pevalue",
			"match": function(element) {
				return NamespaceManager.compareFullName(element.parentNode, "range", "http://www.w3.org/2002/xforms");
			},
			"apply": function(arrBehaviours) {
				return RangeValue;//arrBehaviours.concat([EventTarget, RangeValue]);
			}
		},
		{
			"name": "inputcalendar-pevalue",
			"match": function(element) {
				var parent = element.parentNode,
					datatype = parent.getAttribute("datatype"),
					appearance = parent.getAttribute("appearance"),
					xf4hdatatype = XF4HProcessor.getAttribute(parent, "datatype"),
					prefixes = [],
					prefix = "",
					isDate = false,
					match = false;
				if (NamespaceManager.compareFullName(parent, "input", "http://www.w3.org/2002/xforms")) {
					prefixes = NamespaceManager.getOutputPrefixesFromURI("http://www.w3.org/2002/xforms");
					prefix = prefixes[prefixes.length - 1];
					isDate = (datatype === "xsd:date" || datatype === (prefix + ":date") || xf4hdatatype === "date");
					if (isDate && appearance !== "minimal") {
						match = true;
					}
				}
				return match;
			},
			"apply": function(arrBehaviours) {
				return InputValueCalendar;/*UX.replaceArrayElement(arrBehaviours, XFormsInputValue, InputValueCalendar);
				return arrBehaviours;*/
			}
		},
		{
			"name": "inputcolor-pevalue",
			"match": function(element) {
				var parent = element.parentNode,
					datatype = parent.getAttribute("datatype"),
					appearance = parent.getAttribute("appearance"),
					match = false;
				if (NamespaceManager.compareFullName(parent, "input", "http://www.w3.org/2002/xforms") && datatype === "xhd:color") {
					match = true;
				}
				return match;
			},
			"apply": function(arrBehaviours) {
				return InputValueColor;/*UX.replaceArrayElement(arrBehaviours, XFormsInputValue, InputValueColor);
				return arrBehaviours;*/
			}
		},
		{
			"name": "inputboolean-pevalue",
			"match": function(element) {
				var parent = element.parentNode,
					datatype = parent.getAttribute("datatype"),
					prefixes = [],
					prefix = "",
					match = false;
				if (NamespaceManager.compareFullName(parent, "input", "http://www.w3.org/2002/xforms")) {
					prefixes = NamespaceManager.getOutputPrefixesFromURI("http://www.w3.org/2002/xforms");
					prefix = prefixes[prefixes.length - 1];
					if (datatype === "xsd:boolean" || datatype === (prefix + ":boolean")) {
						match = true;
					}
				}
				return match;
			},
			"apply": function(arrBehaviours) {
				return XFormsBooleanValue; /*UX.replaceArrayElement(arrBehaviours, XFormsInputValue, XFormsBooleanValue);
				return arrBehaviours;*/
			}
		},
		{
			"name": "rangemap-pevalue",
			"match": function(element) {
				var parent = element.parentNode,
					rangeClass = parent.className,
					match = false;
				if (NamespaceManager.compareFullName(parent, "range", "http://www.w3.org/2002/xforms") && rangeClass && rangeClass.indexOf("geolocation") !== -1) {
					match = true;
				}
				return match;
			},
			"apply": function(arrBehaviours) {
				return RangeValueGMAP;/*
				UX.replaceArrayElement(arrBehaviours, RangeValue, RangeValueGMAP);
				UX.insertArrayElement(arrBehaviours, GMapControl, RangeValueGMAP);
				return arrBehaviours;*/
			}
		},
		{
			"name": "outputmap-pevalue",
			"match": function(element) {
				var parent = element.parentNode,
					outputClass = parent.className,
					match = false;
				if (NamespaceManager.compareFullName(parent, "output", "http://www.w3.org/2002/xforms") && outputClass && outputClass.indexOf("geolocation") !== -1) {
					match = true;
				}
				return match;
			},
			"apply": function(arrBehaviours) {
				return XFormsOutputValueGMap;/*
				UX.replaceArrayElement(arrBehaviours, XFormsOutputValue, XFormsOutputValueGMap);
				UX.insertArrayElement(arrBehaviours, GMapControl, XFormsOutputValueGMap);
				return arrBehaviours;*/
			}
		},
		{
			"name": "trigger-minimal",
			"match": function(element) {
				var grandParent = element.parentNode.parentNode,
					grandParentIsTrigger = NamespaceManager.compareFullName(grandParent, "trigger", "http://www.w3.org/2002/xforms"),
					grandParentIsSubmit = NamespaceManager.compareFullName(grandParent, "submit", "http://www.w3.org/2002/xforms");
				if ((grandParentIsTrigger || grandParentIsSubmit) && grandParent.getAttribute("appearance") === "minimal") {
					return true;
				}
				return false;
			},
			"apply": function(arrBehaviours) {
				return TriggerMinimalMixin;//arrBehaviours.concat(TriggerMinimalMixin);
			}
		}],
		"*": []
	}
});

/*UX.replaceArrayElement = function(array, remove, add) {
	var counter;
	for (counter = 0; counter < array.length; counter++) {
		if (array[counter] === remove) {
			array[counter] = add;
			break;
		}
	}
};

UX.insertArrayElement = function(array, insertItem, indexItem) {
	var lastItem, swap;

	for (var i = 0; i < array.length; ++i) {
		if (array[i] === indexItem) {
			lastItem = array[i];
			array[i] = insertItem;
		} else if (lastItem) {
			swap = array[i];
			array[i] = lastItem;
			lastItem = swap;
		}
	}

	if (lastItem) {
		array[i] = lastItem;
	}
};*/

UX.selectors = {
	input: {
		color: {
			value: "xf|input.yui-widget-color > pe-value",
			labelvalue: "xf|input.yui-widget-color > xf|label > pe-value"
		},
		date: {
			value: "xf|input.yui-widget-calendar > pe-value",
			labelvalue: "xf|input.yui-widget-calendar > xf|label > pe-value"
		},
		dateminimal: {
			value: "xf|input.minimal-date > pe-value",
			labelvalue: "xf|input.minimal-date > xf|label > pe-value"
		}
	},
	itemset: {
		repeatReady: "xf|itemset.repeat-ready > xf|item"
	},
	repeat: {
		repeatReady: "xf|repeat.repeat-ready > xf|group"
	},
	header: {
		headerReady: "xf|header.header-ready > *"
	}

};

if (!UX.isIE6) {
	UX.selectors.input.color.value += ", xf|input[datatype='xhd:color'] > pe-value";
	UX.selectors.input.color.labelvalue += ", xf|input[datatype='xhd:color'] > xf| label > pe-value";
	UX.selectors.input.date.value += ", xf|input[datatype='xsd:date'] > pe-value, xf|input[datatype='xf:date'] > pe-value";
	UX.selectors.input.date.labelvalue += ", xf|input[datatype='xsd:date'] > xf|label > pe-value, xf|input[datatype='xf:date'] > xf|label > pe-value";
	UX.selectors.input.dateminimal.value += ", xf|input[datatype='xsd:date'][appearance='minimal'] > pe-value, xf|input[datatype='xf:date'][appearance='minimal'] > pe-value";
	UX.selectors.input.dateminimal.labelvalue += ", xf|input[datatype='xsd:date'][appearance='minimal'] > xf|label > pe-value, xf|input[datatype='xf:date'][appearance='minimal'] > xf|label > pe-value";
	UX.selectors.repeat.repeatReady += ", xf|repeat[class~='repeat-ready'] > xf|group";
	UX.selectors.itemset.repeatReady += ", xf|itemset[class~='repeat-ready'] > xf|item";
	UX.selectors.header.headerReady += ", xf|header[class~='header-ready'] > *";
}
NamespaceManager.addSelectionNamespace("xf", "http://www.w3.org/2002/xforms");

DECORATOR.setupDecorator([

/* Model */

{
	selector: "xf|instance",
	objects: []
},

{
	selector: "xf|model",
	objects: []
},

{
	selector: "xf|submission",
	objects: []
},
{
	selector: "xf|header",
	objects: []
},

{
	selector: "xf|name",
	objects: []
},

/* Container Controls */
{
	selector: "xf|repeat",
	objects: []
},

{
	selector: "xf|group",
	objects: []
},

{
	selector: "xf|switch",
	objects: []
},

{
	selector: "xf|case",
	objects: []
},

/* Controls */
{
	selector: "xf|submit",
	objects: []
},

{
	selector: "xf|trigger",
	objects: []
},

{
	selector: "xf|output >  pe-value",
	objects: []
},
/*
		{
			selector:"pe-value",
			objects:[EventTarget]
		},
    */
{
	selector: "xf|input",
	objects: []
},

{
	selector: "xf|range",
	objects: []
},

{
	selector: "xf|output",
	objects: []
},

{
	selector: "xf|textarea",
	objects: []
},

{
	selector: "xf|secret",
	objects: []
},
{
	selector: "xf|label",
	objects: []
},
{
	selector: "xf|alert",
	objects: []
},
{
	selector: "xf|value",
	objects: []
},
{
	selector: "xf|copy",
	objects: []
},

{
	selector: "xf|input > pe-value",
	objects: []
},
{
	selector: "xf|secret  > pe-value",
	objects: []
},
{
	selector: "xf|textarea  > pe-value",
	objects: []
},

{
	selector: "xf|select > pe-value",
	objects: []
},
{
	selector: "xf|select1 >  pe-value ",
	objects: []
},
{
	selector: "xf|range > pe-value",
	objects: []
},
{
	selector: " xf|alert > pe-value",
	objects: []
},
{
	selector: " xf|hint > pe-value",
	objects: []
},
{
	selector: " xf|message > pe-value",
	objects: []
},
{
	selector: " xf|help > pe-value",
	objects: []
},

{
	selector: "xf|label",
	objects: []
},
{
	selector: "xf|mediatype",
	objects: []
},

{
	selector: "xf|value > pe-value",
	objects: []
},
{
	selector: "xf|item",
	objects: []
},
{
	selector: "xf|itemset",
	objects: []
},
{
	selector: "xf|range.geolocation > pe-value",
	objects: []
},
{
	selector: "xf|range.geolocation > xf|label > pe-value",
	objects: []
},
{
	selector: "xf|output.geolocation > pe-value",
	objects: []
},
{
	selector: "xf|output.geolocation > xf|label > pe-value",
	objects: []
},

{
	selector: UX.selectors.input.color.value,
	objects: []
},
{
	selector: UX.selectors.input.color.labelvalue,
	objects: []
},

{
	selector: UX.selectors.input.date.value,
	objects: []
},
{
	selector: UX.selectors.input.date.labelvalue,
	objects: []
},
{
	selector: UX.selectors.input.dateminimal.value,
	objects: []
},
{
	selector: UX.selectors.input.dateminimal.labelvalue,
	objects: []
},

{
	selector: "xf|select",
	objects: []
},

{
	selector: "xf|select1",
	objects: []
},

/* Actions */

{
	selector: "xf|action",
	objects: []
},

{
	selector: "xf|hint",
	objects: []
},

{
	selector: "xf|load",
	objects: []
},
{
	selector: "xf|message",
	objects: []
},
{
	selector: "xf|help",
	objects: []
},

{
	selector: "xf|setindex",
	objects: []
},

{
	selector: "xf|setvalue",
	objects: []
},

{
	selector: "xf|setfocus",
	objects: []
},

{
	selector: "xf|insert",
	objects: []
},

{
	selector: "xf|delete",
	objects: []
},

{
	selector: "xf|send",
	objects: []
},

{
	selector: "xf|dispatch",
	objects: []
},

{
	selector: "xf|toggle",
	objects: []
},

{
	selector: "xf|rebuild",
	objects: []
},
{
	selector: "xf|recalculate",
	objects: []
},
{
	selector: "xf|revalidate",
	objects: []
},
{
	selector: "xf|refresh",
	objects: []
},
{
	selector: "xf|reset",
	objects: []
},
{
	selector: "xf|label >  pe-value",
	objects: [],
	important: true
},
{
	selector: "xf|mediatype >  pe-value",
	objects: []
},
{
	selector: "xf|name >  pe-value",
	objects: []
},

{
	selector: "xf|repeat > *,  xf|itemset > *, xf|header > *",
	cssText: "-moz-binding:url();"
},
{
	selector: UX.selectors.itemset.repeatReady,
	objects: []
},

{
	selector: UX.selectors.repeat.repeatReady,
	objects: []
},
{
	selector: UX.selectors.header.headerReady,
	objects: []
},

{
	selector: "xf|repeat *, xf|itemset *, xf|header *",
	cssText: "-binding-ignore:true;"
},

{
	selector: "xf|repeat.repeat-ready xf|repeat.repeat-ready *",
	cssText: "-binding-ignore:false;"
},
{
	selector: "xf|repeat.repeat-ready xf|repeat *",
	cssText: "-binding-ignore:true;"
},
{
	selector: "xf|repeat.repeat-ready *",
	cssText: "-binding-ignore:false;"
},
{
	selector: "xf|itemset.repeat-ready *",
	cssText: "-binding-ignore:false;"
},
{
	selector: "xf|header.header-ready *",
	cssText: "-binding-ignore:false;"
}], "http://www.w3.org/2002/xforms"); //to tell the decorator so that it doesn't need to write these definitions again
window.status = "Loading Ubiquity modules...";
loader.insert();

